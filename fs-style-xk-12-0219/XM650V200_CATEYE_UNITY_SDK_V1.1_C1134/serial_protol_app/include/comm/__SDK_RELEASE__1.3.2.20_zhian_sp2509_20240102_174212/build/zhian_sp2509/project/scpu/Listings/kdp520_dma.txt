; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\kdp520_dma.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\kdp520_dma.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\kdp520_dma.crf ..\..\..\..\scpu\drivers\src\kdp520_dma.c]
                          THUMB

                          AREA ||i.AHB_DMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  AHB_DMA_IRQHandler PROC
;;;36     
;;;37     void AHB_DMA_IRQHandler(void)
000000  4807              LDR      r0,|L1.32|
;;;38     {
000002  b510              PUSH     {r4,lr}
;;;39         //kdp_printf("NCPU_AHB_DMA_IRQHandler\n");
;;;40         UINT32 status;
;;;41     
;;;42     
;;;43         status = m_dma_reg->dma_int;
000004  6841              LDR      r1,[r0,#4]  ; m_dma_reg
000006  680c              LDR      r4,[r1,#0]
000008  2c00              CMP      r4,#0                 ;38
00000a  d008              BEQ      |L1.30|
;;;44     
;;;45         if(status)
;;;46             __dma_int_occurred |= status;
00000c  6881              LDR      r1,[r0,#8]  ; __dma_int_occurred
00000e  4321              ORRS     r1,r1,r4
000010  6081              STR      r1,[r0,#8]  ; __dma_int_occurred
;;;47       else
;;;48             return;
;;;49     
;;;50         delay_us(10);
000012  200a              MOVS     r0,#0xa
000014  f7fffffe          BL       delay_us
;;;51     
;;;52         outw(DMAC_FTDMAC020_PA_BASE_SCPU+DMA_INT_TC_CLR, status);
000018  4802              LDR      r0,|L1.36|
00001a  6084              STR      r4,[r0,#8]
;;;53         outw(DMAC_FTDMAC020_PA_BASE_SCPU+DMA_INT_ERRABT_CLR, status);
00001c  6104              STR      r4,[r0,#0x10]
                  |L1.30|
;;;54     }
00001e  bd10              POP      {r4,pc}
;;;55     
                          ENDP

                  |L1.32|
                          DCD      ||.data||
                  |L1.36|
                          DCD      0xa0100000

                          AREA ||i.AHB_DMA_TC_IRQHandler||, CODE, READONLY, ALIGN=2

                  AHB_DMA_TC_IRQHandler PROC
;;;56     
;;;57     void AHB_DMA_TC_IRQHandler(void)
000000  4905              LDR      r1,|L2.24|
;;;58     {
;;;59         //kdp_printf("NCPU_AHB_DMA_TC_IRQHandler\n");
;;;60         UINT32 status;
;;;61     
;;;62     
;;;63         status = m_dma_reg->dma_int_tc;
000002  6848              LDR      r0,[r1,#4]  ; m_dma_reg
000004  6840              LDR      r0,[r0,#4]
000006  2800              CMP      r0,#0                 ;58
000008  d004              BEQ      |L2.20|
;;;64     
;;;65         if(status)
;;;66             __dma_tc_int_occurred |= status;
00000a  68ca              LDR      r2,[r1,#0xc]  ; __dma_tc_int_occurred
00000c  4302              ORRS     r2,r2,r0
00000e  60ca              STR      r2,[r1,#0xc]  ; __dma_tc_int_occurred
;;;67         else
;;;68             return;
;;;69     
;;;70         outw(DMAC_FTDMAC020_PA_BASE_SCPU+DMA_INT_TC_CLR, status);
000010  4902              LDR      r1,|L2.28|
000012  6088              STR      r0,[r1,#8]
                  |L2.20|
;;;71     }
000014  4770              BX       lr
;;;72     
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      ||.data||
                  |L2.28|
                          DCD      0xa0100000

                          AREA ||i.__NVIC_DisableIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_DisableIRQ PROC
;;;1721    */
;;;1722   __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1723   {
000002  db0d              BLT      |L3.32|
;;;1724     if ((int32_t)(IRQn) >= 0)
;;;1725     {
;;;1726       NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01180          STR      r1,[r0,#0x180]
;;;1727       __DSB();
000018  f3bf8f4f          DSB      
;;;1728       __ISB();
00001c  f3bf8f6f          ISB      
                  |L3.32|
;;;1729     }
;;;1730   }
000020  4770              BX       lr
;;;1731   
                          ENDP


                          AREA ||i.__NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_EnableIRQ PROC
;;;1683    */
;;;1684   __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1685   {
000002  db09              BLT      |L4.24|
;;;1686     if ((int32_t)(IRQn) >= 0)
;;;1687     {
;;;1688       __COMPILER_BARRIER();
;;;1689       NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01100          STR      r1,[r0,#0x100]
                  |L4.24|
;;;1690       __COMPILER_BARRIER();
;;;1691     }
;;;1692   }
000018  4770              BX       lr
;;;1693   
                          ENDP


                          AREA ||i.kdp_api_2D_memcpy||, CODE, READONLY, ALIGN=2

                  kdp_api_2D_memcpy PROC
;;;587    
;;;588    u8 kdp_api_2D_memcpy( dma_2d_memcpy_t info )
000000  e92d0ff0          PUSH     {r4-r11}
;;;589    {
000004  4699              MOV      r9,r3
000006  e9dd4509          LDRD     r4,r5,[sp,#0x24]
;;;590        u16 i;
;;;591        u8 ret;
;;;592    
;;;593        {
;;;594            u16 src_raws_lenth = info.src.data_type*info.src.w;
00000a  f3c44307          UBFX     r3,r4,#16,#8
00000e  4682              MOV      r10,r0                ;589
;;;595            u16 dst_raws_lenth = info.dst.data_type*info.dst.w;
000010  435c              MULS     r4,r3,r4
000012  f3c24007          UBFX     r0,r2,#16,#8          ;589
000016  b2a6              UXTH     r6,r4
000018  b28c              UXTH     r4,r1
00001a  4342              MULS     r2,r0,r2              ;594
00001c  b292              UXTH     r2,r2                 ;594
;;;596    
;;;597            u16 src_w_offset = info.src.start_x*info.src.data_type + info.src.start_y*src_raws_lenth;
00001e  4344              MULS     r4,r0,r4
000020  0c09              LSRS     r1,r1,#16
000022  fb014102          MLA      r1,r1,r2,r4
000026  9f08              LDR      r7,[sp,#0x20]
000028  fa1ff881          UXTH     r8,r1
00002c  b2b9              UXTH     r1,r7
;;;598            u16 dst_w_offset = info.dst.start_x*info.src.data_type + info.dst.start_y*src_raws_lenth;
00002e  4341              MULS     r1,r0,r1
000030  0c38              LSRS     r0,r7,#16
000032  fb001002          MLA      r0,r0,r2,r1
000036  b287              UXTH     r7,r0
;;;599    
;;;600            u32 data_raws_lens = info.data_w*info.dst.data_type; // if dst.data_type != src.data_type, first choose dst.data_type
;;;601    
;;;602            _link_list_descriptor_t *llp_array = (_link_list_descriptor_t *)llp_buf;
000038  480f              LDR      r0,|L5.120|
00003a  b2ac              UXTH     r4,r5                 ;598
00003c  435c              MULS     r4,r3,r4              ;600
;;;603    
;;;604            for( i=0; i<info.data_h; i++ )
00003e  2100              MOVS     r1,#0
000040  6903              LDR      r3,[r0,#0x10]  ; llp_buf
000042  0c28              LSRS     r0,r5,#16
000044  e011              B        |L5.106|
;;;605            {
;;;606                llp_array[i].src_addr = ( info.src.addr + src_w_offset + (src_raws_lenth*i) );
000046  bf00              NOP      
                  |L5.72|
000048  fb02ac01          MLA      r12,r2,r1,r10
00004c  eb010581          ADD      r5,r1,r1,LSL #2
000050  44c4              ADD      r12,r12,r8
000052  f843c025          STR      r12,[r3,r5,LSL #2]
;;;607                llp_array[i].dst_addr = ( info.dst.addr + dst_w_offset + (dst_raws_lenth*i) );
000056  fb069c01          MLA      r12,r6,r1,r9
00005a  eb030585          ADD      r5,r3,r5,LSL #2
00005e  44bc              ADD      r12,r12,r7
;;;608                llp_array[i].total_size = ( data_raws_lens );
000060  1c49              ADDS     r1,r1,#1
000062  f8c5c004          STR      r12,[r5,#4]           ;604
000066  b289              UXTH     r1,r1                 ;604
000068  612c              STR      r4,[r5,#0x10]         ;604
                  |L5.106|
00006a  4288              CMP      r0,r1                 ;604
00006c  d8ec              BHI      |L5.72|
;;;609            }
;;;610        }
;;;611    
;;;612        ret = kdp_dma_memcpy( info.data_h );
00006e  e8bd0ff0          POP      {r4-r11}
000072  f7ffbffe          B.W      kdp_dma_memcpy
;;;613    
;;;614        return ret;
;;;615    
;;;616    }
;;;617    
                          ENDP

000076  0000              DCW      0x0000
                  |L5.120|
                          DCD      ||.data||

                          AREA ||i.kdp_ddr_to_flash_dma_copy||, CODE, READONLY, ALIGN=2

                  kdp_ddr_to_flash_dma_copy PROC
;;;417    extern void norflash_write_running( UINT8 type, UINT32 offset, UINT32 total_send_byte, UINT8 *buf );
;;;418    void kdp_ddr_to_flash_dma_copy(UINT32 src_addr, UINT32 dst_addr, UINT32 size){
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  b088              SUB      sp,sp,#0x20
000006  4689              MOV      r9,r1
000008  4682              MOV      r10,r0
00000a  4616              MOV      r6,r2
;;;419        
;;;420        //UINT32 i;
;;;421    
;;;422        UINT32 write_len=size;
00000c  4614              MOV      r4,r2
;;;423        UINT8 ch = AHBDMA_Channel1;
00000e  f04f0801          MOV      r8,#1
;;;424        
;;;425        UINT32 access_byte;
;;;426        UINT32 offset=0;
000012  2500              MOVS     r5,#0
;;;427    
;;;428    
;;;429        dma_ch DMAChannel;
;;;430    
;;;431        memset(&DMAChannel, 0x0, sizeof(dma_ch));
000014  2120              MOVS     r1,#0x20
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       __aeabi_memclr4
;;;432        //memset(&csr, 0x0, sizeof(fLib_DMA_CH_CSR_t));
;;;433        //memset(&cfg, 0x0, sizeof(fLib_DMA_CH_CFG_t));
;;;434    
;;;435        //fLib_printf("before spi020_flash_64kErase\n");
;;;436        //spi020_flash_64kErase((UINT32)dst_addr+offset);
;;;437        //fLib_printf("after spi020_flash_64kErase\n");
;;;438    	//fLib_InitDMA(FALSE, FALSE, 0x0);				
;;;439        //fLib_DMA_ClearAllInterrupt();
;;;440    	//fLib_DMA_EnableDMAInt(); //Enable DMA Interrupt		
;;;441    	//fLib_DMA_ResetChannel(0);	
;;;442    
;;;443        kdp_dma_init(0,0,0);//fLib_InitDMA(FALSE, FALSE, 0x0);
00001c  2200              MOVS     r2,#0
00001e  4611              MOV      r1,r2
000020  4610              MOV      r0,r2
000022  f7fffffe          BL       kdp_dma_init
;;;444    
;;;445        kdp_dma_reset_ch(ch);// fLib_DMA_ResetChannel(0);
000026  4640              MOV      r0,r8
000028  f7fffffe          BL       kdp_dma_reset_ch
;;;446        kdp_dma_enable_dma_int();// fLib_DMA_EnableDMAInt(); //Enable DMA Interrupt
00002c  f7fffffe          BL       kdp_dma_enable_dma_int
;;;447    
;;;448        DMAChannel.csr.dst_ctrl = AHBDMA_DstFix;
000030  9800              LDR      r0,[sp,#0]
000032  f0200018          BIC      r0,r0,#0x18
000036  3010              ADDS     r0,r0,#0x10
;;;449        DMAChannel.csr.src_ctrl = AHBDMA_SrcInc;
;;;450        DMAChannel.csr.mode = AHBDMA_HwHandShakeMode;
000038  f42060ec          BIC      r0,r0,#0x760
;;;451        DMAChannel.csr.dst_width = AHBDMA_DstWidth_DWord;
00003c  f0400080          ORR      r0,r0,#0x80
000040  f5007000          ADD      r0,r0,#0x200
;;;452        DMAChannel.csr.src_width = AHBDMA_SrcWidth_DWord;
000044  f4205060          BIC      r0,r0,#0x3800
000048  f5005080          ADD      r0,r0,#0x1000
;;;453    
;;;454        DMAChannel.cfg.dst_rs = SPI_DMA_REQ;
00004c  9000              STR      r0,[sp,#0]
00004e  9801              LDR      r0,[sp,#4]
;;;455        DMAChannel.cfg.dst_he = 1;
;;;456        DMAChannel.cfg.src_rs = 0;
;;;457        DMAChannel.cfg.src_he = 0;
;;;458        DMAChannel.cfg.int_abt_msk = 0;	
;;;459        DMAChannel.cfg.int_err_msk = 0;
;;;460        DMAChannel.cfg.int_tc_msk = 0;
;;;461    
;;;462        kdp_dma_set_ch_cfg(ch, DMAChannel.csr); //    fLib_SetDMAChannelCfg(0, csr);
000050  9900              LDR      r1,[sp,#0]
000052  f42050f0          BIC      r0,r0,#0x1e00         ;454
000056  f50050b0          ADD      r0,r0,#0x1600         ;454
00005a  f02000ff          BIC      r0,r0,#0xff           ;459
00005e  f4405000          ORR      r0,r0,#0x2000         ;460
000062  9001              STR      r0,[sp,#4]
000064  4640              MOV      r0,r8
000066  f7fffffe          BL       kdp_dma_set_ch_cfg
;;;463        kdp_dma_set_ch_cn_cfg(ch, DMAChannel.cfg);// fLib_SetDMAChannelCnCfg(0, cfg);
00006a  4640              MOV      r0,r8
00006c  9901              LDR      r1,[sp,#4]
00006e  f7fffffe          BL       kdp_dma_set_ch_cn_cfg
;;;464    
;;;465        while(write_len>0)
000072  e020              B        |L6.182|
                  |L6.116|
;;;466        {
;;;467           
;;;468            access_byte = MIN(write_len, kdp520_spi_txfifo_depth());     //access_byte = min_t(write_len, spi020_txfifo_depth());
000074  f7fffffe          BL       kdp520_spi_txfifo_depth
000078  42a0              CMP      r0,r4
00007a  d202              BCS      |L6.130|
00007c  f7fffffe          BL       kdp520_spi_txfifo_depth
000080  e000              B        |L6.132|
                  |L6.130|
000082  4620              MOV      r0,r4
                  |L6.132|
000084  4607              MOV      r7,r0
;;;469            
;;;470            norflash_write_running(FLASH_DMA_WRITE, (UINT32)dst_addr+offset, access_byte, NULL);    //spi020_flash_write(FLASH_DMA_WRITE, (UINT32)dst_addr+offset, access_byte, NULL);
000086  eb090105          ADD      r1,r9,r5
00008a  2300              MOVS     r3,#0
00008c  463a              MOV      r2,r7
00008e  2008              MOVS     r0,#8
000090  f7fffffe          BL       norflash_write_running
;;;471    
;;;472            kdp_dma_ch_data_ctrl(ch, ((UINT32)src_addr)+offset, (UINT32)SPI020REG_DATAPORT, size>>2);           //fLib_DMA_CHDataCtrl(0, ((UINT32)src_addr)+offset, SPI020REG_DATAPORT, access_byte>>2);		
000094  08b3              LSRS     r3,r6,#2
000096  eb0a0105          ADD      r1,r10,r5
00009a  4a0b              LDR      r2,|L6.200|
00009c  4640              MOV      r0,r8
00009e  f7fffffe          BL       kdp_dma_ch_data_ctrl
;;;473            
;;;474            kdp_dma_enable_ch(ch);// fLib_EnableDMAChannel(0);
0000a2  4640              MOV      r0,r8
0000a4  f7fffffe          BL       kdp_dma_enable_ch
;;;475            
;;;476            //kdp_dma_wait_dma_int(ch);       //fLib_DMA_WaitDMAInt(0);		
;;;477            kdp_flash_dma_write_stop();     //spi020_dma_write_stop();
0000a8  f7fffffe          BL       kdp_flash_dma_write_stop
;;;478            kdp_dma_disable_ch(ch);         //fLib_DisableDMAChannel(0);  
0000ac  4640              MOV      r0,r8
0000ae  f7fffffe          BL       kdp_dma_disable_ch
;;;479    
;;;480            //dbg_msg_console("access_byte=%d", access_byte);
;;;481            write_len-=access_byte;
0000b2  1be4              SUBS     r4,r4,r7
;;;482            offset+=access_byte;
0000b4  443d              ADD      r5,r5,r7
                  |L6.182|
0000b6  2c00              CMP      r4,#0                 ;465
0000b8  d1dc              BNE      |L6.116|
;;;483        }
;;;484    
;;;485        kdp_dma_disable_ch(ch);     //fLib_DMA_DisableDMAInt(); //Disable DMA Interrupt
0000ba  4640              MOV      r0,r8
0000bc  f7fffffe          BL       kdp_dma_disable_ch
;;;486    }
0000c0  b008              ADD      sp,sp,#0x20
0000c2  e8bd87f0          POP      {r4-r10,pc}
;;;487    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L6.200|
                          DCD      0xa0000100

                          AREA ||i.kdp_dma_ch_data_ctrl||, CODE, READONLY, ALIGN=2

                  kdp_dma_ch_data_ctrl PROC
;;;194    
;;;195    void kdp_dma_ch_data_ctrl(INT32 Channel, UINT32 SrcAddr, UINT32 DstAddr, UINT32 Size)
000000  b510              PUSH     {r4,lr}
;;;196    {
;;;197        m_dma_reg->dma_ch[Channel].src_addr = SrcAddr/*CPU_TO_AHB_ADDRSPACE(SrcAddr)*/;
000002  4c05              LDR      r4,|L7.24|
000004  6864              LDR      r4,[r4,#4]  ; m_dma_reg
000006  eb041040          ADD      r0,r4,r0,LSL #5
00000a  f8c01108          STR      r1,[r0,#0x108]
;;;198        m_dma_reg->dma_ch[Channel].dst_addr = DstAddr/*CPU_TO_AHB_ADDRSPACE(DstAddr)*/;
00000e  f8c0210c          STR      r2,[r0,#0x10c]
;;;199        m_dma_reg->dma_ch[Channel].size = Size;
000012  f8c03114          STR      r3,[r0,#0x114]
;;;200    }
000016  bd10              POP      {r4,pc}
;;;201    
                          ENDP

                  |L7.24|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_ch_datactrl||, CODE, READONLY, ALIGN=2

                  kdp_dma_ch_datactrl PROC
;;;357    
;;;358    void kdp_dma_ch_datactrl(s32 Channel, u32 SrcAddr, u32 DstAddr, u32 Size)
000000  b510              PUSH     {r4,lr}
;;;359    {
;;;360        m_dma_reg->dma_ch[Channel].src_addr = SrcAddr/*CPU_TO_AHB_ADDRSPACE(SrcAddr)*/;
000002  4c05              LDR      r4,|L8.24|
000004  6864              LDR      r4,[r4,#4]  ; m_dma_reg
000006  eb041040          ADD      r0,r4,r0,LSL #5
00000a  f8c01108          STR      r1,[r0,#0x108]
;;;361        m_dma_reg->dma_ch[Channel].dst_addr = DstAddr/*CPU_TO_AHB_ADDRSPACE(DstAddr)*/;
00000e  f8c0210c          STR      r2,[r0,#0x10c]
;;;362        m_dma_reg->dma_ch[Channel].size = Size;
000012  f8c03114          STR      r3,[r0,#0x114]
;;;363    }
000016  bd10              POP      {r4,pc}
;;;364    
                          ENDP

                  |L8.24|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_ch_int_mask||, CODE, READONLY, ALIGN=2

                  kdp_dma_ch_int_mask PROC
;;;184    
;;;185    void kdp_dma_ch_int_mask(INT32 Channel, dma_ch_cfg Mask)
000000  4a03              LDR      r2,|L9.16|
;;;186    {
;;;187        m_dma_reg->dma_ch[Channel].cfg = Mask;
000002  6852              LDR      r2,[r2,#4]  ; m_dma_reg
000004  eb021040          ADD      r0,r2,r0,LSL #5
000008  f8c01104          STR      r1,[r0,#0x104]
;;;188    }
00000c  4770              BX       lr
;;;189    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_ch_linklist||, CODE, READONLY, ALIGN=2

                  kdp_dma_ch_linklist PROC
;;;189    
;;;190    void kdp_dma_ch_linklist(INT32 Channel, dma_ch_llp LLP)
000000  4a03              LDR      r2,|L10.16|
;;;191    {
;;;192        m_dma_reg->dma_ch[Channel].llp = LLP;
000002  6852              LDR      r2,[r2,#4]  ; m_dma_reg
000004  eb021040          ADD      r0,r2,r0,LSL #5
000008  f8c01110          STR      r1,[r0,#0x110]
;;;193    }
00000c  4770              BX       lr
;;;194    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_ch_llp_data_ctrl||, CODE, READONLY, ALIGN=2

                  kdp_dma_ch_llp_data_ctrl PROC
;;;497    
;;;498    void kdp_dma_ch_llp_data_ctrl( INT32 Channel, UINT32 SrcAddr, UINT32 DstAddr, UINT32 Size, UINT32 llp_buf )
000000  b530              PUSH     {r4,r5,lr}
;;;499    {
;;;500        m_dma_reg->dma_ch[Channel].src_addr = SrcAddr/*CPU_TO_AHB_ADDRSPACE(SrcAddr)*/;
000002  4d0c              LDR      r5,|L11.52|
000004  9c03              LDR      r4,[sp,#0xc]
000006  686d              LDR      r5,[r5,#4]  ; m_dma_reg
000008  eb051040          ADD      r0,r5,r0,LSL #5
00000c  f8c01108          STR      r1,[r0,#0x108]
;;;501        m_dma_reg->dma_ch[Channel].dst_addr = DstAddr/*CPU_TO_AHB_ADDRSPACE(DstAddr)*/;
000010  f8c0210c          STR      r2,[r0,#0x10c]
;;;502        m_dma_reg->dma_ch[Channel].size = Size;
000014  f8c03114          STR      r3,[r0,#0x114]
;;;503        m_dma_reg->dma_ch[Channel].llp.link_list_addr = (llp_buf >> 2);
000018  f8d01110          LDR      r1,[r0,#0x110]
00001c  08a2              LSRS     r2,r4,#2
00001e  f362019f          BFI      r1,r2,#2,#30
000022  f8c01110          STR      r1,[r0,#0x110]
;;;504        m_dma_reg->dma_ch[Channel].csr.tc_msk = 1;
000026  f8d01100          LDR      r1,[r0,#0x100]
00002a  f0414100          ORR      r1,r1,#0x80000000
00002e  f8c01100          STR      r1,[r0,#0x100]
;;;505    }
000032  bd30              POP      {r4,r5,pc}
;;;506    
                          ENDP

                  |L11.52|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_clear_all_interrupt||, CODE, READONLY, ALIGN=2

                  kdp_dma_clear_all_interrupt PROC
;;;850    
;;;851    void kdp_dma_clear_all_interrupt()
000000  4803              LDR      r0,|L12.16|
;;;852    {
;;;853        // Clear all interrupt source
;;;854        outw(DMAC_FTDMAC020_PA_BASE_SCPU+DMA_INT_TC_CLR,0xFF);
000002  21ff              MOVS     r1,#0xff
000004  6081              STR      r1,[r0,#8]
;;;855        outw(DMAC_FTDMAC020_PA_BASE_SCPU+DMA_INT_ERRABT_CLR,0xFF00FF);
000006  f04f11ff          MOV      r1,#0xff00ff
00000a  6101              STR      r1,[r0,#0x10]
;;;856    }
00000c  4770              BX       lr
;;;857    
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      0xa0100000

                          AREA ||i.kdp_dma_clear_ch_int_status||, CODE, READONLY, ALIGN=2

                  kdp_dma_clear_ch_int_status PROC
;;;156    
;;;157    void kdp_dma_clear_ch_int_status(INT32 Channel)
000000  2101              MOVS     r1,#1
;;;158    {
;;;159        m_dma_reg->dma_int_tc_clr = 1 << Channel;
000002  4081              LSLS     r1,r1,r0
000004  4802              LDR      r0,|L13.16|
000006  6840              LDR      r0,[r0,#4]  ; m_dma_reg
000008  6081              STR      r1,[r0,#8]
;;;160        m_dma_reg->dma_int_err_clr = 1 << Channel;
00000a  6101              STR      r1,[r0,#0x10]
;;;161    }
00000c  4770              BX       lr
;;;162    
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_clear_interrupt||, CODE, READONLY, ALIGN=2

                  kdp_dma_clear_interrupt PROC
;;;844    
;;;845    void kdp_dma_clear_interrupt(UINT8 channel)
000000  4904              LDR      r1,|L14.20|
;;;846    {
;;;847        outw(DMAC_FTDMAC020_PA_BASE_SCPU+DMA_INT_TC_CLR, (1 << channel));
000002  2201              MOVS     r2,#1
000004  4082              LSLS     r2,r2,r0
000006  608a              STR      r2,[r1,#8]
;;;848        outw(DMAC_FTDMAC020_PA_BASE_SCPU+DMA_INT_ERRABT_CLR, (0x00010001 << channel));
000008  f04f1201          MOV      r2,#0x10001
00000c  4082              LSLS     r2,r2,r0
00000e  610a              STR      r2,[r1,#0x10]
;;;849    }
000010  4770              BX       lr
;;;850    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0xa0100000

                          AREA ||i.kdp_dma_disable_ch||, CODE, READONLY, ALIGN=2

                  kdp_dma_disable_ch PROC
;;;133    
;;;134    void kdp_dma_disable_ch(INT32 Channel)
000000  4905              LDR      r1,|L15.24|
;;;135    {
;;;136        UINT32 reg;
;;;137    
;;;138        reg = *(UINT32 *)&m_dma_reg->dma_ch[Channel].csr;
000002  6849              LDR      r1,[r1,#4]  ; m_dma_reg
000004  eb011040          ADD      r0,r1,r0,LSL #5
;;;139        reg &= ~DMA_CSR_CH_ENABLE;
000008  f8d01100          LDR      r1,[r0,#0x100]
00000c  f0210101          BIC      r1,r1,#1
;;;140        *(UINT32 *)&m_dma_reg->dma_ch[Channel].csr = reg;
000010  f8c01100          STR      r1,[r0,#0x100]
;;;141    }
000014  4770              BX       lr
;;;142    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_disable_dma_int||, CODE, READONLY, ALIGN=2

                  kdp_dma_disable_dma_int PROC
;;;888    
;;;889    void kdp_dma_disable_dma_int(void)
000000  b510              PUSH     {r4,lr}
;;;890    {
;;;891        if(dma_int_initized)
000002  4c05              LDR      r4,|L16.24|
000004  7820              LDRB     r0,[r4,#0]  ; dma_int_initized
000006  2800              CMP      r0,#0                 ;890
000008  d004              BEQ      |L16.20|
;;;892        {
;;;893            NVIC_DisableIRQ(DMA_FTDMAC020_0_IRQ);
00000a  2003              MOVS     r0,#3
00000c  f7fffffe          BL       __NVIC_DisableIRQ
;;;894            dma_int_initized = 0;
000010  2000              MOVS     r0,#0
000012  7020              STRB     r0,[r4,#0]
                  |L16.20|
;;;895        }
;;;896    }
000014  bd10              POP      {r4,pc}
;;;897    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_disable_dma_tc_int||, CODE, READONLY, ALIGN=2

                  kdp_dma_disable_dma_tc_int PROC
;;;908    
;;;909    void kdp_dma_disable_dma_tc_int(void)
000000  b510              PUSH     {r4,lr}
;;;910    {
;;;911        if(dma_tc_int_initized)
000002  4c05              LDR      r4,|L17.24|
000004  7860              LDRB     r0,[r4,#1]  ; dma_tc_int_initized
000006  2800              CMP      r0,#0                 ;910
000008  d004              BEQ      |L17.20|
;;;912        {
;;;913            NVIC_DisableIRQ(DMA_FTDMAC020_0_TC_IRQ);
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       __NVIC_DisableIRQ
;;;914            dma_tc_int_initized = 0;
000010  2000              MOVS     r0,#0
000012  7060              STRB     r0,[r4,#1]
                  |L17.20|
;;;915        }
;;;916    }
000014  bd10              POP      {r4,pc}
;;;917    
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_enable||, CODE, READONLY, ALIGN=2

                  kdp_dma_enable PROC
;;;142    
;;;143    void kdp_dma_enable(unsigned int value)
000000  f0000201          AND      r2,r0,#1
;;;144    {
;;;145        unsigned int reg;
;;;146    
;;;147        value &= 0x1;	// check input
;;;148    
;;;149        reg = m_dma_reg->dma_csr;
000004  4803              LDR      r0,|L18.20|
000006  6841              LDR      r1,[r0,#4]  ; m_dma_reg
000008  6a48              LDR      r0,[r1,#0x24]
;;;150    
;;;151        reg &= ~(0x1);
00000a  f0200001          BIC      r0,r0,#1
;;;152        reg |= value;
00000e  4310              ORRS     r0,r0,r2
;;;153    
;;;154        m_dma_reg->dma_csr = reg;
000010  6248              STR      r0,[r1,#0x24]
;;;155    }
000012  4770              BX       lr
;;;156    
                          ENDP

                  |L18.20|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_enable_ch||, CODE, READONLY, ALIGN=2

                  kdp_dma_enable_ch PROC
;;;124    
;;;125    void kdp_dma_enable_ch(INT32 Channel)
000000  4905              LDR      r1,|L19.24|
;;;126    {
;;;127        UINT32 reg;
;;;128    
;;;129        reg = *(UINT32 *)&m_dma_reg->dma_ch[Channel].csr;
000002  6849              LDR      r1,[r1,#4]  ; m_dma_reg
000004  eb011040          ADD      r0,r1,r0,LSL #5
;;;130        reg |= DMA_CSR_CH_ENABLE;
000008  f8d01100          LDR      r1,[r0,#0x100]
00000c  f0410101          ORR      r1,r1,#1
;;;131        *(UINT32 *)&m_dma_reg->dma_ch[Channel].csr = reg;
000010  f8c01100          STR      r1,[r0,#0x100]
;;;132    }
000014  4770              BX       lr
;;;133    
                          ENDP

000016  0000              DCW      0x0000
                  |L19.24|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_enable_dma_int||, CODE, READONLY, ALIGN=2

                  kdp_dma_enable_dma_int PROC
;;;877    
;;;878    void kdp_dma_enable_dma_int(void)
000000  b510              PUSH     {r4,lr}
;;;879    {
;;;880        if(0 == dma_int_initized)
000002  4c07              LDR      r4,|L20.32|
000004  7820              LDRB     r0,[r4,#0]  ; dma_int_initized
000006  2800              CMP      r0,#0                 ;879
000008  d109              BNE      |L20.30|
;;;881        {
;;;882            __dma_int_occurred = 0;
00000a  60a0              STR      r0,[r4,#8]  ; __dma_int_occurred
00000c  4806              LDR      r0,|L20.40|
;;;883            NVIC_SetVector((IRQn_Type)DMA_FTDMAC020_0_IRQ, (uint32_t)AHB_DMA_IRQHandler);
00000e  4905              LDR      r1,|L20.36|
000010  6800              LDR      r0,[r0,#0]
;;;884            NVIC_EnableIRQ(DMA_FTDMAC020_0_IRQ);
000012  64c1              STR      r1,[r0,#0x4c]
000014  2003              MOVS     r0,#3
000016  f7fffffe          BL       __NVIC_EnableIRQ
;;;885            dma_int_initized = 1;
00001a  2001              MOVS     r0,#1
00001c  7020              STRB     r0,[r4,#0]
                  |L20.30|
;;;886        }
;;;887    }
00001e  bd10              POP      {r4,pc}
;;;888    
                          ENDP

                  |L20.32|
                          DCD      ||.data||
                  |L20.36|
                          DCD      AHB_DMA_IRQHandler
                  |L20.40|
                          DCD      0xe000ed08

                          AREA ||i.kdp_dma_enable_dma_tc_int||, CODE, READONLY, ALIGN=2

                  kdp_dma_enable_dma_tc_int PROC
;;;897    
;;;898    void kdp_dma_enable_dma_tc_int(void)
000000  b510              PUSH     {r4,lr}
;;;899    {
;;;900        if(0 == dma_tc_int_initized)
000002  4c07              LDR      r4,|L21.32|
000004  7860              LDRB     r0,[r4,#1]  ; dma_tc_int_initized
000006  2800              CMP      r0,#0                 ;899
000008  d109              BNE      |L21.30|
;;;901        {
;;;902            __dma_tc_int_occurred = 0;
00000a  60e0              STR      r0,[r4,#0xc]  ; __dma_tc_int_occurred
00000c  4806              LDR      r0,|L21.40|
;;;903            NVIC_SetVector((IRQn_Type)DMA_FTDMAC020_0_TC_IRQ, (uint32_t)AHB_DMA_TC_IRQHandler);
00000e  4905              LDR      r1,|L21.36|
000010  6800              LDR      r0,[r0,#0]
;;;904            NVIC_EnableIRQ(DMA_FTDMAC020_0_TC_IRQ);
000012  6501              STR      r1,[r0,#0x50]
000014  2004              MOVS     r0,#4
000016  f7fffffe          BL       __NVIC_EnableIRQ
;;;905            dma_tc_int_initized = 1;
00001a  2001              MOVS     r0,#1
00001c  7060              STRB     r0,[r4,#1]
                  |L21.30|
;;;906        }
;;;907    }
00001e  bd10              POP      {r4,pc}
;;;908    
                          ENDP

                  |L21.32|
                          DCD      ||.data||
                  |L21.36|
                          DCD      AHB_DMA_TC_IRQHandler
                  |L21.40|
                          DCD      0xe000ed08

                          AREA ||i.kdp_dma_get_busy_status||, CODE, READONLY, ALIGN=2

                  kdp_dma_get_busy_status PROC
;;;82     
;;;83     int kdp_dma_get_busy_status(void)
000000  4801              LDR      r0,|L22.8|
;;;84     {
;;;85         return m_dma_reg->dma_ch_busy;
000002  6840              LDR      r0,[r0,#4]  ; m_dma_reg
000004  6a00              LDR      r0,[r0,#0x20]
;;;86     }
000006  4770              BX       lr
;;;87     
                          ENDP

                  |L22.8|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_get_ch_cfg||, CODE, READONLY, ALIGN=2

                  kdp_dma_get_ch_cfg PROC
;;;168    
;;;169    dma_ch_csr kdp_dma_get_ch_cfg(INT32 Channel)
000000  4903              LDR      r1,|L23.16|
;;;170    {
;;;171        return m_dma_reg->dma_ch[Channel].csr;
000002  6849              LDR      r1,[r1,#4]  ; m_dma_reg
000004  eb011040          ADD      r0,r1,r0,LSL #5
000008  f8d00100          LDR      r0,[r0,#0x100]
;;;172    }
00000c  4770              BX       lr
;;;173    
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_get_ch_cn_cfg||, CODE, READONLY, ALIGN=2

                  kdp_dma_get_ch_cn_cfg PROC
;;;179    
;;;180    dma_ch_cfg kdp_dma_get_ch_cn_cfg(INT32 Channel)
000000  4903              LDR      r1,|L24.16|
;;;181    {
;;;182        return m_dma_reg->dma_ch[Channel].cfg;
000002  6849              LDR      r1,[r1,#4]  ; m_dma_reg
000004  eb011040          ADD      r0,r1,r0,LSL #5
000008  f8d00104          LDR      r0,[r0,#0x104]
;;;183    }
00000c  4770              BX       lr
;;;184    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_get_ch_int_status||, CODE, READONLY, ALIGN=2

                  kdp_dma_get_ch_int_status PROC
;;;99     
;;;100    UINT32 kdp_dma_get_ch_int_status(INT32 Channel)
000000  b508              PUSH     {r3,lr}
;;;101    {
;;;102        volatile UINT32 IntStatus = 0;
000002  2100              MOVS     r1,#0
;;;103    
;;;104        if((m_dma_reg->dma_int >> Channel) & 0x01)
000004  9100              STR      r1,[sp,#0]
000006  490b              LDR      r1,|L25.52|
000008  6849              LDR      r1,[r1,#4]  ; m_dma_reg
00000a  680a              LDR      r2,[r1,#0]
00000c  40c2              LSRS     r2,r2,r0
00000e  07d2              LSLS     r2,r2,#31
000010  d00d              BEQ      |L25.46|
;;;105        {
;;;106            if((m_dma_reg->dma_int_tc >> Channel) & 0x01)
000012  684a              LDR      r2,[r1,#4]
000014  40c2              LSRS     r2,r2,r0
000016  07d2              LSLS     r2,r2,#31
000018  d001              BEQ      |L25.30|
;;;107                IntStatus |= 1;
00001a  2201              MOVS     r2,#1
00001c  9200              STR      r2,[sp,#0]
                  |L25.30|
;;;108            if((m_dma_reg->dma_int_err >> Channel) & 0x01)
00001e  68c9              LDR      r1,[r1,#0xc]
000020  40c1              LSRS     r1,r1,r0
000022  07c8              LSLS     r0,r1,#31
000024  d003              BEQ      |L25.46|
;;;109                IntStatus |= 2;
000026  9800              LDR      r0,[sp,#0]
000028  f0400002          ORR      r0,r0,#2
00002c  9000              STR      r0,[sp,#0]
                  |L25.46|
;;;110        }
;;;111    
;;;112        return IntStatus;
00002e  9800              LDR      r0,[sp,#0]
;;;113    }
000030  bd08              POP      {r3,pc}
;;;114    
                          ENDP

000032  0000              DCW      0x0000
                  |L25.52|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_get_ch_num||, CODE, READONLY, ALIGN=2

                  kdp_dma_get_ch_num PROC
;;;871    
;;;872    int kdp_dma_get_ch_num()
000000  4802              LDR      r0,|L26.12|
;;;873    {
;;;874        //kdp_printf("channel_num reg: %d\n",readl(DMAC_FTDMAC020_PA_BASE_SCPU+DMA_FEATURE));
;;;875        return (readl(DMAC_FTDMAC020_PA_BASE_SCPU+DMA_FEATURE)>>12)&0xf;
000002  6b40              LDR      r0,[r0,#0x34]
000004  f3c03003          UBFX     r0,r0,#12,#4
;;;876    }
000008  4770              BX       lr
;;;877    
                          ENDP

00000a  0000              DCW      0x0000
                  |L26.12|
                          DCD      0xa0100000

                          AREA ||i.kdp_dma_get_enable_status||, CODE, READONLY, ALIGN=2

                  kdp_dma_get_enable_status PROC
;;;87     
;;;88     int kdp_dma_get_enable_status(void)
000000  4801              LDR      r0,|L27.8|
;;;89     {
;;;90         return m_dma_reg->dma_ch_enable;
000002  6840              LDR      r0,[r0,#4]  ; m_dma_reg
000004  69c0              LDR      r0,[r0,#0x1c]
;;;91     }
000006  4770              BX       lr
;;;92     
                          ENDP

                  |L27.8|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_get_int_status||, CODE, READONLY, ALIGN=2

                  kdp_dma_get_int_status PROC
;;;92     
;;;93     UINT32 kdp_dma_get_int_status(void)
000000  4801              LDR      r0,|L28.8|
;;;94     {
;;;95         return m_dma_reg->dma_int;
000002  6840              LDR      r0,[r0,#4]  ; m_dma_reg
000004  6800              LDR      r0,[r0,#0]
;;;96     }
000006  4770              BX       lr
;;;97     
                          ENDP

                  |L28.8|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_init||, CODE, READONLY, ALIGN=2

                  kdp_dma_init PROC
;;;115    
;;;116    void kdp_dma_init(UINT32 M0_BigEndian, UINT32 M1_BigEndian, UINT32 Sync)
000000  b100              CBZ      r0,|L29.4|
;;;117    {
;;;118        m_dma_reg->dma_csr = (M0_BigEndian ? DMA_CSR_M0ENDIAN : 0) |
000002  2002              MOVS     r0,#2
                  |L29.4|
000004  b101              CBZ      r1,|L29.8|
;;;119        (M1_BigEndian ? DMA_CSR_M1ENDIAN : 0) | DMA_CSR_DMACEN;
000006  2104              MOVS     r1,#4
                  |L29.8|
000008  4308              ORRS     r0,r0,r1
00000a  f0400101          ORR      r1,r0,#1
00000e  4802              LDR      r0,|L29.24|
000010  6840              LDR      r0,[r0,#4]  ; m_dma_reg
000012  6241              STR      r1,[r0,#0x24]
;;;120    
;;;121        m_dma_reg->dma_sync = Sync;
000014  6282              STR      r2,[r0,#0x28]
;;;122    }
000016  4770              BX       lr
;;;123    
                          ENDP

                  |L29.24|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_is_ch_busy||, CODE, READONLY, ALIGN=2

                  kdp_dma_is_ch_busy PROC
;;;72     
;;;73     int kdp_dma_is_ch_busy(INT32 Channel)
000000  4903              LDR      r1,|L30.16|
;;;74     {
;;;75         return ((m_dma_reg->dma_ch_busy >> Channel) & 0x1);
000002  6849              LDR      r1,[r1,#4]  ; m_dma_reg
000004  6a09              LDR      r1,[r1,#0x20]
000006  40c1              LSRS     r1,r1,r0
000008  f0010001          AND      r0,r1,#1
;;;76     }
00000c  4770              BX       lr
;;;77     
                          ENDP

00000e  0000              DCW      0x0000
                  |L30.16|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_is_ch_enable||, CODE, READONLY, ALIGN=2

                  kdp_dma_is_ch_enable PROC
;;;77     
;;;78     int kdp_dma_is_ch_enable(INT32 Channel)
000000  4903              LDR      r1,|L31.16|
;;;79     {
;;;80         return ((m_dma_reg->dma_ch_enable >> Channel) & 0x1);
000002  6849              LDR      r1,[r1,#4]  ; m_dma_reg
000004  69c9              LDR      r1,[r1,#0x1c]
000006  40c1              LSRS     r1,r1,r0
000008  f0010001          AND      r0,r1,#1
;;;81     }
00000c  4770              BX       lr
;;;82     
                          ENDP

00000e  0000              DCW      0x0000
                  |L31.16|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_link_transfer||, CODE, READONLY, ALIGN=2

                  kdp_dma_link_transfer PROC
;;;201    
;;;202    void kdp_dma_link_transfer(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;203    UINT32 Channel,   // use which channel for AHB DMA, 0..7
;;;204    UINT32 LinkAddr,  // Link-List address
;;;205    UINT32 LLPCount,  // total link-list node
;;;206    UINT32 SrcAddr,   // source begin address
;;;207    UINT32 DstAddr,   // dest begin address
;;;208    UINT32 Size,      // total bytes
;;;209    UINT32 SrcWidth,  // source width 8/16/32 bits -> 0/1/2
;;;210    UINT32 DstWidth,  // dest width 8/16/32 bits -> 0/1/2
;;;211    UINT32 SrcSize,   // source burst size, How many "SrcWidth" will be transmmited at one times ?
;;;212    UINT32 SrcCtrl,   // source address change : Inc/dec/fixed --> 0/1/2
;;;213    UINT32 DstCtrl,   // dest address change : Inc/dec/fixed --> 0/1/2
;;;214    UINT32 Priority,  // priority for this chaanel 0(low)/1/2/3(high)
;;;215    UINT32 Mode,      // Normal/Hardwire,   0/1
;;;216    int req)
;;;217    {
000004  b081              SUB      sp,sp,#4
;;;218        dma_ch DMAChannel;
;;;219        UINT32 LLPSize, i, offset;
;;;220        dma_lld *LLP;
;;;221        UINT32 Count = 0;
;;;222        UINT32 AHB_SrcAddr = /*CPU_TO_AHB_ADDRSPACE*/(SrcAddr);
;;;223        UINT32 AHB_DstAddr = /*CPU_TO_AHB_ADDRSPACE*/(DstAddr);
;;;224        int burst_size = burst_size_selection[SrcSize];			// ref: [18:16] in Cn_CSR
;;;225    
;;;226        LLP = (dma_lld *)LinkAddr;
;;;227        *((unsigned int *)&DMAChannel.csr) = 0;		// clear value of csr;
;;;228    
;;;229        Size = Size / (1 << SrcWidth);		// how many unit want to transfer
000006  f04f0701          MOV      r7,#1
00000a  e9ddc60f          LDRD     r12,r6,[sp,#0x3c]     ;217
00000e  e9dd4313          LDRD     r4,r3,[sp,#0x4c]      ;217
000012  980e              LDR      r0,[sp,#0x38]         ;223
000014  fa07f706          LSL      r7,r7,r6
000018  ea5f0802          MOVS     r8,r2                 ;217
00001c  9000              STR      r0,[sp,#0]            ;224
00001e  fbbcf7f7          UDIV     r7,r12,r7
000022  4a69              LDR      r2,|L32.456|
000024  9812              LDR      r0,[sp,#0x48]         ;224
000026  f04f0500          MOV      r5,#0                 ;221
00002a  f8dde010          LDR      lr,[sp,#0x10]         ;223
00002e  f8dd905c          LDR      r9,[sp,#0x5c]         ;223
000032  f8520020          LDR      r0,[r2,r0,LSL #2]     ;224
000036  460a              MOV      r2,r1                 ;226
000038  46ab              MOV      r11,r5                ;227
00003a  d072              BEQ      |L32.290|
;;;230    
;;;231        if(LLPCount && LinkAddr )
00003c  2a00              CMP      r2,#0
00003e  d070              BEQ      |L32.290|
;;;232        {
;;;233    
;;;234        LLPSize = 240*2;
000040  f44f7cf0          MOV      r12,#0x1e0
;;;235        if (req != 0)		// memory to memory does not have this restriction
000044  ea5f0109          MOVS     r1,r9
000048  d00b              BEQ      |L32.98|
;;;236        {
;;;237            LLPSize = RoundDown(CN_SIZE, burst_size);			// how many cycle a descriptor can transfer
00004a  f44f617f          MOV      r1,#0xff0
00004e  fbb1fcf0          UDIV     r12,r1,r0
;;;238            ASSERT((Size%burst_size)==0);
000052  fbb7f1f0          UDIV     r1,r7,r0
000056  fb0cfc00          MUL      r12,r12,r0            ;237
00005a  fb007011          MLS      r0,r0,r1,r7
00005e  b100              CBZ      r0,|L32.98|
                  |L32.96|
000060  e7fe              B        |L32.96|
                  |L32.98|
;;;239        }
;;;240        Count = LLPCount;		// how many link-list structure need to fill
000062  4645              MOV      r5,r8
;;;241       // ASSERT(Count<=LLPCount);
;;;242    
;;;243        // At last, 2 part
;;;244    
;;;245        if (Count > 0)
;;;246        {
;;;247    
;;;248                offset = 320 << 2;
000064  f44f6aa0          MOV      r10,#0x500
;;;249    
;;;250               for(i = 0; i < Count ;i++)
000068  2000              MOVS     r0,#0
00006a  e04a              B        |L32.258|
                  |L32.108|
;;;251               {
;;;252    
;;;253    								if (SrcCtrl == 0)  // increase
00006c  b124              CBZ      r4,|L32.120|
;;;254    									 LLP[i].src_addr = (UINT32)AHB_SrcAddr + ((i+1) * offset);
;;;255    								else if(SrcCtrl==1) // decrease
00006e  2c01              CMP      r4,#1
000070  d006              BEQ      |L32.128|
;;;256    									 LLP[i].src_addr = (UINT32)AHB_SrcAddr - ((i+1) * offset);
;;;257    								else if(SrcCtrl==2)	// fixed
000072  2c02              CMP      r4,#2
000074  d00c              BEQ      |L32.144|
000076  e00f              B        |L32.152|
                  |L32.120|
000078  1c47              ADDS     r7,r0,#1              ;254
00007a  fb07e10a          MLA      r1,r7,r10,lr          ;254
00007e  e002              B        |L32.134|
                  |L32.128|
000080  1c47              ADDS     r7,r0,#1              ;256
000082  fb07e11a          MLS      r1,r7,r10,lr          ;256
                  |L32.134|
000086  eb000780          ADD      r7,r0,r0,LSL #2       ;256
00008a  f8421027          STR      r1,[r2,r7,LSL #2]     ;256
00008e  e003              B        |L32.152|
                  |L32.144|
;;;258    									 LLP[i].src_addr = (UINT32)AHB_SrcAddr;
000090  eb000780          ADD      r7,r0,r0,LSL #2
000094  f842e027          STR      lr,[r2,r7,LSL #2]
                  |L32.152|
;;;259    
;;;260    								if(DstCtrl == 0)
000098  b123              CBZ      r3,|L32.164|
;;;261    									 LLP[i].dst_addr = (UINT32)AHB_DstAddr + ((i+1) * offset);
;;;262    								else if(DstCtrl == 1)	// Decrease
00009a  2b01              CMP      r3,#1
00009c  d007              BEQ      |L32.174|
;;;263    									 LLP[i].dst_addr = (UINT32)AHB_DstAddr - ((i+1) * offset);
;;;264    								else if(DstCtrl == 2)
00009e  2b02              CMP      r3,#2
0000a0  d00a              BEQ      |L32.184|
0000a2  e00f              B        |L32.196|
                  |L32.164|
0000a4  9900              LDR      r1,[sp,#0]            ;261
0000a6  1c47              ADDS     r7,r0,#1              ;261
0000a8  fb07110a          MLA      r1,r7,r10,r1          ;261
0000ac  e005              B        |L32.186|
                  |L32.174|
0000ae  9f00              LDR      r7,[sp,#0]            ;263
0000b0  1c41              ADDS     r1,r0,#1              ;263
0000b2  fb01711a          MLS      r1,r1,r10,r7          ;263
0000b6  e000              B        |L32.186|
                  |L32.184|
;;;265    									 LLP[i].dst_addr = (UINT32)AHB_DstAddr;
0000b8  9900              LDR      r1,[sp,#0]
                  |L32.186|
0000ba  eb000780          ADD      r7,r0,r0,LSL #2
0000be  eb020787          ADD      r7,r2,r7,LSL #2
0000c2  6079              STR      r1,[r7,#4]
                  |L32.196|
;;;266    
;;;267    								*((UINT32 *)&(LLP[i].llp)) = 0;
0000c4  eb000780          ADD      r7,r0,r0,LSL #2
0000c8  eb020787          ADD      r7,r2,r7,LSL #2
0000cc  2100              MOVS     r1,#0
;;;268    								LLP[i].llp.link_list_addr = /*CPU_TO_AHB_ADDRSPACE*/((UINT32)&LLP[i+1]) >> 2;
0000ce  f1070814          ADD      r8,r7,#0x14
0000d2  ea4f0898          LSR      r8,r8,#2
0000d6  f368019f          BFI      r1,r8,#2,#30
;;;269    
;;;270    
;;;271    								*((UINT32 *)&(LLP[i].llp_ctrl)) = 0;
;;;272    								LLP[i].llp_ctrl.tc_msk = 1;
0000da  60b9              STR      r1,[r7,#8]
0000dc  f04f5180          MOV      r1,#0x10000000
;;;273    								LLP[i].llp_ctrl.src_width = SrcWidth; /* source transfer size */
;;;274    								LLP[i].llp_ctrl.dst_width = DstWidth; /* destination transfer size */
0000e0  f8dd8044          LDR      r8,[sp,#0x44]
0000e4  f366615b          BFI      r1,r6,#25,#3          ;273
0000e8  f3685198          BFI      r1,r8,#22,#3
;;;275    								LLP[i].llp_ctrl.src_ctrl = SrcCtrl; /* source increment, decrement or fix */
0000ec  f3645115          BFI      r1,r4,#20,#2
;;;276    								LLP[i].llp_ctrl.dst_ctrl = DstCtrl; /* destination increment, decrement or fix */
0000f0  f3634193          BFI      r1,r3,#18,#2
;;;277    								LLP[i].llp_ctrl.src_sel = 0; /* source AHB master id */
;;;278    								LLP[i].llp_ctrl.dst_sel = 0; /* destination AHB master id */
0000f4  f4213140          BIC      r1,r1,#0x30000
0000f8  f1014180          ADD      r1,r1,#0x40000000
0000fc  e9c71c03          STRD     r1,r12,[r7,#0xc]
000100  1c40              ADDS     r0,r0,#1
                  |L32.258|
000102  42a8              CMP      r0,r5                 ;250
000104  d3b2              BCC      |L32.108|
;;;279    								LLP[i].llp_ctrl.ff_th = 2; //FIE7021 fifo threshold value = 4
;;;280    								LLP[i].size = LLPSize;
;;;281    
;;;282    							Size -= LLPSize;
;;;283    
;;;284            }
;;;285               LLP[i-1].llp.link_list_addr = 0;
000106  eb000080          ADD      r0,r0,r0,LSL #2
00010a  eb020080          ADD      r0,r2,r0,LSL #2
00010e  f8101d0c          LDRB     r1,[r0,#-0xc]!
000112  f0010103          AND      r1,r1,#3
;;;286               LLP[i-1].llp_ctrl.tc_msk = 0;	// Enable tc status
000116  6001              STR      r1,[r0,#0]
000118  6841              LDR      r1,[r0,#4]
00011a  f0215180          BIC      r1,r1,#0x10000000
00011e  e9c01c01          STRD     r1,r12,[r0,#4]
                  |L32.290|
;;;287               LLP[i-1].size = LLPSize;
;;;288               Size = LLPSize;
;;;289        }
;;;290    
;;;291    #ifdef DBG_DMA
;;;292        for(i = 0; i < LLPCount;i++)
;;;293        {
;;;294            kdp_printf("src=%0.8X, dst=%0.8X, link=%0.8X, ctrl=%.8X\n", LLP[i].src_addr, LLP[i].dst_addr,
;;;295                *(UINT32 *)&(LLP[i].llp), *(UINT32 *)&(LLP[i].llp_ctrl));
;;;296    
;;;297        }
;;;298    #endif
;;;299    }
;;;300        /* program channel */
;;;301        kdp_dma_clear_ch_int_status(Channel);
000122  9801              LDR      r0,[sp,#4]
000124  f7fffffe          BL       kdp_dma_clear_ch_int_status
;;;302    
;;;303        /* program channel CSR */
;;;304           DMAChannel.csr.ff_th = 2; //FIE7021 fifo threshold value = 4
;;;305           DMAChannel.csr.priority = Priority; /* priority */
000128  9915              LDR      r1,[sp,#0x54]
00012a  f10b7000          ADD      r0,r11,#0x2000000     ;304
00012e  f3615097          BFI      r0,r1,#22,#2
;;;306           DMAChannel.csr.prot = 0; /* PROT 1-3 bits */
;;;307           DMAChannel.csr.src_size = SrcSize; /* source burst size */
000132  9912              LDR      r1,[sp,#0x48]
000134  f4201060          BIC      r0,r0,#0x380000       ;306
000138  f3614012          BFI      r0,r1,#16,#3
;;;308        //FIE7021 this bit should be 0 when change other bits
;;;309           DMAChannel.csr.abt = 0; /* NOT transaction abort */
00013c  f4204000          BIC      r0,r0,#0x8000
;;;310           DMAChannel.csr.src_width = SrcWidth; /* source transfer size */
;;;311           DMAChannel.csr.dst_width = DstWidth; /* destination transfer size */
000140  9911              LDR      r1,[sp,#0x44]
000142  f36620cd          BFI      r0,r6,#11,#3          ;310
000146  f361200a          BFI      r0,r1,#8,#3
;;;312           DMAChannel.csr.mode = Mode; /* Normal mode or Hardware handshake mode */
00014a  9916              LDR      r1,[sp,#0x58]
;;;313           DMAChannel.csr.src_ctrl = SrcCtrl; /* source increment, decrement or fix */
;;;314           DMAChannel.csr.dst_ctrl = DstCtrl; /* destination increment, decrement or fix */
;;;315           DMAChannel.csr.src_sel = 0; /* source AHB master id */
;;;316           DMAChannel.csr.dst_sel = 0; /* destination AHB master id */
;;;317    
;;;318        DMAChannel.csr.reserved1 = 0;
;;;319        DMAChannel.csr.reserved0 = 0;
;;;320    
;;;321        /* program channel CFG */
;;;322        DMAChannel.cfg.int_tc_msk = 0;				// Enable tc status
;;;323        DMAChannel.cfg.int_err_msk = 0;
;;;324        DMAChannel.cfg.src_rs = req;
;;;325        DMAChannel.cfg.dst_rs = req;
;;;326        DMAChannel.cfg.src_he = (SrcCtrl == 2);		// SrcCtrl==2 means fix source address ==> peripheral
00014c  2c02              CMP      r4,#2
00014e  f36110c7          BFI      r0,r1,#7,#1           ;312
000152  f3641046          BFI      r0,r4,#5,#2           ;313
000156  f36300c4          BFI      r0,r3,#3,#2           ;314
00015a  f0200006          BIC      r0,r0,#6              ;316
00015e  f4204180          BIC      r1,r0,#0x4000         ;318
000162  f0290003          BIC      r0,r9,#3              ;323
000166  f36900c6          BFI      r0,r9,#3,#4           ;324
00016a  f369204c          BFI      r0,r9,#9,#4           ;325
00016e  d024              BEQ      |L32.442|
000170  f0200080          BIC      r0,r0,#0x80
                  |L32.372|
;;;327        DMAChannel.cfg.dst_he = (DstCtrl == 2);
000174  2b02              CMP      r3,#2
000176  d023              BEQ      |L32.448|
000178  f4205000          BIC      r0,r0,#0x2000
                  |L32.380|
;;;328        DMAChannel.cfg.busy = 0;
;;;329        DMAChannel.cfg.reserved1 = 0;
00017c  f4204041          BIC      r0,r0,#0xc100
;;;330        DMAChannel.cfg.llp_cnt = 0;
;;;331        DMAChannel.cfg.reserved2 = 0;
000180  b284              UXTH     r4,r0
;;;332    
;;;333       /* program channel llp */
;;;334       *((UINT32 *)&(DMAChannel.llp)) = 0;
000182  465b              MOV      r3,r11
;;;335    
;;;336        if (Count > 0)
000184  b125              CBZ      r5,|L32.400|
;;;337        {
;;;338            DMAChannel.csr.tc_msk = 1; /* enable terminal count */
;;;339            DMAChannel.llp.link_list_addr = /*CPU_TO_AHB_ADDRSPACE*/((UINT32)&LLP[0]) >> 2;
000186  0890              LSRS     r0,r2,#2
000188  f0414100          ORR      r1,r1,#0x80000000     ;338
00018c  f360039f          BFI      r3,r0,#2,#30
                  |L32.400|
;;;340        }
;;;341        else
;;;342        {
;;;343            DMAChannel.csr.tc_msk = 0; /* no LLP */
;;;344        }
;;;345    
;;;346        kdp_dma_set_ch_cfg(Channel, DMAChannel.csr);
000190  9801              LDR      r0,[sp,#4]
000192  f7fffffe          BL       kdp_dma_set_ch_cfg
;;;347        kdp_dma_ch_int_mask(Channel, DMAChannel.cfg);
000196  4621              MOV      r1,r4
000198  9801              LDR      r0,[sp,#4]
00019a  f7fffffe          BL       kdp_dma_ch_int_mask
;;;348        kdp_dma_ch_linklist(Channel, DMAChannel.llp);
00019e  4619              MOV      r1,r3
0001a0  9801              LDR      r0,[sp,#4]
0001a2  f7fffffe          BL       kdp_dma_ch_linklist
;;;349    
;;;350           /* porgram address and size */
;;;351           kdp_dma_ch_data_ctrl(Channel, SrcAddr, DstAddr, 240*2);
0001a6  9a0e              LDR      r2,[sp,#0x38]
0001a8  9904              LDR      r1,[sp,#0x10]
0001aa  9801              LDR      r0,[sp,#4]
0001ac  b005              ADD      sp,sp,#0x14
0001ae  f44f73f0          MOV      r3,#0x1e0
0001b2  e8bd4ff0          POP      {r4-r11,lr}
0001b6  f7ffbffe          B.W      kdp_dma_ch_data_ctrl
                  |L32.442|
0001ba  f0400080          ORR      r0,r0,#0x80           ;326
0001be  e7d9              B        |L32.372|
                  |L32.448|
0001c0  f4405000          ORR      r0,r0,#0x2000         ;327
0001c4  e7da              B        |L32.380|
;;;352    }
;;;353    
                          ENDP

0001c6  0000              DCW      0x0000
                  |L32.456|
                          DCD      ||.data||+0x14

                          AREA ||i.kdp_dma_linkmode||, CODE, READONLY, ALIGN=2

                  kdp_dma_linkmode PROC
;;;618    
;;;619    void kdp_dma_linkmode(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;620    UINT32 Channel,   // use which channel for AHB DMA, 0..7
;;;621    UINT32 LinkAddr,  // Link-List address
;;;622    UINT32 LLPCount,  // total link-list node
;;;623    UINT32 SrcAddr,   // source begin address
;;;624    UINT32 DstAddr,   // dest begin address
;;;625    UINT32 Size,      // total bytes
;;;626    UINT32 SrcWidth,  // source width 8/16/32 bits -> 0/1/2
;;;627    UINT32 DstWidth,  // dest width 8/16/32 bits -> 0/1/2
;;;628    UINT32 SrcSize,   // source burst size, How many "SrcWidth" will be transmmited at one times ?
;;;629    UINT32 SrcCtrl,   // source address change : Inc/dec/fixed --> 0/1/2
;;;630    UINT32 DstCtrl,   // dest address change : Inc/dec/fixed --> 0/1/2
;;;631    UINT32 Priority,  // priority for this chaanel 0(low)/1/2/3(high)
;;;632    UINT32 Mode,      // Normal/Hardwire,   0/1
;;;633    int    req
;;;634    )
;;;635    {
000004  b082              SUB      sp,sp,#8
;;;636        dma_ch DMAChannel;
;;;637        UINT32 LLPSize, i, offset;
;;;638        dma_lld *LLP;
;;;639        UINT32 Count = 0;
;;;640        UINT32 AHB_SrcAddr = /*CPU_TO_AHB_ADDRSPACE*/(SrcAddr);
;;;641        UINT32 AHB_DstAddr = /*CPU_TO_AHB_ADDRSPACE*/(DstAddr);
;;;642        int burst_size = burst_size_selection[SrcSize];			// ref: [18:16] in Cn_CSR
000006  4c76              LDR      r4,|L33.480|
000008  e9dd7614          LDRD     r7,r6,[sp,#0x50]      ;635
00000c  9b05              LDR      r3,[sp,#0x14]         ;640
00000e  9300              STR      r3,[sp,#0]            ;641
000010  e9dd9a10          LDRD     r9,r10,[sp,#0x40]     ;635
000014  9b13              LDR      r3,[sp,#0x4c]
;;;643    
;;;644        LLP = (dma_lld *)LinkAddr;
;;;645        *((unsigned int *)&DMAChannel.csr) = 0;		// clear value of csr;
;;;646    
;;;647    #ifdef DBG_DMA
;;;648        kdp_printf("Ch%d, Src=%08X, Dst=%08X, Size=%08X SrcWidth=%db, DstWidth=%db, SrcSize=%dB\n"
;;;649               "SrcCtrl=%s, DstCtrl=%s, Priority=%d, Mode=%s, LLPCnt = %d\n",
;;;650               Channel, SrcAddr, DstAddr, Size, 1 << (SrcWidth + 3), 1 << (DstWidth + 3),
;;;651               ((SrcSize == 0) ? 1 : 1 << (SrcSize+1)),
;;;652               ((SrcCtrl == 0) ? "Inc" : ((SrcCtrl == 1) ? "Dec" : "Fix")),
;;;653               ((DstCtrl == 0) ? "Inc" : ((DstCtrl == 1) ? "Dec" : "Fix")),
;;;654               Priority, ((Mode == 0) ? "Normal" : "HW"), LLPCount);
;;;655    #endif
;;;656    
;;;657        Size = Size / (1 << SrcWidth);		// how many unit want to transfer
000016  f04f0801          MOV      r8,#1
00001a  fa08f80a          LSL      r8,r8,r10
00001e  f854c023          LDR      r12,[r4,r3,LSL #2]    ;642
000022  fbb9f3f8          UDIV     r3,r9,r8
000026  2500              MOVS     r5,#0                 ;639
000028  f8ddb060          LDR      r11,[sp,#0x60]        ;640
00002c  f8dde03c          LDR      lr,[sp,#0x3c]         ;645
000030  460c              MOV      r4,r1                 ;644
;;;658    
;;;659        if(LLPCount && LinkAddr)
000032  9501              STR      r5,[sp,#4]
000034  2a00              CMP      r2,#0
000036  d047              BEQ      |L33.200|
000038  2c00              CMP      r4,#0
00003a  d07e              BEQ      |L33.314|
;;;660        {
;;;661        //LLPSize = CN_SIZE;
;;;662        if (req != 0)		// memory to memory does not have this restriction
00003c  ea5f010b          MOVS     r1,r11
000040  d00b              BEQ      |L33.90|
;;;663        {
;;;664            LLPSize = RoundDown(CN_SIZE, burst_size);			// how many cycle a descriptor can transfer
000042  f44f607f          MOV      r0,#0xff0
;;;665            ASSERT((Size%burst_size)==0);
000046  fbb3f1fc          UDIV     r1,r3,r12
00004a  fbb0f0fc          UDIV     r0,r0,r12             ;664
00004e  fb0c3111          MLS      r1,r12,r1,r3
000052  fb00f00c          MUL      r0,r0,r12             ;664
000056  b101              CBZ      r1,|L33.90|
                  |L33.88|
000058  e7fe              B        |L33.88|
                  |L33.90|
;;;666        }
;;;667        Count = divRoundDown(Size, LLPSize);		// how many link-list structure need to fill
00005a  fbb3f5f0          UDIV     r5,r3,r0
;;;668        ASSERT(Count<=LLPCount);
00005e  4295              CMP      r5,r2
000060  d900              BLS      |L33.100|
                  |L33.98|
000062  e7fe              B        |L33.98|
                  |L33.100|
;;;669    
;;;670        // At last, 2 part
;;;671        if (Count > 0)
000064  b385              CBZ      r5,|L33.200|
;;;672        {
;;;673                offset = LLPSize << SrcWidth;
000066  fa00f90a          LSL      r9,r0,r10
;;;674               for(i = 0; i < Count ;i++)
00006a  2100              MOVS     r1,#0
00006c  e054              B        |L33.280|
                  |L33.110|
;;;675               {
;;;676                  if (SrcCtrl == 0)  // increase
00006e  b127              CBZ      r7,|L33.122|
;;;677                     LLP[i].src_addr = (UINT32)AHB_SrcAddr + ((i+1) * offset);
;;;678                  else if(SrcCtrl==1) // decrease
000070  2f01              CMP      r7,#1
000072  d008              BEQ      |L33.134|
;;;679                     LLP[i].src_addr = (UINT32)AHB_SrcAddr - ((i+1) * offset);
;;;680                  else if(SrcCtrl==2)	// fixed
000074  2f02              CMP      r7,#2
000076  d00c              BEQ      |L33.146|
000078  e010              B        |L33.156|
                  |L33.122|
00007a  9a00              LDR      r2,[sp,#0]            ;677
00007c  f1010c01          ADD      r12,r1,#1             ;677
000080  fb0c2209          MLA      r2,r12,r9,r2          ;677
000084  e006              B        |L33.148|
                  |L33.134|
000086  f8ddc000          LDR      r12,[sp,#0]           ;679
00008a  1c4a              ADDS     r2,r1,#1              ;679
00008c  fb02c219          MLS      r2,r2,r9,r12          ;679
000090  e000              B        |L33.148|
                  |L33.146|
;;;681                     LLP[i].src_addr = (UINT32)AHB_SrcAddr;
000092  9a00              LDR      r2,[sp,#0]
                  |L33.148|
000094  eb010c81          ADD      r12,r1,r1,LSL #2
000098  f844202c          STR      r2,[r4,r12,LSL #2]
                  |L33.156|
;;;682    
;;;683                  if(DstCtrl == 0)
00009c  b126              CBZ      r6,|L33.168|
;;;684                     LLP[i].dst_addr = (UINT32)AHB_DstAddr + ((i+1) * offset);
;;;685                  else if(DstCtrl == 1)	// Decrease
00009e  2e01              CMP      r6,#1
0000a0  d007              BEQ      |L33.178|
;;;686                     LLP[i].dst_addr = (UINT32)AHB_DstAddr - ((i+1) * offset);
;;;687                  else if(DstCtrl == 2)
0000a2  2e02              CMP      r6,#2
0000a4  d011              BEQ      |L33.202|
0000a6  e016              B        |L33.214|
                  |L33.168|
0000a8  f1010c01          ADD      r12,r1,#1             ;684
0000ac  fb0ce209          MLA      r2,r12,r9,lr          ;684
0000b0  e003              B        |L33.186|
                  |L33.178|
0000b2  f1010c01          ADD      r12,r1,#1             ;686
0000b6  fb0ce219          MLS      r2,r12,r9,lr          ;686
                  |L33.186|
0000ba  eb010c81          ADD      r12,r1,r1,LSL #2      ;686
0000be  eb040c8c          ADD      r12,r4,r12,LSL #2     ;686
0000c2  f8cc2004          STR      r2,[r12,#4]           ;686
0000c6  e006              B        |L33.214|
                  |L33.200|
0000c8  e037              B        |L33.314|
                  |L33.202|
;;;688                     LLP[i].dst_addr = (UINT32)AHB_DstAddr;
0000ca  eb010c81          ADD      r12,r1,r1,LSL #2
0000ce  eb040c8c          ADD      r12,r4,r12,LSL #2
0000d2  f8cce004          STR      lr,[r12,#4]
                  |L33.214|
;;;689    
;;;690                  *((UINT32 *)&(LLP[i].llp)) = 0;
0000d6  eb010c81          ADD      r12,r1,r1,LSL #2
0000da  eb040c8c          ADD      r12,r4,r12,LSL #2
0000de  2200              MOVS     r2,#0
;;;691                  LLP[i].llp.link_list_addr = /*CPU_TO_AHB_ADDRSPACE*/((UINT32)&LLP[i+1]) >> 2;
0000e0  f10c0814          ADD      r8,r12,#0x14
0000e4  ea4f0898          LSR      r8,r8,#2
0000e8  f368029f          BFI      r2,r8,#2,#30
;;;692    
;;;693                  *((UINT32 *)&(LLP[i].llp_ctrl)) = 0;
;;;694                  LLP[i].llp_ctrl.tc_msk = 1;
0000ec  f8cc2008          STR      r2,[r12,#8]
0000f0  f04f5280          MOV      r2,#0x10000000
;;;695                  LLP[i].llp_ctrl.src_width = SrcWidth; /* source transfer size */
;;;696                  LLP[i].llp_ctrl.dst_width = DstWidth; /* destination transfer size */
0000f4  f8dd8048          LDR      r8,[sp,#0x48]
0000f8  f36a625b          BFI      r2,r10,#25,#3         ;695
0000fc  f3685298          BFI      r2,r8,#22,#3
;;;697                  LLP[i].llp_ctrl.src_ctrl = SrcCtrl; /* source increment, decrement or fix */
000100  f3675215          BFI      r2,r7,#20,#2
;;;698                  LLP[i].llp_ctrl.dst_ctrl = DstCtrl; /* destination increment, decrement or fix */
000104  f3664293          BFI      r2,r6,#18,#2
;;;699                  LLP[i].llp_ctrl.src_sel = 0; /* source AHB master id */
;;;700                  LLP[i].llp_ctrl.dst_sel = 0; /* destination AHB master id */
000108  f4223240          BIC      r2,r2,#0x30000
00010c  f1024280          ADD      r2,r2,#0x40000000
000110  e9cc2003          STRD     r2,r0,[r12,#0xc]
;;;701                  LLP[i].llp_ctrl.ff_th = 2; //FIE7021 fifo threshold value = 4
;;;702                LLP[i].size = LLPSize;
;;;703                Size -= LLPSize;
000114  1a1b              SUBS     r3,r3,r0
000116  1c49              ADDS     r1,r1,#1
                  |L33.280|
000118  42a9              CMP      r1,r5                 ;674
00011a  d3a8              BCC      |L33.110|
;;;704            }
;;;705               LLP[i-1].llp.link_list_addr = 0;
00011c  eb010181          ADD      r1,r1,r1,LSL #2
000120  eb040181          ADD      r1,r4,r1,LSL #2
000124  f8112d0c          LDRB     r2,[r1,#-0xc]!
000128  f0020203          AND      r2,r2,#3
;;;706               LLP[i-1].llp_ctrl.tc_msk = 0;	// Enable tc status
00012c  600a              STR      r2,[r1,#0]
00012e  684a              LDR      r2,[r1,#4]
000130  f0225280          BIC      r2,r2,#0x10000000
000134  e9c12301          STRD     r2,r3,[r1,#4]
;;;707               LLP[i-1].size = Size;
;;;708               Size = LLPSize;
000138  4603              MOV      r3,r0
                  |L33.314|
;;;709        }
;;;710    
;;;711    #ifdef DBG_DMA
;;;712        for(i = 0; i < LLPCount;i++)
;;;713        {
;;;714            kdp_printf("src=%0.8X, dst=%0.8X, link=%0.8X, ctrl=%.8X\n", LLP[i].src_addr, LLP[i].dst_addr,
;;;715                *(UINT32 *)&(LLP[i].llp), *(UINT32 *)&(LLP[i].llp_ctrl));
;;;716    
;;;717        }
;;;718    #endif
;;;719    }
;;;720        /* program channel */
;;;721        kdp_dma_clear_ch_int_status(Channel);
00013a  9802              LDR      r0,[sp,#8]
00013c  f7fffffe          BL       kdp_dma_clear_ch_int_status
;;;722    
;;;723        /* program channel CSR */
;;;724           DMAChannel.csr.ff_th = 2; //FIE7021 fifo threshold value = 4
;;;725           DMAChannel.csr.priority = Priority; /* priority */
000140  9801              LDR      r0,[sp,#4]
000142  9916              LDR      r1,[sp,#0x58]
000144  f1007000          ADD      r0,r0,#0x2000000
000148  f3615097          BFI      r0,r1,#22,#2
;;;726           DMAChannel.csr.prot = 0; /* PROT 1-3 bits */
;;;727           DMAChannel.csr.src_size = SrcSize; /* source burst size */
00014c  9913              LDR      r1,[sp,#0x4c]
00014e  f4201060          BIC      r0,r0,#0x380000       ;726
000152  f3614012          BFI      r0,r1,#16,#3
;;;728        //FIE7021 this bit should be 0 when change other bits
;;;729           DMAChannel.csr.abt = 0; /* NOT transaction abort */
000156  f4204000          BIC      r0,r0,#0x8000
;;;730           DMAChannel.csr.src_width = SrcWidth; /* source transfer size */
;;;731           DMAChannel.csr.dst_width = DstWidth; /* destination transfer size */
00015a  9912              LDR      r1,[sp,#0x48]
00015c  f36a20cd          BFI      r0,r10,#11,#3         ;730
000160  f361200a          BFI      r0,r1,#8,#3
;;;732           DMAChannel.csr.mode = Mode; /* Normal mode or Hardware handshake mode */
000164  9917              LDR      r1,[sp,#0x5c]
;;;733           DMAChannel.csr.src_ctrl = SrcCtrl; /* source increment, decrement or fix */
;;;734           DMAChannel.csr.dst_ctrl = DstCtrl; /* destination increment, decrement or fix */
;;;735           DMAChannel.csr.src_sel = 0; /* source AHB master id */
;;;736           DMAChannel.csr.dst_sel = 0; /* destination AHB master id */
;;;737    
;;;738        DMAChannel.csr.reserved1 = 0;
;;;739        DMAChannel.csr.reserved0 = 0;
;;;740    
;;;741        /* program channel CFG */
;;;742        DMAChannel.cfg.int_tc_msk = 0;				// Enable tc status
;;;743        DMAChannel.cfg.int_err_msk = 0;
;;;744        DMAChannel.cfg.src_rs = req;
;;;745        DMAChannel.cfg.dst_rs = req;
;;;746        DMAChannel.cfg.src_he = (SrcCtrl == 2);		// SrcCtrl==2 means fix source address ==> peripheral
000166  2f02              CMP      r7,#2
000168  f36110c7          BFI      r0,r1,#7,#1           ;732
00016c  f3671046          BFI      r0,r7,#5,#2           ;733
000170  f36600c4          BFI      r0,r6,#3,#2           ;734
000174  f0200006          BIC      r0,r0,#6              ;736
000178  f4204180          BIC      r1,r0,#0x4000         ;738
00017c  f02a0003          BIC      r0,r10,#3             ;743
000180  f36b00c6          BFI      r0,r11,#3,#4          ;744
000184  f36b204c          BFI      r0,r11,#9,#4          ;745
000188  d023              BEQ      |L33.466|
00018a  f0200080          BIC      r0,r0,#0x80
                  |L33.398|
;;;747        DMAChannel.cfg.dst_he = (DstCtrl == 2);
00018e  2e02              CMP      r6,#2
000190  d022              BEQ      |L33.472|
000192  f4205000          BIC      r0,r0,#0x2000
;;;748        DMAChannel.cfg.busy = 0;
;;;749        DMAChannel.cfg.reserved1 = 0;
000196  bf00              NOP      
                  |L33.408|
000198  f4204041          BIC      r0,r0,#0xc100
;;;750        DMAChannel.cfg.llp_cnt = 0;
;;;751        DMAChannel.cfg.reserved2 = 0;
00019c  b287              UXTH     r7,r0
;;;752    
;;;753       /* program channel llp */
;;;754       *((UINT32 *)&(DMAChannel.llp)) = 0;
00019e  2600              MOVS     r6,#0
;;;755    
;;;756        if (Count > 0)
0001a0  b125              CBZ      r5,|L33.428|
;;;757        {
;;;758            DMAChannel.csr.tc_msk = 1; /* enable terminal count */
;;;759            DMAChannel.llp.link_list_addr = /*CPU_TO_AHB_ADDRSPACE*/((UINT32)&LLP[0]) >> 2;
0001a2  08a0              LSRS     r0,r4,#2
0001a4  f0414100          ORR      r1,r1,#0x80000000     ;758
0001a8  f360069f          BFI      r6,r0,#2,#30
                  |L33.428|
;;;760        }
;;;761        else
;;;762        {
;;;763            DMAChannel.csr.tc_msk = 0; /* no LLP */
;;;764        }
;;;765    
;;;766        kdp_dma_set_ch_cfg(Channel, DMAChannel.csr);
0001ac  9802              LDR      r0,[sp,#8]
0001ae  f7fffffe          BL       kdp_dma_set_ch_cfg
;;;767        kdp_dma_ch_int_mask(Channel, DMAChannel.cfg);
0001b2  4639              MOV      r1,r7
0001b4  9802              LDR      r0,[sp,#8]
0001b6  f7fffffe          BL       kdp_dma_ch_int_mask
;;;768        kdp_dma_ch_linklist(Channel, DMAChannel.llp);
0001ba  4631              MOV      r1,r6
0001bc  9802              LDR      r0,[sp,#8]
0001be  f7fffffe          BL       kdp_dma_ch_linklist
;;;769    
;;;770           /* porgram address and size */
;;;771           kdp_dma_ch_data_ctrl(Channel, SrcAddr, DstAddr, Size);
0001c2  9a0f              LDR      r2,[sp,#0x3c]
0001c4  9905              LDR      r1,[sp,#0x14]
0001c6  9802              LDR      r0,[sp,#8]
0001c8  b006              ADD      sp,sp,#0x18
0001ca  e8bd4ff0          POP      {r4-r11,lr}
0001ce  f7ffbffe          B.W      kdp_dma_ch_data_ctrl
                  |L33.466|
0001d2  f0400080          ORR      r0,r0,#0x80           ;746
0001d6  e7da              B        |L33.398|
                  |L33.472|
0001d8  f4405000          ORR      r0,r0,#0x2000         ;747
0001dc  e7dc              B        |L33.408|
;;;772    }
;;;773    
                          ENDP

0001de  0000              DCW      0x0000
                  |L33.480|
                          DCD      ||.data||+0x14

                          AREA ||i.kdp_dma_mem_link_list_init||, CODE, READONLY, ALIGN=2

                  kdp_dma_mem_link_list_init PROC
;;;507    
;;;508    void kdp_dma_mem_link_list_init( u32 llp_buf, dma_ch_csr ch_crs, u32 count )
000000  b570              PUSH     {r4-r6,lr}
;;;509    {
;;;510    
;;;511        u32 control = (ch_crs.ff_th << 29) |
000002  0e0b              LSRS     r3,r1,#24
000004  075b              LSLS     r3,r3,#29
000006  f3c124c2          UBFX     r4,r1,#11,#3
00000a  ea436344          ORR      r3,r3,r4,LSL #25
00000e  f3c12502          UBFX     r5,r1,#8,#3
000012  ea435385          ORR      r3,r3,r5,LSL #22
000016  f3c11541          UBFX     r5,r1,#5,#2
00001a  ea435305          ORR      r3,r3,r5,LSL #20
00001e  f3c101c1          UBFX     r1,r1,#3,#2
000022  ea434181          ORR      r1,r3,r1,LSL #18
000026  f0415580          ORR      r5,r1,#0x10000000
;;;512                      (0x1 << 28) |
;;;513                      (ch_crs.src_width << 25) |
;;;514                      (ch_crs.dst_width << 22) |
;;;515                      (ch_crs.src_ctrl << 20) |
;;;516                      (ch_crs.dst_ctrl << 18);
;;;517    
;;;518        u32 src_width_shift = ch_crs.src_width;
;;;519    
;;;520        _link_list_descriptor_t *llp_array = (_link_list_descriptor_t *)llp_buf;
;;;521    
;;;522        for (u32 i = 0; i < count; i++)
00002a  2300              MOVS     r3,#0
00002c  e00c              B        |L34.72|
;;;523        {
;;;524            //dbg_msg_console( "tx_buf[%d]= %#x, rx_buf[%d]= %#x, size[%d]= %d", i, llp_array[i].src_addr, i, llp_array[i].dst_addr, i , llp_array[i].total_size );
;;;525            llp_array[i].llp = (u32)(&(llp_array[i + 1]));
00002e  bf00              NOP      
                  |L34.48|
000030  eb030183          ADD      r1,r3,r3,LSL #2
000034  eb000181          ADD      r1,r0,r1,LSL #2
000038  f1010614          ADD      r6,r1,#0x14
00003c  e9c16502          STRD     r6,r5,[r1,#8]
;;;526            llp_array[i].control = control;
;;;527            llp_array[i].total_size = llp_array[i].total_size >> src_width_shift;// (u32) (size[i] >> src_width_shift);
000040  690e              LDR      r6,[r1,#0x10]
000042  40e6              LSRS     r6,r6,r4
000044  1c5b              ADDS     r3,r3,#1
000046  610e              STR      r6,[r1,#0x10]
                  |L34.72|
000048  4293              CMP      r3,r2                 ;522
00004a  d3f1              BCC      |L34.48|
;;;528        }
;;;529        llp_array[count - 1].llp = 0;
00004c  eb020282          ADD      r2,r2,r2,LSL #2
000050  eb000082          ADD      r0,r0,r2,LSL #2
000054  2100              MOVS     r1,#0
000056  f8401d0c          STR      r1,[r0,#-0xc]!
;;;530        llp_array[count - 1].control &= ~(0x1 << 28);
00005a  6841              LDR      r1,[r0,#4]
00005c  f0215180          BIC      r1,r1,#0x10000000
000060  6041              STR      r1,[r0,#4]
;;;531    
;;;532    }
000062  bd70              POP      {r4-r6,pc}
;;;533    
                          ENDP


                          AREA ||i.kdp_dma_memcpy||, CODE, READONLY, ALIGN=2

                  kdp_dma_memcpy PROC
;;;533    
;;;534    u8 kdp_dma_memcpy( u32 count )
000000  b570              PUSH     {r4-r6,lr}
;;;535    {
;;;536        u8 ret = 0;
000002  2400              MOVS     r4,#0
000004  4606              MOV      r6,r0                 ;535
000006  b08a              SUB      sp,sp,#0x28           ;535
;;;537        dma_ch DMAChannel;
;;;538        UINT8 ch = AHBDMA_Channel1;
000008  2501              MOVS     r5,#1
;;;539    
;;;540        kdp_dma_init(0,0,0);//fLib_InitDMA(FALSE, FALSE, 0x0);
00000a  4622              MOV      r2,r4
00000c  4621              MOV      r1,r4
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       kdp_dma_init
                  |L35.20|
;;;541    
;;;542        while (kdp_dma_is_ch_busy(ch));// { osDelay(1); } ;
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       kdp_dma_is_ch_busy
00001a  2800              CMP      r0,#0
00001c  d1fa              BNE      |L35.20|
;;;543    
;;;544        kdp_dma_reset_ch(ch);// fLib_DMA_ResetChannel(0);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       kdp_dma_reset_ch
;;;545        kdp_dma_clear_interrupt(ch);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       kdp_dma_clear_interrupt
;;;546        kdp_dma_enable_dma_int();// fLib_DMA_EnableDMAInt(); //Enable DMA Interrupt
00002a  f7fffffe          BL       kdp_dma_enable_dma_int
;;;547    
;;;548        // tx channel setting
;;;549        memset(&DMAChannel, 0x0, sizeof(dma_ch));
00002e  2120              MOVS     r1,#0x20
000030  a801              ADD      r0,sp,#4
000032  f7fffffe          BL       __aeabi_memclr4
;;;550        DMAChannel.csr.dst_ctrl = AHBDMA_DstInc;
;;;551        DMAChannel.csr.src_ctrl = AHBDMA_SrcInc;
;;;552        DMAChannel.csr.mode = AHBDMA_NormalMode;
;;;553        DMAChannel.csr.dst_width = AHBDMA_DstWidth_Byte;
000036  9801              LDR      r0,[sp,#4]
;;;554        DMAChannel.csr.src_width = AHBDMA_DstWidth_Byte;
;;;555        DMAChannel.csr.priority = 3;
;;;556        DMAChannel.csr.src_size = 0;
;;;557    
;;;558        DMAChannel.cfg.dst_rs = 0; //SSP_u1_TX_DMA_REQ
;;;559        DMAChannel.cfg.dst_he = 0;
;;;560        DMAChannel.cfg.src_rs = 0;
;;;561        DMAChannel.cfg.src_he = 0;
;;;562        DMAChannel.cfg.int_abt_msk = 0;
;;;563        DMAChannel.cfg.int_err_msk = 0;
;;;564        DMAChannel.cfg.int_tc_msk = 0;
;;;565    
;;;566        //dbg_msg_console(" src addr = %#X, dst addr = %#X" , *tx_buf, *rx_buf, *size );
;;;567    
;;;568        //_link_list_descriptor_t llp_buf[count];
;;;569        kdp_dma_mem_link_list_init( llp_buf, DMAChannel.csr, count );
000038  4632              MOV      r2,r6
00003a  f42060ff          BIC      r0,r0,#0x7f8          ;553
00003e  f42020e7          BIC      r0,r0,#0x73800        ;555
000042  f4400040          ORR      r0,r0,#0xc00000       ;556
000046  9001              STR      r0,[sp,#4]            ;558
000048  9802              LDR      r0,[sp,#8]            ;559
00004a  4e14              LDR      r6,|L35.156|
00004c  f4205078          BIC      r0,r0,#0x3e00         ;559
000050  f02000ff          BIC      r0,r0,#0xff           ;564
000054  9002              STR      r0,[sp,#8]
000056  9901              LDR      r1,[sp,#4]
000058  6930              LDR      r0,[r6,#0x10]  ; llp_buf
00005a  f7fffffe          BL       kdp_dma_mem_link_list_init
;;;570    
;;;571        kdp_dma_set_ch_cfg(ch, DMAChannel.csr); //    fLib_SetDMAChannelCfg(0, csr);
00005e  4628              MOV      r0,r5
000060  9901              LDR      r1,[sp,#4]
000062  f7fffffe          BL       kdp_dma_set_ch_cfg
;;;572        kdp_dma_set_ch_cn_cfg(ch, DMAChannel.cfg);// fLib_SetDMAChannelCnCfg(0, cfg);
000066  4628              MOV      r0,r5
000068  9902              LDR      r1,[sp,#8]
00006a  f7fffffe          BL       kdp_dma_set_ch_cn_cfg
;;;573        /* porgram address and size */
;;;574        kdp_dma_ch_llp_data_ctrl(ch, *((u32*)(llp_buf)) , *((u32*)(llp_buf+4)), *((u32*)(llp_buf+16)), llp_buf );
00006e  6930              LDR      r0,[r6,#0x10]  ; llp_buf
000070  9000              STR      r0,[sp,#0]
000072  e9d01200          LDRD     r1,r2,[r0,#0]
000076  6903              LDR      r3,[r0,#0x10]
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       kdp_dma_ch_llp_data_ctrl
;;;575    
;;;576    
;;;577        kdp_dma_enable_ch(ch);// fLib_EnableDMAChannel(0);
00007e  4628              MOV      r0,r5
000080  f7fffffe          BL       kdp_dma_enable_ch
;;;578        ret |= kdp_dma_wait_dma_int(ch);// fLib_DMA_WaitDMAInt(0);
000084  4628              MOV      r0,r5
000086  f7fffffe          BL       kdp_dma_wait_dma_int
00008a  ea400204          ORR      r2,r0,r4
;;;579    
;;;580        kdp_dma_disable_ch(ch);// fLib_DisableDMAChannel(0);
00008e  4628              MOV      r0,r5
000090  f7fffffe          BL       kdp_dma_disable_ch
;;;581    
;;;582       // kdp_dma_disable_dma_int();// fLib_DMA_EnableDMAInt(); //Enable DMA Interrupt
;;;583    
;;;584        return ret;
;;;585    
;;;586    }
000094  b00a              ADD      sp,sp,#0x28
000096  4610              MOV      r0,r2                 ;584
000098  bd70              POP      {r4-r6,pc}
;;;587    
                          ENDP

00009a  0000              DCW      0x0000
                  |L35.156|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_normal_mode||, CODE, READONLY, ALIGN=1

                  kdp_dma_normal_mode PROC
;;;774    
;;;775    void kdp_dma_normal_mode(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;776    UINT32 Channel,   // use which channel for AHB DMA, 0..7
;;;777    UINT32 SrcAddr,   // source begin address
;;;778    UINT32 DstAddr,   // dest begin address
;;;779    UINT32 Size,      // total bytes
;;;780    UINT32 SrcWidth,  // source width 8/16/32 bits -> 0/1/2
;;;781    UINT32 DstWidth,  // dest width 8/16/32 bits -> 0/1/2
;;;782    UINT32 SrcSize,   // source burst size, How many "SrcWidth" will be transmmited at one times ?
;;;783    UINT32 SrcCtrl,   // source address change : Inc/dec/fixed --> 0/1/2
;;;784    UINT32 DstCtrl,   // dest address change : Inc/dec/fixed --> 0/1/2
;;;785    UINT32 Priority,  // priority for this chaanel 0(low)/1/2/3(high)
;;;786    UINT32 Mode,      // Normal/Hardwire,   0/1
;;;787    int    req
;;;788    )
;;;789    {
000004  b08a              SUB      sp,sp,#0x28
000006  f10d0e48          ADD      lr,sp,#0x48
00000a  4682              MOV      r10,r0
00000c  e89e13e0          LDM      lr,{r5-r9,r12}
000010  e9dd4018          LDRD     r4,r0,[sp,#0x60]
000014  e9cd4008          STRD     r4,r0,[sp,#0x20]
;;;790        kdp_dma_linkmode(
000018  9200              STR      r2,[sp,#0]
00001a  e9cd3501          STRD     r3,r5,[sp,#4]
00001e  f10d0e0c          ADD      lr,sp,#0xc
000022  460b              MOV      r3,r1
000024  e88e13c0          STM      lr,{r6-r9,r12}
000028  2200              MOVS     r2,#0
00002a  4611              MOV      r1,r2
00002c  4650              MOV      r0,r10
00002e  f7fffffe          BL       kdp_dma_linkmode
;;;791                Channel,   // use which channel for AHB DMA, 0..7
;;;792                NULL,
;;;793                0,  // total link-list node
;;;794                SrcAddr,   // source begin address
;;;795                DstAddr,   // dest begin address
;;;796                Size,      // total bytes
;;;797                SrcWidth,  // source width 8/16/32 bits -> 0/1/2
;;;798                DstWidth,  // dest width 8/16/32 bits -> 0/1/2
;;;799                SrcSize,   // source burst size, How many "SrcWidth" will be transmmited at one times ?
;;;800                SrcCtrl,   // source address change : Inc/dec/fixed --> 0/1/2
;;;801                DstCtrl,   // dest address change : Inc/dec/fixed --> 0/1/2
;;;802                Priority,  // priority for this chaanel 0(low)/1/2/3(high)
;;;803                Mode,      // Normal/Hardwire,   0/1
;;;804                req);
;;;805    }
000032  b00a              ADD      sp,sp,#0x28
000034  e8bd87f0          POP      {r4-r10,pc}
;;;806    
                          ENDP


                          AREA ||i.kdp_dma_reset_ch||, CODE, READONLY, ALIGN=2

                  kdp_dma_reset_ch PROC
;;;832    
;;;833    void kdp_dma_reset_ch(UINT8 channel)
000000  4905              LDR      r1,|L37.24|
;;;834    {
;;;835        UINT32 base = DMAC_FTDMAC020_PA_BASE_SCPU+DMA_CHANNEL0_BASE+channel*DMA_CHANNEL_OFFSET;
000002  eb011040          ADD      r0,r1,r0,LSL #5
;;;836    
;;;837        outw(base+DMA_CHANNEL_CSR_OFFSET,0);
000006  2100              MOVS     r1,#0
000008  6001              STR      r1,[r0,#0]
;;;838        outw(base+DMA_CHANNEL_CFG_OFFSET,7);
00000a  2207              MOVS     r2,#7
00000c  6042              STR      r2,[r0,#4]
;;;839        outw(base+DMA_CHANNEL_SRCADDR_OFFSET,0);
00000e  6081              STR      r1,[r0,#8]
;;;840        outw(base+DMA_CHANNEL_DSTADDR_OFFSET,0);
000010  60c1              STR      r1,[r0,#0xc]
;;;841        outw(base+DMA_CHANNEL_LLP_OFFSET,0);
000012  6101              STR      r1,[r0,#0x10]
;;;842        outw(base+DMA_CHANNEL_SIZE_OFFSET,0);
000014  6141              STR      r1,[r0,#0x14]
;;;843    }
000016  4770              BX       lr
;;;844    
                          ENDP

                  |L37.24|
                          DCD      0xa0100100

                          AREA ||i.kdp_dma_set_ch_cfg||, CODE, READONLY, ALIGN=2

                  kdp_dma_set_ch_cfg PROC
;;;163    
;;;164    void kdp_dma_set_ch_cfg(INT32 Channel, dma_ch_csr Csr)
000000  4a03              LDR      r2,|L38.16|
;;;165    {
;;;166        m_dma_reg->dma_ch[Channel].csr = Csr;
000002  6852              LDR      r2,[r2,#4]  ; m_dma_reg
000004  eb021040          ADD      r0,r2,r0,LSL #5
000008  f8c01100          STR      r1,[r0,#0x100]
;;;167    }
00000c  4770              BX       lr
;;;168    
                          ENDP

00000e  0000              DCW      0x0000
                  |L38.16|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_set_ch_cn_cfg||, CODE, READONLY, ALIGN=2

                  kdp_dma_set_ch_cn_cfg PROC
;;;174    
;;;175    void kdp_dma_set_ch_cn_cfg(INT32 Channel, dma_ch_cfg CnCfg)
000000  4a03              LDR      r2,|L39.16|
;;;176    {
;;;177        m_dma_reg->dma_ch[Channel].cfg = CnCfg;
000002  6852              LDR      r2,[r2,#4]  ; m_dma_reg
000004  eb021040          ADD      r0,r2,r0,LSL #5
000008  f8c01104          STR      r1,[r0,#0x104]
;;;178    }
00000c  4770              BX       lr
;;;179    
                          ENDP

00000e  0000              DCW      0x0000
                  |L39.16|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_set_interrupt||, CODE, READONLY, ALIGN=1

                  kdp_dma_set_interrupt PROC
;;;807    
;;;808    void kdp_dma_set_interrupt(UINT32 channel, UINT32 tcintr, UINT32 errintr, UINT32 abtintr)
000000  b530              PUSH     {r4,r5,lr}
;;;809    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;810        dma_ch_cfg cfg;
;;;811    //	int i;
;;;812    
;;;813        cfg =  kdp_dma_get_ch_cn_cfg(channel); //ycmo091007 add
000006  f7fffffe          BL       kdp_dma_get_ch_cn_cfg
;;;814    
;;;815        if(tcintr)
00000a  b115              CBZ      r5,|L40.18|
;;;816            cfg.int_tc_msk = 0;	// Enable terminal count interrupt
00000c  f0200001          BIC      r0,r0,#1
000010  e001              B        |L40.22|
                  |L40.18|
;;;817        else
;;;818            cfg.int_tc_msk = 1;	// Disable terminal count interrupt
000012  f0400001          ORR      r0,r0,#1
                  |L40.22|
;;;819    
;;;820        if(errintr)
000016  b112              CBZ      r2,|L40.30|
;;;821            cfg.int_err_msk = 0;	// Enable error interrupt
000018  f0200002          BIC      r0,r0,#2
00001c  e001              B        |L40.34|
                  |L40.30|
;;;822        else
;;;823            cfg.int_err_msk = 1;	// Disable error interrupt
00001e  f0400002          ORR      r0,r0,#2
                  |L40.34|
;;;824    
;;;825        if(abtintr)
000022  b113              CBZ      r3,|L40.42|
;;;826            cfg.int_abt_msk = 0;	// Enable abort interrupt
000024  f0200104          BIC      r1,r0,#4
000028  e001              B        |L40.46|
                  |L40.42|
;;;827        else
;;;828            cfg.int_abt_msk = 1;	// Disable abort interrupt
00002a  f0400104          ORR      r1,r0,#4
                  |L40.46|
;;;829    
;;;830        kdp_dma_ch_int_mask(channel, cfg);
00002e  4620              MOV      r0,r4
000030  e8bd4030          POP      {r4,r5,lr}
000034  f7ffbffe          B.W      kdp_dma_ch_int_mask
;;;831    }
;;;832    
                          ENDP


                          AREA ||i.kdp_dma_wait_dma_int||, CODE, READONLY, ALIGN=2

                  kdp_dma_wait_dma_int PROC
;;;917    
;;;918    u8 kdp_dma_wait_dma_int(UINT32 channel)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;919    {
;;;920        u32 cnt = 0;
000004  2500              MOVS     r5,#0
000006  4681              MOV      r9,r0                 ;919
;;;921        u8 ret = 1;
000008  2701              MOVS     r7,#1
;;;922        while(!(__dma_int_occurred & (1 << channel)))
00000a  fa07f409          LSL      r4,r7,r9
00000e  4e0d              LDR      r6,|L41.68|
;;;923        {
;;;924           //kdp_printf("kdp_dma_wait_dma_int: __dma_int_occurred %d\n", __dma_int_occurred);
;;;925            //__WFE (); 								   // Power-Down until next Event/Interrupt
;;;926            delay_us(1);
;;;927            if (DMA_WAIT_INT_TIMEOUT_CNT < cnt)
000010  f44f2800          MOV      r8,#0x80000
000014  e00d              B        |L41.50|
                  |L41.22|
000016  2001              MOVS     r0,#1                 ;926
000018  f7fffffe          BL       delay_us
00001c  4545              CMP      r5,r8
00001e  d307              BCC      |L41.48|
;;;928            {
;;;929                err_msg("kdp_dma_wait_dma_int time :%d ch :%d", cnt, channel);
000020  464b              MOV      r3,r9
000022  462a              MOV      r2,r5
000024  a108              ADR      r1,|L41.72|
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       kdp_level_printf
;;;930                ret = 0;
00002c  2700              MOVS     r7,#0
;;;931                break;
00002e  e003              B        |L41.56|
                  |L41.48|
000030  1c6d              ADDS     r5,r5,#1
                  |L41.50|
000032  68b0              LDR      r0,[r6,#8]            ;922  ; __dma_int_occurred
000034  4204              TST      r4,r0                 ;922
000036  d0ee              BEQ      |L41.22|
                  |L41.56|
;;;932            }
;;;933            cnt++;
;;;934        }
;;;935        __dma_int_occurred &= ~(1 << channel);
000038  68b0              LDR      r0,[r6,#8]  ; __dma_int_occurred
00003a  43a0              BICS     r0,r0,r4
00003c  60b0              STR      r0,[r6,#8]  ; __dma_int_occurred
;;;936    
;;;937        return ret;
00003e  4638              MOV      r0,r7
;;;938    }
000040  e8bd87f0          POP      {r4-r10,pc}
;;;939    
                          ENDP

                  |L41.68|
                          DCD      ||.data||
                  |L41.72|
000048  6b64705f          DCB      "kdp_dma_wait_dma_int time :%d ch :%d",0
00004c  646d615f
000050  77616974
000054  5f646d61
000058  5f696e74
00005c  2074696d
000060  65203a25
000064  64206368
000068  203a2564
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.kdp_dma_wait_dma_tc_int||, CODE, READONLY, ALIGN=2

                  kdp_dma_wait_dma_tc_int PROC
;;;939    
;;;940    void kdp_dma_wait_dma_tc_int(UINT32 channel)
000000  2101              MOVS     r1,#1
;;;941    {
;;;942        while(!(__dma_tc_int_occurred & (1 << channel)))
000002  4081              LSLS     r1,r1,r0
000004  4804              LDR      r0,|L42.24|
;;;943        {
;;;944          __WFE (); 								   // Power-Down until next Event/Interrupt
000006  e000              B        |L42.10|
                  |L42.8|
000008  bf20              WFE      
                  |L42.10|
00000a  68c2              LDR      r2,[r0,#0xc]          ;942  ; __dma_tc_int_occurred
00000c  4211              TST      r1,r2                 ;942
00000e  d0fb              BEQ      |L42.8|
;;;945        }
;;;946    
;;;947        __dma_tc_int_occurred &= ~(1 << channel);
000010  68c2              LDR      r2,[r0,#0xc]  ; __dma_tc_int_occurred
000012  438a              BICS     r2,r2,r1
000014  60c2              STR      r2,[r0,#0xc]  ; __dma_tc_int_occurred
;;;948    }
000016  4770              BX       lr
;;;949    
                          ENDP

                  |L42.24|
                          DCD      ||.data||

                          AREA ||i.kdp_dma_wait_int_status||, CODE, READONLY, ALIGN=2

                  kdp_dma_wait_int_status PROC
;;;857    
;;;858    void kdp_dma_wait_int_status(UINT32 Channel)
000000  2101              MOVS     r1,#1
;;;859    {
;;;860        UINT32 choffset;
;;;861        volatile UINT32 status;
;;;862    
;;;863        choffset = 1 << Channel;
;;;864    
;;;865        while((inw(DMAC_FTDMAC020_PA_BASE_SCPU+DMA_TC)&choffset)==0)
000002  4a03              LDR      r2,|L43.16|
000004  4081              LSLS     r1,r1,r0              ;863
                  |L43.6|
000006  6953              LDR      r3,[r2,#0x14]
000008  420b              TST      r3,r1
00000a  d0fc              BEQ      |L43.6|
;;;866            ;
;;;867    
;;;868    
;;;869        kdp_dma_disable_ch(Channel);
00000c  f7ffbffe          B.W      kdp_dma_disable_ch
;;;870    }
;;;871    
                          ENDP

                  |L43.16|
                          DCD      0xa0100000

                          AREA ||i.kdp_flash_to_ddr_dma_copy||, CODE, READONLY, ALIGN=2

                  kdp_flash_to_ddr_dma_copy PROC
;;;365    
;;;366    void kdp_flash_to_ddr_dma_copy(UINT32 *src_addr, UINT32 *dst_addr, UINT32 size)
000000  b570              PUSH     {r4-r6,lr}
;;;367    {
000002  b088              SUB      sp,sp,#0x20
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;368        uint32_t dat;
;;;369        dma_ch DMAChannel;
;;;370        UINT8 ch = AHBDMA_Channel0;
000008  2400              MOVS     r4,#0
;;;371    
;;;372        memset(&DMAChannel, 0x0, sizeof(dma_ch));
00000a  2120              MOVS     r1,#0x20
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;373        dat=inw(SPI020REG_INTERRUPT);
000012  f04f4020          MOV      r0,#0xa0000000
000016  6a01              LDR      r1,[r0,#0x20]
;;;374        outw(SPI020REG_INTERRUPT, (dat | SPI020_DMA_EN));/* enable DMA function */
000018  f0410101          ORR      r1,r1,#1
00001c  6201              STR      r1,[r0,#0x20]
;;;375        kdp_dma_init(0,0,0);//fLib_InitDMA(FALSE, FALSE, 0x0);
00001e  2200              MOVS     r2,#0
000020  4611              MOV      r1,r2
000022  4610              MOV      r0,r2
000024  f7fffffe          BL       kdp_dma_init
;;;376    
;;;377        kdp_dma_reset_ch(ch);// fLib_DMA_ResetChannel(0);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       kdp_dma_reset_ch
;;;378        kdp_dma_enable_dma_int();// fLib_DMA_EnableDMAInt(); //Enable DMA Interrupt
00002e  f7fffffe          BL       kdp_dma_enable_dma_int
;;;379    
;;;380        DMAChannel.csr.dst_ctrl = AHBDMA_DstInc;
;;;381        DMAChannel.csr.src_ctrl = AHBDMA_SrcFix;
000032  9800              LDR      r0,[sp,#0]
000034  f0200078          BIC      r0,r0,#0x78
000038  3040              ADDS     r0,r0,#0x40
;;;382        DMAChannel.csr.mode = AHBDMA_HwHandShakeMode;
00003a  f42060e0          BIC      r0,r0,#0x700
;;;383        DMAChannel.csr.dst_width = AHBDMA_DstWidth_DWord;
00003e  f0400080          ORR      r0,r0,#0x80
000042  f5007000          ADD      r0,r0,#0x200
;;;384        DMAChannel.csr.src_width = AHBDMA_SrcWidth_DWord;
000046  f4205060          BIC      r0,r0,#0x3800
00004a  f5005080          ADD      r0,r0,#0x1000
;;;385        DMAChannel.csr.priority = 3;
00004e  f42020e0          BIC      r0,r0,#0x70000
;;;386        DMAChannel.csr.src_size = 2;
000052  f4400040          ORR      r0,r0,#0xc00000
000056  f5003000          ADD      r0,r0,#0x20000
;;;387    
;;;388        DMAChannel.cfg.dst_rs = 0;
00005a  9000              STR      r0,[sp,#0]
;;;389        DMAChannel.cfg.dst_he = 0;
00005c  9801              LDR      r0,[sp,#4]
;;;390        DMAChannel.cfg.src_rs = 11; //SPI_DMA_REQ
;;;391        DMAChannel.cfg.src_he = 1;
;;;392        DMAChannel.cfg.int_abt_msk = 0;
;;;393        DMAChannel.cfg.int_err_msk = 0;
;;;394        DMAChannel.cfg.int_tc_msk = 0;
;;;395    
;;;396        kdp_dma_set_ch_cfg(ch, DMAChannel.csr); //    fLib_SetDMAChannelCfg(0, csr);
00005e  9900              LDR      r1,[sp,#0]
000060  f4205078          BIC      r0,r0,#0x3e00         ;389
000064  f0200078          BIC      r0,r0,#0x78           ;390
000068  3058              ADDS     r0,r0,#0x58           ;390
00006a  f0200007          BIC      r0,r0,#7              ;393
00006e  f0400080          ORR      r0,r0,#0x80           ;394
000072  9001              STR      r0,[sp,#4]
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       kdp_dma_set_ch_cfg
;;;397        kdp_dma_set_ch_cn_cfg(ch, DMAChannel.cfg);// fLib_SetDMAChannelCnCfg(0, cfg);
00007a  4620              MOV      r0,r4
00007c  9901              LDR      r1,[sp,#4]
00007e  f7fffffe          BL       kdp_dma_set_ch_cn_cfg
;;;398        /* porgram address and size */
;;;399        kdp_dma_ch_data_ctrl(ch, SPI020REG_DATAPORT, (UINT32)dst_addr, size>>2);
000082  08ab              LSRS     r3,r5,#2
000084  4632              MOV      r2,r6
000086  4908              LDR      r1,|L44.168|
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       kdp_dma_ch_data_ctrl
;;;400        kdp_dma_enable_ch(ch);// fLib_EnableDMAChannel(0);
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       kdp_dma_enable_ch
;;;401    
;;;402    
;;;403        kdp_dma_wait_dma_int(ch);// fLib_DMA_WaitDMAInt(0);
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       kdp_dma_wait_dma_int
;;;404    
;;;405        kdp_dma_disable_ch(ch);// fLib_DisableDMAChannel(0);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       kdp_dma_disable_ch
;;;406        kdp_flash_dma_read_stop();// spi020_dma_read_stop();
0000a0  f7fffffe          BL       kdp_flash_dma_read_stop
;;;407    
;;;408    
;;;409    
;;;410    
;;;411    //    kdp_dma_disable_ch(ch);  //    fLib_DMA_DisableDMAInt(); //Disable DMA Interrupt
;;;412    //    //fLib_printf("====== finish dma_flash_to_ddr_test ========\n");
;;;413    
;;;414    
;;;415    }
0000a4  b008              ADD      sp,sp,#0x20
0000a6  bd70              POP      {r4-r6,pc}
;;;416    
                          ENDP

                  |L44.168|
                          DCD      0xa0000100

                          AREA ||.data||, DATA, ALIGN=2

                  dma_int_initized
000000  00                DCB      0x00
                  dma_tc_int_initized
000001  000000            DCB      0x00,0x00,0x00
                  m_dma_reg
                          DCD      0xa0100000
                  __dma_int_occurred
                          DCD      0x00000000
                  __dma_tc_int_occurred
                          DCD      0x00000000
                  llp_buf
                          DCD      0x61e00000
                  burst_size_selection
                          DCD      0x00000001
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000010
                          DCD      0x00000020
                          DCD      0x00000040
                          DCD      0x00000080
                          DCD      0x00000100

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\scpu\\drivers\\src\\kdp520_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp520_dma_c_4eaa53e6____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___12_kdp520_dma_c_4eaa53e6____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp520_dma_c_4eaa53e6____REVSH|
#line 223
|__asm___12_kdp520_dma_c_4eaa53e6____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp520_dma_c_4eaa53e6____RRX|
#line 410
|__asm___12_kdp520_dma_c_4eaa53e6____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
