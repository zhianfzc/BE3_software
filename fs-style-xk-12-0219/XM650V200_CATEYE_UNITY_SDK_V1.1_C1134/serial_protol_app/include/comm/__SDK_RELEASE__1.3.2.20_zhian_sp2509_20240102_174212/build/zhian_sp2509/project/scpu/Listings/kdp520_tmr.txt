; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\kdp520_tmr.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\kdp520_tmr.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\kdp520_tmr.crf ..\..\..\..\scpu\drivers\src\kdp520_tmr.c]
                          THUMB

                          AREA ||i.Clear_IntrStateRegister||, CODE, READONLY, ALIGN=2

                  Clear_IntrStateRegister PROC
;;;194    
;;;195    INT32 Clear_IntrStateRegister(tmr timer)
000000  4923              LDR      r1,|L1.144|
;;;196    {
000002  b108              CBZ      r0,|L1.8|
;;;197    /*
;;;198    When a interrupt whose interrupt status register = 7(overflow+match1+match2),
;;;199    the first comparison(TimerIntrState->Tm1Overflow == 1) turns out true.
;;;200    It seems we only clear the Tm1Overflow bit(TimerIntrState->Tm1Overflow=1;),
;;;201    but actually we also clear the Tm1Match1 & Tm1Match2.
;;;202    This is tricky. With this trick, we can clear intrstatus register this way.
;;;203    */
;;;204        volatile TimerIntrStateType *TimerIntrState = (TimerIntrStateType *)(timer_base + TIMER_INTSTATE);
;;;205        if ((timer == 0) || (timer > MAX_TIMER))
000004  2803              CMP      r0,#3
000006  d901              BLS      |L1.12|
                  |L1.8|
;;;206            return FALSE;
000008  2000              MOVS     r0,#0
;;;207    
;;;208        switch(timer)
;;;209        {
;;;210            case 1:
;;;211                if (TimerIntrState->Tm1Overflow == 1)
;;;212                    TimerIntrState->Tm1Overflow=1;
;;;213                else if (TimerIntrState->Tm1Match1 == 1)
;;;214                    TimerIntrState->Tm1Match1=1;
;;;215                else if (TimerIntrState->Tm1Match2 == 1)
;;;216                    TimerIntrState->Tm1Match2=1;
;;;217                break;
;;;218            case 2:
;;;219            if (TimerIntrState->Tm2Overflow == 1)
;;;220                    TimerIntrState->Tm2Overflow=1;
;;;221            else if (TimerIntrState->Tm2Match1 == 1)
;;;222                    TimerIntrState->Tm2Match1=1;
;;;223            else if (TimerIntrState->Tm2Match2 == 1)
;;;224                    TimerIntrState->Tm2Match2=1;
;;;225            break;
;;;226            
;;;227            case 3:
;;;228                if (TimerIntrState->Tm3Overflow == 1)
;;;229                    TimerIntrState->Tm3Overflow=1;
;;;230                else if (TimerIntrState->Tm3Match1 == 1)
;;;231                    TimerIntrState->Tm3Match1=1;
;;;232                else if (TimerIntrState->Tm3Match2 == 1)
;;;233                    TimerIntrState->Tm3Match2=1;
;;;234            break;
;;;235    
;;;236        default:
;;;237            break;
;;;238    
;;;239        }
;;;240    
;;;241        return TRUE;
;;;242    }
00000a  4770              BX       lr
                  |L1.12|
00000c  2801              CMP      r0,#1                 ;208
00000e  d004              BEQ      |L1.26|
000010  2802              CMP      r0,#2                 ;208
000012  d015              BEQ      |L1.64|
000014  2803              CMP      r0,#3                 ;208
000016  d139              BNE      |L1.140|
000018  e025              B        |L1.102|
                  |L1.26|
00001a  6808              LDR      r0,[r1,#0]            ;211
00001c  0740              LSLS     r0,r0,#29             ;211
00001e  6808              LDR      r0,[r1,#0]            ;213
000020  d502              BPL      |L1.40|
000022  f0400004          ORR      r0,r0,#4              ;212
000026  e030              B        |L1.138|
                  |L1.40|
000028  07c0              LSLS     r0,r0,#31             ;213
00002a  6808              LDR      r0,[r1,#0]            ;215
00002c  d002              BEQ      |L1.52|
00002e  f0400001          ORR      r0,r0,#1              ;214
000032  e02a              B        |L1.138|
                  |L1.52|
000034  0780              LSLS     r0,r0,#30             ;215
000036  d529              BPL      |L1.140|
000038  6808              LDR      r0,[r1,#0]            ;216
00003a  f0400002          ORR      r0,r0,#2              ;216
00003e  e024              B        |L1.138|
                  |L1.64|
000040  6808              LDR      r0,[r1,#0]            ;219
000042  0680              LSLS     r0,r0,#26             ;219
000044  6808              LDR      r0,[r1,#0]            ;221
000046  d502              BPL      |L1.78|
000048  f0400020          ORR      r0,r0,#0x20           ;220
00004c  e01d              B        |L1.138|
                  |L1.78|
00004e  0700              LSLS     r0,r0,#28             ;221
000050  6808              LDR      r0,[r1,#0]            ;223
000052  d502              BPL      |L1.90|
000054  f0400008          ORR      r0,r0,#8              ;222
000058  e017              B        |L1.138|
                  |L1.90|
00005a  06c0              LSLS     r0,r0,#27             ;223
00005c  d516              BPL      |L1.140|
00005e  6808              LDR      r0,[r1,#0]            ;224
000060  f0400010          ORR      r0,r0,#0x10           ;224
000064  e011              B        |L1.138|
                  |L1.102|
000066  6808              LDR      r0,[r1,#0]            ;228
000068  05c0              LSLS     r0,r0,#23             ;228
00006a  6808              LDR      r0,[r1,#0]            ;230
00006c  d502              BPL      |L1.116|
00006e  f4407080          ORR      r0,r0,#0x100          ;229
000072  e00a              B        |L1.138|
                  |L1.116|
000074  0640              LSLS     r0,r0,#25             ;230
000076  6808              LDR      r0,[r1,#0]            ;232
000078  d502              BPL      |L1.128|
00007a  f0400040          ORR      r0,r0,#0x40           ;231
00007e  e004              B        |L1.138|
                  |L1.128|
000080  0600              LSLS     r0,r0,#24             ;232
000082  d503              BPL      |L1.140|
000084  6808              LDR      r0,[r1,#0]            ;233
000086  f0400080          ORR      r0,r0,#0x80           ;233
                  |L1.138|
00008a  6008              STR      r0,[r1,#0]            ;233
                  |L1.140|
00008c  2001              MOVS     r0,#1                 ;241
00008e  4770              BX       lr
;;;243    
                          ENDP

                  |L1.144|
                          DCD      0xc2000034

                          AREA ||i.GetCurrentT1Tick||, CODE, READONLY, ALIGN=2

                  GetCurrentT1Tick PROC
;;;595    
;;;596    UINT32 GetCurrentT1Tick(void)
000000  4801              LDR      r0,|L2.8|
;;;597    {
;;;598        return gT1_Tick;
000002  6800              LDR      r0,[r0,#0]  ; gT1_Tick
;;;599    }
000004  4770              BX       lr
;;;600    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||.data||

                          AREA ||i.GetCurrentT2Tick||, CODE, READONLY, ALIGN=2

                  GetCurrentT2Tick PROC
;;;600    
;;;601    UINT32 GetCurrentT2Tick(void)
000000  4801              LDR      r0,|L3.8|
;;;602    {
;;;603        return gT2_Tick;
000002  6840              LDR      r0,[r0,#4]  ; gT2_Tick
;;;604    }
000004  4770              BX       lr
;;;605    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.GetCurrentT3Tick||, CODE, READONLY, ALIGN=2

                  GetCurrentT3Tick PROC
;;;605    
;;;606    UINT32 GetCurrentT3Tick(void)
000000  4801              LDR      r0,|L4.8|
;;;607    {
;;;608        return gT3_Tick;
000002  6880              LDR      r0,[r0,#8]  ; gT3_Tick
;;;609    }
000004  4770              BX       lr
;;;610    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||.data||

                          AREA ||i.GetTick||, CODE, READONLY, ALIGN=2

                  GetTick PROC
;;;120    
;;;121    INT32 GetTick(tmr timer)
000000  4904              LDR      r1,|L5.20|
;;;122    {
;;;123        UINT32 cur_tick;
;;;124    
;;;125        volatile TimerStructType *ctimer = &gFtimer[timer];
000002  eb011100          ADD      r1,r1,r0,LSL #4
000006  b108              CBZ      r0,|L5.12|
;;;126    
;;;127        if ((timer == 0) || (timer > MAX_TIMER))
000008  2803              CMP      r0,#3
00000a  d901              BLS      |L5.16|
                  |L5.12|
;;;128            return FALSE;
00000c  2000              MOVS     r0,#0
;;;129    
;;;130        cur_tick=ctimer->Tick;
;;;131    
;;;132        return cur_tick;
;;;133    }
00000e  4770              BX       lr
                  |L5.16|
000010  6888              LDR      r0,[r1,#8]            ;130
000012  4770              BX       lr
;;;134    
                          ENDP

                  |L5.20|
                          DCD      ||.bss||

                          AREA ||i.ResetAllTimer||, CODE, READONLY, ALIGN=1

                  ResetAllTimer PROC
;;;107    
;;;108    void ResetAllTimer(void)
000000  b500              PUSH     {lr}
;;;109    {
;;;110        /* Start-up routine to initialise the timers to a known state */
;;;111        //UINT32 i;
;;;112    
;;;113        //reset all timer to default value
;;;114        //for (i = 1; i <= MAX_TIMER; i++)
;;;115        //    Timer_Disable(i);
;;;116            Timer_Disable(TMR1);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       Timer_Disable
;;;117            Timer_Disable(TMR2);
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       Timer_Disable
;;;118            Timer_Disable(TMR3);
00000e  2003              MOVS     r0,#3
000010  f85deb04          POP      {lr}
000014  f7ffbffe          B.W      Timer_Disable
;;;119    }
;;;120    
                          ENDP


                          AREA ||i.SetClkSource||, CODE, READONLY, ALIGN=2

                  SetClkSource PROC
;;;146    
;;;147    INT32 SetClkSource(tmr timer,UINT32 clk)
000000  4a0d              LDR      r2,|L7.56|
;;;148    {
000002  b108              CBZ      r0,|L7.8|
;;;149        volatile TimerCRType *TimerControl=(TimerCRType *)(timer_base + TIMER_CR);
;;;150    
;;;151    
;;;152        if ((timer == 0) || (timer > MAX_TIMER))
000004  2803              CMP      r0,#3
000006  d901              BLS      |L7.12|
                  |L7.8|
;;;153            return FALSE;
000008  2000              MOVS     r0,#0
;;;154    
;;;155        switch(timer)
;;;156        {
;;;157        case 1:
;;;158            TimerControl->Tm1Clock=clk;
;;;159            break;
;;;160        case 2:
;;;161            TimerControl->Tm2Clock=clk;
;;;162            break;
;;;163        case 3:
;;;164            TimerControl->Tm3Clock=clk;
;;;165            break;
;;;166    
;;;167        default:
;;;168            break;
;;;169      }
;;;170    
;;;171       return TRUE;
;;;172    }
00000a  4770              BX       lr
                  |L7.12|
00000c  2801              CMP      r0,#1                 ;155
00000e  d004              BEQ      |L7.26|
000010  2802              CMP      r0,#2                 ;155
000012  d006              BEQ      |L7.34|
000014  2803              CMP      r0,#3                 ;155
000016  d108              BNE      |L7.42|
000018  e009              B        |L7.46|
                  |L7.26|
00001a  6810              LDR      r0,[r2,#0]            ;158
00001c  f3610041          BFI      r0,r1,#1,#1           ;158
000020  e002              B        |L7.40|
                  |L7.34|
000022  6810              LDR      r0,[r2,#0]            ;161
000024  f3611004          BFI      r0,r1,#4,#1           ;161
                  |L7.40|
000028  6010              STR      r0,[r2,#0]            ;158
                  |L7.42|
00002a  2001              MOVS     r0,#1                 ;171
00002c  4770              BX       lr
                  |L7.46|
00002e  6810              LDR      r0,[r2,#0]            ;164
000030  f36110c7          BFI      r0,r1,#7,#1           ;164
000034  e7f8              B        |L7.40|
;;;173    
                          ENDP

000036  0000              DCW      0x0000
                  |L7.56|
                          DCD      0xc2000030

                          AREA ||i.SetTick||, CODE, READONLY, ALIGN=2

                  SetTick PROC
;;;134    
;;;135    INT32 SetTick(tmr timer,UINT32 clk_tick)
000000  4a05              LDR      r2,|L8.24|
;;;136    {
;;;137        volatile TimerStructType *ctimer = &gFtimer[timer];
000002  eb021200          ADD      r2,r2,r0,LSL #4
000006  b108              CBZ      r0,|L8.12|
;;;138    
;;;139        if ((timer == 0) || (timer > MAX_TIMER))
000008  2803              CMP      r0,#3
00000a  d901              BLS      |L8.16|
                  |L8.12|
;;;140            return FALSE;
00000c  2000              MOVS     r0,#0
;;;141    
;;;142        ctimer->Tick=clk_tick;
;;;143    
;;;144        return TRUE;
;;;145    }
00000e  4770              BX       lr
                  |L8.16|
000010  6091              STR      r1,[r2,#8]            ;142
000012  2001              MOVS     r0,#1                 ;144
000014  4770              BX       lr
;;;146    
                          ENDP

000016  0000              DCW      0x0000
                  |L8.24|
                          DCD      ||.bss||

                          AREA ||i.TickTimer1||, CODE, READONLY, ALIGN=2

                  TickTimer1 PROC
;;;545    
;;;546    void TickTimer1()
000000  4803              LDR      r0,|L9.16|
;;;547    {
;;;548    	//fLib_ClearIRQ(TMR_FTTMR010_0_IRQ);
;;;549    	gT1_Tick++;
000002  6801              LDR      r1,[r0,#0]  ; gT1_Tick
000004  1c49              ADDS     r1,r1,#1
;;;550    	Clear_IntrStateRegister(TMR1);
000006  6001              STR      r1,[r0,#0]  ; gT1_Tick
000008  2001              MOVS     r0,#1
00000a  f7ffbffe          B.W      Clear_IntrStateRegister
;;;551        //dbg_msg("gT1_Tick=%d", gT1_Tick);
;;;552    }
;;;553    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      ||.data||

                          AREA ||i.TickTimer2||, CODE, READONLY, ALIGN=2

                  TickTimer2 PROC
;;;553    
;;;554    void TickTimer2()
000000  4803              LDR      r0,|L10.16|
;;;555    {
;;;556        //fLib_ClearIRQ(TMR_FTTMR010_0_1_IRQ);
;;;557        gT2_Tick++;
000002  6841              LDR      r1,[r0,#4]  ; gT2_Tick
000004  1c49              ADDS     r1,r1,#1
;;;558    	Clear_IntrStateRegister(TMR2);
000006  6041              STR      r1,[r0,#4]  ; gT2_Tick
000008  2002              MOVS     r0,#2
00000a  f7ffbffe          B.W      Clear_IntrStateRegister
;;;559        //dbg_msg("gT2_Tick=%d", gT2_Tick);
;;;560    }
;;;561    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      ||.data||

                          AREA ||i.TickTimer3||, CODE, READONLY, ALIGN=2

                  TickTimer3 PROC
;;;561    
;;;562    void TickTimer3()
000000  4803              LDR      r0,|L11.16|
;;;563    {
;;;564    	//fLib_ClearIRQ(TMR_FTTMR010_0_2_IRQ);
;;;565    	gT3_Tick++;
000002  6881              LDR      r1,[r0,#8]  ; gT3_Tick
000004  1c49              ADDS     r1,r1,#1
;;;566    	Clear_IntrStateRegister(TMR3);
000006  6081              STR      r1,[r0,#8]  ; gT3_Tick
000008  2003              MOVS     r0,#3
00000a  f7ffbffe          B.W      Clear_IntrStateRegister
;;;567        //dbg_msg("gT3_Tick=%d", gT3_Tick);
;;;568    }
;;;569    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      ||.data||

                          AREA ||i.Tick_Timer1_One_Shot||, CODE, READONLY, ALIGN=2

                  Tick_Timer1_One_Shot PROC
;;;571    
;;;572    void Tick_Timer1_One_Shot()
000000  4807              LDR      r0,|L12.32|
;;;573    {
000002  b500              PUSH     {lr}
;;;574        gT1_Tick++;
000004  6801              LDR      r1,[r0,#0]  ; gT1_Tick
000006  1c49              ADDS     r1,r1,#1
;;;575        Timer_Counter(TMR1, 0xffffffff/2);
000008  6001              STR      r1,[r0,#0]  ; gT1_Tick
00000a  f06f4100          MVN      r1,#0x80000000
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       Timer_Counter
;;;576        //fLib_ClearIRQ(TMR_FTTMR010_0_IRQ);
;;;577        Clear_IntrStateRegister(TMR1);
000014  2001              MOVS     r0,#1
000016  f85deb04          POP      {lr}
00001a  f7ffbffe          B.W      Clear_IntrStateRegister
;;;578    }
;;;579    
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      ||.data||

                          AREA ||i.Tick_Timer2_One_Shot||, CODE, READONLY, ALIGN=2

                  Tick_Timer2_One_Shot PROC
;;;579    
;;;580    void Tick_Timer2_One_Shot()
000000  4807              LDR      r0,|L13.32|
;;;581    {
000002  b500              PUSH     {lr}
;;;582        gT2_Tick++;
000004  6841              LDR      r1,[r0,#4]  ; gT2_Tick
000006  1c49              ADDS     r1,r1,#1
;;;583        Timer_Counter(TMR2, 0xffffffff/2); 
000008  6041              STR      r1,[r0,#4]  ; gT2_Tick
00000a  f06f4100          MVN      r1,#0x80000000
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       Timer_Counter
;;;584        //fLib_ClearIRQ(TMR_FTTMR010_0_1_IRQ);
;;;585        Clear_IntrStateRegister(TMR2);
000014  2002              MOVS     r0,#2
000016  f85deb04          POP      {lr}
00001a  f7ffbffe          B.W      Clear_IntrStateRegister
;;;586    }
;;;587    
                          ENDP

00001e  0000              DCW      0x0000
                  |L13.32|
                          DCD      ||.data||

                          AREA ||i.Tick_Timer3_One_Shot||, CODE, READONLY, ALIGN=2

                  Tick_Timer3_One_Shot PROC
;;;587    
;;;588    void Tick_Timer3_One_Shot()
000000  4807              LDR      r0,|L14.32|
;;;589    {
000002  b500              PUSH     {lr}
;;;590        gT3_Tick++;
000004  6881              LDR      r1,[r0,#8]  ; gT3_Tick
000006  1c49              ADDS     r1,r1,#1
;;;591        Timer_Counter(TMR3, 0xffffffff/2); 
000008  6081              STR      r1,[r0,#8]  ; gT3_Tick
00000a  f06f4100          MVN      r1,#0x80000000
00000e  2003              MOVS     r0,#3
000010  f7fffffe          BL       Timer_Counter
;;;592        //fLib_ClearIRQ(TMR_FTTMR010_0_2_IRQ);
;;;593        Clear_IntrStateRegister(TMR3);
000014  2003              MOVS     r0,#3
000016  f85deb04          POP      {lr}
00001a  f7ffbffe          B.W      Clear_IntrStateRegister
;;;594    }
;;;595    
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      ||.data||

                          AREA ||i.Timer_AutoReloadValue||, CODE, READONLY, ALIGN=2

                  Timer_AutoReloadValue PROC
;;;101    // ============  Function Definition  =================
;;;102    void Timer_AutoReloadValue(tmr timer, UINT32 value)
000000  4a02              LDR      r2,|L15.12|
;;;103    {
;;;104        //writel(value, (UINT32*)(uintptr_t)(gTimerBase[timer] + TIMER_LOAD));
;;;105        outw((UINT32*)(uintptr_t)(gTimerBase[timer] + TIMER_LOAD), value);
000002  f8520020          LDR      r0,[r2,r0,LSL #2]
000006  6041              STR      r1,[r0,#4]
;;;106    }
000008  4770              BX       lr
;;;107    
                          ENDP

00000a  0000              DCW      0x0000
                  |L15.12|
                          DCD      ||.data||+0x1c

                          AREA ||i.Timer_Close||, CODE, READONLY, ALIGN=2

                  Timer_Close PROC
;;;244    /* Routine to disable a timer and free-up the associated IRQ */
;;;245    INT32 Timer_Close(tmr timer)
000000  b500              PUSH     {lr}
;;;246    {
000002  0003              MOVS     r3,r0
000004  d001              BEQ      |L16.10|
;;;247        UINT32 i;
;;;248    
;;;249        if (timer == 0 || timer > MAX_TIMER)
000006  2b03              CMP      r3,#3
000008  d901              BLS      |L16.14|
                  |L16.10|
;;;250            return FALSE;
00000a  2000              MOVS     r0,#0
                  |L16.12|
;;;251    
;;;252        if(!Timer_Disable(timer))
;;;253            return FALSE;   /* Stop the timer first */
;;;254    
;;;255        i = gTimer_Vectors[timer];  /* then release the IRQ */
;;;256        
;;;257    		//if (!fLib_CloseIRQ(i))
;;;258            //return FALSE;
;;;259    		NVIC_DisableIRQ((IRQn_Type)i);
;;;260    
;;;261        return TRUE;
;;;262    }
00000c  bd00              POP      {pc}
                  |L16.14|
00000e  f7fffffe          BL       Timer_Disable
000012  2800              CMP      r0,#0                 ;252
000014  d0fa              BEQ      |L16.12|
000016  480b              LDR      r0,|L16.68|
000018  f8100023          LDRB     r0,[r0,r3,LSL #2]     ;255
00001c  b240              SXTB     r0,r0                 ;259
00001e  2800              CMP      r0,#0                 ;259
000020  db0d              BLT      |L16.62|
000022  f000021f          AND      r2,r0,#0x1f           ;259
000026  2101              MOVS     r1,#1                 ;259
000028  4091              LSLS     r1,r1,r2              ;259
00002a  0940              LSRS     r0,r0,#5              ;259
00002c  0080              LSLS     r0,r0,#2              ;259
00002e  f10020e0          ADD      r0,r0,#0xe000e000     ;259
000032  f8c01180          STR      r1,[r0,#0x180]        ;259
000036  f3bf8f4f          DSB                            ;259
00003a  f3bf8f6f          ISB                            ;259
                  |L16.62|
00003e  2001              MOVS     r0,#1                 ;261
000040  bd00              POP      {pc}
;;;263    
                          ENDP

000042  0000              DCW      0x0000
                  |L16.68|
                          DCD      ||.data||+0xc

                          AREA ||i.Timer_Counter||, CODE, READONLY, ALIGN=2

                  Timer_Counter PROC
;;;521    
;;;522    UINT32 Timer_Counter(tmr timer, UINT32 value)
000000  4a04              LDR      r2,|L17.20|
;;;523    {
000002  b111              CBZ      r1,|L17.10|
;;;524        if (value)
;;;525            outw((UINT32*)(uintptr_t)(gTimerBase[timer] + TIMER_RegCOUNT), value);
000004  f8523020          LDR      r3,[r2,r0,LSL #2]
000008  6019              STR      r1,[r3,#0]
                  |L17.10|
;;;526    
;;;527        return readl((UINT32*)(uintptr_t)(gTimerBase[timer] + TIMER_RegCOUNT));
00000a  f8520020          LDR      r0,[r2,r0,LSL #2]
00000e  6800              LDR      r0,[r0,#0]
;;;528    }
000010  4770              BX       lr
;;;529    
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      ||.data||+0x1c

                          AREA ||i.Timer_Disable||, CODE, READONLY, ALIGN=2

                  Timer_Disable PROC
;;;482    
;;;483    INT32 Timer_Disable(tmr timer)
000000  4a16              LDR      r2,|L18.92|
;;;484    {
;;;485        /* This routine stops the specified timer hardware. */
;;;486        volatile TimerCRType *TimerControl=(TimerCRType *)(timer_base + TIMER_CR);
000002  4915              LDR      r1,|L18.88|
;;;487    
;;;488        TimerStructType *ctimer=&gFtimer[timer];
000004  eb021200          ADD      r2,r2,r0,LSL #4
000008  b108              CBZ      r0,|L18.14|
;;;489    
;;;490    
;;;491        if ((timer == 0) || (timer > MAX_TIMER))
00000a  2803              CMP      r0,#3
00000c  d901              BLS      |L18.18|
                  |L18.14|
;;;492        {
;;;493            return FALSE;
00000e  2000              MOVS     r0,#0
;;;494        }
;;;495    
;;;496        /* Disable the Control register bit */
;;;497        switch(timer)
;;;498        {
;;;499        case TMR1:
;;;500            TimerControl->Tm1En=0;
;;;501            TimerControl->Tm1OfEn=0;
;;;502            break;
;;;503        case TMR2:
;;;504            TimerControl->Tm2En=0;
;;;505            TimerControl->Tm2OfEn=0;
;;;506            break;
;;;507        case TMR3:
;;;508            TimerControl->Tm3En=0;
;;;509            TimerControl->Tm3OfEn=0;
;;;510            break;
;;;511    
;;;512        default:
;;;513            break;
;;;514        }
;;;515    
;;;516        //set the timer status=false
;;;517        ctimer->Running=FALSE;
;;;518    
;;;519        return TRUE;
;;;520    }
000010  4770              BX       lr
                  |L18.18|
000012  2801              CMP      r0,#1                 ;497
000014  d004              BEQ      |L18.32|
000016  2802              CMP      r0,#2                 ;497
000018  d00a              BEQ      |L18.48|
00001a  2803              CMP      r0,#3                 ;497
00001c  d110              BNE      |L18.64|
00001e  e013              B        |L18.72|
                  |L18.32|
000020  6808              LDR      r0,[r1,#0]            ;500
000022  f0200001          BIC      r0,r0,#1              ;500
000026  6008              STR      r0,[r1,#0]            ;500
000028  6808              LDR      r0,[r1,#0]            ;501
00002a  f0200004          BIC      r0,r0,#4              ;501
00002e  e006              B        |L18.62|
                  |L18.48|
000030  6808              LDR      r0,[r1,#0]            ;504
000032  f0200008          BIC      r0,r0,#8              ;504
000036  6008              STR      r0,[r1,#0]            ;504
000038  6808              LDR      r0,[r1,#0]            ;505
00003a  f0200020          BIC      r0,r0,#0x20           ;505
                  |L18.62|
00003e  6008              STR      r0,[r1,#0]            ;501
                  |L18.64|
000040  2000              MOVS     r0,#0                 ;517
000042  60d0              STR      r0,[r2,#0xc]          ;519
000044  2001              MOVS     r0,#1                 ;519
000046  4770              BX       lr
                  |L18.72|
000048  6808              LDR      r0,[r1,#0]            ;508
00004a  f0200040          BIC      r0,r0,#0x40           ;508
00004e  6008              STR      r0,[r1,#0]            ;508
000050  6808              LDR      r0,[r1,#0]            ;509
000052  f4207080          BIC      r0,r0,#0x100          ;509
000056  e7f2              B        |L18.62|
;;;521    
                          ENDP

                  |L18.88|
                          DCD      0xc2000030
                  |L18.92|
                          DCD      ||.bss||

                          AREA ||i.Timer_Enable||, CODE, READONLY, ALIGN=2

                  Timer_Enable PROC
;;;463    
;;;464    INT32 Timer_Enable(tmr timer)
000000  4906              LDR      r1,|L19.28|
;;;465    {
;;;466        /* This routine starts the specified timer hardware. */
;;;467        TimerStructType *ctimer=&gFtimer[timer];
000002  eb011100          ADD      r1,r1,r0,LSL #4
000006  b138              CBZ      r0,|L19.24|
;;;468    
;;;469        if ((timer == 0) || (timer > MAX_TIMER))
000008  2803              CMP      r0,#3
00000a  d805              BHI      |L19.24|
;;;470            return FALSE;
;;;471    
;;;472        if(ctimer->Running == TRUE)
00000c  68c8              LDR      r0,[r1,#0xc]
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L19.24|
;;;473        {
;;;474    //        printf("Timer is running.\r\n");
;;;475    	return FALSE;
;;;476        }
;;;477    
;;;478        ctimer->Running=TRUE;
000012  2001              MOVS     r0,#1
;;;479        return TRUE;
000014  60c8              STR      r0,[r1,#0xc]
;;;480    }
000016  4770              BX       lr
                  |L19.24|
000018  2000              MOVS     r0,#0                 ;475
00001a  4770              BX       lr
;;;481    
                          ENDP

                  |L19.28|
                          DCD      ||.bss||

                          AREA ||i.Timer_IOCtrl||, CODE, READONLY, ALIGN=1

                  Timer_IOCtrl PROC
;;;264    
;;;265    INT32 Timer_IOCtrl(timeriotype IoType,tmr timer,UINT32 tick)
000000  b500              PUSH     {lr}
;;;266    {
000002  460b              MOV      r3,r1
000004  b138              CBZ      r0,|L20.22|
;;;267    
;;;268        switch(IoType)
000006  2801              CMP      r0,#1
000008  d008              BEQ      |L20.28|
00000a  2802              CMP      r0,#2
00000c  d00a              BEQ      |L20.36|
00000e  2803              CMP      r0,#3
000010  d00d              BEQ      |L20.46|
;;;269        {
;;;270            case IO_TIMER_RESETALL:
;;;271                ResetAllTimer();
;;;272            break;
;;;273            
;;;274            case IO_TIMER_GETTICK:
;;;275                GetTick(timer);
;;;276            break;
;;;277            
;;;278            case IO_TIMER_SETTICK:
;;;279                SetTick(timer,tick);
;;;280            break;
;;;281            
;;;282            case IO_TIMER_SETCLKSRC:
;;;283                SetClkSource(timer,tick);
;;;284            break;
;;;285            
;;;286            default:
;;;287            return FALSE;
000012  2000              MOVS     r0,#0
;;;288        }
;;;289    
;;;290        return TRUE;
;;;291    }
000014  bd00              POP      {pc}
                  |L20.22|
000016  f7fffffe          BL       ResetAllTimer
00001a  e00c              B        |L20.54|
                  |L20.28|
00001c  4608              MOV      r0,r1                 ;275
00001e  f7fffffe          BL       GetTick
000022  e008              B        |L20.54|
                  |L20.36|
000024  4611              MOV      r1,r2                 ;279
000026  4618              MOV      r0,r3                 ;279
000028  f7fffffe          BL       SetTick
00002c  e003              B        |L20.54|
                  |L20.46|
00002e  4611              MOV      r1,r2                 ;283
000030  4618              MOV      r0,r3                 ;283
000032  f7fffffe          BL       SetClkSource
                  |L20.54|
000036  2001              MOVS     r0,#1                 ;290
000038  bd00              POP      {pc}
;;;292    
                          ENDP


                          AREA ||i.Timer_Init||, CODE, READONLY, ALIGN=2

                  Timer_Init PROC
;;;292    
;;;293    BOOL Timer_Init(tmr timer, UINT32 tick, UINT32 handler)
000000  b570              PUSH     {r4-r6,lr}
;;;294    {
000002  4604              MOV      r4,r0
000004  4616              MOV      r6,r2
;;;295        /* Routine to start the specified timer & enable the interrupt */
;;;296        int intNum = gTimer_Vectors[timer];
000006  481a              LDR      r0,|L21.112|
000008  460a              MOV      r2,r1                 ;294
;;;297    	//dbg_msg("%s timer=%d,irq=%d\n",__func__, timer, intNum);
;;;298        switch(timer)
;;;299        {
;;;300            case TMR1:
;;;301            gT1_Tick = 0;
00000a  4919              LDR      r1,|L21.112|
00000c  f8505024          LDR      r5,[r0,r4,LSL #2]     ;296
000010  2000              MOVS     r0,#0                 ;296
000012  390c              SUBS     r1,r1,#0xc
000014  2c01              CMP      r4,#1                 ;298
000016  d007              BEQ      |L21.40|
000018  2c02              CMP      r4,#2                 ;298
00001a  d007              BEQ      |L21.44|
00001c  2c03              CMP      r4,#3                 ;298
00001e  d007              BEQ      |L21.48|
;;;302            break;
;;;303            
;;;304            case TMR2:
;;;305            gT2_Tick = 0;
;;;306            break;
;;;307            
;;;308            case TMR3:
;;;309            gT3_Tick = 0;
;;;310            break;
;;;311    
;;;312            default:
;;;313            break;
;;;314        }
;;;315     
;;;316        if (timer == 0 || timer > MAX_TIMER)
000020  b104              CBZ      r4,|L21.36|
000022  d906              BLS      |L21.50|
                  |L21.36|
;;;317            return FALSE;
000024  2000              MOVS     r0,#0
                  |L21.38|
;;;318    
;;;319        /* Set the timer tick */
;;;320        if(!Timer_IOCtrl(IO_TIMER_SETTICK, timer, tick))
;;;321            return FALSE;
;;;322    
;;;323        Clear_IntrStateRegister(timer);
;;;324    
;;;325        //connect timer ISR
;;;326        if(!Timer_SetIsr(timer, handler))
;;;327            return FALSE;
;;;328    
;;;329        /* Install timer interrupt routine */
;;;330        //fLib_SetIRQmode((UINT32)intNum, EDGE);
;;;331        //fLib_EnableIRQ((UINT32)intNum);
;;;332    		NVIC_EnableIRQ((IRQn_Type)intNum);
;;;333    
;;;334        if (!Timer_IntEnable(timer))
;;;335    	return FALSE;
;;;336    
;;;337        /* Start the timer ticking */
;;;338        if(!Timer_Enable(timer))
;;;339            return FALSE;
;;;340    
;;;341        return TRUE;
;;;342    }
000026  bd70              POP      {r4-r6,pc}
                  |L21.40|
000028  6008              STR      r0,[r1,#0]            ;302  ; gT1_Tick
00002a  e002              B        |L21.50|
                  |L21.44|
00002c  6048              STR      r0,[r1,#4]            ;306  ; gT2_Tick
00002e  e000              B        |L21.50|
                  |L21.48|
000030  6088              STR      r0,[r1,#8]            ;309  ; gT3_Tick
                  |L21.50|
000032  4621              MOV      r1,r4                 ;320
000034  2002              MOVS     r0,#2                 ;320
000036  f7fffffe          BL       Timer_IOCtrl
00003a  2800              CMP      r0,#0                 ;320
00003c  d0f3              BEQ      |L21.38|
00003e  4620              MOV      r0,r4                 ;323
000040  f7fffffe          BL       Clear_IntrStateRegister
000044  4631              MOV      r1,r6                 ;326
000046  4620              MOV      r0,r4                 ;326
000048  f7fffffe          BL       Timer_SetIsr
00004c  2800              CMP      r0,#0                 ;326
00004e  d0ea              BEQ      |L21.38|
000050  b268              SXTB     r0,r5                 ;332
000052  f7fffffe          BL       __NVIC_EnableIRQ
000056  4620              MOV      r0,r4                 ;334
000058  f7fffffe          BL       Timer_IntEnable
00005c  2800              CMP      r0,#0                 ;334
00005e  d0e2              BEQ      |L21.38|
000060  4620              MOV      r0,r4                 ;338
000062  f7fffffe          BL       Timer_Enable
000066  2800              CMP      r0,#0                 ;338
000068  d0dd              BEQ      |L21.38|
00006a  2001              MOVS     r0,#1                 ;341
00006c  bd70              POP      {r4-r6,pc}
;;;343    
                          ENDP

00006e  0000              DCW      0x0000
                  |L21.112|
                          DCD      ||.data||+0xc

                          AREA ||i.Timer_IntEnable||, CODE, READONLY, ALIGN=2

                  Timer_IntEnable PROC
;;;345    /* This routine starts the specified timer hardware. */
;;;346    INT32 Timer_IntEnable(tmr timer)
000000  492b              LDR      r1,|L22.176|
;;;347    {
000002  b108              CBZ      r0,|L22.8|
;;;348        volatile TimerMaskType *TimerMask = (TimerMaskType *)(timer_base + TIMER_INTMASK);
;;;349    
;;;350        if ((timer == 0) || (timer > MAX_TIMER))
000004  2803              CMP      r0,#3
000006  d901              BLS      |L22.12|
                  |L22.8|
;;;351            return FALSE;
000008  2000              MOVS     r0,#0
;;;352    
;;;353        TimerMask->MTm1Overflow=0;
;;;354        TimerMask->MTm1Match1=1;
;;;355        TimerMask->MTm1Match2=1;
;;;356        TimerMask->MTm2Overflow=0;
;;;357        TimerMask->MTm2Match1=0;
;;;358        TimerMask->MTm2Match2=0;
;;;359        TimerMask->MTm3Overflow=0;
;;;360        TimerMask->MTm3Match1=0;
;;;361        TimerMask->MTm3Match2=0;
;;;362    
;;;363        //enable timer
;;;364        switch(timer)
;;;365        {
;;;366        case 1:
;;;367            TimerMask->MTm1Overflow=0;
;;;368            TimerMask->MTm1Match1=0;
;;;369            TimerMask->MTm1Match2=0;
;;;370            break;
;;;371        case 2:
;;;372            TimerMask->MTm2Overflow=0;
;;;373            TimerMask->MTm2Match1=0;
;;;374            TimerMask->MTm2Match2=0;
;;;375            break;
;;;376        case 3:
;;;377            TimerMask->MTm3Overflow=0;
;;;378            TimerMask->MTm3Match1=0;
;;;379            TimerMask->MTm3Match2=0;
;;;380            break;
;;;381    
;;;382        default:
;;;383            break;
;;;384    
;;;385        }
;;;386    
;;;387        return TRUE;
;;;388    }
00000a  4770              BX       lr
                  |L22.12|
00000c  680a              LDR      r2,[r1,#0]            ;353
00000e  f0220204          BIC      r2,r2,#4              ;353
000012  600a              STR      r2,[r1,#0]            ;353
000014  680a              LDR      r2,[r1,#0]            ;354
000016  f0420201          ORR      r2,r2,#1              ;354
00001a  600a              STR      r2,[r1,#0]            ;354
00001c  680a              LDR      r2,[r1,#0]            ;355
00001e  f0420202          ORR      r2,r2,#2              ;355
000022  600a              STR      r2,[r1,#0]            ;355
000024  680a              LDR      r2,[r1,#0]            ;356
000026  f0220220          BIC      r2,r2,#0x20           ;356
00002a  600a              STR      r2,[r1,#0]            ;356
00002c  680a              LDR      r2,[r1,#0]            ;357
00002e  f0220208          BIC      r2,r2,#8              ;357
000032  600a              STR      r2,[r1,#0]            ;357
000034  680a              LDR      r2,[r1,#0]            ;358
000036  f0220210          BIC      r2,r2,#0x10           ;358
00003a  600a              STR      r2,[r1,#0]            ;358
00003c  680a              LDR      r2,[r1,#0]            ;359
00003e  f4227280          BIC      r2,r2,#0x100          ;359
000042  600a              STR      r2,[r1,#0]            ;359
000044  680a              LDR      r2,[r1,#0]            ;360
000046  f0220240          BIC      r2,r2,#0x40           ;360
00004a  600a              STR      r2,[r1,#0]            ;360
00004c  680a              LDR      r2,[r1,#0]            ;361
00004e  f0220280          BIC      r2,r2,#0x80           ;361
000052  600a              STR      r2,[r1,#0]            ;361
000054  2801              CMP      r0,#1                 ;364
000056  d004              BEQ      |L22.98|
000058  2802              CMP      r0,#2                 ;364
00005a  d00e              BEQ      |L22.122|
00005c  2803              CMP      r0,#3                 ;364
00005e  d118              BNE      |L22.146|
000060  e019              B        |L22.150|
                  |L22.98|
000062  6808              LDR      r0,[r1,#0]            ;367
000064  f0200004          BIC      r0,r0,#4              ;367
000068  6008              STR      r0,[r1,#0]            ;367
00006a  6808              LDR      r0,[r1,#0]            ;368
00006c  f0200001          BIC      r0,r0,#1              ;368
000070  6008              STR      r0,[r1,#0]            ;368
000072  6808              LDR      r0,[r1,#0]            ;369
000074  f0200002          BIC      r0,r0,#2              ;369
000078  e00a              B        |L22.144|
                  |L22.122|
00007a  6808              LDR      r0,[r1,#0]            ;372
00007c  f0200020          BIC      r0,r0,#0x20           ;372
000080  6008              STR      r0,[r1,#0]            ;372
000082  6808              LDR      r0,[r1,#0]            ;373
000084  f0200008          BIC      r0,r0,#8              ;373
000088  6008              STR      r0,[r1,#0]            ;373
00008a  6808              LDR      r0,[r1,#0]            ;374
00008c  f0200010          BIC      r0,r0,#0x10           ;374
                  |L22.144|
000090  6008              STR      r0,[r1,#0]            ;369
                  |L22.146|
000092  2001              MOVS     r0,#1                 ;387
000094  4770              BX       lr
                  |L22.150|
000096  6808              LDR      r0,[r1,#0]            ;377
000098  f4207080          BIC      r0,r0,#0x100          ;377
00009c  6008              STR      r0,[r1,#0]            ;377
00009e  6808              LDR      r0,[r1,#0]            ;378
0000a0  f0200040          BIC      r0,r0,#0x40           ;378
0000a4  6008              STR      r0,[r1,#0]            ;378
0000a6  6808              LDR      r0,[r1,#0]            ;379
0000a8  f0200080          BIC      r0,r0,#0x80           ;379
0000ac  e7f0              B        |L22.144|
;;;389    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L22.176|
                          DCD      0xc2000038

                          AREA ||i.Timer_MatchValue1||, CODE, READONLY, ALIGN=2

                  Timer_MatchValue1 PROC
;;;529    
;;;530    void Timer_MatchValue1(tmr timer, UINT32 value)
000000  4a02              LDR      r2,|L23.12|
;;;531    {
;;;532        outw((UINT32*)(uintptr_t)(gTimerBase[timer] + TIMER_MATCH1), value);
000002  f8520020          LDR      r0,[r2,r0,LSL #2]
000006  6081              STR      r1,[r0,#8]
;;;533    }
000008  4770              BX       lr
;;;534    
                          ENDP

00000a  0000              DCW      0x0000
                  |L23.12|
                          DCD      ||.data||+0x1c

                          AREA ||i.Timer_MatchValue2||, CODE, READONLY, ALIGN=2

                  Timer_MatchValue2 PROC
;;;534    
;;;535    void Timer_MatchValue2(tmr timer, UINT32 value)
000000  4a02              LDR      r2,|L24.12|
;;;536    {
;;;537        outw((UINT32*)(uintptr_t)(gTimerBase[timer] + TIMER_MATCH2), value);
000002  f8520020          LDR      r0,[r2,r0,LSL #2]
000006  60c1              STR      r1,[r0,#0xc]
;;;538    }
000008  4770              BX       lr
;;;539    
                          ENDP

00000a  0000              DCW      0x0000
                  |L24.12|
                          DCD      ||.data||+0x1c

                          AREA ||i.Timer_SetIsr||, CODE, READONLY, ALIGN=2

                  Timer_SetIsr PROC
;;;173    
;;;174    INT32 Timer_SetIsr(tmr timer, UINT32 handler)
000000  4a07              LDR      r2,|L25.32|
;;;175    {
000002  b530              PUSH     {r4,r5,lr}
;;;176        /* Routine to initialise install requested timer. Stops the timer. */
;;;177        TimerStructType *ctimer=&gFtimer[timer];
000004  eb021300          ADD      r3,r2,r0,LSL #4
;;;178        UINT32 i;
;;;179    
;;;180        i = gTimer_Vectors[timer];
000008  4a06              LDR      r2,|L25.36|
00000a  4d07              LDR      r5,|L25.40|
00000c  f8522020          LDR      r2,[r2,r0,LSL #2]
000010  682d              LDR      r5,[r5,#0]
;;;181    
;;;182        //fLib_CloseIRQ(i);
;;;183    
;;;184        //if (!fLib_ConnectIRQ(i, handler))
;;;185        //    return FALSE;
;;;186    	
;;;187    		NVIC_SetVector((IRQn_Type) i, handler);
000012  b254              SXTB     r4,r2
000014  eb050484          ADD      r4,r5,r4,LSL #2
000018  6421              STR      r1,[r4,#0x40]
00001a  e9c32100          STRD     r2,r1,[r3,#0]
;;;188    
;;;189        ctimer->Handler = handler;
;;;190        ctimer->IntNum = i;     /* INT number */
;;;191    
;;;192        return timer;
;;;193    }
00001e  bd30              POP      {r4,r5,pc}
;;;194    
                          ENDP

                  |L25.32|
                          DCD      ||.bss||
                  |L25.36|
                          DCD      ||.data||+0xc
                  |L25.40|
                          DCD      0xe000ed08

                          AREA ||i.Write_CR||, CODE, READONLY, ALIGN=2

                  Write_CR PROC
;;;430    
;;;431    INT32 Write_CR(tmr timer, UINT32 source, UINT32 upDown)
000000  4b1f              LDR      r3,|L26.128|
;;;432    {
000002  b108              CBZ      r0,|L26.8|
;;;433    	volatile TimerCRType *TimerControl=(TimerCRType *)(timer_base + TIMER_CR);
;;;434    	if ((timer == 0) || (timer > MAX_TIMER))
000004  2803              CMP      r0,#3
000006  d901              BLS      |L26.12|
                  |L26.8|
;;;435    		return FALSE;
000008  2000              MOVS     r0,#0
;;;436    
;;;437    	switch(timer)
;;;438    	{
;;;439    		case TMR1:
;;;440    			TimerControl -> Tm1Clock = source;
;;;441    			TimerControl -> Tm1OfEn = 1;
;;;442    			TimerControl -> Tm1UpDown = upDown;
;;;443    			TimerControl -> Tm1En = 1;
;;;444    			break;
;;;445    		case TMR2:
;;;446    			TimerControl -> Tm2Clock = source;
;;;447    			TimerControl -> Tm2OfEn = 1;
;;;448    			TimerControl -> Tm2UpDown = upDown;
;;;449    			TimerControl -> Tm2En = 1;
;;;450    			break;
;;;451    		case TMR3:
;;;452    			TimerControl -> Tm3Clock = source;
;;;453    			TimerControl -> Tm3OfEn = 1;
;;;454    			TimerControl -> Tm3UpDown = upDown;
;;;455    			TimerControl -> Tm3En = 1;
;;;456    			break;
;;;457    		default:
;;;458    			break;
;;;459    	}
;;;460    
;;;461    	return TRUE;
;;;462    }
00000a  4770              BX       lr
                  |L26.12|
00000c  2801              CMP      r0,#1                 ;437
00000e  d004              BEQ      |L26.26|
000010  2802              CMP      r0,#2                 ;437
000012  d012              BEQ      |L26.58|
000014  2803              CMP      r0,#3                 ;437
000016  d120              BNE      |L26.90|
000018  e021              B        |L26.94|
                  |L26.26|
00001a  6818              LDR      r0,[r3,#0]            ;440
00001c  f3610041          BFI      r0,r1,#1,#1           ;440
000020  6018              STR      r0,[r3,#0]            ;440
000022  6818              LDR      r0,[r3,#0]            ;441
000024  f0400004          ORR      r0,r0,#4              ;441
000028  6018              STR      r0,[r3,#0]            ;441
00002a  6818              LDR      r0,[r3,#0]            ;442
00002c  f3622049          BFI      r0,r2,#9,#1           ;442
000030  6018              STR      r0,[r3,#0]            ;442
000032  6818              LDR      r0,[r3,#0]            ;443
000034  f0400001          ORR      r0,r0,#1              ;443
000038  e00e              B        |L26.88|
                  |L26.58|
00003a  6818              LDR      r0,[r3,#0]            ;446
00003c  f3611004          BFI      r0,r1,#4,#1           ;446
000040  6018              STR      r0,[r3,#0]            ;446
000042  6818              LDR      r0,[r3,#0]            ;447
000044  f0400020          ORR      r0,r0,#0x20           ;447
000048  6018              STR      r0,[r3,#0]            ;447
00004a  6818              LDR      r0,[r3,#0]            ;448
00004c  f362208a          BFI      r0,r2,#10,#1          ;448
000050  6018              STR      r0,[r3,#0]            ;448
000052  6818              LDR      r0,[r3,#0]            ;449
000054  f0400008          ORR      r0,r0,#8              ;449
                  |L26.88|
000058  6018              STR      r0,[r3,#0]            ;443
                  |L26.90|
00005a  2001              MOVS     r0,#1                 ;461
00005c  4770              BX       lr
                  |L26.94|
00005e  6818              LDR      r0,[r3,#0]            ;452
000060  f36110c7          BFI      r0,r1,#7,#1           ;452
000064  6018              STR      r0,[r3,#0]            ;452
000066  6818              LDR      r0,[r3,#0]            ;453
000068  f4407080          ORR      r0,r0,#0x100          ;453
00006c  6018              STR      r0,[r3,#0]            ;453
00006e  6818              LDR      r0,[r3,#0]            ;454
000070  f36220cb          BFI      r0,r2,#11,#1          ;454
000074  6018              STR      r0,[r3,#0]            ;454
000076  6818              LDR      r0,[r3,#0]            ;455
000078  f0400040          ORR      r0,r0,#0x40           ;455
00007c  e7ec              B        |L26.88|
;;;463    
                          ENDP

00007e  0000              DCW      0x0000
                  |L26.128|
                          DCD      0xc2000030

                          AREA ||i.Write_MR||, CODE, READONLY, ALIGN=2

                  Write_MR PROC
;;;389    
;;;390    INT32 Write_MR(tmr timer, int match1, int match2, int overflow)
000000  b530              PUSH     {r4,r5,lr}
;;;391    {
;;;392    	volatile TimerMaskType *TimerMask = (TimerMaskType *)(timer_base + TIMER_INTMASK);
000002  4c2b              LDR      r4,|L27.176|
000004  b108              CBZ      r0,|L27.10|
;;;393    	if ((timer == 0) || (timer > MAX_TIMER))
000006  2803              CMP      r0,#3
000008  d901              BLS      |L27.14|
                  |L27.10|
;;;394    		return FALSE;
00000a  2000              MOVS     r0,#0
;;;395    
;;;396    	TimerMask -> MTm1Overflow = 0;
;;;397    	TimerMask -> MTm1Match1 = 0;
;;;398    	TimerMask -> MTm1Match2 = 0;
;;;399    	TimerMask -> MTm2Overflow = 0;
;;;400    	TimerMask -> MTm2Match1 = 0;
;;;401    	TimerMask -> MTm2Match2 = 0;
;;;402    	TimerMask -> MTm3Overflow = 0;
;;;403    	TimerMask -> MTm3Match1 = 0;
;;;404    	TimerMask -> MTm3Match2 = 0;
;;;405        
;;;406    	switch(timer)
;;;407    	{
;;;408    		case 1:
;;;409    			TimerMask -> MTm1Overflow = overflow;
;;;410    			TimerMask -> MTm1Match1 = match1;
;;;411    			TimerMask -> MTm1Match2 = match2;
;;;412    			break;
;;;413    		case 2:
;;;414    			TimerMask -> MTm2Overflow = overflow;
;;;415    			TimerMask -> MTm2Match1 = match1;
;;;416    			TimerMask -> MTm2Match2 = match2;
;;;417    			break;
;;;418    		case 3:
;;;419    			TimerMask -> MTm3Overflow = overflow;
;;;420    			TimerMask -> MTm3Match1 = match1;
;;;421    			TimerMask -> MTm3Match2 = match2;
;;;422    			break;
;;;423    
;;;424    		default:
;;;425    			break;
;;;426    	}
;;;427    
;;;428    	return TRUE;
;;;429    }
00000c  bd30              POP      {r4,r5,pc}
                  |L27.14|
00000e  6825              LDR      r5,[r4,#0]            ;396
000010  f0250504          BIC      r5,r5,#4              ;396
000014  6025              STR      r5,[r4,#0]            ;396
000016  6825              LDR      r5,[r4,#0]            ;397
000018  f0250501          BIC      r5,r5,#1              ;397
00001c  6025              STR      r5,[r4,#0]            ;397
00001e  6825              LDR      r5,[r4,#0]            ;398
000020  f0250502          BIC      r5,r5,#2              ;398
000024  6025              STR      r5,[r4,#0]            ;398
000026  6825              LDR      r5,[r4,#0]            ;399
000028  f0250520          BIC      r5,r5,#0x20           ;399
00002c  6025              STR      r5,[r4,#0]            ;399
00002e  6825              LDR      r5,[r4,#0]            ;400
000030  f0250508          BIC      r5,r5,#8              ;400
000034  6025              STR      r5,[r4,#0]            ;400
000036  6825              LDR      r5,[r4,#0]            ;401
000038  f0250510          BIC      r5,r5,#0x10           ;401
00003c  6025              STR      r5,[r4,#0]            ;401
00003e  6825              LDR      r5,[r4,#0]            ;402
000040  f4257580          BIC      r5,r5,#0x100          ;402
000044  6025              STR      r5,[r4,#0]            ;402
000046  6825              LDR      r5,[r4,#0]            ;403
000048  f0250540          BIC      r5,r5,#0x40           ;403
00004c  6025              STR      r5,[r4,#0]            ;403
00004e  6825              LDR      r5,[r4,#0]            ;404
000050  f0250580          BIC      r5,r5,#0x80           ;404
000054  6025              STR      r5,[r4,#0]            ;404
000056  2801              CMP      r0,#1                 ;406
000058  d004              BEQ      |L27.100|
00005a  2802              CMP      r0,#2                 ;406
00005c  d00e              BEQ      |L27.124|
00005e  2803              CMP      r0,#3                 ;406
000060  d118              BNE      |L27.148|
000062  e019              B        |L27.152|
                  |L27.100|
000064  6820              LDR      r0,[r4,#0]            ;409
000066  f3630082          BFI      r0,r3,#2,#1           ;409
00006a  6020              STR      r0,[r4,#0]            ;409
00006c  6820              LDR      r0,[r4,#0]            ;410
00006e  f3610000          BFI      r0,r1,#0,#1           ;410
000072  6020              STR      r0,[r4,#0]            ;410
000074  6820              LDR      r0,[r4,#0]            ;411
000076  f3620041          BFI      r0,r2,#1,#1           ;411
00007a  e00a              B        |L27.146|
                  |L27.124|
00007c  6820              LDR      r0,[r4,#0]            ;414
00007e  f3631045          BFI      r0,r3,#5,#1           ;414
000082  6020              STR      r0,[r4,#0]            ;414
000084  6820              LDR      r0,[r4,#0]            ;415
000086  f36100c3          BFI      r0,r1,#3,#1           ;415
00008a  6020              STR      r0,[r4,#0]            ;415
00008c  6820              LDR      r0,[r4,#0]            ;416
00008e  f3621004          BFI      r0,r2,#4,#1           ;416
                  |L27.146|
000092  6020              STR      r0,[r4,#0]            ;411
                  |L27.148|
000094  2001              MOVS     r0,#1                 ;428
000096  bd30              POP      {r4,r5,pc}
                  |L27.152|
000098  6820              LDR      r0,[r4,#0]            ;419
00009a  f3632008          BFI      r0,r3,#8,#1           ;419
00009e  6020              STR      r0,[r4,#0]            ;419
0000a0  6820              LDR      r0,[r4,#0]            ;420
0000a2  f3611086          BFI      r0,r1,#6,#1           ;420
0000a6  6020              STR      r0,[r4,#0]            ;420
0000a8  6820              LDR      r0,[r4,#0]            ;421
0000aa  f36210c7          BFI      r0,r2,#7,#1           ;421
0000ae  e7f0              B        |L27.146|
;;;430    
                          ENDP

                  |L27.176|
                          DCD      0xc2000038

                          AREA ||i.__NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_EnableIRQ PROC
;;;1683    */
;;;1684   __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1685   {
000002  db09              BLT      |L28.24|
;;;1686     if ((int32_t)(IRQn) >= 0)
;;;1687     {
;;;1688       __COMPILER_BARRIER();
;;;1689       NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01100          STR      r1,[r0,#0x100]
                  |L28.24|
;;;1690       __COMPILER_BARRIER();
;;;1691     }
;;;1692   }
000018  4770              BX       lr
;;;1693   
                          ENDP


                          AREA ||i.kdp_tmr_init||, CODE, READONLY, ALIGN=2

                  kdp_tmr_init PROC
;;;610    
;;;611    BOOL kdp_tmr_init(tmr timer, u32 tick)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;612    {
000004  460f              MOV      r7,r1
000006  0006              MOVS     r6,r0
000008  d009              BEQ      |L29.30|
;;;613        UINT32 tmr_irq;
;;;614        FNTmrISR isr;
;;;615        
;;;616        if (timer == 0 || timer > MAX_TIMER)
00000a  2e03              CMP      r6,#3
00000c  d807              BHI      |L29.30|
00000e  2000              MOVS     r0,#0
;;;617            return FALSE;
;;;618    
;;;619        switch(timer)
;;;620        {
;;;621            case TMR1:
;;;622                gT1_Tick = 0;
000010  4918              LDR      r1,|L29.116|
000012  2e01              CMP      r6,#1                 ;619
000014  d006              BEQ      |L29.36|
000016  2e02              CMP      r6,#2                 ;619
000018  d008              BEQ      |L29.44|
00001a  2e03              CMP      r6,#3                 ;619
00001c  d00a              BEQ      |L29.52|
                  |L29.30|
;;;623                tmr_irq = TMR_FTTMR010_0_1_IRQ;		
;;;624                isr = TickTimer1;
;;;625            break;
;;;626            case TMR2:
;;;627                gT2_Tick = 0;
;;;628                tmr_irq = TMR_FTTMR010_0_2_IRQ;		
;;;629                isr = TickTimer2;
;;;630            break;
;;;631            case TMR3:
;;;632                gT3_Tick = 0;
;;;633                tmr_irq = TMR_FTTMR010_0_3_IRQ;		
;;;634                isr = TickTimer3;
;;;635            break;
;;;636            default:
;;;637                return FALSE;
00001e  2000              MOVS     r0,#0
                  |L29.32|
;;;638        }
;;;639    
;;;640        Timer_Init(timer, 1, (UINT32)isr);
;;;641        Timer_Counter(timer, 0);
;;;642        Timer_AutoReloadValue(timer, tick);
;;;643        Write_CR(timer, PCLK, DOWN);
;;;644        
;;;645        NVIC_SetVector((IRQn_Type)tmr_irq, (uint32_t)isr);    
;;;646        NVIC_EnableIRQ((IRQn_Type)tmr_irq);    
;;;647        
;;;648        
;;;649        return TRUE;
;;;650    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L29.36|
000024  2419              MOVS     r4,#0x19              ;623
000026  4d14              LDR      r5,|L29.120|
000028  6008              STR      r0,[r1,#0]            ;625  ; gT1_Tick
00002a  e006              B        |L29.58|
                  |L29.44|
00002c  241a              MOVS     r4,#0x1a              ;628
00002e  4d13              LDR      r5,|L29.124|
000030  6048              STR      r0,[r1,#4]            ;630  ; gT2_Tick
000032  e002              B        |L29.58|
                  |L29.52|
000034  4d12              LDR      r5,|L29.128|
000036  241b              MOVS     r4,#0x1b              ;633
000038  6088              STR      r0,[r1,#8]            ;634  ; gT3_Tick
                  |L29.58|
00003a  462a              MOV      r2,r5                 ;640
00003c  2101              MOVS     r1,#1                 ;640
00003e  4630              MOV      r0,r6                 ;640
000040  f7fffffe          BL       Timer_Init
000044  2100              MOVS     r1,#0                 ;641
000046  4630              MOV      r0,r6                 ;641
000048  f7fffffe          BL       Timer_Counter
00004c  4809              LDR      r0,|L29.116|
00004e  301c              ADDS     r0,r0,#0x1c           ;641
000050  f8500026          LDR      r0,[r0,r6,LSL #2]     ;641
000054  6047              STR      r7,[r0,#4]            ;641
000056  2202              MOVS     r2,#2                 ;643
000058  2100              MOVS     r1,#0                 ;643
00005a  4630              MOV      r0,r6                 ;643
00005c  f7fffffe          BL       Write_CR
000060  4908              LDR      r1,|L29.132|
000062  4620              MOV      r0,r4                 ;645
000064  6809              LDR      r1,[r1,#0]            ;645
000066  eb010180          ADD      r1,r1,r0,LSL #2       ;645
00006a  640d              STR      r5,[r1,#0x40]         ;646
00006c  f7fffffe          BL       __NVIC_EnableIRQ
000070  2001              MOVS     r0,#1                 ;649
000072  e7d5              B        |L29.32|
                          ENDP

                  |L29.116|
                          DCD      ||.data||
                  |L29.120|
                          DCD      TickTimer1
                  |L29.124|
                          DCD      TickTimer2
                  |L29.128|
                          DCD      TickTimer3
                  |L29.132|
                          DCD      0xe000ed08

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gFtimer
                          %        64

                          AREA ||.data||, DATA, ALIGN=2

                  gT1_Tick
                          DCD      0x00000000
                  gT2_Tick
                          DCD      0x00000000
                  gT3_Tick
                          DCD      0x00000000
                  gTimer_Vectors
                          DCD      0x00000000
                          DCD      0x00000019
                          DCD      0x0000001a
                          DCD      0x0000001b
                  gTimerBase
                          DCD      0x00000000
                          DCD      0xc2000000
                          DCD      0xc2000010
                          DCD      0xc2000020

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\scpu\\drivers\\src\\kdp520_tmr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp520_tmr_c_0fc386bf____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___12_kdp520_tmr_c_0fc386bf____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp520_tmr_c_0fc386bf____REVSH|
#line 223
|__asm___12_kdp520_tmr_c_0fc386bf____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp520_tmr_c_0fc386bf____RRX|
#line 410
|__asm___12_kdp520_tmr_c_0fc386bf____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
