; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\rtx_semaphore.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\rtx_semaphore.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\rtx_semaphore.crf F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_semaphore.c]
                          THUMB

                          AREA ||i.IsException||, CODE, READONLY, ALIGN=1

                  IsException PROC
;;;122    /// \return     true=exception, false=thread
;;;123    __STATIC_INLINE bool_t IsException (void) {
000000  f3ef8005          MRS      r0,IPSR
000004  2800              CMP      r0,#0
000006  d000              BEQ      |L1.10|
;;;124      return (__get_IPSR() != 0U);
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;125    }
00000a  4770              BX       lr
;;;126    
                          ENDP


                          AREA ||i.IsIrqMasked||, CODE, READONLY, ALIGN=1

                  IsIrqMasked PROC
;;;128    /// \return     true=masked, false=not masked
;;;129    __STATIC_INLINE bool_t IsIrqMasked (void) {
000000  f3ef8010          MRS      r0,PRIMASK
000004  b918              CBNZ     r0,|L2.14|
000006  f3ef8011          MRS      r0,BASEPRI
;;;130    #if   ((defined(__ARM_ARCH_7M__)        && (__ARM_ARCH_7M__        != 0)) || \
;;;131           (defined(__ARM_ARCH_7EM__)       && (__ARM_ARCH_7EM__       != 0)) || \
;;;132           (defined(__ARM_ARCH_8M_MAIN__)   && (__ARM_ARCH_8M_MAIN__   != 0)) || \
;;;133           (defined(__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ != 0)))
;;;134      return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L2.16|
                  |L2.14|
00000e  2001              MOVS     r0,#1
                  |L2.16|
;;;135    #else
;;;136      return  (__get_PRIMASK() != 0U);
;;;137    #endif
;;;138    }
000010  4770              BX       lr
;;;139    
                          ENDP


                          AREA ||i.SemaphoreTokenDecrement||, CODE, READONLY, ALIGN=1

                  SemaphoreTokenDecrement PROC
;;;41     /// \return 1 - success, 0 - failure.
;;;42     static uint32_t SemaphoreTokenDecrement (os_semaphore_t *semaphore) {
000000  b510              PUSH     {r4,lr}
000002  300c              ADDS     r0,r0,#0xc
;;;43     #if (EXCLUSIVE_ACCESS == 0)
;;;44       uint32_t primask = __get_PRIMASK();
;;;45     #endif
;;;46       uint32_t ret;
;;;47     
;;;48     #if (EXCLUSIVE_ACCESS == 0)
;;;49       __disable_irq();
;;;50     
;;;51       if (semaphore->tokens != 0U) {
;;;52         semaphore->tokens--;
;;;53         ret = 1U;
;;;54       } else {
;;;55         ret = 0U;
;;;56       }
;;;57     
;;;58       if (primask == 0U) {
;;;59         __enable_irq();
;;;60       }
;;;61     #else
;;;62       if (atomic_dec16_nz(&semaphore->tokens) != 0U) {
000004  f7fffffe          BL       __asm___15_rtx_semaphore_c_7b131ed0__atomic_dec16_nz
000008  2800              CMP      r0,#0
00000a  d000              BEQ      |L3.14|
;;;63         ret = 1U;
00000c  2001              MOVS     r0,#1
                  |L3.14|
;;;64       } else {
;;;65         ret = 0U;
;;;66       }
;;;67     #endif
;;;68     
;;;69       return ret;
;;;70     }
00000e  bd10              POP      {r4,pc}
;;;71     
                          ENDP


                          AREA ||i.SemaphoreTokenIncrement||, CODE, READONLY, ALIGN=1

                  SemaphoreTokenIncrement PROC
;;;74     /// \return 1 - success, 0 - failure.
;;;75     static uint32_t SemaphoreTokenIncrement (os_semaphore_t *semaphore) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;76     #if (EXCLUSIVE_ACCESS == 0)
;;;77       uint32_t primask = __get_PRIMASK();
;;;78     #endif
;;;79       uint32_t ret;
;;;80     
;;;81     #if (EXCLUSIVE_ACCESS == 0)
;;;82       __disable_irq();
;;;83     
;;;84       if (semaphore->tokens < semaphore->max_tokens) {
;;;85         semaphore->tokens++;
;;;86         ret = 1U;
;;;87       } else {
;;;88         ret = 0U;
;;;89       }
;;;90     
;;;91       if (primask == 0U) {
;;;92         __enable_irq();
;;;93       }
;;;94     #else
;;;95       if (atomic_inc16_lt(&semaphore->tokens, semaphore->max_tokens) < semaphore->max_tokens) {
000004  89c1              LDRH     r1,[r0,#0xe]
000006  300c              ADDS     r0,r0,#0xc
000008  f7fffffe          BL       __asm___15_rtx_semaphore_c_7b131ed0__atomic_inc16_lt
00000c  89e1              LDRH     r1,[r4,#0xe]
00000e  4288              CMP      r0,r1
000010  d201              BCS      |L4.22|
;;;96         ret = 1U;
000012  2001              MOVS     r0,#1
;;;97       } else {
;;;98         ret = 0U;
;;;99       }
;;;100    #endif
;;;101    
;;;102      return ret;
;;;103    }
000014  bd10              POP      {r4,pc}
                  |L4.22|
000016  2000              MOVS     r0,#0                 ;98
000018  bd10              POP      {r4,pc}
;;;104    
                          ENDP


                          AREA ||i.osRtxSemaphorePostProcess||, CODE, READONLY, ALIGN=1

                  osRtxSemaphorePostProcess PROC
;;;109    /// \param[in]  semaphore       semaphore object.
;;;110    static void osRtxSemaphorePostProcess (os_semaphore_t *semaphore) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;111      os_thread_t *thread;
;;;112    
;;;113      // Check if Thread is waiting for a token
;;;114      if (semaphore->thread_list != NULL) {
000004  6880              LDR      r0,[r0,#8]
000006  2800              CMP      r0,#0                 ;110
000008  d011              BEQ      |L5.46|
;;;115        // Try to acquire token
;;;116        if (SemaphoreTokenDecrement(semaphore) != 0U) {
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       SemaphoreTokenDecrement
000010  2800              CMP      r0,#0
000012  d00c              BEQ      |L5.46|
;;;117          // Wakeup waiting Thread with highest Priority
;;;118          thread = osRtxThreadListGet(osRtxObject(semaphore));
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       osRtxThreadListGet
;;;119          osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
00001a  2200              MOVS     r2,#0
00001c  4611              MOV      r1,r2
00001e  f7fffffe          BL       osRtxThreadWaitExit
;;;120          EvrRtxSemaphoreAcquired(semaphore, semaphore->tokens);
000022  89a1              LDRH     r1,[r4,#0xc]
000024  4620              MOV      r0,r4
000026  e8bd4010          POP      {r4,lr}
00002a  f7ffbffe          B.W      EvrRtxSemaphoreAcquired
                  |L5.46|
;;;121        }
;;;122      }
;;;123    }
00002e  bd10              POP      {r4,pc}
;;;124    
                          ENDP


                          AREA ||i.osSemaphoreAcquire||, CODE, READONLY, ALIGN=2

                  osSemaphoreAcquire PROC
;;;457    /// Acquire a Semaphore token or timeout if no tokens are available.
;;;458    osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;459      osStatus_t status;
;;;460    
;;;461      EvrRtxSemaphoreAcquire(semaphore_id, timeout);
000006  f7fffffe          BL       EvrRtxSemaphoreAcquire
;;;462      if (IsException() || IsIrqMasked()) {
00000a  f7fffffe          BL       IsException
00000e  b910              CBNZ     r0,|L6.22|
000010  f7fffffe          BL       IsIrqMasked
000014  b1e0              CBZ      r0,|L6.80|
                  |L6.22|
;;;463        status = isrRtxSemaphoreAcquire(semaphore_id, timeout);
000016  b11c              CBZ      r4,|L6.32|
000018  7820              LDRB     r0,[r4,#0]
00001a  28f6              CMP      r0,#0xf6
00001c  d100              BNE      |L6.32|
00001e  b135              CBZ      r5,|L6.46|
                  |L6.32|
000020  f06f0503          MVN      r5,#3
000024  4629              MOV      r1,r5
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       EvrRtxSemaphoreError
00002c  e00e              B        |L6.76|
                  |L6.46|
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       SemaphoreTokenDecrement
000034  b128              CBZ      r0,|L6.66|
000036  89a1              LDRH     r1,[r4,#0xc]
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       EvrRtxSemaphoreAcquired
00003e  2500              MOVS     r5,#0
000040  e004              B        |L6.76|
                  |L6.66|
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       EvrRtxSemaphoreNotAcquired
000048  f06f0502          MVN      r5,#2
                  |L6.76|
00004c  4628              MOV      r0,r5
;;;464      } else {
;;;465        status =  __svcSemaphoreAcquire(semaphore_id, timeout);
;;;466      }
;;;467      return status;
;;;468    }
00004e  bd70              POP      {r4-r6,pc}
                  |L6.80|
000050  4620              MOV      r0,r4                 ;465
000052  4629              MOV      r1,r5                 ;465
000054  f8dfc004          LDR      r12,|L6.92|
000058  df00              SVC      #0x0                  ;465
00005a  bd70              POP      {r4-r6,pc}
;;;469    
                          ENDP

                  |L6.92|
                          DCD      svcRtxSemaphoreAcquire

                          AREA ||i.osSemaphoreDelete||, CODE, READONLY, ALIGN=2

                  osSemaphoreDelete PROC
;;;495    /// Delete a Semaphore object.
;;;496    osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;497      osStatus_t status;
;;;498    
;;;499      EvrRtxSemaphoreDelete(semaphore_id);
000004  f7fffffe          BL       EvrRtxSemaphoreDelete
;;;500      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L7.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L7.36|
                  |L7.20|
;;;501        EvrRtxSemaphoreError(semaphore_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxSemaphoreError
;;;502        status = osErrorISR;
000020  4628              MOV      r0,r5
;;;503      } else {
;;;504        status = __svcSemaphoreDelete(semaphore_id);
;;;505      }
;;;506      return status;
;;;507    }
000022  bd70              POP      {r4-r6,pc}
                  |L7.36|
000024  4620              MOV      r0,r4                 ;504
000026  f8dfc008          LDR      r12,|L7.48|
00002a  df00              SVC      #0x0                  ;504
00002c  bd70              POP      {r4-r6,pc}
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      svcRtxSemaphoreDelete

                          AREA ||i.osSemaphoreGetCount||, CODE, READONLY, ALIGN=2

                  osSemaphoreGetCount PROC
;;;483    /// Get current Semaphore token count.
;;;484    uint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;485      uint32_t count;
;;;486    
;;;487      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L8.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b120              CBZ      r0,|L8.26|
                  |L8.16|
;;;488        count = svcRtxSemaphoreGetCount(semaphore_id);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      svcRtxSemaphoreGetCount
                  |L8.26|
;;;489      } else {
;;;490        count =  __svcSemaphoreGetCount(semaphore_id);
00001a  4620              MOV      r0,r4
00001c  f8dfc004          LDR      r12,|L8.36|
000020  df00              SVC      #0x0
;;;491      }
;;;492      return count;
;;;493    }
000022  bd10              POP      {r4,pc}
;;;494    
                          ENDP

                  |L8.36|
                          DCD      svcRtxSemaphoreGetCount

                          AREA ||i.osSemaphoreGetName||, CODE, READONLY, ALIGN=2

                  osSemaphoreGetName PROC
;;;444    /// Get name of a Semaphore object.
;;;445    const char *osSemaphoreGetName (osSemaphoreId_t semaphore_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;446      const char *name;
;;;447    
;;;448      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L9.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b128              CBZ      r0,|L9.28|
                  |L9.16|
;;;449        EvrRtxSemaphoreGetName(semaphore_id, NULL);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxSemaphoreGetName
;;;450        name = NULL;
000018  2000              MOVS     r0,#0
;;;451      } else {
;;;452        name = __svcSemaphoreGetName(semaphore_id);
;;;453      }
;;;454      return name;
;;;455    }
00001a  bd10              POP      {r4,pc}
                  |L9.28|
00001c  4620              MOV      r0,r4                 ;452
00001e  f8dfc008          LDR      r12,|L9.40|
000022  df00              SVC      #0x0                  ;452
000024  bd10              POP      {r4,pc}
;;;456    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      svcRtxSemaphoreGetName

                          AREA ||i.osSemaphoreNew||, CODE, READONLY, ALIGN=2

                  osSemaphoreNew PROC
;;;430    /// Create and Initialize a Semaphore object.
;;;431    osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr) {
000000  b570              PUSH     {r4-r6,lr}
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;432      osSemaphoreId_t semaphore_id;
;;;433    
;;;434      EvrRtxSemaphoreNew(max_count, initial_count, attr);
000008  f7fffffe          BL       EvrRtxSemaphoreNew
;;;435      if (IsException() || IsIrqMasked()) {
00000c  f7fffffe          BL       IsException
000010  b910              CBNZ     r0,|L10.24|
000012  f7fffffe          BL       IsIrqMasked
000016  b130              CBZ      r0,|L10.38|
                  |L10.24|
;;;436        EvrRtxSemaphoreError(NULL, (int32_t)osErrorISR);
000018  f06f0105          MVN      r1,#5
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       EvrRtxSemaphoreError
;;;437        semaphore_id = NULL;
000022  2000              MOVS     r0,#0
;;;438      } else {
;;;439        semaphore_id = __svcSemaphoreNew(max_count, initial_count, attr);
;;;440      }
;;;441      return semaphore_id;
;;;442    }
000024  bd70              POP      {r4-r6,pc}
                  |L10.38|
000026  4630              MOV      r0,r6                 ;439
000028  4629              MOV      r1,r5                 ;439
00002a  4622              MOV      r2,r4                 ;439
00002c  f8dfc004          LDR      r12,|L10.52|
000030  df00              SVC      #0x0                  ;439
000032  bd70              POP      {r4-r6,pc}
;;;443    
                          ENDP

                  |L10.52|
                          DCD      svcRtxSemaphoreNew

                          AREA ||i.osSemaphoreRelease||, CODE, READONLY, ALIGN=2

                  osSemaphoreRelease PROC
;;;470    /// Release a Semaphore token that was acquired by osSemaphoreAcquire.
;;;471    osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;472      osStatus_t status;
;;;473    
;;;474      EvrRtxSemaphoreRelease(semaphore_id);
000004  f7fffffe          BL       EvrRtxSemaphoreRelease
;;;475      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L11.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b300              CBZ      r0,|L11.86|
                  |L11.20|
;;;476        status = isrRtxSemaphoreRelease(semaphore_id);
000014  b114              CBZ      r4,|L11.28|
000016  7820              LDRB     r0,[r4,#0]
000018  28f6              CMP      r0,#0xf6
00001a  d006              BEQ      |L11.42|
                  |L11.28|
00001c  f06f0503          MVN      r5,#3
000020  4629              MOV      r1,r5
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       EvrRtxSemaphoreError
000028  e013              B        |L11.82|
                  |L11.42|
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       SemaphoreTokenIncrement
000030  b140              CBZ      r0,|L11.68|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       osRtxPostProcess
000038  89a1              LDRH     r1,[r4,#0xc]
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       EvrRtxSemaphoreReleased
000040  2500              MOVS     r5,#0
000042  e006              B        |L11.82|
                  |L11.68|
000044  f06f0110          MVN      r1,#0x10
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       EvrRtxSemaphoreError
00004e  f06f0502          MVN      r5,#2
                  |L11.82|
000052  4628              MOV      r0,r5
;;;477      } else {
;;;478        status =  __svcSemaphoreRelease(semaphore_id);
;;;479      }
;;;480      return status;
;;;481    }
000054  bd70              POP      {r4-r6,pc}
                  |L11.86|
000056  4620              MOV      r0,r4                 ;478
000058  f8dfc004          LDR      r12,|L11.96|
00005c  df00              SVC      #0x0                  ;478
00005e  bd70              POP      {r4-r6,pc}
;;;482    
                          ENDP

                  |L11.96|
                          DCD      svcRtxSemaphoreRelease

                          AREA ||i.svcRtxSemaphoreAcquire||, CODE, READONLY, ALIGN=2

                  svcRtxSemaphoreAcquire PROC
;;;228    /// \note API identical to osSemaphoreAcquire
;;;229    static osStatus_t svcRtxSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
;;;230      os_semaphore_t *semaphore = osRtxSemaphoreId(semaphore_id);
000004  0004              MOVS     r4,r0
000006  d002              BEQ      |L12.14|
;;;231      osStatus_t      status;
;;;232    
;;;233      // Check parameters
;;;234      if ((semaphore == NULL) || (semaphore->id != osRtxIdSemaphore)) {
000008  7820              LDRB     r0,[r4,#0]
00000a  28f6              CMP      r0,#0xf6
00000c  d007              BEQ      |L12.30|
                  |L12.14|
;;;235        EvrRtxSemaphoreError(semaphore, (int32_t)osErrorParameter);
00000e  f06f0503          MVN      r5,#3
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       EvrRtxSemaphoreError
;;;236        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;237        return osErrorParameter;
00001a  4628              MOV      r0,r5
;;;238      }
;;;239    
;;;240      // Try to acquire token
;;;241      if (SemaphoreTokenDecrement(semaphore) != 0U) {
;;;242        EvrRtxSemaphoreAcquired(semaphore, semaphore->tokens);
;;;243        status = osOK;
;;;244      } else {
;;;245        // No token available
;;;246        if (timeout != 0U) {
;;;247          EvrRtxSemaphoreAcquirePending(semaphore, timeout);
;;;248          // Suspend current Thread
;;;249          if (osRtxThreadWaitEnter(osRtxThreadWaitingSemaphore, timeout)) {
;;;250            osRtxThreadListPut(osRtxObject(semaphore), osRtxThreadGetRunning());
;;;251          } else {
;;;252            EvrRtxSemaphoreAcquireTimeout(semaphore);
;;;253          }
;;;254          status = osErrorTimeout;
;;;255        } else {
;;;256          EvrRtxSemaphoreNotAcquired(semaphore);
;;;257          status = osErrorResource;
;;;258        }
;;;259      }
;;;260    
;;;261      return status;
;;;262    }
00001c  bd70              POP      {r4-r6,pc}
                  |L12.30|
00001e  4620              MOV      r0,r4                 ;241
000020  f7fffffe          BL       SemaphoreTokenDecrement
000024  b128              CBZ      r0,|L12.50|
000026  89a1              LDRH     r1,[r4,#0xc]          ;242
000028  4620              MOV      r0,r4                 ;242
00002a  f7fffffe          BL       EvrRtxSemaphoreAcquired
00002e  2000              MOVS     r0,#0                 ;243
000030  bd70              POP      {r4-r6,pc}
                  |L12.50|
000032  b1a5              CBZ      r5,|L12.94|
000034  4629              MOV      r1,r5                 ;247
000036  4620              MOV      r0,r4                 ;247
000038  f7fffffe          BL       EvrRtxSemaphoreAcquirePending
00003c  4629              MOV      r1,r5                 ;249
00003e  2063              MOVS     r0,#0x63              ;249
000040  f7fffffe          BL       osRtxThreadWaitEnter
000044  b128              CBZ      r0,|L12.82|
000046  4809              LDR      r0,|L12.108|
000048  6941              LDR      r1,[r0,#0x14]         ;250  ; osRtxInfo
00004a  4620              MOV      r0,r4                 ;250
00004c  f7fffffe          BL       osRtxThreadListPut
000050  e002              B        |L12.88|
                  |L12.82|
000052  4620              MOV      r0,r4                 ;252
000054  f7fffffe          BL       EvrRtxSemaphoreAcquireTimeout
                  |L12.88|
000058  f06f0001          MVN      r0,#1                 ;254
00005c  bd70              POP      {r4-r6,pc}
                  |L12.94|
00005e  4620              MOV      r0,r4                 ;256
000060  f7fffffe          BL       EvrRtxSemaphoreNotAcquired
000064  f06f0002          MVN      r0,#2                 ;257
000068  bd70              POP      {r4-r6,pc}
;;;263    
                          ENDP

00006a  0000              DCW      0x0000
                  |L12.108|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxSemaphoreDelete||, CODE, READONLY, ALIGN=2

                  svcRtxSemaphoreDelete PROC
;;;318    /// \note API identical to osSemaphoreDelete
;;;319    static osStatus_t svcRtxSemaphoreDelete (osSemaphoreId_t semaphore_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;320      os_semaphore_t *semaphore = osRtxSemaphoreId(semaphore_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L13.12|
;;;321      os_thread_t    *thread;
;;;322    
;;;323      // Check parameters
;;;324      if ((semaphore == NULL) || (semaphore->id != osRtxIdSemaphore)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f6              CMP      r0,#0xf6
00000a  d007              BEQ      |L13.28|
                  |L13.12|
;;;325        EvrRtxSemaphoreError(semaphore, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxSemaphoreError
;;;326        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;327        return osErrorParameter;
000018  4628              MOV      r0,r5
;;;328      }
;;;329    
;;;330      // Unblock waiting threads
;;;331      if (semaphore->thread_list != NULL) {
;;;332        do {
;;;333          thread = osRtxThreadListGet(osRtxObject(semaphore));
;;;334          osRtxThreadWaitExit(thread, (uint32_t)osErrorResource, FALSE);
;;;335        } while (semaphore->thread_list != NULL);
;;;336        osRtxThreadDispatch(NULL);
;;;337      }
;;;338    
;;;339      // Mark object as invalid
;;;340      semaphore->id = osRtxIdInvalid;
;;;341    
;;;342      // Free object memory
;;;343      if ((semaphore->flags & osRtxFlagSystemObject) != 0U) {
;;;344        if (osRtxInfo.mpi.semaphore != NULL) {
;;;345          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.semaphore, semaphore);
;;;346        } else {
;;;347          (void)osRtxMemoryFree(osRtxInfo.mem.common, semaphore);
;;;348        }
;;;349    #ifdef RTX_OBJ_MEM_USAGE
;;;350        osRtxSemaphoreMemUsage.cnt_free++;
;;;351    #endif
;;;352      }
;;;353    
;;;354      EvrRtxSemaphoreDestroyed(semaphore);
;;;355    
;;;356      return osOK;
;;;357    }
00001a  bd70              POP      {r4-r6,pc}
                  |L13.28|
00001c  68a0              LDR      r0,[r4,#8]            ;331
00001e  b168              CBZ      r0,|L13.60|
000020  f06f0502          MVN      r5,#2                 ;334
                  |L13.36|
000024  4620              MOV      r0,r4                 ;333
000026  f7fffffe          BL       osRtxThreadListGet
00002a  2200              MOVS     r2,#0                 ;334
00002c  4629              MOV      r1,r5                 ;334
00002e  f7fffffe          BL       osRtxThreadWaitExit
000032  68a0              LDR      r0,[r4,#8]            ;335
000034  2800              CMP      r0,#0                 ;335
000036  d1f5              BNE      |L13.36|
000038  f7fffffe          BL       osRtxThreadDispatch
                  |L13.60|
00003c  2000              MOVS     r0,#0                 ;340
00003e  7020              STRB     r0,[r4,#0]            ;340
000040  78a0              LDRB     r0,[r4,#2]            ;343
000042  07c0              LSLS     r0,r0,#31             ;343
000044  d010              BEQ      |L13.104|
000046  490b              LDR      r1,|L13.116|
000048  f8d10098          LDR      r0,[r1,#0x98]         ;344  ; osRtxInfo
00004c  b118              CBZ      r0,|L13.86|
00004e  4621              MOV      r1,r4                 ;345
000050  f7fffffe          BL       osRtxMemoryPoolFree
000054  e004              B        |L13.96|
                  |L13.86|
000056  f8d10080          LDR      r0,[r1,#0x80]         ;347  ; osRtxInfo
00005a  4621              MOV      r1,r4                 ;347
00005c  f7fffffe          BL       osRtxMemoryFree
                  |L13.96|
000060  4805              LDR      r0,|L13.120|
000062  6841              LDR      r1,[r0,#4]            ;350  ; osRtxSemaphoreMemUsage
000064  1c49              ADDS     r1,r1,#1              ;350
000066  6041              STR      r1,[r0,#4]            ;350  ; osRtxSemaphoreMemUsage
                  |L13.104|
000068  4620              MOV      r0,r4                 ;354
00006a  f7fffffe          BL       EvrRtxSemaphoreDestroyed
00006e  2000              MOVS     r0,#0                 ;356
000070  bd70              POP      {r4-r6,pc}
;;;358    
                          ENDP

000072  0000              DCW      0x0000
                  |L13.116|
                          DCD      osRtxInfo
                  |L13.120|
                          DCD      ||.data.os.semaphore.obj||

                          AREA ||i.svcRtxSemaphoreGetCount||, CODE, READONLY, ALIGN=1

                  svcRtxSemaphoreGetCount PROC
;;;301    /// \note API identical to osSemaphoreGetCount
;;;302    static uint32_t svcRtxSemaphoreGetCount (osSemaphoreId_t semaphore_id) {
000000  b510              PUSH     {r4,lr}
;;;303      os_semaphore_t *semaphore = osRtxSemaphoreId(semaphore_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L14.12|
;;;304    
;;;305      // Check parameters
;;;306      if ((semaphore == NULL) || (semaphore->id != osRtxIdSemaphore)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f6              CMP      r0,#0xf6
00000a  d005              BEQ      |L14.24|
                  |L14.12|
;;;307        EvrRtxSemaphoreGetCount(semaphore, 0U);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxSemaphoreGetCount
;;;308        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;309        return 0U;
000014  2000              MOVS     r0,#0
;;;310      }
;;;311    
;;;312      EvrRtxSemaphoreGetCount(semaphore, semaphore->tokens);
;;;313    
;;;314      return semaphore->tokens;
;;;315    }
000016  bd10              POP      {r4,pc}
                  |L14.24|
000018  89a1              LDRH     r1,[r4,#0xc]          ;312
00001a  4620              MOV      r0,r4                 ;312
00001c  f7fffffe          BL       EvrRtxSemaphoreGetCount
000020  89a0              LDRH     r0,[r4,#0xc]          ;314
000022  bd10              POP      {r4,pc}
;;;316    
                          ENDP


                          AREA ||i.svcRtxSemaphoreGetName||, CODE, READONLY, ALIGN=1

                  svcRtxSemaphoreGetName PROC
;;;211    /// \note API identical to osSemaphoreGetName
;;;212    static const char *svcRtxSemaphoreGetName (osSemaphoreId_t semaphore_id) {
000000  b510              PUSH     {r4,lr}
;;;213      os_semaphore_t *semaphore = osRtxSemaphoreId(semaphore_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L15.12|
;;;214    
;;;215      // Check parameters
;;;216      if ((semaphore == NULL) || (semaphore->id != osRtxIdSemaphore)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f6              CMP      r0,#0xf6
00000a  d005              BEQ      |L15.24|
                  |L15.12|
;;;217        EvrRtxSemaphoreGetName(semaphore, NULL);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxSemaphoreGetName
;;;218        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;219        return NULL;
000014  2000              MOVS     r0,#0
;;;220      }
;;;221    
;;;222      EvrRtxSemaphoreGetName(semaphore, semaphore->name);
;;;223    
;;;224      return semaphore->name;
;;;225    }
000016  bd10              POP      {r4,pc}
                  |L15.24|
000018  4620              MOV      r0,r4                 ;222
00001a  6861              LDR      r1,[r4,#4]            ;222
00001c  f7fffffe          BL       EvrRtxSemaphoreGetName
000020  6860              LDR      r0,[r4,#4]            ;224
000022  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.svcRtxSemaphoreNew||, CODE, READONLY, ALIGN=2

                  svcRtxSemaphoreNew PROC
;;;129    /// \note API identical to osSemaphoreNew
;;;130    static osSemaphoreId_t svcRtxSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  460e              MOV      r6,r1
000006  0005              MOVS     r5,r0
000008  d004              BEQ      |L16.20|
;;;131      os_semaphore_t *semaphore;
;;;132      uint8_t         flags;
;;;133      const char     *name;
;;;134    
;;;135      // Check parameters
;;;136      if ((max_count == 0U) || (max_count > osRtxSemaphoreTokenLimit) || (initial_count > max_count)) {
00000a  f5b53f80          CMP      r5,#0x10000
00000e  d201              BCS      |L16.20|
000010  42ae              CMP      r6,r5
000012  d902              BLS      |L16.26|
                  |L16.20|
;;;137        EvrRtxSemaphoreError(NULL, (int32_t)osErrorParameter);
000014  f06f0103          MVN      r1,#3
;;;138        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;139        return NULL;
000018  e00f              B        |L16.58|
                  |L16.26|
;;;140      }
;;;141    
;;;142      // Process attributes
;;;143      if (attr != NULL) {
;;;144        name      = attr->name;
;;;145        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
;;;146        semaphore = attr->cb_mem;
;;;147        if (semaphore != NULL) {
;;;148          //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
;;;149          if ((((uint32_t)semaphore & 3U) != 0U) || (attr->cb_size < sizeof(os_semaphore_t))) {
;;;150            EvrRtxSemaphoreError(NULL, osRtxErrorInvalidControlBlock);
;;;151            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;152            return NULL;
;;;153          }
;;;154        } else {
;;;155          if (attr->cb_size != 0U) {
;;;156            EvrRtxSemaphoreError(NULL, osRtxErrorInvalidControlBlock);
;;;157            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;158            return NULL;
;;;159          }
;;;160        }
;;;161      } else {
;;;162        name      = NULL;
;;;163        semaphore = NULL;
;;;164      }
;;;165    
;;;166      // Allocate object memory if not provided
;;;167      if (semaphore == NULL) {
;;;168        if (osRtxInfo.mpi.semaphore != NULL) {
00001a  f8df8094          LDR      r8,|L16.176|
00001e  b192              CBZ      r2,|L16.70|
000020  6817              LDR      r7,[r2,#0]            ;147
000022  6894              LDR      r4,[r2,#8]            ;147
000024  f06f0108          MVN      r1,#8                 ;150
000028  b12c              CBZ      r4,|L16.54|
00002a  07a0              LSLS     r0,r4,#30             ;149
00002c  d105              BNE      |L16.58|
00002e  68d0              LDR      r0,[r2,#0xc]          ;149
000030  2810              CMP      r0,#0x10              ;149
000032  d302              BCC      |L16.58|
000034  e029              B        |L16.138|
                  |L16.54|
000036  68d0              LDR      r0,[r2,#0xc]          ;155
000038  b130              CBZ      r0,|L16.72|
                  |L16.58|
00003a  2000              MOVS     r0,#0                 ;156
00003c  f7fffffe          BL       EvrRtxSemaphoreError
000040  2000              MOVS     r0,#0                 ;158
                  |L16.66|
;;;169          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;170          semaphore = osRtxMemoryPoolAlloc(osRtxInfo.mpi.semaphore);
;;;171        } else {
;;;172          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;173          semaphore = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_semaphore_t), 1U);
;;;174        }
;;;175    #ifdef RTX_OBJ_MEM_USAGE
;;;176        if (semaphore != NULL) {
;;;177          uint32_t used;
;;;178          osRtxSemaphoreMemUsage.cnt_alloc++;
;;;179          used = osRtxSemaphoreMemUsage.cnt_alloc - osRtxSemaphoreMemUsage.cnt_free;
;;;180          if (osRtxSemaphoreMemUsage.max_used < used) {
;;;181            osRtxSemaphoreMemUsage.max_used = used;
;;;182          }
;;;183        }
;;;184    #endif
;;;185        flags = osRtxFlagSystemObject;
;;;186      } else {
;;;187        flags = 0U;
;;;188      }
;;;189    
;;;190      if (semaphore != NULL) {
;;;191        // Initialize control block
;;;192        semaphore->id          = osRtxIdSemaphore;
;;;193        semaphore->flags       = flags;
;;;194        semaphore->name        = name;
;;;195        semaphore->thread_list = NULL;
;;;196        semaphore->tokens      = (uint16_t)initial_count;
;;;197        semaphore->max_tokens  = (uint16_t)max_count;
;;;198    
;;;199        // Register post ISR processing function
;;;200        osRtxInfo.post_process.semaphore = osRtxSemaphorePostProcess;
;;;201    
;;;202        EvrRtxSemaphoreCreated(semaphore, semaphore->name);
;;;203      } else {
;;;204        EvrRtxSemaphoreError(NULL,(int32_t)osErrorNoMemory);
;;;205      }
;;;206    
;;;207      return semaphore;
;;;208    }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L16.70|
000046  2700              MOVS     r7,#0                 ;162
                  |L16.72|
000048  f8d81098          LDR      r1,[r8,#0x98]         ;168  ; osRtxInfo
00004c  b119              CBZ      r1,|L16.86|
00004e  4608              MOV      r0,r1                 ;168
000050  f7fffffe          BL       osRtxMemoryPoolAlloc
000054  e005              B        |L16.98|
                  |L16.86|
000056  2201              MOVS     r2,#1                 ;173
000058  2110              MOVS     r1,#0x10              ;173
00005a  f8d80080          LDR      r0,[r8,#0x80]         ;173  ; osRtxInfo
00005e  f7fffffe          BL       osRtxMemoryAlloc
                  |L16.98|
000062  0004              MOVS     r4,r0                 ;173
000064  d00b              BEQ      |L16.126|
000066  4813              LDR      r0,|L16.180|
000068  6801              LDR      r1,[r0,#0]            ;178  ; osRtxSemaphoreMemUsage
00006a  1c49              ADDS     r1,r1,#1              ;178
00006c  6001              STR      r1,[r0,#0]            ;179  ; osRtxSemaphoreMemUsage
00006e  6842              LDR      r2,[r0,#4]            ;179  ; osRtxSemaphoreMemUsage
000070  1a89              SUBS     r1,r1,r2              ;179
000072  6882              LDR      r2,[r0,#8]            ;180  ; osRtxSemaphoreMemUsage
000074  428a              CMP      r2,r1                 ;180
000076  d200              BCS      |L16.122|
000078  6081              STR      r1,[r0,#8]            ;181  ; osRtxSemaphoreMemUsage
                  |L16.122|
00007a  2001              MOVS     r0,#1                 ;185
00007c  e006              B        |L16.140|
                  |L16.126|
00007e  f06f0104          MVN      r1,#4                 ;204
000082  2000              MOVS     r0,#0                 ;204
000084  f7fffffe          BL       EvrRtxSemaphoreError
000088  e00f              B        |L16.170|
                  |L16.138|
00008a  2000              MOVS     r0,#0                 ;187
                  |L16.140|
00008c  21f6              MOVS     r1,#0xf6              ;192
00008e  7021              STRB     r1,[r4,#0]            ;192
000090  70a0              STRB     r0,[r4,#2]            ;193
000092  2000              MOVS     r0,#0                 ;195
000094  e9c47001          STRD     r7,r0,[r4,#4]         ;195
000098  81a6              STRH     r6,[r4,#0xc]          ;196
00009a  81e5              STRH     r5,[r4,#0xe]          ;197
00009c  4906              LDR      r1,|L16.184|
00009e  f8c81068          STR      r1,[r8,#0x68]         ;202  ; osRtxInfo
0000a2  4620              MOV      r0,r4                 ;202
0000a4  6861              LDR      r1,[r4,#4]            ;202
0000a6  f7fffffe          BL       EvrRtxSemaphoreCreated
                  |L16.170|
0000aa  4620              MOV      r0,r4                 ;207
0000ac  e7c9              B        |L16.66|
;;;209    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L16.176|
                          DCD      osRtxInfo
                  |L16.180|
                          DCD      ||.data.os.semaphore.obj||
                  |L16.184|
                          DCD      osRtxSemaphorePostProcess

                          AREA ||i.svcRtxSemaphoreRelease||, CODE, READONLY, ALIGN=1

                  svcRtxSemaphoreRelease PROC
;;;265    /// \note API identical to osSemaphoreRelease
;;;266    static osStatus_t svcRtxSemaphoreRelease (osSemaphoreId_t semaphore_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;267      os_semaphore_t *semaphore = osRtxSemaphoreId(semaphore_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L17.12|
;;;268      os_thread_t    *thread;
;;;269      osStatus_t      status;
;;;270    
;;;271      // Check parameters
;;;272      if ((semaphore == NULL) || (semaphore->id != osRtxIdSemaphore)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f6              CMP      r0,#0xf6
00000a  d007              BEQ      |L17.28|
                  |L17.12|
;;;273        EvrRtxSemaphoreError(semaphore, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxSemaphoreError
;;;274        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;275        return osErrorParameter;
000018  4628              MOV      r0,r5
;;;276      }
;;;277    
;;;278      // Check if Thread is waiting for a token
;;;279      if (semaphore->thread_list != NULL) {
;;;280        EvrRtxSemaphoreReleased(semaphore, semaphore->tokens);
;;;281        // Wakeup waiting Thread with highest Priority
;;;282        thread = osRtxThreadListGet(osRtxObject(semaphore));
;;;283        osRtxThreadWaitExit(thread, (uint32_t)osOK, TRUE);
;;;284        EvrRtxSemaphoreAcquired(semaphore, semaphore->tokens);
;;;285        status = osOK;
;;;286      } else {
;;;287        // Try to release token
;;;288        if (SemaphoreTokenIncrement(semaphore) != 0U) {
;;;289          EvrRtxSemaphoreReleased(semaphore, semaphore->tokens);
;;;290          status = osOK;
;;;291        } else {
;;;292          EvrRtxSemaphoreError(semaphore, osRtxErrorSemaphoreCountLimit);
;;;293          status = osErrorResource;
;;;294        }
;;;295      }
;;;296    
;;;297      return status;
;;;298    }
00001a  bd70              POP      {r4-r6,pc}
                  |L17.28|
00001c  68a0              LDR      r0,[r4,#8]            ;279
00001e  b178              CBZ      r0,|L17.64|
000020  89a1              LDRH     r1,[r4,#0xc]          ;280
000022  4620              MOV      r0,r4                 ;280
000024  f7fffffe          BL       EvrRtxSemaphoreReleased
000028  4620              MOV      r0,r4                 ;282
00002a  f7fffffe          BL       osRtxThreadListGet
00002e  2201              MOVS     r2,#1                 ;283
000030  2100              MOVS     r1,#0                 ;283
000032  f7fffffe          BL       osRtxThreadWaitExit
000036  89a1              LDRH     r1,[r4,#0xc]          ;284
000038  4620              MOV      r0,r4                 ;284
00003a  f7fffffe          BL       EvrRtxSemaphoreAcquired
00003e  e007              B        |L17.80|
                  |L17.64|
000040  4620              MOV      r0,r4                 ;288
000042  f7fffffe          BL       SemaphoreTokenIncrement
000046  b128              CBZ      r0,|L17.84|
000048  89a1              LDRH     r1,[r4,#0xc]          ;289
00004a  4620              MOV      r0,r4                 ;289
00004c  f7fffffe          BL       EvrRtxSemaphoreReleased
                  |L17.80|
000050  2000              MOVS     r0,#0                 ;285
000052  bd70              POP      {r4-r6,pc}
                  |L17.84|
000054  f06f0110          MVN      r1,#0x10              ;292
000058  4620              MOV      r0,r4                 ;292
00005a  f7fffffe          BL       EvrRtxSemaphoreError
00005e  f06f0002          MVN      r0,#2                 ;293
000062  bd70              POP      {r4-r6,pc}
;;;299    
                          ENDP


                          AREA ||.data.os.semaphore.obj||, DATA, ALIGN=2

                  osRtxSemaphoreMemUsage
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_semaphore.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_rtx_semaphore_c_7b131ed0____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0____REVSH|
#line 223
|__asm___15_rtx_semaphore_c_7b131ed0____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0____RRX|
#line 410
|__asm___15_rtx_semaphore_c_7b131ed0____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_wr8|
#line 464 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_core_cm.h"
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_wr8| PROC
#line 464

 mov r2,r0
1
 ldrexb r0,[r2]
 strexb r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_set32|
#line 511
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_set32| PROC
#line 511

 mov r2,r0
1
 ldrex r0,[r2]
 orr r0,r0,r1
 strex r3,r0,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_clr32|
#line 570
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_clr32| PROC
#line 570

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F2
 b %B1
2
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_chk32_all|
#line 630
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_chk32_all| PROC
#line 630

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 and r4,r0,r1
 cmp r4,r1
 beq %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_chk32_any|
#line 705
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_chk32_any| PROC
#line 705

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 tst r0,r1
 bne %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_inc32|
#line 772
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_inc32| PROC
#line 772

 mov r2,r0
1
 ldrex r0,[r2]
 adds r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_inc16_lt|
#line 821
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_inc16_lt| PROC
#line 821

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 cmp r1,r0
 bhi %F2
 clrex
 pop {r4,pc}
2
 adds r4,r0,#1
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_inc16_lim|
#line 882
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_inc16_lim| PROC
#line 882

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 adds r4,r0,#1
 cmp r1,r4
 bhi %F2
 movs r4,#0
2
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_dec32|
#line 940
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_dec32| PROC
#line 940

 mov r2,r0
1
 ldrex r0,[r2]
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_dec32_nz|
#line 988
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_dec32_nz| PROC
#line 988

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_dec16_nz|
#line 1044
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_dec16_nz| PROC
#line 1044

 mov r2,r0
1
 ldrexh r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strexh r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_link_get|
#line 1100
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_link_get| PROC
#line 1100

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 ldr r1,[r0]
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_rtx_semaphore_c_7b131ed0__atomic_link_put|
#line 1156
|__asm___15_rtx_semaphore_c_7b131ed0__atomic_link_put| PROC
#line 1156

1
 ldr r2,[r0]
 str r2,[r1]
 dmb
 ldrex r2,[r0]
 ldr r3,[r1]
 cmp r3,r2
 bne %B1
 strex r3,r1,[r0]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP

;*** End   embedded assembler ***
