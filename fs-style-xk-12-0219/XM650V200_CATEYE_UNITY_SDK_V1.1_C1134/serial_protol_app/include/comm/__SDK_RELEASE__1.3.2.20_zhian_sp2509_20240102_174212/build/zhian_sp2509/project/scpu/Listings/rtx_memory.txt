; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\rtx_memory.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\rtx_memory.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\rtx_memory.crf F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_memory.c]
                          THUMB

                          AREA ||i.osRtxMemoryAlloc||, CODE, READONLY, ALIGN=1

                  osRtxMemoryAlloc PROC
;;;104    /// \return allocated memory block or NULL in case of no memory is available.
;;;105    __WEAK void *osRtxMemoryAlloc (void *mem, uint32_t size, uint32_t type) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  0004              MOVS     r4,r0
000006  d014              BEQ      |L1.50|
;;;106      mem_block_t *ptr;
;;;107      mem_block_t *p, *p_new;
;;;108      uint32_t     block_size;
;;;109      uint32_t     hole_size;
;;;110    
;;;111      // Check parameters
;;;112      if ((mem == NULL) || (size == 0U) || ((type & ~MB_INFO_TYPE_MASK) != 0U)) {
000008  b199              CBZ      r1,|L1.50|
00000a  0890              LSRS     r0,r2,#2
00000c  d111              BNE      |L1.50|
;;;113        EvrRtxMemoryAlloc(mem, size, type, NULL);
;;;114        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;115        return NULL;
;;;116      }
;;;117    
;;;118      // Add block header to size
;;;119      block_size = size + sizeof(mem_block_t);
00000e  f101000f          ADD      r0,r1,#0xf
;;;120      // Make sure that block is 8-byte aligned
;;;121      block_size = (block_size + 7U) & ~((uint32_t)7U);
000012  f0200307          BIC      r3,r0,#7
000016  f1040008          ADD      r0,r4,#8
                  |L1.26|
;;;122    
;;;123      // Search for hole big enough
;;;124      p = MemBlockPtr(mem, sizeof(mem_head_t));
;;;125      for (;;) {
;;;126        //lint -e{923} -e{9078} "cast from pointer to unsigned int"
;;;127        hole_size  = (uint32_t)p->next - (uint32_t)p;
00001a  6805              LDR      r5,[r0,#0]
;;;128        hole_size -= p->info & MB_INFO_LEN_MASK;
00001c  6847              LDR      r7,[r0,#4]
00001e  1a2e              SUBS     r6,r5,r0              ;127
000020  f0270703          BIC      r7,r7,#3
000024  1bf6              SUBS     r6,r6,r7
;;;129        if (hole_size >= block_size) {
000026  429e              CMP      r6,r3
000028  d20a              BCS      |L1.64|
00002a  4628              MOV      r0,r5
;;;130          // Hole found
;;;131          break;
;;;132        }
;;;133        p = p->next;
;;;134        if (p->next == NULL) {
00002c  682d              LDR      r5,[r5,#0]
00002e  2d00              CMP      r5,#0
000030  d1f3              BNE      |L1.26|
                  |L1.50|
;;;135          // Failed (end of list)
;;;136          EvrRtxMemoryAlloc(mem, size, type, NULL);
000032  2300              MOVS     r3,#0
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       EvrRtxMemoryAlloc
;;;137          //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;138          return NULL;
00003a  2000              MOVS     r0,#0
                  |L1.60|
;;;139        }
;;;140      }
;;;141    
;;;142      // Update used memory
;;;143      (MemHeadPtr(mem))->used += block_size;
;;;144    
;;;145      // Update max used memory
;;;146      p_new = MemBlockPtr(mem, (MemHeadPtr(mem))->size - sizeof(mem_block_t));
;;;147      if (p_new->info < (MemHeadPtr(mem))->used) {
;;;148        p_new->info = (MemHeadPtr(mem))->used;
;;;149      }
;;;150    
;;;151      // Allocate block
;;;152      if (p->info == 0U) {
;;;153        // No block allocated, set info of first element
;;;154        p->info = block_size | type;
;;;155        ptr = MemBlockPtr(p, sizeof(mem_block_t));
;;;156      } else {
;;;157        // Insert new element into the list
;;;158        p_new = MemBlockPtr(p, p->info & MB_INFO_LEN_MASK);
;;;159        p_new->next = p->next;
;;;160        p_new->info = block_size | type;
;;;161        p->next = p_new;
;;;162        ptr = MemBlockPtr(p_new, sizeof(mem_block_t));
;;;163      }
;;;164    
;;;165      EvrRtxMemoryAlloc(mem, size, type, ptr);
;;;166    
;;;167      return ptr;
;;;168    }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.64|
000040  6866              LDR      r6,[r4,#4]            ;143
000042  441e              ADD      r6,r6,r3              ;143
000044  6066              STR      r6,[r4,#4]            ;146
000046  6825              LDR      r5,[r4,#0]            ;146
000048  3d08              SUBS     r5,r5,#8              ;146
00004a  4425              ADD      r5,r5,r4              ;146
00004c  686f              LDR      r7,[r5,#4]            ;147
00004e  42b7              CMP      r7,r6                 ;147
000050  d200              BCS      |L1.84|
000052  606e              STR      r6,[r5,#4]            ;148
                  |L1.84|
000054  6845              LDR      r5,[r0,#4]            ;152
000056  b175              CBZ      r5,|L1.118|
000058  f0250503          BIC      r5,r5,#3              ;158
00005c  4405              ADD      r5,r5,r0              ;158
00005e  4313              ORRS     r3,r3,r2              ;160
000060  6806              LDR      r6,[r0,#0]            ;160
000062  e9c56300          STRD     r6,r3,[r5,#0]         ;160
000066  6005              STR      r5,[r0,#0]            ;161
000068  3508              ADDS     r5,r5,#8              ;161
                  |L1.106|
00006a  462b              MOV      r3,r5                 ;165
00006c  4620              MOV      r0,r4                 ;165
00006e  f7fffffe          BL       EvrRtxMemoryAlloc
000072  4628              MOV      r0,r5                 ;167
000074  e7e2              B        |L1.60|
                  |L1.118|
000076  4313              ORRS     r3,r3,r2              ;154
000078  f1000508          ADD      r5,r0,#8              ;154
00007c  6043              STR      r3,[r0,#4]            ;155
00007e  e7f4              B        |L1.106|
;;;169    
                          ENDP


                          AREA ||i.osRtxMemoryFree||, CODE, READONLY, ALIGN=1

                  osRtxMemoryFree PROC
;;;173    /// \return 1 - success, 0 - failure.
;;;174    __WEAK uint32_t osRtxMemoryFree (void *mem, void *block) {
000000  b570              PUSH     {r4-r6,lr}
000002  b1c8              CBZ      r0,|L2.56|
;;;175      const mem_block_t *ptr;
;;;176            mem_block_t *p, *p_prev;
;;;177    
;;;178      // Check parameters
;;;179      if ((mem == NULL) || (block == NULL)) {
000004  b1c1              CBZ      r1,|L2.56|
;;;180        EvrRtxMemoryFree(mem, block, 0U);
;;;181        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;182        return 0U;
;;;183      }
;;;184    
;;;185      // Memory block header
;;;186      ptr = MemBlockPtr(block, 0U);
;;;187      ptr--;
000006  f1a10208          SUB      r2,r1,#8
;;;188    
;;;189      // Search for block header
;;;190      p_prev = NULL;
00000a  2400              MOVS     r4,#0
00000c  f1000308          ADD      r3,r0,#8
;;;191      p = MemBlockPtr(mem, sizeof(mem_head_t));
;;;192      while (p != ptr) {
000010  e002              B        |L2.24|
                  |L2.18|
;;;193        p_prev = p;
000012  461c              MOV      r4,r3
;;;194        p = p->next;
000014  681b              LDR      r3,[r3,#0]
;;;195        if (p == NULL) {
000016  b17b              CBZ      r3,|L2.56|
                  |L2.24|
000018  4293              CMP      r3,r2                 ;192
00001a  d1fa              BNE      |L2.18|
;;;196          // Not found
;;;197          EvrRtxMemoryFree(mem, block, 0U);
;;;198          //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;199          return 0U;
;;;200        }
;;;201      }
;;;202    
;;;203      // Update used memory
;;;204      (MemHeadPtr(mem))->used -= p->info & MB_INFO_LEN_MASK;
00001c  685e              LDR      r6,[r3,#4]
00001e  6845              LDR      r5,[r0,#4]
000020  f0260603          BIC      r6,r6,#3
000024  1bad              SUBS     r5,r5,r6
;;;205    
;;;206      // Free block
;;;207      if (p_prev == NULL) {
000026  6045              STR      r5,[r0,#4]
000028  b15c              CBZ      r4,|L2.66|
;;;208        // Release first block, only set info to 0
;;;209        p->info = 0U;
;;;210      } else {
;;;211        // Discard block from chained list
;;;212        p_prev->next = p->next;
00002a  681a              LDR      r2,[r3,#0]
00002c  6022              STR      r2,[r4,#0]
                  |L2.46|
;;;213      }
;;;214    
;;;215      EvrRtxMemoryFree(mem, block, 1U);
00002e  2201              MOVS     r2,#1
000030  f7fffffe          BL       EvrRtxMemoryFree
;;;216    
;;;217      return 1U;
000034  2001              MOVS     r0,#1
;;;218    }
000036  bd70              POP      {r4-r6,pc}
                  |L2.56|
000038  2200              MOVS     r2,#0                 ;197
00003a  f7fffffe          BL       EvrRtxMemoryFree
00003e  2000              MOVS     r0,#0                 ;199
000040  bd70              POP      {r4-r6,pc}
                  |L2.66|
000042  2200              MOVS     r2,#0                 ;209
000044  605a              STR      r2,[r3,#4]            ;209
000046  e7f2              B        |L2.46|
                          ENDP


                          AREA ||i.osRtxMemoryInit||, CODE, READONLY, ALIGN=1

                  osRtxMemoryInit PROC
;;;69     /// \return 1 - success, 0 - failure.
;;;70     __WEAK uint32_t osRtxMemoryInit (void *mem, uint32_t size) {
000000  b570              PUSH     {r4-r6,lr}
000002  b128              CBZ      r0,|L3.16|
;;;71       mem_head_t  *head;
;;;72       mem_block_t *ptr;
;;;73     
;;;74       // Check parameters
;;;75       //lint -e{923} "cast from pointer to unsigned int" [MISRA Note 7]
;;;76       if ((mem == NULL) || (((uint32_t)mem & 7U) != 0U) || ((size & 7U) != 0U) ||
000004  0742              LSLS     r2,r0,#29
000006  d103              BNE      |L3.16|
000008  074a              LSLS     r2,r1,#29
00000a  d101              BNE      |L3.16|
;;;77           (size < (sizeof(mem_head_t) + (2U*sizeof(mem_block_t))))) {
00000c  2918              CMP      r1,#0x18
00000e  d204              BCS      |L3.26|
                  |L3.16|
;;;78         EvrRtxMemoryInit(mem, size, 0U);
000010  2200              MOVS     r2,#0
000012  f7fffffe          BL       EvrRtxMemoryInit
;;;79         //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;80         return 0U;
000016  2000              MOVS     r0,#0
;;;81       }
;;;82     
;;;83       // Initialize memory pool header
;;;84       head = MemHeadPtr(mem);
;;;85       head->size = size;
;;;86       head->used = sizeof(mem_head_t) + sizeof(mem_block_t);
;;;87     
;;;88       // Initialize first and last block header
;;;89       ptr = MemBlockPtr(mem, sizeof(mem_head_t));
;;;90       ptr->next = MemBlockPtr(mem, size - sizeof(mem_block_t));
;;;91       ptr->next->next = NULL;
;;;92       ptr->next->info = sizeof(mem_head_t) + sizeof(mem_block_t);
;;;93       ptr->info = 0U;
;;;94     
;;;95       EvrRtxMemoryInit(mem, size, 1U);
;;;96     
;;;97       return 1U;
;;;98     }
000018  bd70              POP      {r4-r6,pc}
                  |L3.26|
00001a  f1a10308          SUB      r3,r1,#8              ;90
00001e  4403              ADD      r3,r3,r0              ;90
000020  2410              MOVS     r4,#0x10              ;86
000022  6083              STR      r3,[r0,#8]            ;91
000024  e9c01400          STRD     r1,r4,[r0,#0]         ;91
000028  2500              MOVS     r5,#0                 ;91
00002a  601d              STR      r5,[r3,#0]            ;92
00002c  6883              LDR      r3,[r0,#8]            ;92
00002e  2201              MOVS     r2,#1                 ;95
000030  605c              STR      r4,[r3,#4]            ;93
000032  60c5              STR      r5,[r0,#0xc]          ;95
000034  f7fffffe          BL       EvrRtxMemoryInit
000038  2001              MOVS     r0,#1                 ;97
00003a  bd70              POP      {r4-r6,pc}
;;;99     
                          ENDP


;*** Start embedded assembler ***

#line 1 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_memory.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___12_rtx_memory_c____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c____REVSH|
#line 223
|__asm___12_rtx_memory_c____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c____RRX|
#line 410
|__asm___12_rtx_memory_c____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_wr8|
#line 464 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_core_cm.h"
|__asm___12_rtx_memory_c__atomic_wr8| PROC
#line 464

 mov r2,r0
1
 ldrexb r0,[r2]
 strexb r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_set32|
#line 511
|__asm___12_rtx_memory_c__atomic_set32| PROC
#line 511

 mov r2,r0
1
 ldrex r0,[r2]
 orr r0,r0,r1
 strex r3,r0,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_clr32|
#line 570
|__asm___12_rtx_memory_c__atomic_clr32| PROC
#line 570

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F2
 b %B1
2
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_chk32_all|
#line 630
|__asm___12_rtx_memory_c__atomic_chk32_all| PROC
#line 630

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 and r4,r0,r1
 cmp r4,r1
 beq %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_chk32_any|
#line 705
|__asm___12_rtx_memory_c__atomic_chk32_any| PROC
#line 705

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 tst r0,r1
 bne %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_inc32|
#line 772
|__asm___12_rtx_memory_c__atomic_inc32| PROC
#line 772

 mov r2,r0
1
 ldrex r0,[r2]
 adds r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_inc16_lt|
#line 821
|__asm___12_rtx_memory_c__atomic_inc16_lt| PROC
#line 821

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 cmp r1,r0
 bhi %F2
 clrex
 pop {r4,pc}
2
 adds r4,r0,#1
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_inc16_lim|
#line 882
|__asm___12_rtx_memory_c__atomic_inc16_lim| PROC
#line 882

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 adds r4,r0,#1
 cmp r1,r4
 bhi %F2
 movs r4,#0
2
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_dec32|
#line 940
|__asm___12_rtx_memory_c__atomic_dec32| PROC
#line 940

 mov r2,r0
1
 ldrex r0,[r2]
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_dec32_nz|
#line 988
|__asm___12_rtx_memory_c__atomic_dec32_nz| PROC
#line 988

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_dec16_nz|
#line 1044
|__asm___12_rtx_memory_c__atomic_dec16_nz| PROC
#line 1044

 mov r2,r0
1
 ldrexh r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strexh r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_link_get|
#line 1100
|__asm___12_rtx_memory_c__atomic_link_get| PROC
#line 1100

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 ldr r1,[r0]
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_memory_c__atomic_link_put|
#line 1156
|__asm___12_rtx_memory_c__atomic_link_put| PROC
#line 1156

1
 ldr r2,[r0]
 str r2,[r1]
 dmb
 ldrex r2,[r0]
 ldr r3,[r1]
 cmp r3,r2
 bne %B1
 strex r3,r1,[r0]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP

;*** End   embedded assembler ***
