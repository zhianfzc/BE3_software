; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\kdp520_touch.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\kdp520_touch.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\kdp520_touch.crf ..\..\..\..\scpu\drivers\media\platform\kdp520_touch.c]
                          THUMB

                          AREA ||i._tp_gpio_set_int_start||, CODE, READONLY, ALIGN=1

                  _tp_gpio_set_int_start PROC
;;;168    
;;;169    static void _tp_gpio_set_int_start(void) {
000000  b510              PUSH     {r4,lr}
;;;170        u8 i = KDP_GPIO_INT_PIN_FOR_TOUCH;
000002  241b              MOVS     r4,#0x1b
;;;171        kdp520_gpio_clearint(1<<i);
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       kdp520_gpio_clearint
;;;172        kdp520_gpio_setintenable(i);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       kdp520_gpio_setintenable
;;;173        kdp520_gpio_setintunmask(i);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  f7ffbffe          B.W      kdp520_gpio_setintunmask
;;;174    }
;;;175    
                          ENDP


                          AREA ||i._tp_gpio_set_int_stop||, CODE, READONLY, ALIGN=1

                  _tp_gpio_set_int_stop PROC
;;;162    
;;;163    static void _tp_gpio_set_int_stop(void) {
000000  b510              PUSH     {r4,lr}
;;;164        u8 i = KDP_GPIO_INT_PIN_FOR_TOUCH;
000002  241b              MOVS     r4,#0x1b
;;;165        kdp520_gpio_setintmask(i);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       kdp520_gpio_setintmask
;;;166        kdp520_gpio_setintdisable(i);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      kdp520_gpio_setintdisable
;;;167    }
;;;168    
                          ENDP


                          AREA ||i.kdp520_touch_attach_panel||, CODE, READONLY, ALIGN=2

                  kdp520_touch_attach_panel PROC
;;;153    
;;;154    static int kdp520_touch_attach_panel(struct core_device *core_d, struct touch_panel_driver *panel)
000000  4801              LDR      r0,|L3.8|
;;;155    {
;;;156        struct touch_driver *touch_drv = &kdp520_touch_driver;
;;;157    
;;;158        touch_drv->panel = panel;
;;;159        
;;;160        return 0;
000002  6481              STR      r1,[r0,#0x48]
000004  2000              MOVS     r0,#0
;;;161    }
000006  4770              BX       lr
;;;162    
                          ENDP

                  |L3.8|
                          DCD      ||.data||+0x18

                          AREA ||i.kdp520_touch_init||, CODE, READONLY, ALIGN=2

                  kdp520_touch_init PROC
;;;175    
;;;176    static int kdp520_touch_init(struct core_device *core_d)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;177    {
000004  4607              MOV      r7,r0
;;;178    #if BOARD_VERSION==3
;;;179        return 0;
;;;180    #else
;;;181        struct touch_driver *touch_drv = &kdp520_touch_driver;
;;;182        u8 i = KDP_GPIO_INT_PIN_FOR_TOUCH;
000006  261b              MOVS     r6,#0x1b
000008  4c1f              LDR      r4,|L4.136|
;;;183    
;;;184        //GPIO interrupt setting
;;;185        //sd_data3
;;;186    	kdp520_gpio_setmode(i);	//set gpio
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       kdp520_gpio_setmode
;;;187    	
;;;188        kdp520_gpio_setdir(i, GPIO_DIR_INPUT);
000010  2100              MOVS     r1,#0
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       kdp520_gpio_setdir
;;;189        kdp520_gpio_setedgemode(i, SINGLE);
000018  2100              MOVS     r1,#0
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       kdp520_gpio_setedgemode
;;;190        kdp520_gpio_settrigger(i, GPIO_EDGE);
000020  2100              MOVS     r1,#0
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       kdp520_gpio_settrigger
;;;191        kdp520_gpio_setactivemode(i, GPIO_Rising);
000028  2100              MOVS     r1,#0
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       kdp520_gpio_setactivemode
;;;192        //clear CPIO interrupt
;;;193        kdp520_gpio_clearint(1<<i);
000030  2501              MOVS     r5,#1
000032  06e8              LSLS     r0,r5,#27
000034  f7fffffe          BL       kdp520_gpio_clearint
;;;194        kdp520_gpio_enablebounce(i, APB_CLOCK /12000); //
000038  f242018d          MOV      r1,#0x208d
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       kdp520_gpio_enablebounce
;;;195        //Enable GPIO interrupt
;;;196        kdp520_gpio_setintenable(i);
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       kdp520_gpio_setintenable
;;;197        kdp520_gpio_setintunmask(i);
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       kdp520_gpio_setintunmask
;;;198    
;;;199        // read device ID
;;;200        if ((touch_drv) && (touch_drv->panel))
00004e  6ca0              LDR      r0,[r4,#0x48]
000050  b188              CBZ      r0,|L4.118|
;;;201        {
;;;202            if (touch_drv->cb_power_on)
000052  f8d40094          LDR      r0,[r4,#0x94]
000056  b100              CBZ      r0,|L4.90|
;;;203                touch_drv->cb_power_on();
000058  4780              BLX      r0
                  |L4.90|
;;;204    
;;;205            //dbg_msg_touch("touch driver probing...");
;;;206            //delay_ms(100);//need to delay a little for i2c pending issue.
;;;207            touch_drv->panel->init(core_d);
00005a  6ca0              LDR      r0,[r4,#0x48]
00005c  6801              LDR      r1,[r0,#0]
00005e  4638              MOV      r0,r7
000060  4788              BLX      r1
;;;208            touch_drv->device_id = touch_drv->panel->read_did(core_d);
000062  6ca0              LDR      r0,[r4,#0x48]
000064  6841              LDR      r1,[r0,#4]
000066  4638              MOV      r0,r7
000068  4788              BLX      r1
;;;209            //dbg_msg_touch("touch_drv->display_id=%x", touch_drv->device_id);
;;;210            if(touch_drv->device_id == 0xFFFF)
00006a  f5a0417f          SUB      r1,r0,#0xff00
00006e  f8a40044          STRH     r0,[r4,#0x44]         ;208
000072  39ff              SUBS     r1,r1,#0xff
000074  d005              BEQ      |L4.130|
                  |L4.118|
;;;211                return -1;
;;;212        }
;;;213    
;;;214        m_touch_state = TOUCH_STATE_INITED;
000076  4804              LDR      r0,|L4.136|
000078  3818              SUBS     r0,r0,#0x18
00007a  7005              STRB     r5,[r0,#0]
;;;215    
;;;216        return 0;
00007c  2000              MOVS     r0,#0
                  |L4.126|
;;;217    #endif
;;;218    }
00007e  e8bd81f0          POP      {r4-r8,pc}
                  |L4.130|
000082  f04f30ff          MOV      r0,#0xffffffff        ;211
000086  e7fa              B        |L4.126|
;;;219    
                          ENDP

                  |L4.136|
                          DCD      ||.data||+0x18

                          AREA ||i.kdp520_touch_is_started||, CODE, READONLY, ALIGN=2

                  kdp520_touch_is_started PROC
;;;286    
;;;287    BOOL kdp520_touch_is_started(struct core_device *core_d)
000000  4803              LDR      r0,|L5.16|
;;;288    {
;;;289        return (TOUCH_STATE_STARTED == m_touch_state);
000002  7800              LDRB     r0,[r0,#0]  ; m_touch_state
000004  2804              CMP      r0,#4
000006  d001              BEQ      |L5.12|
000008  2000              MOVS     r0,#0
;;;290    }
00000a  4770              BX       lr
                  |L5.12|
00000c  2001              MOVS     r0,#1                 ;289
00000e  4770              BX       lr
;;;291    
                          ENDP

                  |L5.16|
                          DCD      ||.data||

                          AREA ||i.kdp520_touch_power||, CODE, READONLY, ALIGN=1

                  kdp520_touch_power PROC
;;;219    
;;;220    static int kdp520_touch_power(struct core_device *core_d, BOOL on){
000000  2000              MOVS     r0,#0
;;;221        return 0;
;;;222    }
000002  4770              BX       lr
;;;223    
                          ENDP


                          AREA ||i.kdp520_touch_probe||, CODE, READONLY, ALIGN=2

                  kdp520_touch_probe PROC
;;;138    
;;;139    static int kdp520_touch_probe(struct core_device *core_d)
000000  4902              LDR      r1,|L7.12|
;;;140    {
;;;141        dbg_msg_touch("[%s]", __func__);
;;;142    
;;;143        m_touch_state = TOUCH_STATE_PROBED;
000002  2003              MOVS     r0,#3
000004  7008              STRB     r0,[r1,#0]
;;;144    
;;;145        return 0;
000006  2000              MOVS     r0,#0
;;;146    }
000008  4770              BX       lr
;;;147    
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      ||.data||

                          AREA ||i.kdp520_touch_remove||, CODE, READONLY, ALIGN=2

                  kdp520_touch_remove PROC
;;;147    
;;;148    static int kdp520_touch_remove(struct core_device *core_d)
000000  4901              LDR      r1,|L8.8|
;;;149    {
;;;150        m_touch_state = TOUCH_STATE_IDLE;
000002  2000              MOVS     r0,#0
000004  7008              STRB     r0,[r1,#0]
;;;151        return 0;
;;;152    }
000006  4770              BX       lr
;;;153    
                          ENDP

                  |L8.8|
                          DCD      ||.data||

                          AREA ||i.kdp520_touch_set_hook||, CODE, READONLY, ALIGN=2

                  kdp520_touch_set_hook PROC
;;;291    
;;;292    void kdp520_touch_set_hook(struct core_device *core_d, fn_power_hook fn_power_on, fn_power_hook fn_power_off)
000000  4801              LDR      r0,|L9.8|
;;;293    {
;;;294        struct touch_driver *touch_drv = &kdp520_touch_driver;
000002  e9c01225          STRD     r1,r2,[r0,#0x94]
;;;295    
;;;296        touch_drv->cb_power_on = fn_power_on;
;;;297        touch_drv->cb_power_off = fn_power_off;
;;;298    }
000006  4770              BX       lr
;;;299    
                          ENDP

                  |L9.8|
                          DCD      ||.data||+0x18

                          AREA ||i.kdp520_touch_start||, CODE, READONLY, ALIGN=2

                  kdp520_touch_start PROC
;;;223    
;;;224    static int kdp520_touch_start(struct core_device *core_d)
000000  b530              PUSH     {r4,r5,lr}
;;;225    {
;;;226        int ret = -KDP_FRAMEWORK_ERRNO_INVALA;
;;;227    
;;;228        struct touch_driver *touch_drv = &kdp520_touch_driver;
000002  4915              LDR      r1,|L10.88|
000004  4605              MOV      r5,r0                 ;225
000006  b089              SUB      sp,sp,#0x24           ;225
;;;229    
;;;230        //dbg_msg_touch("[%s]", __func__);
;;;231        //dbg_msg_touch("touch_drv=%x", touch_drv);
;;;232        //dbg_msg_touch("touch_drv->panel=%x", touch_drv->panel);
;;;233        
;;;234        if ((touch_drv) && (touch_drv->panel) && (TOUCH_STATE_STARTED != m_touch_state)){
000008  6c89              LDR      r1,[r1,#0x48]
00000a  f06f0007          MVN      r0,#7                 ;226
00000e  2900              CMP      r1,#0                 ;225
000010  d01f              BEQ      |L10.82|
000012  4c11              LDR      r4,|L10.88|
000014  3c18              SUBS     r4,r4,#0x18
000016  7822              LDRB     r2,[r4,#0]  ; m_touch_state
000018  2a04              CMP      r2,#4
00001a  d01a              BEQ      |L10.82|
;;;235            touch_drv->panel->start(core_d);
00001c  6889              LDR      r1,[r1,#8]
00001e  4628              MOV      r0,r5
000020  4788              BLX      r1
;;;236            
;;;237            if (0 == evt_touch_ack_id)
000022  6860              LDR      r0,[r4,#4]  ; evt_touch_ack_id
000024  b910              CBNZ     r0,|L10.44|
;;;238                evt_touch_ack_id = create_event();
000026  f7fffffe          BL       create_event
00002a  6060              STR      r0,[r4,#4]  ; evt_touch_ack_id
                  |L10.44|
;;;239    
;;;240            //dbg_msg_touch("touch panel : driver thread start");
;;;241            if (0 == m_tid_touch) {
00002c  68e0              LDR      r0,[r4,#0xc]  ; m_tid_touch
00002e  b968              CBNZ     r0,|L10.76|
;;;242                osThreadAttr_t attr = {
000030  2224              MOVS     r2,#0x24
000032  490a              LDR      r1,|L10.92|
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       __aeabi_memcpy4
;;;243                    .stack_size = 768
;;;244                };
;;;245                
;;;246                m_tid_touch = osThreadNew(touch_panel_thread, (void*)core_d, &attr);
00003a  466a              MOV      r2,sp
00003c  4629              MOV      r1,r5
00003e  4808              LDR      r0,|L10.96|
000040  f7fffffe          BL       osThreadNew
;;;247    
;;;248                //osThreadSetPriority(m_tid_touch, osPriorityNormal1);
;;;249                
;;;250                set_thread_event(m_tid_touch, FLAGS_TOUCH_START_EVT);
000044  2120              MOVS     r1,#0x20
000046  60e0              STR      r0,[r4,#0xc]  ; m_tid_touch
000048  f7fffffe          BL       set_thread_event
                  |L10.76|
;;;251            }
;;;252    
;;;253            m_touch_state = TOUCH_STATE_STARTED;
00004c  2004              MOVS     r0,#4
00004e  7020              STRB     r0,[r4,#0]
;;;254            
;;;255            ret = 0;
000050  2000              MOVS     r0,#0
                  |L10.82|
;;;256        }
;;;257    
;;;258        return ret;
;;;259    }
000052  b009              ADD      sp,sp,#0x24
000054  bd30              POP      {r4,r5,pc}
;;;260    
                          ENDP

000056  0000              DCW      0x0000
                  |L10.88|
                          DCD      ||.data||+0x18
                  |L10.92|
                          DCD      ||.constdata||
                  |L10.96|
                          DCD      touch_panel_thread

                          AREA ||i.kdp520_touch_stop||, CODE, READONLY, ALIGN=2

                  kdp520_touch_stop PROC
;;;260    
;;;261    static int kdp520_touch_stop(struct core_device *core_d)
000000  b570              PUSH     {r4-r6,lr}
;;;262    {
;;;263        int ret = -KDP_FRAMEWORK_ERRNO_INVALA;
;;;264    
;;;265        struct touch_driver *touch_drv = &kdp520_touch_driver;
000002  4d0f              LDR      r5,|L11.64|
000004  4602              MOV      r2,r0                 ;262
000006  f06f0007          MVN      r0,#7                 ;263
00000a  6ca9              LDR      r1,[r5,#0x48]         ;262
00000c  2900              CMP      r1,#0                 ;262
00000e  d016              BEQ      |L11.62|
;;;266    
;;;267        //dbg_msg_touch("[%s]", __func__);
;;;268        
;;;269        if ((touch_drv) && (touch_drv->panel) && (TOUCH_STATE_STOPPED != m_touch_state)) {
000010  f1a50418          SUB      r4,r5,#0x18
000014  7823              LDRB     r3,[r4,#0]  ; m_touch_state
000016  2b02              CMP      r3,#2
000018  d011              BEQ      |L11.62|
;;;270            touch_drv->panel->stop(core_d);
00001a  68c9              LDR      r1,[r1,#0xc]
00001c  4610              MOV      r0,r2
00001e  4788              BLX      r1
;;;271    
;;;272            m_touch_state = TOUCH_STATE_STOPPED;
000020  2002              MOVS     r0,#2
000022  7020              STRB     r0,[r4,#0]
;;;273            osDelay(1);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       osDelay
;;;274            wait_event(evt_touch_ack_id, EVT_TOUCH_ACK_FLAG);
00002a  2120              MOVS     r1,#0x20
00002c  6860              LDR      r0,[r4,#4]  ; evt_touch_ack_id
00002e  f7fffffe          BL       wait_event
;;;275            //dbg_msg_touch("touch panel : driver thread end");
;;;276            
;;;277            if (touch_drv->cb_power_off)
000032  f8d50098          LDR      r0,[r5,#0x98]
000036  b100              CBZ      r0,|L11.58|
;;;278                touch_drv->cb_power_off();
000038  4780              BLX      r0
                  |L11.58|
;;;279            
;;;280            m_tid_touch = 0;
00003a  2000              MOVS     r0,#0
00003c  60e0              STR      r0,[r4,#0xc]  ; m_tid_touch
                  |L11.62|
;;;281            ret = 0;
;;;282        }
;;;283    
;;;284        return ret;
;;;285    }
00003e  bd70              POP      {r4-r6,pc}
;;;286    
                          ENDP

                  |L11.64|
                          DCD      ||.data||+0x18

                          AREA ||i.touch_panel_thread||, CODE, READONLY, ALIGN=2

                  touch_panel_thread PROC
;;;71     
;;;72     static void touch_panel_thread(void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;73     {
;;;74         int timeout_cnt = 0;
;;;75         struct core_device *core_d = (struct core_device*)arg;
000004  4607              MOV      r7,r0
;;;76         struct touch_driver *touch_drv = &kdp520_touch_driver;
000006  4838              LDR      r0,|L12.232|
000008  2600              MOVS     r6,#0                 ;74
;;;77         struct touch_panel_driver *panel = touch_drv->panel;
;;;78         
;;;79         while (1) {
;;;80             osThreadFlagsWait(FLAGS_TOUCH_START_EVT, osFlagsWaitAny, osWaitForever);
00000a  f04f38ff          MOV      r8,#0xffffffff
;;;81             osThreadFlagsClear(FLAGS_TOUCH_START_EVT);
;;;82             set_event(evt_touch_ack_id, EVT_TOUCH_ACK_FLAG);
00000e  6c85              LDR      r5,[r0,#0x48]
000010  f1a00418          SUB      r4,r0,#0x18
                  |L12.20|
000014  4642              MOV      r2,r8                 ;80
000016  2100              MOVS     r1,#0                 ;80
000018  2020              MOVS     r0,#0x20              ;80
00001a  f7fffffe          BL       osThreadFlagsWait
00001e  2020              MOVS     r0,#0x20              ;81
000020  f7fffffe          BL       osThreadFlagsClear
000024  2120              MOVS     r1,#0x20
000026  6860              LDR      r0,[r4,#4]  ; evt_touch_ack_id
000028  f7fffffe          BL       set_event
                  |L12.44|
;;;83     
;;;84             while(1)
;;;85             {
;;;86                 if (TOUCH_STATE_STARTED == m_touch_state)
00002c  7820              LDRB     r0,[r4,#0]  ; m_touch_state
00002e  2804              CMP      r0,#4
000030  d00c              BEQ      |L12.76|
;;;87                 {
;;;88                     if ((kdp520_get_int_occurred(KDP_GPIO_INT_PIN_FOR_TOUCH)) && (FALSE == stop_isr))
;;;89                     {
;;;90                         kdp520_clear_int_occurred(KDP_GPIO_INT_PIN_FOR_TOUCH);
;;;91                         panel->get_raw_data(core_d, 1);
;;;92                         panel->state_handler(core_d, &kdp520_mouse_info);
;;;93                         timeout_cnt = 0;
;;;94                         if (panel->get_active())
;;;95                             set_event(kl520_api_get_event(), KL520_APP_FLAG_TOUCH);
;;;96                         osDelay(1);
;;;97                     }
;;;98                     else
;;;99                     {
;;;100                        ++timeout_cnt;
;;;101                        if (timeout_cnt > TP_THREAD_TIMEOUT_CNT) {
;;;102                            if (panel->get_active()) {
;;;103                                panel->set_inactive();//reset touch event
;;;104                                panel->state_handler(core_d, &kdp520_mouse_info);
;;;105                                set_event(kl520_api_get_event(), KL520_APP_FLAG_TOUCH);
;;;106                            }
;;;107                            timeout_cnt = 0;
;;;108                            if (kdp520_mouse_info.state == 3) {
;;;109                                stop_isr = TRUE;
;;;110                                osDelay((OS_ROBIN_TIMEOUT * osThreadGetCount()) >> 1);
;;;111                                kdp520_clear_int_occurred(KDP_GPIO_INT_PIN_FOR_TOUCH);
;;;112                                stop_isr = FALSE;
;;;113                            } else
;;;114                                osDelay(1);
;;;115                            continue;
;;;116                        }
;;;117                        else
;;;118                        {
;;;119                            osDelay(20);
;;;120                            continue;
;;;121                        }
;;;122                    }
;;;123                }
;;;124                else {
;;;125                    set_event(evt_touch_ack_id, EVT_TOUCH_ACK_FLAG);
000032  2120              MOVS     r1,#0x20
000034  6860              LDR      r0,[r4,#4]  ; evt_touch_ack_id
000036  f7fffffe          BL       set_event
;;;126                    break;
;;;127                }
;;;128                osDelay(1);
;;;129            }
;;;130    
;;;131            if (TOUCH_STATE_IDLE == m_touch_state ||TOUCH_STATE_STOPPED == m_touch_state)
00003a  7820              LDRB     r0,[r4,#0]  ; m_touch_state
00003c  2800              CMP      r0,#0                 ;126
00003e  d051              BEQ      |L12.228|
000040  2802              CMP      r0,#2
000042  d04f              BEQ      |L12.228|
;;;132                break;
;;;133        
;;;134            osDelay(1);
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       osDelay
00004a  e7e3              B        |L12.20|
                  |L12.76|
00004c  201b              MOVS     r0,#0x1b              ;88
00004e  f7fffffe          BL       kdp520_get_int_occurred
000052  b108              CBZ      r0,|L12.88|
000054  68a0              LDR      r0,[r4,#8]            ;88  ; stop_isr
000056  b1c0              CBZ      r0,|L12.138|
                  |L12.88|
000058  1c76              ADDS     r6,r6,#1              ;88
00005a  2e05              CMP      r6,#5                 ;101
00005c  dd3e              BLE      |L12.220|
00005e  69e8              LDR      r0,[r5,#0x1c]         ;102
000060  4780              BLX      r0                    ;102
000062  b158              CBZ      r0,|L12.124|
000064  69a8              LDR      r0,[r5,#0x18]         ;103
000066  4780              BLX      r0                    ;103
000068  491f              LDR      r1,|L12.232|
00006a  696a              LDR      r2,[r5,#0x14]         ;104
00006c  3908              SUBS     r1,r1,#8              ;104
00006e  4638              MOV      r0,r7                 ;104
000070  4790              BLX      r2                    ;104
000072  f7fffffe          BL       kl520_api_get_event
000076  2108              MOVS     r1,#8                 ;105
000078  f7fffffe          BL       set_event
                  |L12.124|
00007c  481a              LDR      r0,|L12.232|
00007e  2600              MOVS     r6,#0                 ;107
000080  3808              SUBS     r0,r0,#8              ;108
000082  7800              LDRB     r0,[r0,#0]            ;108  ; kdp520_mouse_info
000084  2803              CMP      r0,#3                 ;108
000086  d01a              BEQ      |L12.190|
000088  e017              B        |L12.186|
                  |L12.138|
00008a  201b              MOVS     r0,#0x1b              ;90
00008c  f7fffffe          BL       kdp520_clear_int_occurred
000090  692a              LDR      r2,[r5,#0x10]         ;91
000092  2101              MOVS     r1,#1                 ;91
000094  4638              MOV      r0,r7                 ;91
000096  4790              BLX      r2                    ;91
000098  4913              LDR      r1,|L12.232|
00009a  696a              LDR      r2,[r5,#0x14]         ;92
00009c  3908              SUBS     r1,r1,#8              ;92
00009e  4638              MOV      r0,r7                 ;92
0000a0  4790              BLX      r2                    ;92
0000a2  69e8              LDR      r0,[r5,#0x1c]         ;94
0000a4  2600              MOVS     r6,#0                 ;93
0000a6  4780              BLX      r0                    ;94
0000a8  b120              CBZ      r0,|L12.180|
0000aa  f7fffffe          BL       kl520_api_get_event
0000ae  2108              MOVS     r1,#8                 ;95
0000b0  f7fffffe          BL       set_event
                  |L12.180|
0000b4  2001              MOVS     r0,#1                 ;96
0000b6  f7fffffe          BL       osDelay
                  |L12.186|
0000ba  2001              MOVS     r0,#1                 ;114
0000bc  e00f              B        |L12.222|
                  |L12.190|
0000be  2001              MOVS     r0,#1                 ;109
0000c0  60a0              STR      r0,[r4,#8]            ;110  ; stop_isr
0000c2  f7fffffe          BL       osThreadGetCount
0000c6  eb000080          ADD      r0,r0,r0,LSL #2       ;110
0000ca  0840              LSRS     r0,r0,#1              ;110
0000cc  f7fffffe          BL       osDelay
0000d0  201b              MOVS     r0,#0x1b              ;111
0000d2  f7fffffe          BL       kdp520_clear_int_occurred
0000d6  2000              MOVS     r0,#0                 ;112
0000d8  60a0              STR      r0,[r4,#8]            ;112  ; stop_isr
0000da  e7a7              B        |L12.44|
                  |L12.220|
0000dc  2014              MOVS     r0,#0x14              ;119
                  |L12.222|
0000de  f7fffffe          BL       osDelay
0000e2  e7a3              B        |L12.44|
                  |L12.228|
;;;135        }
;;;136    
;;;137    }
0000e4  e8bd81f0          POP      {r4-r8,pc}
;;;138    
                          ENDP

                  |L12.232|
                          DCD      ||.data||+0x18

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000300
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  m_touch_state
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  evt_touch_ack_id
                          DCD      0x00000000
                  stop_isr
                          DCD      0x00000000
                  m_tid_touch
                          DCD      0x00000000
                  kdp520_mouse_info
                          DCD      0x00000000
000014  00000000          DCB      0x00,0x00,0x00,0x00
                  kdp520_touch_driver
                          DCD      kdp520_touch_probe
                          DCD      kdp520_touch_remove
                          DCD      kdp520_touch
000024  6b647035          DCB      0x6b,0x64,0x70,0x35
000028  32305f74          DCB      0x32,0x30,0x5f,0x74
00002c  6f756368          DCB      0x6f,0x75,0x63,0x68
000030  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          %        8
                          DCD      kdp520_touch_power
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      kdp520_touch_ops
00005c  0000              DCW      0x0000
00005e  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      kdp520_touch_attach_panel
                          DCD      kdp520_touch_init
                          DCD      kdp520_touch_start
                          DCD      kdp520_touch_stop
                          DCD      kdp520_touch_is_started
                          DCD      kdp520_touch_set_hook
00007c  00000000          DCW      0x0000,0x0000
                          %        16
000090  0000              DCB      0x00,0x00
000092  0000              DCW      0x0000
                          %        16
0000a4  0000              DCB      0x00,0x00
0000a6  00f0              DCW      0x00f0
0000a8  0140              DCW      0x0140
0000aa  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||area_number.17||, DATA, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.data||
                  kdp520_touch_ops
                          DCD      _tp_gpio_set_int_stop
                          DCD      _tp_gpio_set_int_start

                          AREA ||area_number.18||, DATA, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.data||
                  touch_ctx_s
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\scpu\\drivers\\media\\platform\\kdp520_touch.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_kdp520_touch_c_795c7f5a____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___14_kdp520_touch_c_795c7f5a____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_kdp520_touch_c_795c7f5a____REVSH|
#line 223
|__asm___14_kdp520_touch_c_795c7f5a____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_kdp520_touch_c_795c7f5a____RRX|
#line 410
|__asm___14_kdp520_touch_c_795c7f5a____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
