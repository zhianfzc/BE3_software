; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\rtx_kernel.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\rtx_kernel.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\rtx_kernel.crf F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_kernel.c]
                          THUMB

                          AREA ||i.GetKernelSleepTime||, CODE, READONLY, ALIGN=2

                  GetKernelSleepTime PROC
;;;65     // Get Kernel sleep time
;;;66     static uint32_t GetKernelSleepTime (void) {
000000  4a06              LDR      r2,|L1.28|
;;;67       const os_thread_t *thread;
;;;68       const os_timer_t  *timer;
;;;69       uint32_t           delay;
;;;70     
;;;71       delay = osWaitForever;
000002  f04f30ff          MOV      r0,#0xffffffff
000006  6ad1              LDR      r1,[r2,#0x2c]         ;66  ; osRtxInfo
000008  b101              CBZ      r1,|L1.12|
;;;72     
;;;73       // Check Thread Delay list
;;;74       thread = osRtxInfo.thread.delay_list;
;;;75       if (thread != NULL) {
;;;76         delay = thread->delay;
00000a  69c8              LDR      r0,[r1,#0x1c]
                  |L1.12|
;;;77       }
;;;78     
;;;79       // Check Active Timer list
;;;80       timer = osRtxInfo.timer.list;
;;;81       if (timer != NULL) {
00000c  6c51              LDR      r1,[r2,#0x44]  ; osRtxInfo
00000e  2900              CMP      r1,#0
000010  d003              BEQ      |L1.26|
;;;82         if (timer->tick < delay) {
000012  6909              LDR      r1,[r1,#0x10]
000014  4281              CMP      r1,r0
000016  d200              BCS      |L1.26|
000018  4608              MOV      r0,r1
                  |L1.26|
;;;83           delay = timer->tick;
;;;84         }
;;;85       }
;;;86     
;;;87       return delay;
;;;88     }
00001a  4770              BX       lr
;;;89     
                          ENDP

                  |L1.28|
                          DCD      ||.data.os||

                          AREA ||i.IsException||, CODE, READONLY, ALIGN=1

                  IsException PROC
;;;122    /// \return     true=exception, false=thread
;;;123    __STATIC_INLINE bool_t IsException (void) {
000000  f3ef8005          MRS      r0,IPSR
000004  2800              CMP      r0,#0
000006  d000              BEQ      |L2.10|
;;;124      return (__get_IPSR() != 0U);
000008  2001              MOVS     r0,#1
                  |L2.10|
;;;125    }
00000a  4770              BX       lr
;;;126    
                          ENDP


                          AREA ||i.IsIrqMasked||, CODE, READONLY, ALIGN=1

                  IsIrqMasked PROC
;;;128    /// \return     true=masked, false=not masked
;;;129    __STATIC_INLINE bool_t IsIrqMasked (void) {
000000  f3ef8010          MRS      r0,PRIMASK
000004  b918              CBNZ     r0,|L3.14|
000006  f3ef8011          MRS      r0,BASEPRI
;;;130    #if   ((defined(__ARM_ARCH_7M__)        && (__ARM_ARCH_7M__        != 0)) || \
;;;131           (defined(__ARM_ARCH_7EM__)       && (__ARM_ARCH_7EM__       != 0)) || \
;;;132           (defined(__ARM_ARCH_8M_MAIN__)   && (__ARM_ARCH_8M_MAIN__   != 0)) || \
;;;133           (defined(__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ != 0)))
;;;134      return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L3.16|
                  |L3.14|
00000e  2001              MOVS     r0,#1
                  |L3.16|
;;;135    #else
;;;136      return  (__get_PRIMASK() != 0U);
;;;137    #endif
;;;138    }
000010  4770              BX       lr
;;;139    
                          ENDP


                          AREA ||i.osKernelGetInfo||, CODE, READONLY, ALIGN=2

                  osKernelGetInfo PROC
;;;541    ///  Get RTOS Kernel Information.
;;;542    osStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size) {
000000  b570              PUSH     {r4-r6,lr}
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;543      osStatus_t status;
;;;544    
;;;545      EvrRtxKernelGetInfo(version, id_buf, id_size);
000008  f7fffffe          BL       EvrRtxKernelGetInfo
;;;546      if (IsException() || IsIrqMasked() || IsPrivileged()) {
00000c  f7fffffe          BL       IsException
000010  b940              CBNZ     r0,|L4.36|
000012  f7fffffe          BL       IsIrqMasked
000016  b928              CBNZ     r0,|L4.36|
000018  f3ef8014          MRS      r0,CONTROL
00001c  f3400000          SBFX     r0,r0,#0,#1
000020  1c40              ADDS     r0,r0,#1
000022  d006              BEQ      |L4.50|
                  |L4.36|
;;;547        status = svcRtxKernelGetInfo(version, id_buf, id_size);
000024  4622              MOV      r2,r4
000026  4629              MOV      r1,r5
000028  4630              MOV      r0,r6
00002a  e8bd4070          POP      {r4-r6,lr}
00002e  f7ffbffe          B.W      svcRtxKernelGetInfo
                  |L4.50|
;;;548      } else {
;;;549        status =  __svcKernelGetInfo(version, id_buf, id_size);
000032  4630              MOV      r0,r6
000034  4629              MOV      r1,r5
000036  4622              MOV      r2,r4
000038  f8dfc004          LDR      r12,|L4.64|
00003c  df00              SVC      #0x0
;;;550      }
;;;551      return status;
;;;552    }
00003e  bd70              POP      {r4-r6,pc}
;;;553    
                          ENDP

                  |L4.64|
                          DCD      svcRtxKernelGetInfo

                          AREA ||i.osKernelGetState||, CODE, READONLY, ALIGN=2

                  osKernelGetState PROC
;;;554    /// Get the current RTOS Kernel state.
;;;555    osKernelState_t osKernelGetState (void) {
000000  b510              PUSH     {r4,lr}
;;;556      osKernelState_t state;
;;;557    
;;;558      if (IsException() || IsIrqMasked() || IsPrivileged()) {
000002  f7fffffe          BL       IsException
000006  b940              CBNZ     r0,|L5.26|
000008  f7fffffe          BL       IsIrqMasked
00000c  b928              CBNZ     r0,|L5.26|
00000e  f3ef8014          MRS      r0,CONTROL
000012  f3400000          SBFX     r0,r0,#0,#1
000016  1c40              ADDS     r0,r0,#1
000018  d003              BEQ      |L5.34|
                  |L5.26|
;;;559        state = svcRtxKernelGetState();
00001a  e8bd4010          POP      {r4,lr}
00001e  f7ffbffe          B.W      svcRtxKernelGetState
                  |L5.34|
000022  f8dfc008          LDR      r12,|L5.44|
000026  df00              SVC      #0x0
;;;560      } else {
;;;561        state =  __svcKernelGetState();
;;;562      }
;;;563      return state;
;;;564    }
000028  bd10              POP      {r4,pc}
;;;565    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      svcRtxKernelGetState

                          AREA ||i.osKernelGetSysTimerCount||, CODE, READONLY, ALIGN=2

                  osKernelGetSysTimerCount PROC
;;;671    /// Get the RTOS kernel system timer count.
;;;672    uint32_t osKernelGetSysTimerCount (void) {
000000  b510              PUSH     {r4,lr}
;;;673      uint32_t count;
;;;674    
;;;675      if (IsException() || IsIrqMasked()) {
000002  f7fffffe          BL       IsException
000006  b910              CBNZ     r0,|L6.14|
000008  f7fffffe          BL       IsIrqMasked
00000c  b118              CBZ      r0,|L6.22|
                  |L6.14|
;;;676        count = svcRtxKernelGetSysTimerCount();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      svcRtxKernelGetSysTimerCount
                  |L6.22|
000016  f8dfc008          LDR      r12,|L6.32|
00001a  df00              SVC      #0x0
;;;677      } else {
;;;678        count =  __svcKernelGetSysTimerCount();
;;;679      }
;;;680      return count;
;;;681    }
00001c  bd10              POP      {r4,pc}
;;;682    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      svcRtxKernelGetSysTimerCount

                          AREA ||i.osKernelGetSysTimerFreq||, CODE, READONLY, ALIGN=2

                  osKernelGetSysTimerFreq PROC
;;;683    /// Get the RTOS kernel system timer frequency.
;;;684    uint32_t osKernelGetSysTimerFreq (void) {
000000  b510              PUSH     {r4,lr}
;;;685      uint32_t freq;
;;;686    
;;;687      if (IsException() || IsIrqMasked()) {
000002  f7fffffe          BL       IsException
000006  b910              CBNZ     r0,|L7.14|
000008  f7fffffe          BL       IsIrqMasked
00000c  b118              CBZ      r0,|L7.22|
                  |L7.14|
;;;688        freq = svcRtxKernelGetSysTimerFreq();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      svcRtxKernelGetSysTimerFreq
                  |L7.22|
000016  f8dfc008          LDR      r12,|L7.32|
00001a  df00              SVC      #0x0
;;;689      } else {
;;;690        freq =  __svcKernelGetSysTimerFreq();
;;;691      }
;;;692      return freq;
;;;693    }
00001c  bd10              POP      {r4,pc}
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      svcRtxKernelGetSysTimerFreq

                          AREA ||i.osKernelGetTickCount||, CODE, READONLY, ALIGN=2

                  osKernelGetTickCount PROC
;;;647    /// Get the RTOS kernel tick count.
;;;648    uint32_t osKernelGetTickCount (void) {
000000  b510              PUSH     {r4,lr}
;;;649      uint32_t count;
;;;650    
;;;651      if (IsException() || IsIrqMasked()) {
000002  f7fffffe          BL       IsException
000006  b910              CBNZ     r0,|L8.14|
000008  f7fffffe          BL       IsIrqMasked
00000c  b118              CBZ      r0,|L8.22|
                  |L8.14|
;;;652        count = svcRtxKernelGetTickCount();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      svcRtxKernelGetTickCount
                  |L8.22|
000016  f8dfc008          LDR      r12,|L8.32|
00001a  df00              SVC      #0x0
;;;653      } else {
;;;654        count =  __svcKernelGetTickCount();
;;;655      }
;;;656      return count;
;;;657    }
00001c  bd10              POP      {r4,pc}
;;;658    
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      svcRtxKernelGetTickCount

                          AREA ||i.osKernelGetTickFreq||, CODE, READONLY, ALIGN=2

                  osKernelGetTickFreq PROC
;;;659    /// Get the RTOS kernel tick frequency.
;;;660    uint32_t osKernelGetTickFreq (void) {
000000  b510              PUSH     {r4,lr}
;;;661      uint32_t freq;
;;;662    
;;;663      if (IsException() || IsIrqMasked()) {
000002  f7fffffe          BL       IsException
000006  b910              CBNZ     r0,|L9.14|
000008  f7fffffe          BL       IsIrqMasked
00000c  b118              CBZ      r0,|L9.22|
                  |L9.14|
;;;664        freq = svcRtxKernelGetTickFreq();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      svcRtxKernelGetTickFreq
                  |L9.22|
000016  f8dfc008          LDR      r12,|L9.32|
00001a  df00              SVC      #0x0
;;;665      } else {
;;;666        freq =  __svcKernelGetTickFreq();
;;;667      }
;;;668      return freq;
;;;669    }
00001c  bd10              POP      {r4,pc}
;;;670    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      svcRtxKernelGetTickFreq

                          AREA ||i.osKernelInitialize||, CODE, READONLY, ALIGN=2

                  osKernelInitialize PROC
;;;526    /// Initialize the RTOS Kernel.
;;;527    osStatus_t osKernelInitialize (void) {
000000  b510              PUSH     {r4,lr}
;;;528      osStatus_t status;
;;;529    
;;;530      osRtxKernelPreInit();
000002  f7fffffe          BL       osRtxKernelPreInit
;;;531      EvrRtxKernelInitialize();
000006  f7fffffe          BL       EvrRtxKernelInitialize
;;;532      if (IsException() || IsIrqMasked()) {
00000a  f7fffffe          BL       IsException
00000e  b910              CBNZ     r0,|L10.22|
000010  f7fffffe          BL       IsIrqMasked
000014  b130              CBZ      r0,|L10.36|
                  |L10.22|
;;;533        EvrRtxKernelError((int32_t)osErrorISR);
000016  f06f0405          MVN      r4,#5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxKernelError
;;;534        status = osErrorISR;
000020  4620              MOV      r0,r4
;;;535      } else {
;;;536        status = __svcKernelInitialize();
;;;537      }
;;;538      return status;
;;;539    }
000022  bd10              POP      {r4,pc}
                  |L10.36|
000024  f8dfc004          LDR      r12,|L10.44|
000028  df00              SVC      #0x0
00002a  bd10              POP      {r4,pc}
;;;540    
                          ENDP

                  |L10.44|
                          DCD      svcRtxKernelInitialize

                          AREA ||i.osKernelLock||, CODE, READONLY, ALIGN=2

                  osKernelLock PROC
;;;580    /// Lock the RTOS Kernel scheduler.
;;;581    int32_t osKernelLock (void) {
000000  b510              PUSH     {r4,lr}
;;;582      int32_t lock;
;;;583    
;;;584      EvrRtxKernelLock();
000002  f7fffffe          BL       EvrRtxKernelLock
;;;585      if (IsException() || IsIrqMasked()) {
000006  f7fffffe          BL       IsException
00000a  b910              CBNZ     r0,|L11.18|
00000c  f7fffffe          BL       IsIrqMasked
000010  b130              CBZ      r0,|L11.32|
                  |L11.18|
;;;586        EvrRtxKernelError((int32_t)osErrorISR);
000012  f06f0405          MVN      r4,#5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       EvrRtxKernelError
;;;587        lock = (int32_t)osErrorISR;
00001c  4620              MOV      r0,r4
;;;588      } else {
;;;589        lock = __svcKernelLock();
;;;590      }
;;;591      return lock;
;;;592    }
00001e  bd10              POP      {r4,pc}
                  |L11.32|
000020  f8dfc004          LDR      r12,|L11.40|
000024  df00              SVC      #0x0
000026  bd10              POP      {r4,pc}
;;;593    
                          ENDP

                  |L11.40|
                          DCD      svcRtxKernelLock

                          AREA ||i.osKernelRestoreLock||, CODE, READONLY, ALIGN=2

                  osKernelRestoreLock PROC
;;;608    /// Restore the RTOS Kernel scheduler lock state.
;;;609    int32_t osKernelRestoreLock (int32_t lock) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;610      int32_t lock_new;
;;;611    
;;;612      EvrRtxKernelRestoreLock(lock);
000004  f7fffffe          BL       EvrRtxKernelRestoreLock
;;;613      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L12.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b130              CBZ      r0,|L12.34|
                  |L12.20|
;;;614        EvrRtxKernelError((int32_t)osErrorISR);
000014  f06f0405          MVN      r4,#5
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       EvrRtxKernelError
;;;615        lock_new = (int32_t)osErrorISR;
00001e  4620              MOV      r0,r4
;;;616      } else {
;;;617        lock_new = __svcKernelRestoreLock(lock);
;;;618      }
;;;619      return lock_new;
;;;620    }
000020  bd10              POP      {r4,pc}
                  |L12.34|
000022  4620              MOV      r0,r4                 ;617
000024  f8dfc004          LDR      r12,|L12.44|
000028  df00              SVC      #0x0                  ;617
00002a  bd10              POP      {r4,pc}
;;;621    
                          ENDP

                  |L12.44|
                          DCD      svcRtxKernelRestoreLock

                          AREA ||i.osKernelResume||, CODE, READONLY, ALIGN=2

                  osKernelResume PROC
;;;636    /// Resume the RTOS Kernel scheduler.
;;;637    void osKernelResume (uint32_t sleep_ticks) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;638    
;;;639      EvrRtxKernelResume(sleep_ticks);
000004  f7fffffe          BL       EvrRtxKernelResume
;;;640      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L13.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b128              CBZ      r0,|L13.32|
                  |L13.20|
;;;641        EvrRtxKernelError((int32_t)osErrorISR);
000014  e8bd4010          POP      {r4,lr}
000018  f06f0005          MVN      r0,#5
00001c  f7ffbffe          B.W      EvrRtxKernelError
                  |L13.32|
;;;642      } else {
;;;643        __svcKernelResume(sleep_ticks);
000020  4620              MOV      r0,r4
000022  f8dfc008          LDR      r12,|L13.44|
000026  df00              SVC      #0x0
;;;644      }
;;;645    }
000028  bd10              POP      {r4,pc}
;;;646    
                          ENDP

00002a  0000              DCW      0x0000
                  |L13.44|
                          DCD      svcRtxKernelResume

                          AREA ||i.osKernelStart||, CODE, READONLY, ALIGN=2

                  osKernelStart PROC
;;;566    /// Start the RTOS Kernel scheduler.
;;;567    osStatus_t osKernelStart (void) {
000000  b510              PUSH     {r4,lr}
;;;568      osStatus_t status;
;;;569    
;;;570      EvrRtxKernelStart();
000002  f7fffffe          BL       EvrRtxKernelStart
;;;571      if (IsException() || IsIrqMasked()) {
000006  f7fffffe          BL       IsException
00000a  b910              CBNZ     r0,|L14.18|
00000c  f7fffffe          BL       IsIrqMasked
000010  b130              CBZ      r0,|L14.32|
                  |L14.18|
;;;572        EvrRtxKernelError((int32_t)osErrorISR);
000012  f06f0405          MVN      r4,#5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       EvrRtxKernelError
;;;573        status = osErrorISR;
00001c  4620              MOV      r0,r4
;;;574      } else {
;;;575        status = __svcKernelStart();
;;;576      }
;;;577      return status;
;;;578    }
00001e  bd10              POP      {r4,pc}
                  |L14.32|
000020  f8dfc004          LDR      r12,|L14.40|
000024  df00              SVC      #0x0
000026  bd10              POP      {r4,pc}
;;;579    
                          ENDP

                  |L14.40|
                          DCD      svcRtxKernelStart

                          AREA ||i.osKernelSuspend||, CODE, READONLY, ALIGN=2

                  osKernelSuspend PROC
;;;622    /// Suspend the RTOS Kernel scheduler.
;;;623    uint32_t osKernelSuspend (void) {
000000  b510              PUSH     {r4,lr}
;;;624      uint32_t ticks;
;;;625    
;;;626      EvrRtxKernelSuspend();
000002  f7fffffe          BL       EvrRtxKernelSuspend
;;;627      if (IsException() || IsIrqMasked()) {
000006  f7fffffe          BL       IsException
00000a  b910              CBNZ     r0,|L15.18|
00000c  f7fffffe          BL       IsIrqMasked
000010  b128              CBZ      r0,|L15.30|
                  |L15.18|
;;;628        EvrRtxKernelError((int32_t)osErrorISR);
000012  f06f0005          MVN      r0,#5
000016  f7fffffe          BL       EvrRtxKernelError
;;;629        ticks = 0U;
00001a  2000              MOVS     r0,#0
;;;630      } else {
;;;631        ticks = __svcKernelSuspend();
;;;632      }
;;;633      return ticks;
;;;634    }
00001c  bd10              POP      {r4,pc}
                  |L15.30|
00001e  f8dfc008          LDR      r12,|L15.40|
000022  df00              SVC      #0x0
000024  bd10              POP      {r4,pc}
;;;635    
                          ENDP

000026  0000              DCW      0x0000
                  |L15.40|
                          DCD      svcRtxKernelSuspend

                          AREA ||i.osKernelUnlock||, CODE, READONLY, ALIGN=2

                  osKernelUnlock PROC
;;;594    /// Unlock the RTOS Kernel scheduler.
;;;595    int32_t osKernelUnlock (void) {
000000  b510              PUSH     {r4,lr}
;;;596      int32_t lock;
;;;597    
;;;598      EvrRtxKernelUnlock();
000002  f7fffffe          BL       EvrRtxKernelUnlock
;;;599      if (IsException() || IsIrqMasked()) {
000006  f7fffffe          BL       IsException
00000a  b910              CBNZ     r0,|L16.18|
00000c  f7fffffe          BL       IsIrqMasked
000010  b130              CBZ      r0,|L16.32|
                  |L16.18|
;;;600        EvrRtxKernelError((int32_t)osErrorISR);
000012  f06f0405          MVN      r4,#5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       EvrRtxKernelError
;;;601        lock = (int32_t)osErrorISR;
00001c  4620              MOV      r0,r4
;;;602      } else {
;;;603        lock = __svcKernelUnlock();
;;;604      }
;;;605      return lock;
;;;606    }
00001e  bd10              POP      {r4,pc}
                  |L16.32|
000020  f8dfc004          LDR      r12,|L16.40|
000024  df00              SVC      #0x0
000026  bd10              POP      {r4,pc}
;;;607    
                          ENDP

                  |L16.40|
                          DCD      svcRtxKernelUnlock

                          AREA ||i.osRtxKernelErrorNotify||, CODE, READONLY, ALIGN=1

                  osRtxKernelErrorNotify PROC
;;;517    /// \note API identical to osRtxErrorNotify
;;;518    uint32_t osRtxKernelErrorNotify (uint32_t code, void *object_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;519      EvrRtxKernelErrorNotify(code, object_id);
000006  f7fffffe          BL       EvrRtxKernelErrorNotify
;;;520      return osRtxErrorNotify(code, object_id);
00000a  4621              MOV      r1,r4
00000c  4628              MOV      r0,r5
00000e  e8bd4070          POP      {r4-r6,lr}
000012  f7ffbffe          B.W      osRtxErrorNotify
;;;521    }
;;;522    
                          ENDP


                          AREA ||i.osRtxKernelPreInit||, CODE, READONLY, ALIGN=1

                  osRtxKernelPreInit PROC
;;;512    //lint -esym(522,osRtxKernelPreInit) "Can be overridden (do not lack side-effects)"
;;;513    __WEAK void osRtxKernelPreInit (void) {
000000  4770              BX       lr
;;;514    }
;;;515    
                          ENDP


                          AREA ||i.svcRtxKernelGetInfo||, CODE, READONLY, ALIGN=2

                  svcRtxKernelGetInfo PROC
;;;210    /// \note API identical to osKernelGetInfo
;;;211    static osStatus_t svcRtxKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size) {
000000  b570              PUSH     {r4-r6,lr}
000002  460e              MOV      r6,r1
000004  0005              MOVS     r5,r0
000006  4614              MOV      r4,r2
000008  d003              BEQ      |L19.18|
;;;212      uint32_t size;
;;;213    
;;;214      if (version != NULL) {
;;;215        version->api    = osRtxVersionAPI;
00000a  480a              LDR      r0,|L19.52|
;;;216        version->kernel = osRtxVersionKernel;
00000c  6028              STR      r0,[r5,#0]
00000e  480a              LDR      r0,|L19.56|
000010  6068              STR      r0,[r5,#4]
                  |L19.18|
;;;217      }
;;;218    
;;;219      if ((id_buf != NULL) && (id_size != 0U)) {
000012  b13e              CBZ      r6,|L19.36|
000014  b134              CBZ      r4,|L19.36|
;;;220        if (id_size > sizeof(osRtxKernelId)) {
000016  2c0b              CMP      r4,#0xb
000018  d900              BLS      |L19.28|
;;;221          size = sizeof(osRtxKernelId);
00001a  220b              MOVS     r2,#0xb
                  |L19.28|
;;;222        } else {
;;;223          size = id_size;
;;;224        }
;;;225        (void)memcpy(id_buf, osRtxKernelId, size);
00001c  a107              ADR      r1,|L19.60|
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       __aeabi_memcpy
                  |L19.36|
;;;226      }
;;;227    
;;;228      EvrRtxKernelInfoRetrieved(version, id_buf, id_size);
000024  4622              MOV      r2,r4
000026  4631              MOV      r1,r6
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       EvrRtxKernelInfoRetrieved
;;;229    
;;;230      return osOK;
00002e  2000              MOVS     r0,#0
;;;231    }
000030  bd70              POP      {r4-r6,pc}
;;;232    
                          ENDP

000032  0000              DCW      0x0000
                  |L19.52|
                          DCD      0x01315413
                  |L19.56|
                          DCD      0x02fbb3d4
                  |L19.60|
00003c  52545820          DCB      "RTX V5.5.4",0
000040  56352e35
000044  2e3400  
000047  00                DCB      0

                          AREA ||i.svcRtxKernelGetState||, CODE, READONLY, ALIGN=2

                  svcRtxKernelGetState PROC
;;;234    /// \note API identical to osKernelGetState
;;;235    static osKernelState_t svcRtxKernelGetState (void) {
000000  4803              LDR      r0,|L20.16|
000002  b510              PUSH     {r4,lr}
000004  7a04              LDRB     r4,[r0,#8]  ; osRtxInfo
;;;236      osKernelState_t state = osRtxKernelState();
;;;237      EvrRtxKernelGetState(state);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       EvrRtxKernelGetState
;;;238      return state;
00000c  4620              MOV      r0,r4
;;;239    }
00000e  bd10              POP      {r4,pc}
;;;240    
                          ENDP

                  |L20.16|
                          DCD      ||.data.os||

                          AREA ||i.svcRtxKernelGetSysTimerCount||, CODE, READONLY, ALIGN=2

                  svcRtxKernelGetSysTimerCount PROC
;;;465    /// \note API identical to osKernelGetSysTimerCount
;;;466    static uint32_t svcRtxKernelGetSysTimerCount (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;467      uint32_t tick;
;;;468      uint32_t count;
;;;469    
;;;470      tick  = (uint32_t)osRtxInfo.kernel.tick;
000002  480a              LDR      r0,|L21.44|
;;;471      count = OS_Tick_GetCount();
000004  68c4              LDR      r4,[r0,#0xc]  ; osRtxInfo
000006  f7fffffe          BL       OS_Tick_GetCount
00000a  4605              MOV      r5,r0
;;;472      if (OS_Tick_GetOverflow() != 0U) {
00000c  f7fffffe          BL       OS_Tick_GetOverflow
000010  b118              CBZ      r0,|L21.26|
;;;473        count = OS_Tick_GetCount();
000012  f7fffffe          BL       OS_Tick_GetCount
000016  4605              MOV      r5,r0
000018  1c64              ADDS     r4,r4,#1
                  |L21.26|
;;;474        tick++;
;;;475      }
;;;476      count += tick * OS_Tick_GetInterval();
00001a  f7fffffe          BL       OS_Tick_GetInterval
00001e  fb045400          MLA      r4,r4,r0,r5
;;;477      EvrRtxKernelGetSysTimerCount(count);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       EvrRtxKernelGetSysTimerCount
;;;478      return count;
000028  4620              MOV      r0,r4
;;;479    }
00002a  bd70              POP      {r4-r6,pc}
;;;480    
                          ENDP

                  |L21.44|
                          DCD      ||.data.os||

                          AREA ||i.svcRtxKernelGetSysTimerFreq||, CODE, READONLY, ALIGN=1

                  svcRtxKernelGetSysTimerFreq PROC
;;;482    /// \note API identical to osKernelGetSysTimerFreq
;;;483    static uint32_t svcRtxKernelGetSysTimerFreq (void) {
000000  b510              PUSH     {r4,lr}
;;;484      uint32_t freq = OS_Tick_GetClock();
000002  f7fffffe          BL       OS_Tick_GetClock
000006  4604              MOV      r4,r0
;;;485      EvrRtxKernelGetSysTimerFreq(freq);
000008  f7fffffe          BL       EvrRtxKernelGetSysTimerFreq
;;;486      return freq;
00000c  4620              MOV      r0,r4
;;;487    }
00000e  bd10              POP      {r4,pc}
;;;488    
                          ENDP


                          AREA ||i.svcRtxKernelGetTickCount||, CODE, READONLY, ALIGN=2

                  svcRtxKernelGetTickCount PROC
;;;451    /// \note API identical to osKernelGetTickCount
;;;452    static uint32_t svcRtxKernelGetTickCount (void) {
000000  b510              PUSH     {r4,lr}
;;;453      EvrRtxKernelGetTickCount(osRtxInfo.kernel.tick);
000002  4c03              LDR      r4,|L23.16|
000004  68e0              LDR      r0,[r4,#0xc]  ; osRtxInfo
000006  f7fffffe          BL       EvrRtxKernelGetTickCount
;;;454      return osRtxInfo.kernel.tick;
00000a  68e0              LDR      r0,[r4,#0xc]  ; osRtxInfo
;;;455    }
00000c  bd10              POP      {r4,pc}
;;;456    
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      ||.data.os||

                          AREA ||i.svcRtxKernelGetTickFreq||, CODE, READONLY, ALIGN=2

                  svcRtxKernelGetTickFreq PROC
;;;458    /// \note API identical to osKernelGetTickFreq
;;;459    static uint32_t svcRtxKernelGetTickFreq (void) {
000000  b510              PUSH     {r4,lr}
;;;460      EvrRtxKernelGetTickFreq(osRtxConfig.tick_freq);
000002  4c03              LDR      r4,|L24.16|
000004  6860              LDR      r0,[r4,#4]  ; osRtxConfig
000006  f7fffffe          BL       EvrRtxKernelGetTickFreq
;;;461      return osRtxConfig.tick_freq;
00000a  6860              LDR      r0,[r4,#4]  ; osRtxConfig
;;;462    }
00000c  bd10              POP      {r4,pc}
;;;463    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      osRtxConfig

                          AREA ||i.svcRtxKernelInitialize||, CODE, READONLY, ALIGN=2

                  svcRtxKernelInitialize PROC
;;;94     /// \note API identical to osKernelInitialize
;;;95     static osStatus_t svcRtxKernelInitialize (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;96     
;;;97       if (osRtxInfo.kernel.state == osRtxKernelReady) {
000002  4d48              LDR      r5,|L25.292|
000004  7a28              LDRB     r0,[r5,#8]  ; osRtxInfo
000006  2801              CMP      r0,#1
000008  d007              BEQ      |L25.26|
;;;98         EvrRtxKernelInitialized();
;;;99         //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;100        return osOK;
;;;101      }
;;;102      if (osRtxInfo.kernel.state != osRtxKernelInactive) {
00000a  b150              CBZ      r0,|L25.34|
;;;103        EvrRtxKernelError((int32_t)osError);
00000c  f04f34ff          MOV      r4,#0xffffffff
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       EvrRtxKernelError
;;;104        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;105        return osError;
000016  4620              MOV      r0,r4
;;;106      }
;;;107    
;;;108    #if (DOMAIN_NS == 1)
;;;109      // Initialize Secure Process Stack
;;;110      if (TZ_InitContextSystem_S() == 0U) {
;;;111        EvrRtxKernelError(osRtxErrorTZ_InitContext_S);
;;;112        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;113        return osError;
;;;114      }
;;;115    #endif
;;;116    
;;;117      // Initialize osRtxInfo
;;;118    
;;;119      osRtxInfo.isr_queue.data = osRtxConfig.isr_queue.data;
;;;120      osRtxInfo.isr_queue.max  = osRtxConfig.isr_queue.max;
;;;121    
;;;122      osRtxInfo.thread.robin.timeout = osRtxConfig.robin_timeout;
;;;123    
;;;124      // Initialize Memory Pools (Variable Block Size)
;;;125      if (osRtxMemoryInit(osRtxConfig.mem.common_addr, osRtxConfig.mem.common_size) != 0U) {
;;;126        osRtxInfo.mem.common = osRtxConfig.mem.common_addr;
;;;127      }
;;;128      if (osRtxMemoryInit(osRtxConfig.mem.stack_addr, osRtxConfig.mem.stack_size) != 0U) {
;;;129        osRtxInfo.mem.stack = osRtxConfig.mem.stack_addr;
;;;130      } else {
;;;131        osRtxInfo.mem.stack = osRtxInfo.mem.common;
;;;132      }
;;;133      if (osRtxMemoryInit(osRtxConfig.mem.mp_data_addr, osRtxConfig.mem.mp_data_size) != 0U) {
;;;134        osRtxInfo.mem.mp_data = osRtxConfig.mem.mp_data_addr;
;;;135      } else {
;;;136        osRtxInfo.mem.mp_data = osRtxInfo.mem.common;
;;;137      }
;;;138      if (osRtxMemoryInit(osRtxConfig.mem.mq_data_addr, osRtxConfig.mem.mq_data_size) != 0U) {
;;;139        osRtxInfo.mem.mq_data = osRtxConfig.mem.mq_data_addr;
;;;140      } else {
;;;141        osRtxInfo.mem.mq_data = osRtxInfo.mem.common;
;;;142      }
;;;143    
;;;144      // Initialize Memory Pools (Fixed Block Size)
;;;145      if (osRtxConfig.mpi.stack != NULL) {
;;;146        (void)osRtxMemoryPoolInit(osRtxConfig.mpi.stack,
;;;147                                  osRtxConfig.mpi.stack->max_blocks,
;;;148                                  osRtxConfig.mpi.stack->block_size,
;;;149                                  osRtxConfig.mpi.stack->block_base);
;;;150        osRtxInfo.mpi.stack = osRtxConfig.mpi.stack;
;;;151      }
;;;152      if (osRtxConfig.mpi.thread != NULL) {
;;;153        (void)osRtxMemoryPoolInit(osRtxConfig.mpi.thread,
;;;154                                  osRtxConfig.mpi.thread->max_blocks,
;;;155                                  osRtxConfig.mpi.thread->block_size,
;;;156                                  osRtxConfig.mpi.thread->block_base);
;;;157        osRtxInfo.mpi.thread = osRtxConfig.mpi.thread;
;;;158      }
;;;159      if (osRtxConfig.mpi.timer != NULL) {
;;;160        (void)osRtxMemoryPoolInit(osRtxConfig.mpi.timer,
;;;161                                  osRtxConfig.mpi.timer->max_blocks,
;;;162                                  osRtxConfig.mpi.timer->block_size,
;;;163                                  osRtxConfig.mpi.timer->block_base);
;;;164        osRtxInfo.mpi.timer = osRtxConfig.mpi.timer;
;;;165      }
;;;166      if (osRtxConfig.mpi.event_flags != NULL) {
;;;167        (void)osRtxMemoryPoolInit(osRtxConfig.mpi.event_flags,
;;;168                                  osRtxConfig.mpi.event_flags->max_blocks,
;;;169                                  osRtxConfig.mpi.event_flags->block_size,
;;;170                                  osRtxConfig.mpi.event_flags->block_base);
;;;171        osRtxInfo.mpi.event_flags = osRtxConfig.mpi.event_flags;
;;;172      }
;;;173      if (osRtxConfig.mpi.mutex != NULL) {
;;;174        (void)osRtxMemoryPoolInit(osRtxConfig.mpi.mutex,
;;;175                                  osRtxConfig.mpi.mutex->max_blocks,
;;;176                                  osRtxConfig.mpi.mutex->block_size,
;;;177                                  osRtxConfig.mpi.mutex->block_base);
;;;178        osRtxInfo.mpi.mutex = osRtxConfig.mpi.mutex;
;;;179      }
;;;180      if (osRtxConfig.mpi.semaphore != NULL) {
;;;181        (void)osRtxMemoryPoolInit(osRtxConfig.mpi.semaphore,
;;;182                                  osRtxConfig.mpi.semaphore->max_blocks,
;;;183                                  osRtxConfig.mpi.semaphore->block_size,
;;;184                                  osRtxConfig.mpi.semaphore->block_base);
;;;185        osRtxInfo.mpi.semaphore = osRtxConfig.mpi.semaphore;
;;;186      }
;;;187      if (osRtxConfig.mpi.memory_pool != NULL) {
;;;188        (void)osRtxMemoryPoolInit(osRtxConfig.mpi.memory_pool,
;;;189                                  osRtxConfig.mpi.memory_pool->max_blocks,
;;;190                                  osRtxConfig.mpi.memory_pool->block_size,
;;;191                                  osRtxConfig.mpi.memory_pool->block_base);
;;;192        osRtxInfo.mpi.memory_pool = osRtxConfig.mpi.memory_pool;
;;;193      }
;;;194      if (osRtxConfig.mpi.message_queue != NULL) {
;;;195        (void)osRtxMemoryPoolInit(osRtxConfig.mpi.message_queue,
;;;196                                  osRtxConfig.mpi.message_queue->max_blocks,
;;;197                                  osRtxConfig.mpi.message_queue->block_size,
;;;198                                  osRtxConfig.mpi.message_queue->block_base);
;;;199        osRtxInfo.mpi.message_queue = osRtxConfig.mpi.message_queue;
;;;200      }
;;;201    
;;;202      osRtxInfo.kernel.state = osRtxKernelReady;
;;;203    
;;;204      EvrRtxKernelInitialized();
;;;205    
;;;206      return osOK;
;;;207    }
000018  bd70              POP      {r4-r6,pc}
                  |L25.26|
00001a  f7fffffe          BL       EvrRtxKernelInitialized
00001e  2000              MOVS     r0,#0                 ;100
000020  bd70              POP      {r4-r6,pc}
                  |L25.34|
000022  4c41              LDR      r4,|L25.296|
000024  68e0              LDR      r0,[r4,#0xc]          ;119  ; osRtxConfig
000026  65e8              STR      r0,[r5,#0x5c]         ;120  ; osRtxInfo
000028  8a20              LDRH     r0,[r4,#0x10]         ;120  ; osRtxConfig
00002a  f8a50054          STRH     r0,[r5,#0x54]         ;120
00002e  68a0              LDR      r0,[r4,#8]            ;122  ; osRtxConfig
000030  6428              STR      r0,[r5,#0x40]         ;122  ; osRtxInfo
000032  e9d4010b          LDRD     r0,r1,[r4,#0x2c]      ;122
000036  f7fffffe          BL       osRtxMemoryInit
00003a  b110              CBZ      r0,|L25.66|
00003c  6ae0              LDR      r0,[r4,#0x2c]         ;126  ; osRtxConfig
00003e  f8c50080          STR      r0,[r5,#0x80]         ;126  ; osRtxInfo
                  |L25.66|
000042  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;126
000046  f7fffffe          BL       osRtxMemoryInit
00004a  b108              CBZ      r0,|L25.80|
00004c  6960              LDR      r0,[r4,#0x14]         ;129  ; osRtxConfig
00004e  e001              B        |L25.84|
                  |L25.80|
000050  f8d50080          LDR      r0,[r5,#0x80]         ;131  ; osRtxInfo
                  |L25.84|
000054  6768              STR      r0,[r5,#0x74]         ;131  ; osRtxInfo
000056  e9d40107          LDRD     r0,r1,[r4,#0x1c]      ;131
00005a  f7fffffe          BL       osRtxMemoryInit
00005e  b108              CBZ      r0,|L25.100|
000060  69e0              LDR      r0,[r4,#0x1c]         ;134  ; osRtxConfig
000062  e001              B        |L25.104|
                  |L25.100|
000064  f8d50080          LDR      r0,[r5,#0x80]         ;136  ; osRtxInfo
                  |L25.104|
000068  67a8              STR      r0,[r5,#0x78]         ;136  ; osRtxInfo
00006a  e9d40109          LDRD     r0,r1,[r4,#0x24]      ;136
00006e  f7fffffe          BL       osRtxMemoryInit
000072  b108              CBZ      r0,|L25.120|
000074  6a60              LDR      r0,[r4,#0x24]         ;139  ; osRtxConfig
000076  e001              B        |L25.124|
                  |L25.120|
000078  f8d50080          LDR      r0,[r5,#0x80]         ;141  ; osRtxInfo
                  |L25.124|
00007c  67e8              STR      r0,[r5,#0x7c]         ;145  ; osRtxInfo
00007e  6b60              LDR      r0,[r4,#0x34]         ;145  ; osRtxConfig
000080  b138              CBZ      r0,|L25.146|
000082  e9d02302          LDRD     r2,r3,[r0,#8]         ;146
000086  6801              LDR      r1,[r0,#0]            ;146
000088  f7fffffe          BL       osRtxMemoryPoolInit
00008c  6b60              LDR      r0,[r4,#0x34]         ;150  ; osRtxConfig
00008e  f8c50084          STR      r0,[r5,#0x84]         ;150  ; osRtxInfo
                  |L25.146|
000092  6ba0              LDR      r0,[r4,#0x38]         ;152  ; osRtxConfig
000094  b138              CBZ      r0,|L25.166|
000096  e9d02302          LDRD     r2,r3,[r0,#8]         ;153
00009a  6801              LDR      r1,[r0,#0]            ;153
00009c  f7fffffe          BL       osRtxMemoryPoolInit
0000a0  6ba0              LDR      r0,[r4,#0x38]         ;157  ; osRtxConfig
0000a2  f8c50088          STR      r0,[r5,#0x88]         ;157  ; osRtxInfo
                  |L25.166|
0000a6  6be0              LDR      r0,[r4,#0x3c]         ;159  ; osRtxConfig
0000a8  b138              CBZ      r0,|L25.186|
0000aa  e9d02302          LDRD     r2,r3,[r0,#8]         ;160
0000ae  6801              LDR      r1,[r0,#0]            ;160
0000b0  f7fffffe          BL       osRtxMemoryPoolInit
0000b4  6be0              LDR      r0,[r4,#0x3c]         ;164  ; osRtxConfig
0000b6  f8c5008c          STR      r0,[r5,#0x8c]         ;164  ; osRtxInfo
                  |L25.186|
0000ba  6c20              LDR      r0,[r4,#0x40]         ;166  ; osRtxConfig
0000bc  b138              CBZ      r0,|L25.206|
0000be  e9d02302          LDRD     r2,r3,[r0,#8]         ;167
0000c2  6801              LDR      r1,[r0,#0]            ;167
0000c4  f7fffffe          BL       osRtxMemoryPoolInit
0000c8  6c20              LDR      r0,[r4,#0x40]         ;171  ; osRtxConfig
0000ca  f8c50090          STR      r0,[r5,#0x90]         ;171  ; osRtxInfo
                  |L25.206|
0000ce  6c60              LDR      r0,[r4,#0x44]         ;173  ; osRtxConfig
0000d0  b138              CBZ      r0,|L25.226|
0000d2  e9d02302          LDRD     r2,r3,[r0,#8]         ;174
0000d6  6801              LDR      r1,[r0,#0]            ;174
0000d8  f7fffffe          BL       osRtxMemoryPoolInit
0000dc  6c60              LDR      r0,[r4,#0x44]         ;178  ; osRtxConfig
0000de  f8c50094          STR      r0,[r5,#0x94]         ;178  ; osRtxInfo
                  |L25.226|
0000e2  6ca0              LDR      r0,[r4,#0x48]         ;180  ; osRtxConfig
0000e4  b138              CBZ      r0,|L25.246|
0000e6  e9d02302          LDRD     r2,r3,[r0,#8]         ;181
0000ea  6801              LDR      r1,[r0,#0]            ;181
0000ec  f7fffffe          BL       osRtxMemoryPoolInit
0000f0  6ca0              LDR      r0,[r4,#0x48]         ;185  ; osRtxConfig
0000f2  f8c50098          STR      r0,[r5,#0x98]         ;185  ; osRtxInfo
                  |L25.246|
0000f6  6ce0              LDR      r0,[r4,#0x4c]         ;187  ; osRtxConfig
0000f8  b138              CBZ      r0,|L25.266|
0000fa  e9d02302          LDRD     r2,r3,[r0,#8]         ;188
0000fe  6801              LDR      r1,[r0,#0]            ;188
000100  f7fffffe          BL       osRtxMemoryPoolInit
000104  6ce0              LDR      r0,[r4,#0x4c]         ;192  ; osRtxConfig
000106  f8c5009c          STR      r0,[r5,#0x9c]         ;192  ; osRtxInfo
                  |L25.266|
00010a  6d20              LDR      r0,[r4,#0x50]         ;194  ; osRtxConfig
00010c  b138              CBZ      r0,|L25.286|
00010e  e9d02302          LDRD     r2,r3,[r0,#8]         ;195
000112  6801              LDR      r1,[r0,#0]            ;195
000114  f7fffffe          BL       osRtxMemoryPoolInit
000118  6d20              LDR      r0,[r4,#0x50]         ;199  ; osRtxConfig
00011a  f8c500a0          STR      r0,[r5,#0xa0]         ;199  ; osRtxInfo
                  |L25.286|
00011e  2001              MOVS     r0,#1                 ;202
000120  7228              STRB     r0,[r5,#8]            ;202
000122  e77a              B        |L25.26|
;;;208    
                          ENDP

                  |L25.292|
                          DCD      ||.data.os||
                  |L25.296|
                          DCD      osRtxConfig

                          AREA ||i.svcRtxKernelLock||, CODE, READONLY, ALIGN=2

                  svcRtxKernelLock PROC
;;;293    /// \note API identical to osKernelLock
;;;294    static int32_t svcRtxKernelLock (void) {
000000  480c              LDR      r0,|L26.52|
000002  b510              PUSH     {r4,lr}
;;;295      int32_t lock;
;;;296    
;;;297      switch (osRtxInfo.kernel.state) {
000004  7a01              LDRB     r1,[r0,#8]  ; osRtxInfo
000006  2902              CMP      r1,#2
000008  d008              BEQ      |L26.28|
00000a  2903              CMP      r1,#3
00000c  d00d              BEQ      |L26.42|
;;;298        case osRtxKernelRunning:
;;;299          osRtxInfo.kernel.state = osRtxKernelLocked;
;;;300          EvrRtxKernelLocked(0);
;;;301          lock = 0;
;;;302          break;
;;;303        case osRtxKernelLocked:
;;;304          EvrRtxKernelLocked(1);
;;;305          lock = 1;
;;;306          break;
;;;307        default:
;;;308          EvrRtxKernelError((int32_t)osError);
00000e  f04f34ff          MOV      r4,#0xffffffff
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxKernelError
;;;309          lock = (int32_t)osError;
000018  4620              MOV      r0,r4
;;;310          break;
;;;311      }
;;;312      return lock;
;;;313    }
00001a  bd10              POP      {r4,pc}
                  |L26.28|
00001c  2103              MOVS     r1,#3                 ;299
00001e  7201              STRB     r1,[r0,#8]            ;299
000020  2000              MOVS     r0,#0                 ;300
000022  f7fffffe          BL       EvrRtxKernelLocked
000026  2000              MOVS     r0,#0                 ;301
000028  bd10              POP      {r4,pc}
                  |L26.42|
00002a  2001              MOVS     r0,#1                 ;304
00002c  f7fffffe          BL       EvrRtxKernelLocked
000030  2001              MOVS     r0,#1                 ;305
000032  bd10              POP      {r4,pc}
;;;314    
                          ENDP

                  |L26.52|
                          DCD      ||.data.os||

                          AREA ||i.svcRtxKernelRestoreLock||, CODE, READONLY, ALIGN=2

                  svcRtxKernelRestoreLock PROC
;;;339    /// \note API identical to osKernelRestoreLock
;;;340    static int32_t svcRtxKernelRestoreLock (int32_t lock) {
000000  490f              LDR      r1,|L27.64|
000002  b510              PUSH     {r4,lr}
;;;341      int32_t lock_new;
;;;342    
;;;343      switch (osRtxInfo.kernel.state) {
000004  7a0a              LDRB     r2,[r1,#8]  ; osRtxInfo
;;;344        case osRtxKernelRunning:
;;;345        case osRtxKernelLocked:
;;;346          switch (lock) {
;;;347            case 0:
;;;348              osRtxInfo.kernel.state = osRtxKernelRunning;
;;;349              EvrRtxKernelLockRestored(0);
;;;350              lock_new = 0;
;;;351              break;
;;;352            case 1:
;;;353              osRtxInfo.kernel.state = osRtxKernelLocked;
;;;354              EvrRtxKernelLockRestored(1);
;;;355              lock_new = 1;
;;;356              break;
;;;357            default:
;;;358              EvrRtxKernelError((int32_t)osError);
000006  f04f34ff          MOV      r4,#0xffffffff
00000a  2a02              CMP      r2,#2                 ;343
00000c  d001              BEQ      |L27.18|
00000e  2a03              CMP      r2,#3                 ;343
000010  d102              BNE      |L27.24|
                  |L27.18|
000012  b130              CBZ      r0,|L27.34|
000014  2801              CMP      r0,#1                 ;346
000016  d00b              BEQ      |L27.48|
                  |L27.24|
;;;359              lock_new = (int32_t)osError;
;;;360              break;
;;;361          }
;;;362          break;
;;;363        default:
;;;364          EvrRtxKernelError((int32_t)osError);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       EvrRtxKernelError
;;;365          lock_new = (int32_t)osError;
00001e  4620              MOV      r0,r4
;;;366          break;
;;;367      }
;;;368      return lock_new;
;;;369    }
000020  bd10              POP      {r4,pc}
                  |L27.34|
000022  2002              MOVS     r0,#2                 ;348
000024  7208              STRB     r0,[r1,#8]            ;348
000026  2000              MOVS     r0,#0                 ;349
000028  f7fffffe          BL       EvrRtxKernelLockRestored
00002c  2000              MOVS     r0,#0                 ;350
00002e  bd10              POP      {r4,pc}
                  |L27.48|
000030  2003              MOVS     r0,#3                 ;353
000032  7208              STRB     r0,[r1,#8]            ;353
000034  2001              MOVS     r0,#1                 ;354
000036  f7fffffe          BL       EvrRtxKernelLockRestored
00003a  2001              MOVS     r0,#1                 ;355
00003c  bd10              POP      {r4,pc}
;;;370    
                          ENDP

00003e  0000              DCW      0x0000
                  |L27.64|
                          DCD      ||.data.os||

                          AREA ||i.svcRtxKernelResume||, CODE, READONLY, ALIGN=2

                  svcRtxKernelResume PROC
;;;394    /// \note API identical to osKernelResume
;;;395    static void svcRtxKernelResume (uint32_t sleep_ticks) {
000000  b570              PUSH     {r4-r6,lr}
;;;396      os_thread_t *thread;
;;;397      os_timer_t  *timer;
;;;398      uint32_t     delay;
;;;399      uint32_t     ticks, kernel_tick;
;;;400    
;;;401      if (osRtxInfo.kernel.state != osRtxKernelSuspended) {
000002  4c1e              LDR      r4,|L28.124|
000004  4605              MOV      r5,r0                 ;395
000006  7a20              LDRB     r0,[r4,#8]  ; osRtxInfo
000008  2804              CMP      r0,#4
00000a  d003              BEQ      |L28.20|
                  |L28.12|
;;;402        EvrRtxKernelResumed();
00000c  e8bd4070          POP      {r4-r6,lr}
000010  f7ffbffe          B.W      EvrRtxKernelResumed
                  |L28.20|
;;;403        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;404        return;
;;;405      }
;;;406    
;;;407      delay = GetKernelSleepTime();
000014  f7fffffe          BL       GetKernelSleepTime
;;;408      if (sleep_ticks >= delay) {
000018  4285              CMP      r5,r0
00001a  d301              BCC      |L28.32|
00001c  1e40              SUBS     r0,r0,#1
;;;409        ticks = delay - 1U;
00001e  e000              B        |L28.34|
                  |L28.32|
;;;410      } else {
;;;411        ticks = sleep_ticks;
000020  4628              MOV      r0,r5
                  |L28.34|
;;;412      }
;;;413    
;;;414      // Update Thread Delay sleep ticks
;;;415      thread = osRtxInfo.thread.delay_list;
;;;416      if (thread != NULL) {
000022  6ae1              LDR      r1,[r4,#0x2c]  ; osRtxInfo
000024  b111              CBZ      r1,|L28.44|
;;;417        thread->delay -= ticks;
000026  69ca              LDR      r2,[r1,#0x1c]
000028  1a12              SUBS     r2,r2,r0
00002a  61ca              STR      r2,[r1,#0x1c]
                  |L28.44|
;;;418      }
;;;419    
;;;420      // Update Timer sleep ticks
;;;421      timer = osRtxInfo.timer.list;
;;;422      if (timer != NULL) {
00002c  6c61              LDR      r1,[r4,#0x44]  ; osRtxInfo
00002e  b111              CBZ      r1,|L28.54|
;;;423        timer->tick -= ticks;
000030  690a              LDR      r2,[r1,#0x10]
000032  1a12              SUBS     r2,r2,r0
000034  610a              STR      r2,[r1,#0x10]
                  |L28.54|
;;;424      }
;;;425    
;;;426      kernel_tick = osRtxInfo.kernel.tick + sleep_ticks;
000036  68e1              LDR      r1,[r4,#0xc]  ; osRtxInfo
;;;427      osRtxInfo.kernel.tick += ticks;
000038  4408              ADD      r0,r0,r1
00003a  440d              ADD      r5,r5,r1              ;426
;;;428    
;;;429      while (osRtxInfo.kernel.tick != kernel_tick) {
00003c  60e0              STR      r0,[r4,#0xc]  ; osRtxInfo
00003e  e006              B        |L28.78|
                  |L28.64|
000040  1c40              ADDS     r0,r0,#1
;;;430        osRtxInfo.kernel.tick++;
;;;431    
;;;432        // Process Thread Delays
;;;433        osRtxThreadDelayTick();
000042  60e0              STR      r0,[r4,#0xc]  ; osRtxInfo
000044  f7fffffe          BL       osRtxThreadDelayTick
;;;434    
;;;435        // Process Timers
;;;436        if (osRtxInfo.timer.tick != NULL) {
000048  6d20              LDR      r0,[r4,#0x50]  ; osRtxInfo
00004a  b100              CBZ      r0,|L28.78|
;;;437          osRtxInfo.timer.tick();
00004c  4780              BLX      r0
                  |L28.78|
00004e  68e0              LDR      r0,[r4,#0xc]          ;429  ; osRtxInfo
000050  42a8              CMP      r0,r5                 ;429
000052  d1f5              BNE      |L28.64|
;;;438        }
;;;439      }
;;;440    
;;;441      osRtxInfo.kernel.state = osRtxKernelRunning;
000054  2002              MOVS     r0,#2
000056  7220              STRB     r0,[r4,#8]
;;;442    
;;;443      osRtxThreadDispatch(NULL);
000058  2000              MOVS     r0,#0
00005a  f7fffffe          BL       osRtxThreadDispatch
00005e  2000              MOVS     r0,#0
000060  7260              STRB     r0,[r4,#9]
000062  f3bf8f4f          DSB      
000066  7aa1              LDRB     r1,[r4,#0xa]  ; osRtxInfo
000068  b121              CBZ      r1,|L28.116|
00006a  4905              LDR      r1,|L28.128|
00006c  72a0              STRB     r0,[r4,#0xa]
00006e  f04f5080          MOV      r0,#0x10000000
000072  6008              STR      r0,[r1,#0]
                  |L28.116|
000074  f7fffffe          BL       OS_Tick_Enable
;;;444    
;;;445      KernelUnblock();
;;;446    
;;;447      EvrRtxKernelResumed();
;;;448    }
000078  e7c8              B        |L28.12|
;;;449    
                          ENDP

00007a  0000              DCW      0x0000
                  |L28.124|
                          DCD      ||.data.os||
                  |L28.128|
                          DCD      0xe000ed04

                          AREA ||i.svcRtxKernelStart||, CODE, READONLY, ALIGN=2

                  svcRtxKernelStart PROC
;;;242    /// \note API identical to osKernelStart
;;;243    static osStatus_t svcRtxKernelStart (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;244      os_thread_t *thread;
;;;245    
;;;246      if (osRtxInfo.kernel.state != osRtxKernelReady) {
000002  4d24              LDR      r5,|L29.148|
;;;247        EvrRtxKernelError(osRtxErrorKernelNotReady);
;;;248        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;249        return osError;
000004  f04f34ff          MOV      r4,#0xffffffff
000008  7a28              LDRB     r0,[r5,#8]            ;246  ; osRtxInfo
00000a  2801              CMP      r0,#1                 ;246
00000c  d001              BEQ      |L29.18|
00000e  1fa0              SUBS     r0,r4,#6              ;247
000010  e021              B        |L29.86|
                  |L29.18|
;;;250      }
;;;251    
;;;252      // Thread startup (Idle and Timer Thread)
;;;253      if (!osRtxThreadStartup()) {
000012  f7fffffe          BL       osRtxThreadStartup
000016  b1e8              CBZ      r0,|L29.84|
000018  481f              LDR      r0,|L29.152|
00001a  21ff              MOVS     r1,#0xff
00001c  7001              STRB     r1,[r0,#0]
00001e  7800              LDRB     r0,[r0,#0]
000020  f06000ff          ORN      r0,r0,#0xff
000024  43c0              MVNS     r0,r0
000026  fab0f080          CLZ      r0,r0
00002a  f1c00120          RSB      r1,r0,#0x20
00002e  481a              LDR      r0,|L29.152|
000030  3816              SUBS     r0,r0,#0x16
000032  6800              LDR      r0,[r0,#0]
000034  f3c02202          UBFX     r2,r0,#8,#3
000038  428a              CMP      r2,r1
00003a  d300              BCC      |L29.62|
00003c  1c51              ADDS     r1,r2,#1
                  |L29.62|
00003e  20fe              MOVS     r0,#0xfe
000040  4088              LSLS     r0,r0,r1
000042  4915              LDR      r1,|L29.152|
000044  1ec9              SUBS     r1,r1,#3
000046  7008              STRB     r0,[r1,#0]
;;;254        EvrRtxKernelError((int32_t)osError);
;;;255        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;256        return osError;
;;;257      }
;;;258    
;;;259      // Setup SVC and PendSV System Service Calls
;;;260      SVC_Setup();
;;;261    
;;;262      // Setup RTOS Tick
;;;263      if (OS_Tick_Setup(osRtxConfig.tick_freq, OS_TICK_HANDLER) != 0) {
000048  4e14              LDR      r6,|L29.156|
00004a  4915              LDR      r1,|L29.160|
00004c  6870              LDR      r0,[r6,#4]  ; osRtxConfig
00004e  f7fffffe          BL       OS_Tick_Setup
000052  b120              CBZ      r0,|L29.94|
                  |L29.84|
;;;264        EvrRtxKernelError((int32_t)osError);
000054  4620              MOV      r0,r4
                  |L29.86|
000056  f7fffffe          BL       EvrRtxKernelError
;;;265        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;266        return osError;
00005a  4620              MOV      r0,r4
;;;267      }
;;;268      osRtxInfo.tick_irqn = OS_Tick_GetIRQn();
;;;269    
;;;270      // Enable RTOS Tick
;;;271      OS_Tick_Enable();
;;;272    
;;;273      // Switch to Ready Thread with highest Priority
;;;274      thread = osRtxThreadListGet(&osRtxInfo.thread.ready);
;;;275      osRtxThreadSwitch(thread);
;;;276    
;;;277      if ((osRtxConfig.flags & osRtxConfigPrivilegedMode) != 0U) {
;;;278        // Privileged Thread mode & PSP
;;;279        __set_CONTROL(0x02U);
;;;280      } else {
;;;281        // Unprivileged Thread mode & PSP
;;;282        __set_CONTROL(0x03U);
;;;283      }
;;;284    
;;;285      osRtxInfo.kernel.state = osRtxKernelRunning;
;;;286    
;;;287      EvrRtxKernelStarted();
;;;288    
;;;289      return osOK;
;;;290    }
00005c  bd70              POP      {r4-r6,pc}
                  |L29.94|
00005e  f7fffffe          BL       OS_Tick_GetIRQn
000062  6128              STR      r0,[r5,#0x10]         ;271  ; osRtxInfo
000064  f7fffffe          BL       OS_Tick_Enable
000068  480a              LDR      r0,|L29.148|
00006a  301c              ADDS     r0,r0,#0x1c           ;274
00006c  f7fffffe          BL       osRtxThreadListGet
000070  f7fffffe          BL       osRtxThreadSwitch
000074  7830              LDRB     r0,[r6,#0]            ;277  ; osRtxConfig
000076  07c0              LSLS     r0,r0,#31             ;277
000078  d001              BEQ      |L29.126|
00007a  2002              MOVS     r0,#2                 ;279
00007c  e000              B        |L29.128|
                  |L29.126|
00007e  2003              MOVS     r0,#3                 ;282
                  |L29.128|
000080  f3808814          MSR      CONTROL,r0            ;282
000084  f3bf8f6f          ISB                            ;282
000088  2002              MOVS     r0,#2                 ;285
00008a  7228              STRB     r0,[r5,#8]            ;285
00008c  f7fffffe          BL       EvrRtxKernelStarted
000090  2000              MOVS     r0,#0                 ;289
000092  bd70              POP      {r4-r6,pc}
;;;291    
                          ENDP

                  |L29.148|
                          DCD      ||.data.os||
                  |L29.152|
                          DCD      0xe000ed22
                  |L29.156|
                          DCD      osRtxConfig
                  |L29.160|
                          DCD      SysTick_Handler

                          AREA ||i.svcRtxKernelSuspend||, CODE, READONLY, ALIGN=2

                  svcRtxKernelSuspend PROC
;;;372    /// \note API identical to osKernelSuspend
;;;373    static uint32_t svcRtxKernelSuspend (void) {
000000  b510              PUSH     {r4,lr}
;;;374      uint32_t delay;
;;;375    
;;;376      if (osRtxInfo.kernel.state != osRtxKernelRunning) {
000002  4c10              LDR      r4,|L30.68|
000004  7a20              LDRB     r0,[r4,#8]  ; osRtxInfo
000006  2802              CMP      r0,#2
000008  d005              BEQ      |L30.22|
;;;377        EvrRtxKernelError(osRtxErrorKernelNotRunning);
00000a  f06f0007          MVN      r0,#7
00000e  f7fffffe          BL       EvrRtxKernelError
;;;378        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;379        return 0U;
000012  2000              MOVS     r0,#0
;;;380      }
;;;381    
;;;382      KernelBlock();
;;;383    
;;;384      osRtxInfo.kernel.state = osRtxKernelSuspended;
;;;385    
;;;386      delay = GetKernelSleepTime();
;;;387    
;;;388      EvrRtxKernelSuspended(delay);
;;;389    
;;;390      return delay;
;;;391    }
000014  bd10              POP      {r4,pc}
                  |L30.22|
000016  f7fffffe          BL       OS_Tick_Disable
00001a  2001              MOVS     r0,#1
00001c  7260              STRB     r0,[r4,#9]
00001e  f3bf8f4f          DSB      
000022  4909              LDR      r1,|L30.72|
000024  680a              LDR      r2,[r1,#0]
000026  f0125f80          TST      r2,#0x10000000
00002a  d002              BEQ      |L30.50|
00002c  06c2              LSLS     r2,r0,#27
00002e  600a              STR      r2,[r1,#0]
000030  72a0              STRB     r0,[r4,#0xa]
                  |L30.50|
000032  2004              MOVS     r0,#4                 ;384
000034  7220              STRB     r0,[r4,#8]            ;384
000036  f7fffffe          BL       GetKernelSleepTime
00003a  4604              MOV      r4,r0                 ;386
00003c  f7fffffe          BL       EvrRtxKernelSuspended
000040  4620              MOV      r0,r4                 ;390
000042  bd10              POP      {r4,pc}
;;;392    
                          ENDP

                  |L30.68|
                          DCD      ||.data.os||
                  |L30.72|
                          DCD      0xe000ed04

                          AREA ||i.svcRtxKernelUnlock||, CODE, READONLY, ALIGN=2

                  svcRtxKernelUnlock PROC
;;;316    /// \note API identical to osKernelUnlock
;;;317    static int32_t svcRtxKernelUnlock (void) {
000000  480c              LDR      r0,|L31.52|
000002  b510              PUSH     {r4,lr}
;;;318      int32_t lock;
;;;319    
;;;320      switch (osRtxInfo.kernel.state) {
000004  7a01              LDRB     r1,[r0,#8]  ; osRtxInfo
000006  2902              CMP      r1,#2
000008  d008              BEQ      |L31.28|
00000a  2903              CMP      r1,#3
00000c  d00b              BEQ      |L31.38|
;;;321        case osRtxKernelRunning:
;;;322          EvrRtxKernelUnlocked(0);
;;;323          lock = 0;
;;;324          break;
;;;325        case osRtxKernelLocked:
;;;326          osRtxInfo.kernel.state = osRtxKernelRunning;
;;;327          EvrRtxKernelUnlocked(1);
;;;328          lock = 1;
;;;329          break;
;;;330        default:
;;;331          EvrRtxKernelError((int32_t)osError);
00000e  f04f34ff          MOV      r4,#0xffffffff
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxKernelError
;;;332          lock = (int32_t)osError;
000018  4620              MOV      r0,r4
;;;333          break;
;;;334      }
;;;335      return lock;
;;;336    }
00001a  bd10              POP      {r4,pc}
                  |L31.28|
00001c  2000              MOVS     r0,#0                 ;322
00001e  f7fffffe          BL       EvrRtxKernelUnlocked
000022  2000              MOVS     r0,#0                 ;323
000024  bd10              POP      {r4,pc}
                  |L31.38|
000026  2102              MOVS     r1,#2                 ;326
000028  7201              STRB     r1,[r0,#8]            ;326
00002a  2001              MOVS     r0,#1                 ;327
00002c  f7fffffe          BL       EvrRtxKernelUnlocked
000030  2001              MOVS     r0,#1                 ;328
000032  bd10              POP      {r4,pc}
;;;337    
                          ENDP

                  |L31.52|
                          DCD      ||.data.os||

                          AREA ||.conststrlit||, DATA, READONLY, ALIGN=2

000000  52545820          DCB      0x52,0x54,0x58,0x20
000004  56352e35          DCB      0x56,0x35,0x2e,0x35
000008  2e3400            DCB      0x2e,0x34,0x00

                          AREA ||.data.os||, DATA, ALIGN=2

                  osRtxInfo
                          DCD      ||.conststrlit||
                          DCD      0x02fbb3d4
000008  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          %        144

;*** Start embedded assembler ***

#line 1 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___12_rtx_kernel_c_e0a8919a____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a____REVSH|
#line 223
|__asm___12_rtx_kernel_c_e0a8919a____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a____RRX|
#line 410
|__asm___12_rtx_kernel_c_e0a8919a____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_wr8|
#line 464 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_core_cm.h"
|__asm___12_rtx_kernel_c_e0a8919a__atomic_wr8| PROC
#line 464

 mov r2,r0
1
 ldrexb r0,[r2]
 strexb r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_set32|
#line 511
|__asm___12_rtx_kernel_c_e0a8919a__atomic_set32| PROC
#line 511

 mov r2,r0
1
 ldrex r0,[r2]
 orr r0,r0,r1
 strex r3,r0,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_clr32|
#line 570
|__asm___12_rtx_kernel_c_e0a8919a__atomic_clr32| PROC
#line 570

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F2
 b %B1
2
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_chk32_all|
#line 630
|__asm___12_rtx_kernel_c_e0a8919a__atomic_chk32_all| PROC
#line 630

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 and r4,r0,r1
 cmp r4,r1
 beq %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_chk32_any|
#line 705
|__asm___12_rtx_kernel_c_e0a8919a__atomic_chk32_any| PROC
#line 705

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 tst r0,r1
 bne %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_inc32|
#line 772
|__asm___12_rtx_kernel_c_e0a8919a__atomic_inc32| PROC
#line 772

 mov r2,r0
1
 ldrex r0,[r2]
 adds r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_inc16_lt|
#line 821
|__asm___12_rtx_kernel_c_e0a8919a__atomic_inc16_lt| PROC
#line 821

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 cmp r1,r0
 bhi %F2
 clrex
 pop {r4,pc}
2
 adds r4,r0,#1
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_inc16_lim|
#line 882
|__asm___12_rtx_kernel_c_e0a8919a__atomic_inc16_lim| PROC
#line 882

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 adds r4,r0,#1
 cmp r1,r4
 bhi %F2
 movs r4,#0
2
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_dec32|
#line 940
|__asm___12_rtx_kernel_c_e0a8919a__atomic_dec32| PROC
#line 940

 mov r2,r0
1
 ldrex r0,[r2]
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_dec32_nz|
#line 988
|__asm___12_rtx_kernel_c_e0a8919a__atomic_dec32_nz| PROC
#line 988

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_dec16_nz|
#line 1044
|__asm___12_rtx_kernel_c_e0a8919a__atomic_dec16_nz| PROC
#line 1044

 mov r2,r0
1
 ldrexh r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strexh r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_link_get|
#line 1100
|__asm___12_rtx_kernel_c_e0a8919a__atomic_link_get| PROC
#line 1100

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 ldr r1,[r0]
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_kernel_c_e0a8919a__atomic_link_put|
#line 1156
|__asm___12_rtx_kernel_c_e0a8919a__atomic_link_put| PROC
#line 1156

1
 ldr r2,[r0]
 str r2,[r1]
 dmb
 ldrex r2,[r0]
 ldr r3,[r1]
 cmp r3,r2
 bne %B1
 strex r3,r1,[r0]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP

;*** End   embedded assembler ***
