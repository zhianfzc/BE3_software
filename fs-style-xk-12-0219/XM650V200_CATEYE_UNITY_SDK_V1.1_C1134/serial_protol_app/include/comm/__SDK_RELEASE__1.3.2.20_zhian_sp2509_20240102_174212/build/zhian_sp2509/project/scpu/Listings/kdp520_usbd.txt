; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\kdp520_usbd.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\kdp520_usbd.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\kdp520_usbd.crf ..\..\..\..\scpu\drivers\src\kdp520_usbd.c]
                          THUMB

                          AREA ||i.__NVIC_DisableIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_DisableIRQ PROC
;;;1721    */
;;;1722   __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1723   {
000002  db0d              BLT      |L1.32|
;;;1724     if ((int32_t)(IRQn) >= 0)
;;;1725     {
;;;1726       NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01180          STR      r1,[r0,#0x180]
;;;1727       __DSB();
000018  f3bf8f4f          DSB      
;;;1728       __ISB();
00001c  f3bf8f6f          ISB      
                  |L1.32|
;;;1729     }
;;;1730   }
000020  4770              BX       lr
;;;1731   
                          ENDP


                          AREA ||i.__NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_EnableIRQ PROC
;;;1683    */
;;;1684   __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1685   {
000002  db09              BLT      |L2.24|
;;;1686     if ((int32_t)(IRQn) >= 0)
;;;1687     {
;;;1688       __COMPILER_BARRIER();
;;;1689       NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01100          STR      r1,[r0,#0x100]
                  |L2.24|
;;;1690       __COMPILER_BARRIER();
;;;1691     }
;;;1692   }
000018  4770              BX       lr
;;;1693   
                          ENDP


                          AREA ||i.bulk_in_send||, CODE, READONLY, ALIGN=2

                  bulk_in_send PROC
;;;1323   
;;;1324   static kdrv_status_t bulk_in_send(uint32_t endpoint, uint32_t *buf, uint32_t txLen, int8_t isBlockingCall)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1325   {
000004  461f              MOV      r7,r3
000006  4616              MOV      r6,r2
000008  4688              MOV      r8,r1
;;;1326       FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
00000a  4c20              LDR      r4,|L3.140|
;;;1327   
;;;1328       // find out which FIFO no for the IN endpoint address
;;;1329       int8_t fno = endpoint_to_fifo(endpoint);
00000c  f7fffffe          BL       endpoint_to_fifo
000010  4605              MOV      r5,r0
;;;1330   
;;;1331       // below do some error checking
;;;1332       {
;;;1333           if (fno == -1)
000012  1c40              ADDS     r0,r0,#1
000014  d009              BEQ      |L3.42|
;;;1334               return KDRV_STATUS_USBD_INVALID_ENDPOINT;
;;;1335   
;;;1336           if (fifo_cb[fno].transferType != TXFER_BULK)
000016  eb050085          ADD      r0,r5,r5,LSL #2
00001a  eb0404c0          ADD      r4,r4,r0,LSL #3
00001e  7b20              LDRB     r0,[r4,#0xc]
000020  2802              CMP      r0,#2
000022  d004              BEQ      |L3.46|
;;;1337               return KDRV_STATUS_USBD_INVALID_TRANSFER;
000024  2008              MOVS     r0,#8
                  |L3.38|
;;;1338   
;;;1339           if (fifo_cb[fno].isTransferring)
;;;1340               return KDRV_STATUS_USBD_TRANSFER_IN_PROGRESS;
;;;1341       }
;;;1342   
;;;1343       // set up fifo cb
;;;1344       fifo_cb[fno].isTransferring = true;
;;;1345       fifo_cb[fno].user_buf_addr = dma_remap_addr((uint32_t)buf);
;;;1346       fifo_cb[fno].user_buf_len = txLen;
;;;1347       // check if need to send a zero-length packet at the end of transfer
;;;1348       fifo_cb[fno].short_or_zl_packet = ((txLen & (fifo_cb[fno].maxPacketSize - 1)) == 0) ? true : false;
;;;1349       fifo_cb[fno].isBlockingCall = isBlockingCall;
;;;1350   
;;;1351   	// there is a risk of race condition with IRQ when different endponts are working
;;;1352       NVIC_DisableIRQ(OTG_SBS_3_IRQ);
;;;1353   	{
;;;1354   
;;;1355   	    // reset FIFO content before transmission
;;;1356   	    UsbRegMaskedSet(fifo_cb[fno].byteCntReg, FFRST);
;;;1357   
;;;1358   	    // enable (unmask) the FIFO IN interrupt
;;;1359   	    UsbRegMaskedClr(REG_DEV_MISG1, MF0_IN_INT << fno);
;;;1360   
;;;1361       }
;;;1362   	NVIC_EnableIRQ(OTG_SBS_3_IRQ);
;;;1363   
;;;1364       // now leave and let interrupt handler do the transfer work
;;;1365   
;;;1366       return KDRV_STATUS_OK;
;;;1367   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L3.42|
00002a  2006              MOVS     r0,#6                 ;1334
00002c  e7fb              B        |L3.38|
                  |L3.46|
00002e  7d20              LDRB     r0,[r4,#0x14]         ;1339
000030  b108              CBZ      r0,|L3.54|
000032  2009              MOVS     r0,#9                 ;1340
000034  e7f7              B        |L3.38|
                  |L3.54|
000036  2001              MOVS     r0,#1                 ;1344
000038  7520              STRB     r0,[r4,#0x14]         ;1344
00003a  4640              MOV      r0,r8                 ;1345
00003c  f7fffffe          BL       dma_remap_addr
000040  e9c40606          STRD     r0,r6,[r4,#0x18]      ;1345
000044  68a0              LDR      r0,[r4,#8]            ;1348
000046  1e40              SUBS     r0,r0,#1              ;1348
000048  4230              TST      r0,r6                 ;1348
00004a  d101              BNE      |L3.80|
00004c  2001              MOVS     r0,#1                 ;1348
00004e  e000              B        |L3.82|
                  |L3.80|
000050  2000              MOVS     r0,#0                 ;1348
                  |L3.82|
000052  f8840024          STRB     r0,[r4,#0x24]         ;1348
000056  f8847025          STRB     r7,[r4,#0x25]         ;1349
00005a  2023              MOVS     r0,#0x23              ;1352
00005c  3410              ADDS     r4,r4,#0x10           ;1352
00005e  f7fffffe          BL       __NVIC_DisableIRQ
000062  480b              LDR      r0,|L3.144|
000064  6821              LDR      r1,[r4,#0]            ;1356
000066  4401              ADD      r1,r1,r0              ;1356
000068  680a              LDR      r2,[r1,#0]            ;1356
00006a  f4425280          ORR      r2,r2,#0x1000         ;1356
00006e  600a              STR      r2,[r1,#0]            ;1356
000070  f8d01138          LDR      r1,[r0,#0x138]        ;1359
000074  f44f3280          MOV      r2,#0x10000           ;1359
000078  40aa              LSLS     r2,r2,r5              ;1359
00007a  4391              BICS     r1,r1,r2              ;1359
00007c  f8c01138          STR      r1,[r0,#0x138]        ;1359
000080  2023              MOVS     r0,#0x23              ;1362
000082  f7fffffe          BL       __NVIC_EnableIRQ
000086  2000              MOVS     r0,#0                 ;1366
000088  e7cd              B        |L3.38|
;;;1368   
                          ENDP

00008a  0000              DCW      0x0000
                  |L3.140|
                          DCD      ||.bss||+0x20
                  |L3.144|
                          DCD      0xc0100000

                          AREA ||i.bulk_out_receive||, CODE, READONLY, ALIGN=2

                  bulk_out_receive PROC
;;;1368   
;;;1369   static kdrv_status_t bulk_out_receive(uint32_t endpoint, uint32_t *buf, uint32_t blen, int8_t isBlockingCall)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1370   {
000004  461e              MOV      r6,r3
000006  4690              MOV      r8,r2
000008  4689              MOV      r9,r1
;;;1371       FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
00000a  4c18              LDR      r4,|L4.108|
;;;1372   
;;;1373       // find out which FIFO no for the IN endpoint address
;;;1374       int8_t fno = endpoint_to_fifo(endpoint);
00000c  f7fffffe          BL       endpoint_to_fifo
000010  4605              MOV      r5,r0
;;;1375   
;;;1376       // below do some error checking
;;;1377       {
;;;1378           if (fno == -1)
000012  1c40              ADDS     r0,r0,#1
000014  d009              BEQ      |L4.42|
;;;1379               return KDRV_STATUS_USBD_INVALID_ENDPOINT;
;;;1380   
;;;1381           if (fifo_cb[fno].transferType != TXFER_BULK)
000016  eb050085          ADD      r0,r5,r5,LSL #2
00001a  eb0404c0          ADD      r4,r4,r0,LSL #3
00001e  7b20              LDRB     r0,[r4,#0xc]
000020  2802              CMP      r0,#2
000022  d004              BEQ      |L4.46|
;;;1382               return KDRV_STATUS_USBD_INVALID_TRANSFER;
000024  2008              MOVS     r0,#8
                  |L4.38|
;;;1383   
;;;1384           if (fifo_cb[fno].isTransferring)
;;;1385               return KDRV_STATUS_USBD_TRANSFER_IN_PROGRESS;
;;;1386       }
;;;1387   
;;;1388       // set up fifo cb
;;;1389       fifo_cb[fno].isTransferring = true;
;;;1390       fifo_cb[fno].user_buf_addr = dma_remap_addr((uint32_t)buf);
;;;1391       fifo_cb[fno].user_buf_len = blen;
;;;1392       fifo_cb[fno].received_length = 0;
;;;1393       fifo_cb[fno].isBlockingCall = isBlockingCall;
;;;1394   
;;;1395       // there is a risk of race condition with IRQ when different endponts are working
;;;1396       NVIC_DisableIRQ(OTG_SBS_3_IRQ);
;;;1397       {
;;;1398   	    // the OUT interrupts should have been disabled earlier, re-enable it since buffer is commited
;;;1399   	    UsbRegMaskedClr(REG_DEV_MISG1, MF0_OUT_INT << (fno * 2));
;;;1400       }
;;;1401       NVIC_EnableIRQ(OTG_SBS_3_IRQ);
;;;1402   
;;;1403       return KDRV_STATUS_OK;
;;;1404   }
000026  e8bd87f0          POP      {r4-r10,pc}
                  |L4.42|
00002a  2006              MOVS     r0,#6                 ;1379
00002c  e7fb              B        |L4.38|
                  |L4.46|
00002e  7d20              LDRB     r0,[r4,#0x14]         ;1384
000030  b108              CBZ      r0,|L4.54|
000032  2009              MOVS     r0,#9                 ;1385
000034  e7f7              B        |L4.38|
                  |L4.54|
000036  2701              MOVS     r7,#1                 ;1389
000038  7527              STRB     r7,[r4,#0x14]         ;1389
00003a  4648              MOV      r0,r9                 ;1390
00003c  f7fffffe          BL       dma_remap_addr
000040  e9c40806          STRD     r0,r8,[r4,#0x18]      ;1390
000044  2000              MOVS     r0,#0                 ;1392
000046  6220              STR      r0,[r4,#0x20]         ;1393
000048  f8846025          STRB     r6,[r4,#0x25]         ;1393
00004c  2023              MOVS     r0,#0x23              ;1396
00004e  f7fffffe          BL       __NVIC_DisableIRQ
000052  4807              LDR      r0,|L4.112|
000054  f8d01138          LDR      r1,[r0,#0x138]        ;1399
000058  006a              LSLS     r2,r5,#1              ;1399
00005a  4097              LSLS     r7,r7,r2              ;1399
00005c  43b9              BICS     r1,r1,r7              ;1399
00005e  f8c01138          STR      r1,[r0,#0x138]        ;1399
000062  2023              MOVS     r0,#0x23              ;1401
000064  f7fffffe          BL       __NVIC_EnableIRQ
000068  2000              MOVS     r0,#0                 ;1403
00006a  e7dc              B        |L4.38|
;;;1405   
                          ENDP

                  |L4.108|
                          DCD      ||.bss||+0x20
                  |L4.112|
                          DCD      0xc0100000

                          AREA ||i.bus_reset_work||, CODE, READONLY, ALIGN=2

                  bus_reset_work PROC
;;;508    
;;;509    static void bus_reset_work()
000000  b570              PUSH     {r4-r6,lr}
;;;510    {
;;;511        // clear SET_CONFIG state and usb device address
;;;512        UsbRegWrite(REG_DEV_ADR, 0x0);
000002  4817              LDR      r0,|L5.96|
000004  2100              MOVS     r1,#0
000006  f8c01104          STR      r1,[r0,#0x104]
;;;513    
;;;514        // clear EP0 STALL bit
;;;515        UsbRegMaskedClr(REG_CXCFE, CX_STL);
00000a  f8d01120          LDR      r1,[r0,#0x120]
00000e  f0210104          BIC      r1,r1,#4
000012  f8c01120          STR      r1,[r0,#0x120]
;;;516    
;;;517        // disable (mask) all FIFOs interrupts
;;;518        UsbRegWrite(REG_DEV_MISG1, 0xFFFFFFFF);
000016  1781              ASRS     r1,r0,#30
000018  f8c01138          STR      r1,[r0,#0x138]
;;;519    
;;;520        // clear all FIFO
;;;521        UsbRegMaskedSet(REG_DEV_TST, TST_CLRFF);
00001c  f8d01108          LDR      r1,[r0,#0x108]
000020  f0410101          ORR      r1,r1,#1
000024  f8c01108          STR      r1,[r0,#0x108]
;;;522    
;;;523        // clear this interrupt bit
;;;524        UsbRegMaskedSet(REG_DEV_ISG2, G2_USBRST_INT_RW1C);
000028  f8d0114c          LDR      r1,[r0,#0x14c]
00002c  f0410101          ORR      r1,r1,#1
000030  f8c0114c          STR      r1,[r0,#0x14c]
;;;525    
;;;526        // reset all endpoints, FIXME: better place to do this ?
;;;527        {
;;;528            FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
000034  4d0b              LDR      r5,|L5.100|
;;;529            for (int fno = 0; fno < FIFO_NUM; fno++)
000036  2400              MOVS     r4,#0
                  |L5.56|
;;;530                if (fifo_cb[fno].enabled)
000038  eb040084          ADD      r0,r4,r4,LSL #2
00003c  f8151030          LDRB     r1,[r5,r0,LSL #3]
000040  b121              CBZ      r1,|L5.76|
;;;531                {
;;;532                    kdrv_usbd_reset_endpoint(fifo_cb[fno].endpointAddress);
000042  eb0500c0          ADD      r0,r5,r0,LSL #3
000046  6840              LDR      r0,[r0,#4]
000048  f7fffffe          BL       kdrv_usbd_reset_endpoint
                  |L5.76|
00004c  1c64              ADDS     r4,r4,#1
00004e  2c04              CMP      r4,#4                 ;529
000050  dbf2              BLT      |L5.56|
;;;533                }
;;;534        }
;;;535    
;;;536        notify_event_to_user(KDRV_USBD_EVENT_BUS_RESET, 0, 0);
000052  e8bd4070          POP      {r4-r6,lr}
000056  2200              MOVS     r2,#0
000058  4611              MOV      r1,r2
00005a  2001              MOVS     r0,#1
00005c  f7ffbffe          B.W      notify_event_to_user
;;;537    }
;;;538    
                          ENDP

                  |L5.96|
                          DCD      0xc0100000
                  |L5.100|
                          DCD      ||.bss||+0x20

                          AREA ||i.clean_fifo_cb||, CODE, READONLY, ALIGN=1

                  clean_fifo_cb PROC
;;;595    
;;;596    static void clean_fifo_cb(FIFO_Ctrl *fifo_cb)
000000  2100              MOVS     r1,#0
;;;597    {
;;;598        fifo_cb->user_buf_addr = 0;
;;;599        fifo_cb->user_buf_len = 0;
000002  6181              STR      r1,[r0,#0x18]
;;;600        fifo_cb->isTransferring = false;
000004  61c1              STR      r1,[r0,#0x1c]
000006  7501              STRB     r1,[r0,#0x14]
;;;601        fifo_cb->short_or_zl_packet = false;
000008  f8801024          STRB     r1,[r0,#0x24]
;;;602    }
00000c  4770              BX       lr
;;;603    
                          ENDP


                          AREA ||i.dma_fifo_transfer_sync||, CODE, READONLY, ALIGN=2

                  dma_fifo_transfer_sync PROC
;;;305    // dma polling way
;;;306    static bool dma_fifo_transfer_sync(uint32_t *addr, uint32_t len, uint32_t fifo_sel, uint8_t fifo_dir)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;307    {
000004  461e              MOV      r6,r3
000006  4690              MOV      r8,r2
000008  460f              MOV      r7,r1
00000a  4681              MOV      r9,r0
;;;308        if (dma_is_busy())
00000c  f7fffffe          BL       dma_is_busy
000010  b110              CBZ      r0,|L7.24|
;;;309            return false;
000012  2000              MOVS     r0,#0
                  |L7.20|
;;;310    
;;;311        bool status = false;
;;;312    
;;;313        // set DMA FIFO selection to accuire DMA
;;;314        // FIXME: better use mutex stuff to occupy DMA resource !!
;;;315        UsbRegWrite(REG_DMA_TFN, fifo_sel);
;;;316    
;;;317        // temporarily disable DMA complt interrupt
;;;318        // because we will poll it here
;;;319        UsbRegMaskedSet(REG_DEV_MISG2, G2_DMA_CMPLT_RW1C);
;;;320    
;;;321        // set DMA address
;;;322        UsbRegWrite(REG_DMA_CPS2, dma_remap_addr((uint32_t)addr));
;;;323    
;;;324        // set DMA transfer size
;;;325        UsbRegWrite(REG_DMA_CPS1, len << 8);
;;;326    
;;;327        if (fifo_dir == WRITE_FIFO)
;;;328            UsbRegMaskedSet(REG_DMA_CPS1, BIT1);
;;;329    
;;;330        // start DMA
;;;331        UsbRegMaskedSet(REG_DMA_CPS1, DMA_START);
;;;332    
;;;333        int i;
;;;334        // FIXME: why 500 ? just to prevent from being dead forever
;;;335        for (i = 0; i < 500; i++)
;;;336        {
;;;337            // polling DMA completion status
;;;338            if (UsbRegRead(REG_DEV_ISG2) & G2_DMA_CMPLT_RW1C)
;;;339            {
;;;340                UsbRegMaskedSet(REG_DEV_ISG2, G2_DMA_CMPLT_RW1C);
;;;341                status = true;
;;;342                break;
;;;343            }
;;;344        }
;;;345    
;;;346        // re-enable DMA complt interrupt
;;;347        UsbRegMaskedClr(REG_DEV_MISG2, G2_DMA_CMPLT_RW1C);
;;;348    
;;;349        // clear DMA FIFO selection
;;;350        UsbRegWrite(REG_DMA_TFN, DMA_TARGET_ACC_NONE);
;;;351    
;;;352        return status;
;;;353    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L7.24|
000018  4c1e              LDR      r4,|L7.148|
00001a  2500              MOVS     r5,#0                 ;311
00001c  f8c481c0          STR      r8,[r4,#0x1c0]        ;315
000020  f8d4013c          LDR      r0,[r4,#0x13c]        ;319
000024  f0400080          ORR      r0,r0,#0x80           ;319
000028  f8c4013c          STR      r0,[r4,#0x13c]        ;319
00002c  4648              MOV      r0,r9                 ;322
00002e  f7fffffe          BL       dma_remap_addr
000032  f8c401cc          STR      r0,[r4,#0x1cc]        ;322
000036  0238              LSLS     r0,r7,#8              ;325
000038  f8c401c8          STR      r0,[r4,#0x1c8]        ;325
00003c  2e01              CMP      r6,#1                 ;327
00003e  d105              BNE      |L7.76|
000040  f8d401c8          LDR      r0,[r4,#0x1c8]        ;328
000044  f0400002          ORR      r0,r0,#2              ;328
000048  f8c401c8          STR      r0,[r4,#0x1c8]        ;328
                  |L7.76|
00004c  f8d401c8          LDR      r0,[r4,#0x1c8]        ;331
000050  f0400001          ORR      r0,r0,#1              ;331
000054  f8c401c8          STR      r0,[r4,#0x1c8]        ;331
000058  2000              MOVS     r0,#0                 ;335
00005a  f44f71fa          MOV      r1,#0x1f4             ;335
00005e  bf00              NOP                            ;338
                  |L7.96|
000060  f8d4214c          LDR      r2,[r4,#0x14c]        ;338
000064  0612              LSLS     r2,r2,#24             ;338
000066  d507              BPL      |L7.120|
000068  f8d4014c          LDR      r0,[r4,#0x14c]        ;340
00006c  f0400080          ORR      r0,r0,#0x80           ;340
000070  f8c4014c          STR      r0,[r4,#0x14c]        ;340
000074  2501              MOVS     r5,#1                 ;341
000076  e002              B        |L7.126|
                  |L7.120|
000078  1c40              ADDS     r0,r0,#1              ;342
00007a  4288              CMP      r0,r1                 ;335
00007c  dbf0              BLT      |L7.96|
                  |L7.126|
00007e  f8d4013c          LDR      r0,[r4,#0x13c]        ;347
000082  f0200080          BIC      r0,r0,#0x80           ;347
000086  f8c4013c          STR      r0,[r4,#0x13c]        ;347
00008a  2000              MOVS     r0,#0                 ;350
00008c  f8c401c0          STR      r0,[r4,#0x1c0]        ;350
000090  4628              MOV      r0,r5                 ;352
000092  e7bf              B        |L7.20|
;;;354    
                          ENDP

                  |L7.148|
                          DCD      0xc0100000

                          AREA ||i.dma_fifo_transfer_sync_try||, CODE, READONLY, ALIGN=1

                  dma_fifo_transfer_sync_try PROC
;;;354    
;;;355    static bool dma_fifo_transfer_sync_try(uint32_t *addr, uint32_t len, uint32_t fifo_sel, uint8_t fifo_dir, uint32_t try_count)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;356    {
;;;357        bool status = false;
000004  2500              MOVS     r5,#0
000006  461f              MOV      r7,r3                 ;356
000008  4690              MOV      r8,r2                 ;356
00000a  4689              MOV      r9,r1                 ;356
00000c  4682              MOV      r10,r0                ;356
;;;358        for (int i = 0; i < try_count; i++)
00000e  462c              MOV      r4,r5
000010  9e08              LDR      r6,[sp,#0x20]         ;356
000012  e009              B        |L8.40|
                  |L8.20|
;;;359            if (dma_fifo_transfer_sync(addr, len, fifo_sel, fifo_dir))
000014  463b              MOV      r3,r7
000016  4642              MOV      r2,r8
000018  4649              MOV      r1,r9
00001a  4650              MOV      r0,r10
00001c  f7fffffe          BL       dma_fifo_transfer_sync
000020  b108              CBZ      r0,|L8.38|
;;;360            {
;;;361                status = true;
000022  2501              MOVS     r5,#1
;;;362                break;
000024  e002              B        |L8.44|
                  |L8.38|
000026  1c64              ADDS     r4,r4,#1
                  |L8.40|
000028  42b4              CMP      r4,r6                 ;358
00002a  d3f3              BCC      |L8.20|
                  |L8.44|
;;;363            }
;;;364        return status;
00002c  4628              MOV      r0,r5
;;;365    }
00002e  e8bd87f0          POP      {r4-r10,pc}
;;;366    
                          ENDP


                          AREA ||i.dma_is_busy||, CODE, READONLY, ALIGN=2

                  dma_is_busy PROC
;;;283    
;;;284    static bool dma_is_busy()
000000  4803              LDR      r0,|L9.16|
;;;285    {
;;;286        return (UsbRegRead(REG_DMA_TFN) != DMA_TARGET_ACC_NONE);
000002  f8d001c0          LDR      r0,[r0,#0x1c0]
000006  2800              CMP      r0,#0                 ;285
000008  d000              BEQ      |L9.12|
00000a  2001              MOVS     r0,#1
                  |L9.12|
;;;287    }
00000c  4770              BX       lr
;;;288    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0xc0100000

                          AREA ||i.dma_remap_addr||, CODE, READONLY, ALIGN=1

                  dma_remap_addr PROC
;;;289    //  for data SRAM, the address must be remapped
;;;290    static uint32_t dma_remap_addr(uint32_t addr)
000000  f04f5181          MOV      r1,#0x10200000
;;;291    {
;;;292        uint32_t tmp;
;;;293    
;;;294        if ((addr & (SdRAM_MEM_BASE)) == SdRAM_MEM_BASE)
000004  4381              BICS     r1,r1,r0
000006  d103              BNE      |L10.16|
;;;295        {
;;;296            tmp = ((addr) & (~0x10000000)) | 0x20000000;
000008  f0205080          BIC      r0,r0,#0x10000000
00000c  f0405000          ORR      r0,r0,#0x20000000
                  |L10.16|
;;;297            return tmp;
;;;298        }
;;;299        return addr;
;;;300    }
000010  4770              BX       lr
;;;301    
                          ENDP


                          AREA ||i.endpoint_to_fifo||, CODE, READONLY, ALIGN=2

                  endpoint_to_fifo PROC
;;;584    
;;;585    static int8_t endpoint_to_fifo(uint32_t endpoint)
000000  4601              MOV      r1,r0
;;;586    {
;;;587        // check fifo ctrl blocks to get fifo no
;;;588        int8_t fno;
;;;589        for (fno = 0; fno < FIFO_NUM; fno++)
;;;590            if (cb.fifo_cbs[fno].endpointAddress == endpoint)
000002  4a0a              LDR      r2,|L11.44|
000004  2000              MOVS     r0,#0                 ;589
000006  bf00              NOP      
                  |L11.8|
000008  eb000380          ADD      r3,r0,r0,LSL #2
00000c  eb0203c3          ADD      r3,r2,r3,LSL #3
000010  6a5b              LDR      r3,[r3,#0x24]
000012  428b              CMP      r3,r1
000014  d004              BEQ      |L11.32|
000016  1c40              ADDS     r0,r0,#1
000018  b240              SXTB     r0,r0                 ;589
00001a  2804              CMP      r0,#4                 ;589
00001c  dbf4              BLT      |L11.8|
00001e  e001              B        |L11.36|
                  |L11.32|
;;;591                break;
;;;592    
;;;593        return (fno < 4) ? fno : -1;
000020  2804              CMP      r0,#4
000022  db01              BLT      |L11.40|
                  |L11.36|
000024  f04f30ff          MOV      r0,#0xffffffff
                  |L11.40|
;;;594    }
000028  4770              BX       lr
;;;595    
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      ||.bss||

                          AREA ||i.handle_control_transfer||, CODE, READONLY, ALIGN=2

                  handle_control_transfer PROC
;;;1169   
;;;1170   static void handle_control_transfer()
000000  b57c              PUSH     {r2-r6,lr}
;;;1171   {
;;;1172       // ready to read out 8 bytes setup packet
;;;1173       kdrv_usbd_setup_packet_t setup = {0};
000002  2500              MOVS     r5,#0
000004  9500              STR      r5,[sp,#0]
;;;1174       uint8_t *temp = (uint8_t *)&setup;
;;;1175   
;;;1176       // if DMA is busy now, do nothing and will handle in later interrupts
;;;1177       if (dma_is_busy())
000006  9501              STR      r5,[sp,#4]
000008  f7fffffe          BL       dma_is_busy
00000c  2800              CMP      r0,#0
00000e  d119              BNE      |L12.68|
;;;1178       {
;;;1179           return;
;;;1180       }
;;;1181   
;;;1182       // set DMA FIFO selection to CXF
;;;1183       UsbRegWrite(REG_DMA_TFN, DMA_TARGET_ACC_CXF);
000010  4c16              LDR      r4,|L12.108|
000012  2010              MOVS     r0,#0x10
000014  f8c401c0          STR      r0,[r4,#0x1c0]
;;;1184   
;;;1185       // directly read DMA_CPS3 twice to get 8-byte setup packet
;;;1186       *((uint32_t *)temp) = UsbRegRead(REG_DMA_CPS3);
000018  f8d401d0          LDR      r0,[r4,#0x1d0]
;;;1187       *((uint32_t *)(temp + 4)) = UsbRegRead(REG_DMA_CPS3);
00001c  9000              STR      r0,[sp,#0]
00001e  f8d401d0          LDR      r0,[r4,#0x1d0]
;;;1188   
;;;1189       // clear DMA FIFO selection
;;;1190       UsbRegWrite(REG_DMA_TFN, DMA_TARGET_ACC_NONE);
000022  9001              STR      r0,[sp,#4]
000024  f8c451c0          STR      r5,[r4,#0x1c0]
;;;1191   
;;;1192       // parsing bmRequestType to find out which kind of reqeusts
;;;1193       int8_t resp = RESP_NACK;
;;;1194       uint8_t bmRequestType_type = ((setup.bmRequestType & 0x60) >> 5);
000028  f89d0000          LDRB     r0,[sp,#0]
00002c  f3c01041          UBFX     r0,r0,#5,#2
;;;1195       switch (bmRequestType_type)
000030  b148              CBZ      r0,|L12.70|
000032  2801              CMP      r0,#1
000034  d001              BEQ      |L12.58|
000036  2802              CMP      r0,#2
000038  d104              BNE      |L12.68|
                  |L12.58|
;;;1196       {
;;;1197       case 0: // Standard request
;;;1198           resp = handle_standard_request(&setup);
;;;1199           break;
;;;1200       case 1: // Class request
;;;1201       case 2: // Vendor request
;;;1202           notify_event_to_user(KDRV_USBD_EVENT_SETUP_PACKET,
00003a  e9dd1200          LDRD     r1,r2,[sp,#0]
00003e  2004              MOVS     r0,#4
000040  f7fffffe          BL       notify_event_to_user
                  |L12.68|
;;;1203                                *((uint32_t *)temp), *((uint32_t *)(temp + 4)));
;;;1204           break;
;;;1205       }
;;;1206   
;;;1207       if (resp == RESP_ACK)
;;;1208           // indicate an OK request to host
;;;1209           UsbRegMaskedSet(REG_CXCFE, CX_DONE);
;;;1210       else if (resp == RESP_STALL)
;;;1211       {
;;;1212           // indicate a request error to host
;;;1213           UsbRegMaskedSet(REG_CXCFE, CX_STL | CX_DONE);
;;;1214       }
;;;1215       else
;;;1216       {
;;;1217           // NACK, do nothing for now
;;;1218       }
;;;1219   }
000044  bd7c              POP      {r2-r6,pc}
                  |L12.70|
000046  4668              MOV      r0,sp                 ;1198
000048  f7fffffe          BL       handle_standard_request
00004c  2802              CMP      r0,#2                 ;1207
00004e  d008              BEQ      |L12.98|
000050  2803              CMP      r0,#3                 ;1210
000052  d1f7              BNE      |L12.68|
000054  f8d40120          LDR      r0,[r4,#0x120]        ;1213
000058  f0400005          ORR      r0,r0,#5              ;1213
                  |L12.92|
00005c  f8c40120          STR      r0,[r4,#0x120]        ;1209
000060  bd7c              POP      {r2-r6,pc}
                  |L12.98|
000062  f8d40120          LDR      r0,[r4,#0x120]        ;1209
000066  f0400001          ORR      r0,r0,#1              ;1209
00006a  e7f7              B        |L12.92|
;;;1220   
                          ENDP

                  |L12.108|
                          DCD      0xc0100000

                          AREA ||i.handle_device_interrupts||, CODE, READONLY, ALIGN=2

                  handle_device_interrupts PROC
;;;1220   
;;;1221   static void handle_device_interrupts()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1222   {
;;;1223       uint32_t grp_x_int_status = UsbRegRead(REG_DEV_IGR);
000004  4c34              LDR      r4,|L13.216|
000006  f8d46140          LDR      r6,[r4,#0x140]
;;;1224       uint32_t grp_0_interrupts = (UsbRegRead(REG_DEV_ISG0) & ~(UsbRegRead(REG_DEV_MISG0)));
00000a  f8d47144          LDR      r7,[r4,#0x144]
00000e  f8d40134          LDR      r0,[r4,#0x134]
;;;1225       uint32_t grp_2_interrupts = (UsbRegRead(REG_DEV_ISG2) & ~(UsbRegRead(REG_DEV_MISG2)));
000012  f8d4514c          LDR      r5,[r4,#0x14c]
000016  4387              BICS     r7,r7,r0              ;1224
000018  f8d4013c          LDR      r0,[r4,#0x13c]
00001c  4385              BICS     r5,r5,r0
;;;1226   
;;;1227       if (grp_x_int_status & GX_INT_G1_RO)
00001e  07b0              LSLS     r0,r6,#30
000020  d501              BPL      |L13.38|
;;;1228           handle_fifo_interrupts();
000022  f7fffffe          BL       handle_fifo_interrupts
                  |L13.38|
;;;1229   
;;;1230       if (grp_x_int_status & GX_INT_G2_RO)
000026  0770              LSLS     r0,r6,#29
000028  d544              BPL      |L13.180|
;;;1231       {
;;;1232           if (grp_2_interrupts & G2_DMA_CMPLT_RW1C)
00002a  0628              LSLS     r0,r5,#24
00002c  d502              BPL      |L13.52|
;;;1233               handle_dma_complete_interrupt();
00002e  f7fffffe          BL       handle_dma_complete_interrupt
000032  e03f              B        |L13.180|
                  |L13.52|
;;;1234           else if (grp_2_interrupts & G2_RX0BYTE_INT_RW1C)
000034  0668              LSLS     r0,r5,#25
000036  d502              BPL      |L13.62|
;;;1235               handle_zero_length_packet_interrupt();
000038  f7fffffe          BL       handle_zero_length_packet_interrupt
00003c  e03a              B        |L13.180|
                  |L13.62|
;;;1236           else if (grp_2_interrupts & G2_DMA_ERROR_RW1C)
00003e  05e8              LSLS     r0,r5,#23
000040  d51f              BPL      |L13.130|
000042  f8d4014c          LDR      r0,[r4,#0x14c]
000046  f4407080          ORR      r0,r0,#0x100
00004a  f8c4014c          STR      r0,[r4,#0x14c]
00004e  f8d411c0          LDR      r1,[r4,#0x1c0]
000052  2000              MOVS     r0,#0
000054  f8c401c0          STR      r0,[r4,#0x1c0]
000058  f05f0301          MOVS.W   r3,#1
                  |L13.92|
00005c  fa03f200          LSL      r2,r3,r0
000060  420a              TST      r2,r1
000062  d102              BNE      |L13.106|
000064  1c40              ADDS     r0,r0,#1
000066  2804              CMP      r0,#4
000068  d3f8              BCC      |L13.92|
                  |L13.106|
00006a  491c              LDR      r1,|L13.220|
00006c  eb000080          ADD      r0,r0,r0,LSL #2
000070  eb0100c0          ADD      r0,r1,r0,LSL #3
000074  6a40              LDR      r0,[r0,#0x24]
000076  f7fffffe          BL       kdrv_usbd_reset_endpoint
00007a  2200              MOVS     r2,#0
00007c  4611              MOV      r1,r2
00007e  200a              MOVS     r0,#0xa
;;;1237               handle_dma_error();
000080  e011              B        |L13.166|
                  |L13.130|
;;;1238           else if (grp_2_interrupts & G2_SUSP_INT_RW1C)
000082  07a8              LSLS     r0,r5,#30
000084  d504              BPL      |L13.144|
000086  f8d4014c          LDR      r0,[r4,#0x14c]
00008a  f0400002          ORR      r0,r0,#2
;;;1239               bus_suspend_work();
00008e  e005              B        |L13.156|
                  |L13.144|
;;;1240           else if (grp_2_interrupts & G2_RESM_INT_RW1C)
000090  0768              LSLS     r0,r5,#29
000092  d50b              BPL      |L13.172|
000094  f8d4014c          LDR      r0,[r4,#0x14c]
000098  f0400004          ORR      r0,r0,#4
                  |L13.156|
00009c  f8c4014c          STR      r0,[r4,#0x14c]
0000a0  2200              MOVS     r2,#0
0000a2  4611              MOV      r1,r2
0000a4  2002              MOVS     r0,#2
                  |L13.166|
0000a6  f7fffffe          BL       notify_event_to_user
0000aa  e003              B        |L13.180|
                  |L13.172|
;;;1241               bus_resume_work();
;;;1242           else if (grp_2_interrupts & G2_USBRST_INT_RW1C)
0000ac  07e8              LSLS     r0,r5,#31
0000ae  d001              BEQ      |L13.180|
;;;1243               bus_reset_work();
0000b0  f7fffffe          BL       bus_reset_work
                  |L13.180|
;;;1244       }
;;;1245   
;;;1246       if (grp_x_int_status & GX_INT_G0_RO)
0000b4  07f0              LSLS     r0,r6,#31
0000b6  d007              BEQ      |L13.200|
;;;1247       {
;;;1248           if (grp_0_interrupts & G0_CX_COMABT_INT_RW1C)
0000b8  06b8              LSLS     r0,r7,#26
0000ba  d507              BPL      |L13.204|
0000bc  f8d40144          LDR      r0,[r4,#0x144]
0000c0  f0400020          ORR      r0,r0,#0x20
0000c4  f8c40144          STR      r0,[r4,#0x144]
                  |L13.200|
;;;1249               // first priority
;;;1250               handle_cmd_abort();
;;;1251           else if (grp_0_interrupts & G0_CX_SETUP_INT_RO)
;;;1252               handle_control_transfer();
;;;1253       }
;;;1254   }
0000c8  e8bd81f0          POP      {r4-r8,pc}
                  |L13.204|
0000cc  07f8              LSLS     r0,r7,#31             ;1251
0000ce  d0fb              BEQ      |L13.200|
0000d0  e8bd41f0          POP      {r4-r8,lr}            ;1252
0000d4  f7ffbffe          B.W      handle_control_transfer
;;;1255   
                          ENDP

                  |L13.216|
                          DCD      0xc0100000
                  |L13.220|
                          DCD      ||.bss||

                          AREA ||i.handle_dma_complete_interrupt||, CODE, READONLY, ALIGN=2

                  handle_dma_complete_interrupt PROC
;;;726    // FIXME: this does not handle CX DMA complete
;;;727    static void handle_dma_complete_interrupt()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;728    {
;;;729        // this handles only one DMA complete interrupt
;;;730        uint32_t fno;
;;;731        uint32_t fifoSel = UsbRegRead(REG_DMA_TFN);
000004  4825              LDR      r0,|L14.156|
000006  f8d031c0          LDR      r3,[r0,#0x1c0]
;;;732        uint32_t dmaCPS1 = UsbRegRead(REG_DMA_CPS1);
00000a  f8d041c8          LDR      r4,[r0,#0x1c8]
;;;733    
;;;734        // clear FIFO selection
;;;735        UsbRegWrite(REG_DMA_TFN, DMA_TARGET_ACC_NONE);
00000e  2100              MOVS     r1,#0
000010  f8c011c0          STR      r1,[r0,#0x1c0]
;;;736    
;;;737        // clear DMA completion interrupt
;;;738        UsbRegMaskedSet(REG_DEV_ISG2, G2_DMA_CMPLT_RW1C);
000014  f8d0114c          LDR      r1,[r0,#0x14c]
000018  f0410180          ORR      r1,r1,#0x80
00001c  f8c0114c          STR      r1,[r0,#0x14c]
;;;739    
;;;740        for (fno = 0; fno < FIFO_NUM; fno++)
000020  2200              MOVS     r2,#0
;;;741            if (fifoSel & (0x1 << fno))
000022  2101              MOVS     r1,#1
                  |L14.36|
000024  fa01f502          LSL      r5,r1,r2
000028  421d              TST      r5,r3
00002a  d102              BNE      |L14.50|
00002c  1c52              ADDS     r2,r2,#1
00002e  2a04              CMP      r2,#4                 ;740
000030  d3f8              BCC      |L14.36|
                  |L14.50|
;;;742                break;
;;;743    
;;;744        // check DMA-FIFO direction
;;;745        if (dmaCPS1 & DMA_TYPE)
000032  07a3              LSLS     r3,r4,#30
000034  d509              BPL      |L14.74|
;;;746        {
;;;747    
;;;748            // Memory-to-FIFO, is IN transfer
;;;749            // re-enable (unmask) the FIFO IN interrupt here
;;;750            // because DMA completion does not mean bulk-in transfer is done
;;;751            UsbRegMaskedClr(REG_DEV_MISG1, MF0_IN_INT << fno);
000036  f8d01138          LDR      r1,[r0,#0x138]
00003a  f44f3380          MOV      r3,#0x10000
00003e  4093              LSLS     r3,r3,r2
000040  4399              BICS     r1,r1,r3
000042  f8c01138          STR      r1,[r0,#0x138]
                  |L14.70|
;;;752        }
;;;753        else
;;;754        {
;;;755            // FIFO-to-Memory, is OUT transfer
;;;756    
;;;757            FIFO_Ctrl *fifo_cb = &(cb.fifo_cbs[fno]);
;;;758    
;;;759            {
;;;760                // re-enable OUT interrupts whatever fifo or short packet
;;;761                UsbRegMaskedClr(REG_DEV_MISG1, (MF0_OUT_INT | MF0_SPK_INT) << (fno * 2));
;;;762    
;;;763                if (fifo_cb->short_or_zl_packet)
;;;764                {
;;;765                    // this transfer is a short packet, so transfer is done
;;;766                    // notify transfer done to user
;;;767                    if (fifo_cb->isBlockingCall)
;;;768                    {
;;;769                        fifo_cb->cur_event = KDRV_USBD_EVENT_TRANSFER_DONE;
;;;770                        osEventFlagsSet(cb.evt_id, 0x1 << fno);
;;;771                    }
;;;772                    else
;;;773                    {
;;;774                        clean_fifo_cb(fifo_cb);
;;;775                        notify_event_to_user(KDRV_USBD_EVENT_TRANSFER_DONE, fifo_cb->endpointAddress, fifo_cb->received_length);
;;;776                    }
;;;777                }
;;;778            }
;;;779        }
;;;780    }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L14.74|
00004a  4b15              LDR      r3,|L14.160|
00004c  eb020482          ADD      r4,r2,r2,LSL #2       ;757
000050  f8d05138          LDR      r5,[r0,#0x138]        ;761
000054  eb0304c4          ADD      r4,r3,r4,LSL #3       ;757
000058  0057              LSLS     r7,r2,#1              ;761
00005a  2603              MOVS     r6,#3                 ;761
00005c  40be              LSLS     r6,r6,r7              ;761
00005e  43b5              BICS     r5,r5,r6              ;761
000060  f8c05138          STR      r5,[r0,#0x138]        ;761
000064  f8940044          LDRB     r0,[r4,#0x44]         ;763
000068  3420              ADDS     r4,r4,#0x20           ;763
00006a  2800              CMP      r0,#0                 ;763
00006c  d0eb              BEQ      |L14.70|
00006e  f8940025          LDRB     r0,[r4,#0x25]         ;767
000072  b140              CBZ      r0,|L14.134|
000074  2007              MOVS     r0,#7                 ;769
000076  f8840026          STRB     r0,[r4,#0x26]         ;769
00007a  6858              LDR      r0,[r3,#4]            ;770  ; cb
00007c  e8bd41f0          POP      {r4-r8,lr}            ;770
000080  4091              LSLS     r1,r1,r2              ;770
000082  f7ffbffe          B.W      osEventFlagsSet
                  |L14.134|
000086  4620              MOV      r0,r4                 ;774
000088  f7fffffe          BL       clean_fifo_cb
00008c  6a22              LDR      r2,[r4,#0x20]         ;775
00008e  6861              LDR      r1,[r4,#4]            ;775
000090  e8bd41f0          POP      {r4-r8,lr}            ;775
000094  2007              MOVS     r0,#7                 ;775
000096  f7ffbffe          B.W      notify_event_to_user
;;;781    
                          ENDP

00009a  0000              DCW      0x0000
                  |L14.156|
                          DCD      0xc0100000
                  |L14.160|
                          DCD      ||.bss||

                          AREA ||i.handle_fifo_in_interrupts||, CODE, READONLY, ALIGN=2

                  handle_fifo_in_interrupts PROC
;;;657    
;;;658    static inline void handle_fifo_in_interrupts(uint32_t interrupt_bits)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;659    {
;;;660        // this handles only one fifo interrupt
;;;661    
;;;662        FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
000004  4933              LDR      r1,|L15.212|
;;;663    
;;;664        uint32_t fno;
;;;665        for (fno = 0; fno < FIFO_NUM; fno++)
000006  2600              MOVS     r6,#0
;;;666            if (interrupt_bits & (G1_F0_IN_INT_RO << fno))
000008  f44f3780          MOV      r7,#0x10000
                  |L15.12|
00000c  fa07f206          LSL      r2,r7,r6
000010  4202              TST      r2,r0
000012  d102              BNE      |L15.26|
000014  1c76              ADDS     r6,r6,#1
000016  2e04              CMP      r6,#4                 ;665
000018  d3f8              BCC      |L15.12|
                  |L15.26|
;;;667                break;
;;;668    
;;;669        // disable (mask) the FIFO IN interrupt immediately to prevent from interrupt re-trigger
;;;670        UsbRegMaskedSet(REG_DEV_MISG1, MF0_IN_INT << fno);
00001a  4d2f              LDR      r5,|L15.216|
00001c  f8d50138          LDR      r0,[r5,#0x138]
000020  40b7              LSLS     r7,r7,r6
000022  43b8              BICS     r0,r0,r7
000024  4338              ORRS     r0,r0,r7
000026  f8c50138          STR      r0,[r5,#0x138]
;;;671    
;;;672        if (fifo_cb[fno].user_buf_len > 0)
00002a  eb060086          ADD      r0,r6,r6,LSL #2
00002e  eb0104c0          ADD      r4,r1,r0,LSL #3
000032  f04f0801          MOV      r8,#1
000036  69e0              LDR      r0,[r4,#0x1c]
000038  b338              CBZ      r0,|L15.138|
00003a  f7fffffe          BL       dma_is_busy
00003e  b130              CBZ      r0,|L15.78|
;;;673        {
;;;674            if (dma_start_mem_to_fifo(fno, &fifo_cb[fno]) == false)
;;;675            {
;;;676                // re-enable the interrupt for next try
;;;677                UsbRegMaskedClr(REG_DEV_MISG1, MF0_IN_INT << fno);
000040  f8d50138          LDR      r0,[r5,#0x138]
000044  43b8              BICS     r0,r0,r7
000046  f8c50138          STR      r0,[r5,#0x138]
                  |L15.74|
;;;678            }
;;;679        }
;;;680        else
;;;681        {
;;;682            // FIFO is empty and no more data to send, in other words, the bulk-in transfer is done
;;;683    
;;;684            // send zero-length packet if needed
;;;685            if (fifo_cb[fno].short_or_zl_packet)
;;;686            {
;;;687                UsbRegMaskedSet(REG_DEV_INMPS_1 + 4 * (fifo_cb[fno].enpNo - 1), TX0BYTE_IEPn);
;;;688                // FIXME: should check G2_TX0BYTE_INT_RW1C in later interrupts
;;;689            }
;;;690    
;;;691            // notify transfer done to user
;;;692            if (fifo_cb[fno].isBlockingCall)
;;;693            {
;;;694                fifo_cb[fno].cur_event = KDRV_USBD_EVENT_TRANSFER_DONE;
;;;695                osEventFlagsSet(cb.evt_id, 0x1 << fno);
;;;696            }
;;;697            else
;;;698            {
;;;699                clean_fifo_cb(&fifo_cb[fno]);
;;;700                notify_event_to_user(KDRV_USBD_EVENT_TRANSFER_DONE, fifo_cb[fno].endpointAddress, 0);
;;;701            }
;;;702        }
;;;703    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L15.78|
00004e  fa08f006          LSL      r0,r8,r6
000052  f8c501c0          STR      r0,[r5,#0x1c0]
000056  68a1              LDR      r1,[r4,#8]
000058  69e0              LDR      r0,[r4,#0x1c]
00005a  4281              CMP      r1,r0
00005c  d200              BCS      |L15.96|
00005e  4608              MOV      r0,r1
                  |L15.96|
000060  69a1              LDR      r1,[r4,#0x18]
000062  f8c511cc          STR      r1,[r5,#0x1cc]
000066  2102              MOVS     r1,#2
000068  eb012100          ADD      r1,r1,r0,LSL #8
00006c  f8c511c8          STR      r1,[r5,#0x1c8]
000070  f8d511c8          LDR      r1,[r5,#0x1c8]
000074  f0410101          ORR      r1,r1,#1
000078  f8c511c8          STR      r1,[r5,#0x1c8]
00007c  69a1              LDR      r1,[r4,#0x18]
00007e  4401              ADD      r1,r1,r0
000080  61a1              STR      r1,[r4,#0x18]
000082  69e1              LDR      r1,[r4,#0x1c]
000084  1a08              SUBS     r0,r1,r0
000086  61e0              STR      r0,[r4,#0x1c]
000088  e7df              B        |L15.74|
                  |L15.138|
00008a  f8940024          LDRB     r0,[r4,#0x24]         ;685
00008e  b140              CBZ      r0,|L15.162|
000090  7860              LDRB     r0,[r4,#1]            ;687
000092  eb050080          ADD      r0,r5,r0,LSL #2       ;687
000096  f8d0115c          LDR      r1,[r0,#0x15c]        ;687
00009a  f4414100          ORR      r1,r1,#0x8000         ;687
00009e  f8c0115c          STR      r1,[r0,#0x15c]        ;687
                  |L15.162|
0000a2  f8940025          LDRB     r0,[r4,#0x25]         ;692
0000a6  b158              CBZ      r0,|L15.192|
0000a8  2007              MOVS     r0,#7                 ;694
0000aa  f8840026          STRB     r0,[r4,#0x26]         ;694
0000ae  4809              LDR      r0,|L15.212|
0000b0  fa08f106          LSL      r1,r8,r6              ;695
0000b4  3820              SUBS     r0,r0,#0x20           ;695
0000b6  6840              LDR      r0,[r0,#4]            ;695  ; cb
0000b8  e8bd41f0          POP      {r4-r8,lr}            ;695
0000bc  f7ffbffe          B.W      osEventFlagsSet
                  |L15.192|
0000c0  4620              MOV      r0,r4                 ;695
0000c2  f7fffffe          BL       clean_fifo_cb
0000c6  6861              LDR      r1,[r4,#4]            ;700
0000c8  e8bd41f0          POP      {r4-r8,lr}            ;700
0000cc  2200              MOVS     r2,#0                 ;700
0000ce  2007              MOVS     r0,#7                 ;700
0000d0  f7ffbffe          B.W      notify_event_to_user
;;;704    
                          ENDP

                  |L15.212|
                          DCD      ||.bss||+0x20
                  |L15.216|
                          DCD      0xc0100000

                          AREA ||i.handle_fifo_interrupts||, CODE, READONLY, ALIGN=2

                  handle_fifo_interrupts PROC
;;;708    
;;;709    static void handle_fifo_interrupts()
000000  b570              PUSH     {r4-r6,lr}
;;;710    {
;;;711        uint32_t fifo_interrupts = UsbRegRead(REG_DEV_ISG1) & ~(UsbRegRead(REG_DEV_MISG1));
000002  4919              LDR      r1,|L16.104|
000004  f8d14148          LDR      r4,[r1,#0x148]
000008  f8d10138          LDR      r0,[r1,#0x138]
00000c  4384              BICS     r4,r4,r0
;;;712    
;;;713        // handle OUT short packets interrupts for short packets
;;;714        if (fifo_interrupts & FIFO_SHORT_PKT_INTERRUPTS)
00000e  f0140faa          TST      r4,#0xaa
000012  d01a              BEQ      |L16.74|
000014  2000              MOVS     r0,#0                 ;710
000016  2202              MOVS     r2,#2                 ;710
                  |L16.24|
000018  0043              LSLS     r3,r0,#1              ;710
00001a  fa02f303          LSL      r3,r2,r3              ;710
00001e  4223              TST      r3,r4                 ;710
000020  d010              BEQ      |L16.68|
000022  4e12              LDR      r6,|L16.108|
000024  eb000580          ADD      r5,r0,r0,LSL #2       ;710
000028  eb0605c5          ADD      r5,r6,r5,LSL #3       ;710
00002c  2301              MOVS     r3,#1                 ;710
00002e  f8853044          STRB     r3,[r5,#0x44]         ;710
000032  f8d13138          LDR      r3,[r1,#0x138]        ;710
000036  0040              LSLS     r0,r0,#1              ;710
000038  4082              LSLS     r2,r2,r0              ;710
00003a  4393              BICS     r3,r3,r2              ;710
00003c  4313              ORRS     r3,r3,r2              ;710
00003e  f8c13138          STR      r3,[r1,#0x138]        ;710
000042  e002              B        |L16.74|
                  |L16.68|
000044  1c40              ADDS     r0,r0,#1              ;710
000046  2804              CMP      r0,#4                 ;710
000048  dbe6              BLT      |L16.24|
                  |L16.74|
;;;715            handle_fifo_short_pkt_interrupts(fifo_interrupts);
;;;716    
;;;717        // handle OUT FIFO interrupts
;;;718        if (fifo_interrupts & FIFO_OUT_INTERRUPTS)
00004a  f0140f55          TST      r4,#0x55
00004e  d002              BEQ      |L16.86|
;;;719            handle_fifo_out_interrupts(fifo_interrupts);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       handle_fifo_out_interrupts
                  |L16.86|
;;;720    
;;;721        // handle IN FIFO interrupts
;;;722        if (fifo_interrupts & FIFO_IN_INTERRUPTS)
000056  f4142f70          TST      r4,#0xf0000
00005a  d004              BEQ      |L16.102|
;;;723            handle_fifo_in_interrupts(fifo_interrupts);
00005c  4620              MOV      r0,r4
00005e  e8bd4070          POP      {r4-r6,lr}
000062  f7ffbffe          B.W      handle_fifo_in_interrupts
                  |L16.102|
;;;724    }
000066  bd70              POP      {r4-r6,pc}
;;;725    
                          ENDP

                  |L16.104|
                          DCD      0xc0100000
                  |L16.108|
                          DCD      ||.bss||

                          AREA ||i.handle_fifo_out_interrupts||, CODE, READONLY, ALIGN=2

                  handle_fifo_out_interrupts PROC
;;;624    
;;;625    static inline void handle_fifo_out_interrupts(uint32_t interrupt_bits)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;626    {
;;;627        FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
000004  4f2e              LDR      r7,|L17.192|
;;;628    
;;;629        for (int fno = 0; fno < FIFO_NUM; fno++)
000006  2400              MOVS     r4,#0
;;;630        {
;;;631            // handle interrupts for each fifo
;;;632            if (interrupt_bits & (G1_F0_OUT_INT_RO << (fno * 2)))
;;;633            {
;;;634                // if no user buffer is commited, means that this is a start of OUT transfer
;;;635                if (fifo_cb[fno].user_buf_addr == 0)
;;;636                {
;;;637                    // disable this OUT interrrupt
;;;638                    // it should be re-enabled once user commits a buffer for DMA
;;;639                    UsbRegMaskedSet(REG_DEV_MISG1, MF0_OUT_INT << (fno * 2));
000008  f8dfa0b8          LDR      r10,|L17.196|
00000c  4680              MOV      r8,r0                 ;626
00000e  2601              MOVS     r6,#1                 ;632
                  |L17.16|
000010  0060              LSLS     r0,r4,#1              ;632
000012  fa06f500          LSL      r5,r6,r0              ;632
000016  ea150f08          TST      r5,r8                 ;632
00001a  d04b              BEQ      |L17.180|
00001c  eb040084          ADD      r0,r4,r4,LSL #2       ;635
000020  eb0700c0          ADD      r0,r7,r0,LSL #3       ;635
000024  6981              LDR      r1,[r0,#0x18]         ;635
000026  b131              CBZ      r1,|L17.54|
;;;640    
;;;641                    // then should notify an event to user
;;;642                    notify_event_to_user(KDRV_USBD_EVENT_TRANSFER_OUT, fifo_cb[fno].enpNo, 0);
;;;643                }
;;;644                else // configure DMA transfer for FIFO to user buffer
;;;645                {
;;;646                    if (fifo_cb[fno].user_buf_len > 0 &&
000028  69c1              LDR      r1,[r0,#0x1c]
00002a  b3e1              CBZ      r1,|L17.166|
;;;647                        dma_start_fifo_to_mem(fno, &fifo_cb[fno]) == true)
00002c  4681              MOV      r9,r0
00002e  f7fffffe          BL       dma_is_busy
000032  bbc0              CBNZ     r0,|L17.166|
000034  e00b              B        |L17.78|
                  |L17.54|
000036  f8da2138          LDR      r2,[r10,#0x138]       ;639
00003a  43aa              BICS     r2,r2,r5              ;639
00003c  432a              ORRS     r2,r2,r5              ;639
00003e  f8ca2138          STR      r2,[r10,#0x138]       ;639
000042  7841              LDRB     r1,[r0,#1]            ;642
000044  2200              MOVS     r2,#0                 ;642
000046  2008              MOVS     r0,#8                 ;642
000048  f7fffffe          BL       notify_event_to_user
00004c  e032              B        |L17.180|
                  |L17.78|
00004e  fa06f104          LSL      r1,r6,r4              ;642
000052  4650              MOV      r0,r10                ;642
000054  f8ca11c0          STR      r1,[r10,#0x1c0]       ;642
000058  f8d91010          LDR      r1,[r9,#0x10]         ;642
00005c  5809              LDR      r1,[r1,r0]            ;642
00005e  f8d9201c          LDR      r2,[r9,#0x1c]         ;642
000062  f3c1010a          UBFX     r1,r1,#0,#11          ;642
000066  428a              CMP      r2,r1                 ;642
000068  d800              BHI      |L17.108|
00006a  4611              MOV      r1,r2                 ;642
                  |L17.108|
00006c  f8d92018          LDR      r2,[r9,#0x18]         ;642
000070  f8c021cc          STR      r2,[r0,#0x1cc]        ;642
000074  020a              LSLS     r2,r1,#8              ;642
000076  f8c021c8          STR      r2,[r0,#0x1c8]        ;642
00007a  f8d021c8          LDR      r2,[r0,#0x1c8]        ;642
00007e  f0420201          ORR      r2,r2,#1              ;642
000082  f8c021c8          STR      r2,[r0,#0x1c8]        ;642
000086  f8d92018          LDR      r2,[r9,#0x18]         ;642
00008a  1853              ADDS     r3,r2,r1              ;642
00008c  f8c93018          STR      r3,[r9,#0x18]         ;642
000090  f8d9201c          LDR      r2,[r9,#0x1c]         ;642
000094  1a53              SUBS     r3,r2,r1              ;642
000096  f8c9301c          STR      r3,[r9,#0x1c]         ;642
00009a  f8d92020          LDR      r2,[r9,#0x20]         ;642
00009e  440a              ADD      r2,r2,r1              ;642
;;;648                    {
;;;649                        // DMA has been started, disable this OUT interrupt
;;;650                        // and re-enable the interrupt at DMA completion
;;;651                        UsbRegMaskedSet(REG_DEV_MISG1, MF0_OUT_INT << (fno * 2));
0000a0  f8c92020          STR      r2,[r9,#0x20]
0000a4  e000              B        |L17.168|
                  |L17.166|
0000a6  e005              B        |L17.180|
                  |L17.168|
0000a8  f8d01138          LDR      r1,[r0,#0x138]
0000ac  43a9              BICS     r1,r1,r5
0000ae  4329              ORRS     r1,r1,r5
0000b0  f8c01138          STR      r1,[r0,#0x138]
                  |L17.180|
0000b4  1c64              ADDS     r4,r4,#1
0000b6  2c04              CMP      r4,#4                 ;629
0000b8  dbaa              BLT      |L17.16|
;;;652                    }
;;;653                }
;;;654            }
;;;655        }
;;;656    }
0000ba  e8bd87f0          POP      {r4-r10,pc}
;;;657    
                          ENDP

0000be  0000              DCW      0x0000
                  |L17.192|
                          DCD      ||.bss||+0x20
                  |L17.196|
                          DCD      0xc0100000

                          AREA ||i.handle_standard_request||, CODE, READONLY, ALIGN=2

                  handle_standard_request PROC
;;;1086   
;;;1087   static int8_t handle_standard_request(kdrv_usbd_setup_packet_t *setup)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1088   {
000002  4604              MOV      r4,r0
;;;1089       int8_t resp = RESP_STALL;
000004  2003              MOVS     r0,#3
;;;1090   
;;;1091       // handle requests which are not affected by ep0 halt
;;;1092       switch (setup->bRequest)
000006  7861              LDRB     r1,[r4,#1]
000008  b139              CBZ      r1,|L18.26|
00000a  2901              CMP      r1,#1
00000c  d105              BNE      |L18.26|
;;;1093       {
;;;1094       case 0x0: // GET_STATUS
;;;1095           break;
;;;1096       case 0x1: // CLEAR_FEATURE
;;;1097       {
;;;1098           if (setup->wValue == 0x0)
00000e  8861              LDRH     r1,[r4,#2]
000010  b919              CBNZ     r1,|L18.26|
;;;1099           {
;;;1100               // endpoint halt
;;;1101               kdrv_usbd_reset_endpoint(setup->wIndex);
000012  88a0              LDRH     r0,[r4,#4]
000014  f7fffffe          BL       kdrv_usbd_reset_endpoint
;;;1102               resp = RESP_ACK;
000018  2002              MOVS     r0,#2
                  |L18.26|
;;;1103           }
;;;1104           break;
;;;1105       }
;;;1106       case 0x3: // SET_FEATURE
;;;1107           break;
;;;1108       }
;;;1109   
;;;1110       // if ep0 is halted, some requests should not be done
;;;1111       if (cb.ep0_halted)
00001a  4b27              LDR      r3,|L18.184|
00001c  7b19              LDRB     r1,[r3,#0xc]  ; cb
00001e  b109              CBZ      r1,|L18.36|
;;;1112           return RESP_STALL;
000020  2003              MOVS     r0,#3
                  |L18.34|
;;;1113   
;;;1114       switch (setup->bRequest)
;;;1115       {
;;;1116       case 0x5: // SET_ADDRESS
;;;1117       {
;;;1118           // USB2.0 spec says should not be greaten than 127
;;;1119           if (setup->wValue <= 127)
;;;1120           {
;;;1121               // set DEVADR and also clear AFT_CONF
;;;1122               UsbRegWrite(REG_DEV_ADR, setup->wValue);
;;;1123               resp = RESP_ACK;
;;;1124           }
;;;1125       }
;;;1126       break;
;;;1127       case 0x6: // GET_DESCRIPTOR
;;;1128       {
;;;1129           // low byte: index of specified descriptor type
;;;1130           uint8_t descp_idx = (setup->wValue & 0xFF);
;;;1131   
;;;1132           // high byte: descriptor type
;;;1133           switch (setup->wValue >> 8)
;;;1134           {
;;;1135           case 1: // DEVICE descriptor
;;;1136               resp = send_host_device_descriptor(setup);
;;;1137               break;
;;;1138           case 2: // CONFIGURATION descriptor
;;;1139               resp = send_host_configuration_descriptors(setup);
;;;1140               break;
;;;1141           case 3: // STRING descriptor
;;;1142               resp = send_host_string_descriptor(setup,descp_idx);
;;;1143               break;
;;;1144           case 4: // INTERFACE descriptor
;;;1145               break;
;;;1146           case 5: // ENDPOINT descriptor
;;;1147               break;
;;;1148           case 6: // DEVICE_QUALIFIER descriptor
;;;1149               resp = send_host_device_qual_descriptor(setup);
;;;1150               break;
;;;1151           case 7: // OTHER_SPEED_CONFIGURATION descriptor
;;;1152               break;
;;;1153           case 8: // INTERFACE_POWER descriptor
;;;1154               break;
;;;1155           }
;;;1156       }
;;;1157       break;
;;;1158       case 0x7: // SET_DESCRIPTOR
;;;1159           break;
;;;1160       case 0x8: // GET_CONFIGURATION
;;;1161           break;
;;;1162       case 0x9: // SET_CONFIGURATION
;;;1163           resp = set_configuration(setup);
;;;1164           break;
;;;1165       }
;;;1166   
;;;1167       return resp;
;;;1168   }
000022  bdf8              POP      {r3-r7,pc}
                  |L18.36|
000024  7861              LDRB     r1,[r4,#1]            ;1114
000026  1f49              SUBS     r1,r1,#5              ;1114
000028  2905              CMP      r1,#5                 ;1114
00002a  d2fa              BCS      |L18.34|
00002c  e8dff001          TBB      [pc,r1]               ;1114
000030  040c0303          DCB      0x04,0x0c,0x03,0x03
000034  3f00              DCB      0x3f,0x00
000036  e7f4              B        |L18.34|
000038  8861              LDRH     r1,[r4,#2]            ;1119
00003a  297f              CMP      r1,#0x7f              ;1119
00003c  d8f1              BHI      |L18.34|
00003e  481f              LDR      r0,|L18.188|
000040  f8c01104          STR      r1,[r0,#0x104]        ;1122
000044  2002              MOVS     r0,#2                 ;1123
                  |L18.70|
000046  bdf8              POP      {r3-r7,pc}
000048  8862              LDRH     r2,[r4,#2]            ;1130
00004a  2703              MOVS     r7,#3                 ;1089
00004c  b2d1              UXTB     r1,r2                 ;1130
00004e  ea4f2c12          LSR      r12,r2,#8             ;1133
000052  2501              MOVS     r5,#1                 ;1092
000054  2602              MOVS     r6,#2                 ;1102
000056  2232              MOVS     r2,#0x32              ;1102
000058  f1bc0f07          CMP      r12,#7                ;1133
00005c  d2f3              BCS      |L18.70|
00005e  e8dff00c          TBB      [pc,r12]              ;1133
000062  0405              DCB      0x04,0x05
000064  181d0404          DCB      0x18,0x1d,0x04,0x04
000068  2200              DCB      0x22,0x00
00006a  e7ec              B        |L18.70|
00006c  6918              LDR      r0,[r3,#0x10]         ;1133  ; cb
00006e  e01b              B        |L18.168|
                  |L18.112|
000070  4638              MOV      r0,r7                 ;1133
000072  bdf8              POP      {r3-r7,pc}
                  |L18.116|
000074  7801              LDRB     r1,[r0,#0]
000076  88e3              LDRH     r3,[r4,#6]
000078  4299              CMP      r1,r3
00007a  d300              BCC      |L18.126|
00007c  4619              MOV      r1,r3
                  |L18.126|
00007e  9200              STR      r2,[sp,#0]
000080  2301              MOVS     r3,#1
000082  2210              MOVS     r2,#0x10
000084  f7fffffe          BL       dma_fifo_transfer_sync_try
000088  b108              CBZ      r0,|L18.142|
00008a  4630              MOV      r0,r6
00008c  bdf8              POP      {r3-r7,pc}
                  |L18.142|
00008e  4628              MOV      r0,r5
000090  bdf8              POP      {r3-r7,pc}
000092  4620              MOV      r0,r4                 ;1139
000094  e8bd40f8          POP      {r3-r7,lr}            ;1139
000098  f7ffbffe          B.W      send_host_configuration_descriptors
00009c  4620              MOV      r0,r4                 ;1142
00009e  e8bd40f8          POP      {r3-r7,lr}            ;1142
0000a2  f7ffbffe          B.W      send_host_string_descriptor
0000a6  6958              LDR      r0,[r3,#0x14]         ;1142  ; cb
                  |L18.168|
0000a8  2800              CMP      r0,#0                 ;1142
0000aa  d1e3              BNE      |L18.116|
0000ac  e7e0              B        |L18.112|
0000ae  4620              MOV      r0,r4                 ;1163
0000b0  e8bd40f8          POP      {r3-r7,lr}            ;1163
0000b4  f7ffbffe          B.W      set_configuration
;;;1169   
                          ENDP

                  |L18.184|
                          DCD      ||.bss||
                  |L18.188|
                          DCD      0xc0100000

                          AREA ||i.handle_zero_length_packet_interrupt||, CODE, READONLY, ALIGN=2

                  handle_zero_length_packet_interrupt PROC
;;;781    
;;;782    static void handle_zero_length_packet_interrupt()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;783    {
;;;784        uint32_t zl_endp_interrupts = UsbRegRead(REG_DEV_RXZ);
000004  4d24              LDR      r5,|L19.152|
000006  f8d51150          LDR      r1,[r5,#0x150]
;;;785        uint32_t enpNo;
;;;786        for (enpNo = 1; enpNo <= 8; enpNo++)
00000a  2001              MOVS     r0,#1
00000c  4604              MOV      r4,r0
                  |L19.14|
;;;787            if (zl_endp_interrupts & (0x1 << (enpNo - 1)))
00000e  1e42              SUBS     r2,r0,#1
000010  fa04f202          LSL      r2,r4,r2
000014  420a              TST      r2,r1
000016  d102              BNE      |L19.30|
000018  1c40              ADDS     r0,r0,#1
00001a  2808              CMP      r0,#8                 ;786
00001c  d9f7              BLS      |L19.14|
                  |L19.30|
;;;788                break;
;;;789    
;;;790        // clean corresponding endpoint's rx zero-length interrupt
;;;791        UsbRegMaskedSet(REG_DEV_RXZ, RX0BYTE_EP1 << (enpNo - 1));
00001e  f8d52150          LDR      r2,[r5,#0x150]
000022  1e43              SUBS     r3,r0,#1
000024  fa04f103          LSL      r1,r4,r3
000028  438a              BICS     r2,r2,r1
00002a  430a              ORRS     r2,r2,r1
00002c  f8c52150          STR      r2,[r5,#0x150]
;;;792    
;;;793        // clear global rx zero-length interrupt
;;;794        UsbRegMaskedSet(REG_DEV_ISG2, G2_RX0BYTE_INT_RW1C);
000030  f8d5114c          LDR      r1,[r5,#0x14c]
000034  f0410140          ORR      r1,r1,#0x40
000038  f8c5114c          STR      r1,[r5,#0x14c]
;;;795    
;;;796        int8_t fno = endpoint_to_fifo(enpNo);
00003c  f7fffffe          BL       endpoint_to_fifo
;;;797    
;;;798        FIFO_Ctrl *fifo_cb = &(cb.fifo_cbs[fno]);
000040  4a16              LDR      r2,|L19.156|
000042  eb000180          ADD      r1,r0,r0,LSL #2
000046  eb0206c1          ADD      r6,r2,r1,LSL #3
;;;799        if (fifo_cb->isTransferring)
00004a  f8961034          LDRB     r1,[r6,#0x34]
00004e  3620              ADDS     r6,r6,#0x20
000050  2900              CMP      r1,#0
000052  d01e              BEQ      |L19.146|
;;;800        {
;;;801    
;;;802            // re-enable OUT interrupts whatever fifo or short packet
;;;803            UsbRegMaskedClr(REG_DEV_MISG1, (MF0_OUT_INT | MF0_SPK_INT) << (fno * 2));
000054  f8d51138          LDR      r1,[r5,#0x138]
000058  0047              LSLS     r7,r0,#1
00005a  2303              MOVS     r3,#3
00005c  40bb              LSLS     r3,r3,r7
00005e  4399              BICS     r1,r1,r3
000060  f8c51138          STR      r1,[r5,#0x138]
;;;804    
;;;805            // received a zero-length packet, notify transfer do to user
;;;806            // notify transfer done to user
;;;807            if (fifo_cb->isBlockingCall)
000064  f8961025          LDRB     r1,[r6,#0x25]
000068  b149              CBZ      r1,|L19.126|
;;;808            {
;;;809                fifo_cb->cur_event = KDRV_USBD_EVENT_TRANSFER_DONE;
00006a  2107              MOVS     r1,#7
00006c  f8861026          STRB     r1,[r6,#0x26]
;;;810                osEventFlagsSet(cb.evt_id, 0x1 << fno);
000070  fa04f100          LSL      r1,r4,r0
000074  6850              LDR      r0,[r2,#4]  ; cb
000076  e8bd41f0          POP      {r4-r8,lr}
00007a  f7ffbffe          B.W      osEventFlagsSet
                  |L19.126|
;;;811            }
;;;812            else
;;;813            {
;;;814                clean_fifo_cb(fifo_cb);
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       clean_fifo_cb
;;;815                notify_event_to_user(KDRV_USBD_EVENT_TRANSFER_DONE, fifo_cb->endpointAddress, fifo_cb->received_length);
000084  6a32              LDR      r2,[r6,#0x20]
000086  6871              LDR      r1,[r6,#4]
000088  e8bd41f0          POP      {r4-r8,lr}
00008c  2007              MOVS     r0,#7
00008e  f7ffbffe          B.W      notify_event_to_user
                  |L19.146|
;;;816            }
;;;817    
;;;818            return;
;;;819        }
;;;820    }
000092  e8bd81f0          POP      {r4-r8,pc}
;;;821    
                          ENDP

000096  0000              DCW      0x0000
                  |L19.152|
                          DCD      0xc0100000
                  |L19.156|
                          DCD      ||.bss||

                          AREA ||i.init_fifo_configurations||, CODE, READONLY, ALIGN=2

                  init_fifo_configurations PROC
;;;944    
;;;945    static void init_fifo_configurations(kdrv_usbd_interface_descriptor_t *intf)
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;946    {
;;;947        uint32_t fifo_map_val = 0x0;         // for 0x1A8
000004  2200              MOVS     r2,#0
;;;948        uint32_t endp_map0_val = 0x0;        // for 0x1A0
;;;949        uint32_t endp_map1_val = 0x0;        // for 0x1A4
;;;950        uint32_t fifo_config_val = 0x0;      // for 0x1AC
;;;951        uint32_t fifo_int_mask = 0xFFFFFFFF; // for 0x138, default disable all interrupts
;;;952    
;;;953        // also need to init fifo-dma control blocks
;;;954        for (int fifo = 0; fifo < FIFO_NUM; fifo++)
;;;955            cb.fifo_cbs[fifo].enabled = false;
000006  4d5a              LDR      r5,|L20.368|
000008  b082              SUB      sp,sp,#8              ;946
00000a  4690              MOV      r8,r2                 ;948
00000c  4696              MOV      lr,r2                 ;949
00000e  4614              MOV      r4,r2                 ;950
000010  1e50              SUBS     r0,r2,#1              ;951
000012  4611              MOV      r1,r2                 ;954
000014  4613              MOV      r3,r2                 ;954
                  |L20.22|
000016  eb010681          ADD      r6,r1,r1,LSL #2
00001a  eb0506c6          ADD      r6,r5,r6,LSL #3
00001e  1c49              ADDS     r1,r1,#1
000020  4699              MOV      r9,r3
000022  46aa              MOV      r10,r5
000024  f8863020          STRB     r3,[r6,#0x20]
000028  2904              CMP      r1,#4                 ;954
00002a  dbf4              BLT      |L20.22|
;;;956    
;;;957        // here assume endpoint number order is ascending
;;;958        for (int i = 0; i < intf->bNumEndpoints; i++)
00002c  2300              MOVS     r3,#0
00002e  e07c              B        |L20.298|
                  |L20.48|
;;;959        {
;;;960            uint8_t bEndpointAddress = intf->endpoint[i]->bEndpointAddress;
000030  9902              LDR      r1,[sp,#8]
;;;961            uint8_t bmAttributes = intf->endpoint[i]->bmAttributes;
;;;962            uint16_t wMaxPacketSize = intf->endpoint[i]->wMaxPacketSize;
;;;963    
;;;964            // i value implies FIFO number
;;;965            uint32_t fifo = i;
;;;966            uint8_t isIn = !!(bEndpointAddress & 0x80);
;;;967            uint8_t enpNo = bEndpointAddress & 0xF; // retrieve endpoint no without direction
;;;968            uint32_t bitfield;
;;;969    
;;;970            // set FIFO's direction and corresponding endpoint no.
;;;971            bitfield = (isIn << 4) | enpNo;
000032  ea4f0cc3          LSL      r12,r3,#3
000036  eb010183          ADD      r1,r1,r3,LSL #2       ;960
00003a  f8d11009          LDR      r1,[r1,#9]            ;960
00003e  788e              LDRB     r6,[r1,#2]            ;960
000040  78cd              LDRB     r5,[r1,#3]            ;961
000042  9501              STR      r5,[sp,#4]            ;962
000044  f8b1b004          LDRH     r11,[r1,#4]           ;962
000048  09f5              LSRS     r5,r6,#7              ;966
00004a  f006010f          AND      r1,r6,#0xf            ;967
00004e  ea411705          ORR      r7,r1,r5,LSL #4
;;;972            fifo_map_val |= (bitfield << (fifo * 8));
000052  fa07f70c          LSL      r7,r7,r12
000056  ea470202          ORR      r2,r7,r2
;;;973    
;;;974            // set endpoint's FIFO no.
;;;975            bitfield = isIn ? fifo : (fifo << 4);
00005a  f8cdc000          STR      r12,[sp,#0]
00005e  d001              BEQ      |L20.100|
000060  461f              MOV      r7,r3
000062  e000              B        |L20.102|
                  |L20.100|
000064  011f              LSLS     r7,r3,#4
                  |L20.102|
;;;976            if (enpNo <= 4)
000066  2904              CMP      r1,#4
000068  ea4f0cc1          LSL      r12,r1,#3
00006c  d806              BHI      |L20.124|
00006e  f1ac0c08          SUB      r12,r12,#8
;;;977                endp_map0_val |= (bitfield << ((enpNo - 1) * 8));
000072  fa07f70c          LSL      r7,r7,r12
000076  ea470808          ORR      r8,r7,r8
00007a  e005              B        |L20.136|
                  |L20.124|
00007c  f1ac0c28          SUB      r12,r12,#0x28
;;;978            else // 5~8
;;;979                endp_map1_val |= (bitfield << ((enpNo - 5) * 8));
000080  fa07f70c          LSL      r7,r7,r12
000084  ea470e0e          ORR      lr,r7,lr
                  |L20.136|
;;;980    
;;;981            // enable the corresponding FIFO and set transfer type
;;;982            fifo_config_val |= (BIT5 | (bmAttributes & 0x3)) << (fifo * 8);
000088  9f01              LDR      r7,[sp,#4]
00008a  f8ddc000          LDR      r12,[sp,#0]
00008e  f0070703          AND      r7,r7,#3
000092  9701              STR      r7,[sp,#4]
000094  f0470720          ORR      r7,r7,#0x20
000098  fa07f70c          LSL      r7,r7,r12
00009c  433c              ORRS     r4,r4,r7
;;;983    
;;;984            // set max packet size & reset toggle bit
;;;985            if (isIn)
00009e  2d00              CMP      r5,#0
;;;986            {
;;;987                // for IN endpoints
;;;988                UsbRegWrite(REG_DEV_INMPS_1 + 4 * (enpNo - 1), wMaxPacketSize & 0x7ff);
;;;989                UsbRegMaskedSet(REG_DEV_INMPS_1 + 4 * (enpNo - 1), RSTG_IEPn);
;;;990                UsbRegMaskedClr(REG_DEV_INMPS_1 + 4 * (enpNo - 1), RSTG_IEPn);
;;;991    
;;;992                // disable interrupt for IN endpoint
;;;993                // because when IN fifo is empty, interrupt will be asserted
;;;994                // we could enable IN interrupt only when need to watch it
;;;995                fifo_int_mask |= (MF0_IN_INT << fifo);
;;;996            }
;;;997            else
;;;998            {
;;;999                // for OUT endpoints
;;;1000               UsbRegWrite(REG_DEV_OUTMPS_1 + 4 * (enpNo - 1), wMaxPacketSize & 0x7ff);
0000a0  4d34              LDR      r5,|L20.372|
0000a2  f3cb070a          UBFX     r7,r11,#0,#11
0000a6  eb050581          ADD      r5,r5,r1,LSL #2
0000aa  d012              BEQ      |L20.210|
0000ac  f8c5715c          STR      r7,[r5,#0x15c]        ;988
0000b0  f8d5715c          LDR      r7,[r5,#0x15c]        ;989
0000b4  f4475780          ORR      r7,r7,#0x1000         ;989
0000b8  f8c5715c          STR      r7,[r5,#0x15c]        ;989
0000bc  f8d5715c          LDR      r7,[r5,#0x15c]        ;990
0000c0  f4275780          BIC      r7,r7,#0x1000         ;990
0000c4  f8c5715c          STR      r7,[r5,#0x15c]        ;990
0000c8  f44f3580          MOV      r5,#0x10000           ;995
0000cc  409d              LSLS     r5,r5,r3              ;995
0000ce  4328              ORRS     r0,r0,r5              ;995
0000d0  e011              B        |L20.246|
                  |L20.210|
0000d2  f8c5717c          STR      r7,[r5,#0x17c]
;;;1001               UsbRegMaskedSet(REG_DEV_OUTMPS_1 + 4 * (enpNo - 1), RSTG_OEPn);
0000d6  f8d5717c          LDR      r7,[r5,#0x17c]
0000da  f4475780          ORR      r7,r7,#0x1000
0000de  f8c5717c          STR      r7,[r5,#0x17c]
;;;1002               UsbRegMaskedClr(REG_DEV_OUTMPS_1 + 4 * (enpNo - 1), RSTG_OEPn);
0000e2  f8d5717c          LDR      r7,[r5,#0x17c]
0000e6  f4275780          BIC      r7,r7,#0x1000
0000ea  f8c5717c          STR      r7,[r5,#0x17c]
;;;1003   
;;;1004               // enable interrupt for OUT endpoint
;;;1005               fifo_int_mask &= ~((MF0_SPK_INT | MF0_OUT_INT) << (fifo * 2));
0000ee  005f              LSLS     r7,r3,#1
0000f0  2503              MOVS     r5,#3
0000f2  40bd              LSLS     r5,r5,r7
0000f4  43a8              BICS     r0,r0,r5
                  |L20.246|
;;;1006           }
;;;1007   
;;;1008           // init fifo dma control blocks for each enabled fifo
;;;1009           cb.fifo_cbs[fifo].enabled = true;
0000f6  eb030c83          ADD      r12,r3,r3,LSL #2
0000fa  eb0a05cc          ADD      r5,r10,r12,LSL #3
0000fe  2701              MOVS     r7,#1
000100  f8057f20          STRB     r7,[r5,#0x20]!
;;;1010           cb.fifo_cbs[fifo].enpNo = enpNo;
000104  7069              STRB     r1,[r5,#1]
000106  e9c56b01          STRD     r6,r11,[r5,#4]
;;;1011           cb.fifo_cbs[fifo].endpointAddress = bEndpointAddress;
;;;1012           cb.fifo_cbs[fifo].maxPacketSize = wMaxPacketSize;
;;;1013           cb.fifo_cbs[fifo].transferType = bmAttributes & 0x3;
00010a  9901              LDR      r1,[sp,#4]
00010c  7329              STRB     r1,[r5,#0xc]
;;;1014           cb.fifo_cbs[fifo].byteCntReg = 0x1B0 + 4 * fifo;
00010e  f44f76d8          MOV      r6,#0x1b0
000112  eb060183          ADD      r1,r6,r3,LSL #2
;;;1015           cb.fifo_cbs[fifo].isTransferring = false;
000116  6129              STR      r1,[r5,#0x10]
000118  f8859014          STRB     r9,[r5,#0x14]
;;;1016           cb.fifo_cbs[fifo].user_buf_addr = 0;
;;;1017           cb.fifo_cbs[fifo].user_buf_len = 0;
00011c  f8c59018          STR      r9,[r5,#0x18]
;;;1018           cb.fifo_cbs[fifo].short_or_zl_packet = false;
000120  f8c5901c          STR      r9,[r5,#0x1c]
000124  f8859024          STRB     r9,[r5,#0x24]
000128  1c5b              ADDS     r3,r3,#1
                  |L20.298|
00012a  9902              LDR      r1,[sp,#8]            ;958
00012c  7909              LDRB     r1,[r1,#4]            ;958
00012e  4299              CMP      r1,r3                 ;958
000130  f73faf7e          BGT      |L20.48|
;;;1019       }
;;;1020   
;;;1021       // clear all FIFO
;;;1022       UsbRegMaskedSet(REG_DEV_TST, TST_CLRFF);
000134  490f              LDR      r1,|L20.372|
000136  f8d13108          LDR      r3,[r1,#0x108]
00013a  f0430301          ORR      r3,r3,#1
00013e  f8c13108          STR      r3,[r1,#0x108]
;;;1023   
;;;1024       // set FIFO interrupt mask
;;;1025       UsbRegWrite(REG_DEV_MISG1, fifo_int_mask);
000142  f8c10138          STR      r0,[r1,#0x138]
;;;1026   
;;;1027       // endpoint map 0
;;;1028       UsbRegWrite(REG_DEV_EPMAP0, endp_map0_val);
000146  f8c181a0          STR      r8,[r1,#0x1a0]
;;;1029   
;;;1030       // endpoint map1
;;;1031       UsbRegWrite(REG_DEV_EPMAP1, endp_map1_val);
00014a  f8c1e1a4          STR      lr,[r1,#0x1a4]
;;;1032   
;;;1033       // fifo map
;;;1034       UsbRegWrite(REG_DEV_FMAP, fifo_map_val);
00014e  f8c121a8          STR      r2,[r1,#0x1a8]
;;;1035   
;;;1036       // fifo config / enable
;;;1037       UsbRegWrite(REG_DEV_FCFG, fifo_config_val);
000152  f8c141ac          STR      r4,[r1,#0x1ac]
;;;1038   
;;;1039       // set Device SOF Mask Timer value as data sheet recommended for HS
;;;1040       UsbRegWrite(REG_DEV_SMT, 0x44C);
000156  f240404c          MOV      r0,#0x44c
00015a  f8c10110          STR      r0,[r1,#0x110]
;;;1041   
;;;1042       // set configuration set bit, now allow HW to handle endpoint transfer
;;;1043       UsbRegMaskedSet(REG_DEV_ADR, AFT_CONF);
00015e  f8d10104          LDR      r0,[r1,#0x104]
000162  f0400080          ORR      r0,r0,#0x80
000166  f8c10104          STR      r0,[r1,#0x104]
;;;1044   }
00016a  e8bd8ffe          POP      {r1-r11,pc}
;;;1045   
                          ENDP

00016e  0000              DCW      0x0000
                  |L20.368|
                          DCD      ||.bss||
                  |L20.372|
                          DCD      0xc0100000

                          AREA ||i.init_reg_isr||, CODE, READONLY, ALIGN=2

                  init_reg_isr PROC
;;;1261   
;;;1262   static void init_reg_isr(void)
000000  4831              LDR      r0,|L21.200|
;;;1263   {
;;;1264       SCU_EXTREG_USB_OTG_CTRL_SET_EXTCTRL_SUSPENDM(1);
000002  f8501f8c          LDR      r1,[r0,#0x8c]!
000006  f4417180          ORR      r1,r1,#0x100
00000a  6001              STR      r1,[r0,#0]
;;;1265       SCU_EXTREG_USB_OTG_CTRL_SET_u_iddig(1);
00000c  6801              LDR      r1,[r0,#0]
00000e  f0410180          ORR      r1,r1,#0x80
000012  6001              STR      r1,[r0,#0]
;;;1266       SCU_EXTREG_USB_OTG_CTRL_SET_wakeup(0);
000014  6801              LDR      r1,[r0,#0]
000016  f0210140          BIC      r1,r1,#0x40
00001a  6001              STR      r1,[r0,#0]
;;;1267       SCU_EXTREG_USB_OTG_CTRL_SET_l1_wakeup(0);
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210120          BIC      r1,r1,#0x20
000022  6001              STR      r1,[r0,#0]
;;;1268       SCU_EXTREG_USB_OTG_CTRL_SET_OSCOUTEN(0);
000024  6801              LDR      r1,[r0,#0]
000026  f0210110          BIC      r1,r1,#0x10
00002a  6001              STR      r1,[r0,#0]
;;;1269       SCU_EXTREG_USB_OTG_CTRL_SET_PLLALIV(0);
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210108          BIC      r1,r1,#8
000032  6001              STR      r1,[r0,#0]
;;;1270       SCU_EXTREG_USB_OTG_CTRL_SET_XTLSEL(0);
000034  6801              LDR      r1,[r0,#0]
000036  f0210106          BIC      r1,r1,#6
00003a  6001              STR      r1,[r0,#0]
;;;1271       SCU_EXTREG_USB_OTG_CTRL_SET_OUTCLKSEL(0);
00003c  6801              LDR      r1,[r0,#0]
00003e  f0210101          BIC      r1,r1,#1
000042  6001              STR      r1,[r0,#0]
;;;1272   
;;;1273       // disable all OTG interrupts
;;;1274       UsbRegWrite(REG_OTG_IER, ~(0x0));
000044  4821              LDR      r0,|L21.204|
000046  f04f31ff          MOV      r1,#0xffffffff
00004a  f8c01088          STR      r1,[r0,#0x88]
;;;1275   
;;;1276       // enable only Device interrupt (no Host or OTG)
;;;1277       UsbRegWrite(REG_GLB_INT, ~(INT_POLARITY | DEV_INT) & 0xF);
00004e  2206              MOVS     r2,#6
000050  f8c020c4          STR      r2,[r0,#0xc4]
;;;1278   
;;;1279       // listen all 4 groups for 0x140
;;;1280       UsbRegWrite(REG_DEV_MIGR, 0x0);
000054  2200              MOVS     r2,#0
000056  f8c02130          STR      r2,[r0,#0x130]
;;;1281   
;;;1282       // grop 0 interrupt mask
;;;1283       // FIXME: should care about mroe interrupts
;;;1284       UsbRegWrite(REG_DEV_MISG0,
00005a  f06f0231          MVN      r2,#0x31
00005e  f8c02134          STR      r2,[r0,#0x134]
;;;1285                   ~(G0_CX_SETUP_INT_RO |
;;;1286                     G0_CX_COMFAIL_INT_RO |
;;;1287                     G0_CX_COMABT_INT_RW1C));
;;;1288   
;;;1289       // listen no group 1 interrrupts for 0x148
;;;1290       UsbRegWrite(REG_DEV_MISG1, 0xFFFFFFFF);
000062  f8c01138          STR      r1,[r0,#0x138]
;;;1291   
;;;1292       // enable interested interrupts in group 2 0x14C
;;;1293       UsbRegWrite(REG_DEV_MISG2,
000066  4a1a              LDR      r2,|L21.208|
000068  f8c0213c          STR      r2,[r0,#0x13c]
;;;1294                   ~(G2_RX0BYTE_INT_RW1C |
;;;1295                     G2_DMA_ERROR_RW1C |
;;;1296                     G2_SUSP_INT_RW1C |
;;;1297                     G2_RESM_INT_RW1C |
;;;1298                     G2_USBRST_INT_RW1C));
;;;1299   
;;;1300       // set device idle counter = 7ms
;;;1301       UsbRegWrite(REG_DEV_ICR, 0x7);
00006c  2207              MOVS     r2,#7
00006e  f8c02124          STR      r2,[r0,#0x124]
;;;1302       // device soft reset
;;;1303       UsbRegMaskedSet(REG_DEV_CTL, BIT4);
000072  f8d02100          LDR      r2,[r0,#0x100]
000076  f0420210          ORR      r2,r2,#0x10
00007a  f8c02100          STR      r2,[r0,#0x100]
;;;1304       // clear all FIFO counter
;;;1305       UsbRegMaskedSet(REG_DEV_TST, BIT0);
00007e  f8d02108          LDR      r2,[r0,#0x108]
000082  f0420201          ORR      r2,r2,#1
000086  f8c02108          STR      r2,[r0,#0x108]
;;;1306       // enable chip
;;;1307       UsbRegMaskedSet(REG_DEV_CTL, BIT5);
00008a  f8d02100          LDR      r2,[r0,#0x100]
00008e  f0420220          ORR      r2,r2,#0x20
000092  f8c02100          STR      r2,[r0,#0x100]
;;;1308   
;;;1309       // clear all interrupts status for RW1C bits
;;;1310       UsbRegWrite(REG_OTG_ISR, 0xFFFFFFFF);
000096  f8c01084          STR      r1,[r0,#0x84]
;;;1311       UsbRegWrite(REG_DEV_ISG0, 0xFFFFFFFF);
00009a  f8c01144          STR      r1,[r0,#0x144]
;;;1312       UsbRegWrite(REG_DEV_ISG2, 0xFFFFFFFF);
00009e  f8c0114c          STR      r1,[r0,#0x14c]
;;;1313   
;;;1314       // global interrupt enable
;;;1315       UsbRegMaskedSet(REG_DEV_CTL, BIT2);
0000a2  f8d01100          LDR      r1,[r0,#0x100]
0000a6  f0410104          ORR      r1,r1,#4
0000aa  f8c01100          STR      r1,[r0,#0x100]
0000ae  480a              LDR      r0,|L21.216|
;;;1316   
;;;1317       NVIC_SetVector(OTG_SBS_3_IRQ, (uint32_t)usbd_isr);
0000b0  4908              LDR      r1,|L21.212|
0000b2  6800              LDR      r0,[r0,#0]
0000b4  f8c010cc          STR      r1,[r0,#0xcc]
0000b8  4908              LDR      r1,|L21.220|
0000ba  2008              MOVS     r0,#8
0000bc  f8c10280          STR      r0,[r1,#0x280]
;;;1318   
;;;1319       // Clear and Enable SAI IRQ
;;;1320       NVIC_ClearPendingIRQ(OTG_SBS_3_IRQ);
;;;1321       NVIC_EnableIRQ(OTG_SBS_3_IRQ);
0000c0  2023              MOVS     r0,#0x23
0000c2  f7ffbffe          B.W      __NVIC_EnableIRQ
;;;1322   }
;;;1323   
                          ENDP

0000c6  0000              DCW      0x0000
                  |L21.200|
                          DCD      0xc2380000
                  |L21.204|
                          DCD      0xc0100000
                  |L21.208|
                          DCD      0xfffffeb8
                  |L21.212|
                          DCD      usbd_isr
                  |L21.216|
                          DCD      0xe000ed08
                  |L21.220|
                          DCD      0xe000e004

                          AREA ||i.kdrv_usbd_bulk_receive||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_bulk_receive PROC
;;;1710   
;;;1711   kdrv_status_t kdrv_usbd_bulk_receive(uint32_t endpoint, uint32_t *buf, uint32_t *blen, uint32_t timeout_ms)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1712   {
000004  461f              MOV      r7,r3
000006  4690              MOV      r8,r2
000008  4605              MOV      r5,r0
;;;1713       kdrv_status_t status = bulk_out_receive(endpoint, buf, *blen, true);
00000a  6812              LDR      r2,[r2,#0]
00000c  2301              MOVS     r3,#1
00000e  f7fffffe          BL       bulk_out_receive
000012  0004              MOVS     r4,r0
;;;1714   
;;;1715       if (status != KDRV_STATUS_OK)
000014  d124              BNE      |L22.96|
;;;1716           return status;
;;;1717   
;;;1718       FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
000016  4e14              LDR      r6,|L22.104|
;;;1719       int8_t fno = endpoint_to_fifo(endpoint);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       endpoint_to_fifo
00001e  4605              MOV      r5,r0
;;;1720   
;;;1721       if (timeout_ms == 0)
000020  b907              CBNZ     r7,|L22.36|
;;;1722           timeout_ms = osWaitForever;
000022  1e67              SUBS     r7,r4,#1
                  |L22.36|
;;;1723   
;;;1724       uint32_t flags = osEventFlagsWait(cb.evt_id, (0x1 << fno), osFlagsWaitAny, timeout_ms);
000024  2101              MOVS     r1,#1
000026  4810              LDR      r0,|L22.104|
000028  40a9              LSLS     r1,r1,r5
00002a  3820              SUBS     r0,r0,#0x20
00002c  463b              MOV      r3,r7
00002e  6840              LDR      r0,[r0,#4]  ; cb
000030  2200              MOVS     r2,#0
000032  f7fffffe          BL       osEventFlagsWait
000036  1c80              ADDS     r0,r0,#2
;;;1725       if (flags == osFlagsErrorTimeout)
000038  d014              BEQ      |L22.100|
;;;1726       {
;;;1727           status = KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
;;;1728       }
;;;1729       else
;;;1730       {
;;;1731           *blen = fifo_cb[fno].received_length;
00003a  eb050085          ADD      r0,r5,r5,LSL #2
00003e  eb0600c0          ADD      r0,r6,r0,LSL #3
000042  6a02              LDR      r2,[r0,#0x20]
;;;1732           if (fifo_cb[fno].cur_event == KDRV_USBD_EVENT_TRANSFER_DONE)
000044  f8c82000          STR      r2,[r8,#0]
000048  f8900026          LDRB     r0,[r0,#0x26]
00004c  2807              CMP      r0,#7
00004e  d000              BEQ      |L22.82|
;;;1733               status = KDRV_STATUS_OK;
;;;1734           else
;;;1735               status = KDRV_STATUS_ERROR;
000050  2401              MOVS     r4,#1
                  |L22.82|
;;;1736       }
;;;1737   
;;;1738       clean_fifo_cb(&fifo_cb[fno]);
000052  eb050085          ADD      r0,r5,r5,LSL #2
000056  eb0600c0          ADD      r0,r6,r0,LSL #3
00005a  f7fffffe          BL       clean_fifo_cb
;;;1739       return status;
00005e  4620              MOV      r0,r4
                  |L22.96|
;;;1740   }
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L22.100|
000064  2407              MOVS     r4,#7                 ;1727
000066  e7f4              B        |L22.82|
;;;1741   
                          ENDP

                  |L22.104|
                          DCD      ||.bss||+0x20

                          AREA ||i.kdrv_usbd_bulk_receive_async||, CODE, READONLY, ALIGN=1

                  kdrv_usbd_bulk_receive_async PROC
;;;1741   
;;;1742   kdrv_status_t kdrv_usbd_bulk_receive_async(uint32_t endpoint, uint32_t *buf, uint32_t blen)
000000  2300              MOVS     r3,#0
;;;1743   {
;;;1744       return bulk_out_receive(endpoint, buf, blen, false);
000002  f7ffbffe          B.W      bulk_out_receive
;;;1745   }
;;;1746   
                          ENDP


                          AREA ||i.kdrv_usbd_bulk_send||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_bulk_send PROC
;;;1626   
;;;1627   kdrv_status_t kdrv_usbd_bulk_send(uint32_t endpoint, uint32_t *buf, uint32_t txLen, uint32_t timeout_ms)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1628   {
000004  461f              MOV      r7,r3
000006  4604              MOV      r4,r0
;;;1629       kdrv_status_t status = bulk_in_send(endpoint, buf, txLen, true);
000008  2301              MOVS     r3,#1
00000a  f7fffffe          BL       bulk_in_send
00000e  0005              MOVS     r5,r0
;;;1630   
;;;1631       if (status != KDRV_STATUS_OK)
000010  d121              BNE      |L24.86|
;;;1632           return status;
;;;1633   
;;;1634       FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
000012  4e14              LDR      r6,|L24.100|
;;;1635       int8_t fno = endpoint_to_fifo(endpoint);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       endpoint_to_fifo
00001a  4604              MOV      r4,r0
;;;1636   
;;;1637       if (timeout_ms == 0)
00001c  b907              CBNZ     r7,|L24.32|
;;;1638           timeout_ms = osWaitForever;
00001e  1e6f              SUBS     r7,r5,#1
                  |L24.32|
;;;1639   
;;;1640       uint32_t flags = osEventFlagsWait(cb.evt_id, (0x1 << fno), osFlagsWaitAny, timeout_ms);
000020  2101              MOVS     r1,#1
000022  4810              LDR      r0,|L24.100|
000024  40a1              LSLS     r1,r1,r4
000026  3820              SUBS     r0,r0,#0x20
000028  463b              MOV      r3,r7
00002a  6840              LDR      r0,[r0,#4]  ; cb
00002c  2200              MOVS     r2,#0
00002e  f7fffffe          BL       osEventFlagsWait
000032  1c80              ADDS     r0,r0,#2
;;;1641       if (flags == osFlagsErrorTimeout)
;;;1642       {
;;;1643           clean_fifo_cb(&fifo_cb[fno]);
;;;1644           status = KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
;;;1645       }
;;;1646       else
;;;1647       {
;;;1648           if (fifo_cb[fno].cur_event == KDRV_USBD_EVENT_TRANSFER_DONE)
000034  eb040084          ADD      r0,r4,r4,LSL #2
000038  eb0600c0          ADD      r0,r6,r0,LSL #3
00003c  d00d              BEQ      |L24.90|
00003e  f8900026          LDRB     r0,[r0,#0x26]
000042  2807              CMP      r0,#7
000044  d000              BEQ      |L24.72|
;;;1649               status = KDRV_STATUS_OK;
;;;1650           else
;;;1651               status = KDRV_STATUS_ERROR;
000046  2501              MOVS     r5,#1
                  |L24.72|
;;;1652       }
;;;1653   
;;;1654       clean_fifo_cb(&fifo_cb[fno]);
000048  eb040084          ADD      r0,r4,r4,LSL #2
00004c  eb0600c0          ADD      r0,r6,r0,LSL #3
000050  f7fffffe          BL       clean_fifo_cb
;;;1655       return status;
000054  4628              MOV      r0,r5
                  |L24.86|
;;;1656   }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L24.90|
00005a  f7fffffe          BL       clean_fifo_cb
00005e  2507              MOVS     r5,#7                 ;1644
000060  e7f2              B        |L24.72|
;;;1657   
                          ENDP

000062  0000              DCW      0x0000
                  |L24.100|
                          DCD      ||.bss||+0x20

                          AREA ||i.kdrv_usbd_bulk_send_async||, CODE, READONLY, ALIGN=1

                  kdrv_usbd_bulk_send_async PROC
;;;1705   
;;;1706   kdrv_status_t kdrv_usbd_bulk_send_async(uint32_t endpoint, uint32_t *buf, uint32_t txLen)
000000  2300              MOVS     r3,#0
;;;1707   {
;;;1708       return bulk_in_send(endpoint, buf, txLen, false);
000002  f7ffbffe          B.W      bulk_in_send
;;;1709   }
;;;1710   
                          ENDP


                          AREA ||i.kdrv_usbd_control_receive||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_control_receive PROC
;;;1573   
;;;1574   kdrv_status_t kdrv_usbd_control_receive(uint8_t *buf, uint32_t *size, uint32_t timeout_ms)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1575   {
;;;1576       uint32_t wanted_size = *size;
;;;1577       uint32_t tryMs = 0;
000004  2500              MOVS     r5,#0
;;;1578       *size = 0;
000006  680c              LDR      r4,[r1,#0]
000008  4691              MOV      r9,r2                 ;1575
00000a  460e              MOV      r6,r1                 ;1575
00000c  4682              MOV      r10,r0                ;1575
;;;1579   
;;;1580       while (wanted_size > 0)
;;;1581       {
;;;1582           bool doTxfer = false;
;;;1583   
;;;1584           if (UsbRegRead(REG_DEV_ISG0) & G0_CX_OUT_INT_RO)
00000e  4f17              LDR      r7,|L26.108|
000010  600d              STR      r5,[r1,#0]            ;1575
000012  e027              B        |L26.100|
                  |L26.20|
000014  f8d70144          LDR      r0,[r7,#0x144]
000018  0740              LSLS     r0,r0,#29
00001a  d51a              BPL      |L26.82|
;;;1585           {
;;;1586               uint32_t fifo_bytes = (UsbRegRead(REG_CXCFE) >> 24) & 0x7F;
00001c  f8d70120          LDR      r0,[r7,#0x120]
000020  f3c06006          UBFX     r0,r0,#24,#7
;;;1587               uint32_t transfer_size = MIN(fifo_bytes, wanted_size);
000024  42a0              CMP      r0,r4
000026  d300              BCC      |L26.42|
000028  4620              MOV      r0,r4
                  |L26.42|
00002a  4680              MOV      r8,r0
;;;1588   
;;;1589               if (dma_fifo_transfer_sync_try((uint32_t *)buf, transfer_size, DMA_TARGET_ACC_CXF, READ_FIFO, 500))
00002c  f44f70fa          MOV      r0,#0x1f4
000030  9000              STR      r0,[sp,#0]
000032  2300              MOVS     r3,#0
000034  2210              MOVS     r2,#0x10
000036  4641              MOV      r1,r8
000038  4650              MOV      r0,r10
00003a  f7fffffe          BL       dma_fifo_transfer_sync_try
00003e  b140              CBZ      r0,|L26.82|
;;;1590               {
;;;1591                   doTxfer = true;
;;;1592                   tryMs = 0;
;;;1593                   wanted_size -= transfer_size;
;;;1594                   buf += transfer_size;
;;;1595                   *size += transfer_size;
000040  6831              LDR      r1,[r6,#0]
000042  2500              MOVS     r5,#0                 ;1592
000044  eb010008          ADD      r0,r1,r8
000048  eba40408          SUB      r4,r4,r8              ;1593
00004c  44c2              ADD      r10,r10,r8            ;1594
00004e  6030              STR      r0,[r6,#0]
000050  e008              B        |L26.100|
                  |L26.82|
;;;1596               }
;;;1597           }
;;;1598   
;;;1599           if (!doTxfer)
;;;1600           {
;;;1601               osDelay(1);
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       osDelay
000058  1c6d              ADDS     r5,r5,#1
;;;1602               ++tryMs;
;;;1603               if (tryMs >= timeout_ms)
00005a  454d              CMP      r5,r9
00005c  d302              BCC      |L26.100|
;;;1604                   return KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
00005e  2007              MOVS     r0,#7
                  |L26.96|
;;;1605           }
;;;1606       }
;;;1607   
;;;1608       return KDRV_STATUS_OK;
;;;1609   }
000060  e8bd8ff8          POP      {r3-r11,pc}
                  |L26.100|
000064  2c00              CMP      r4,#0                 ;1580
000066  d1d5              BNE      |L26.20|
000068  2000              MOVS     r0,#0                 ;1608
00006a  e7f9              B        |L26.96|
;;;1610   
                          ENDP

                  |L26.108|
                          DCD      0xc0100000

                          AREA ||i.kdrv_usbd_control_respond||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_control_respond PROC
;;;1610   
;;;1611   kdrv_status_t kdrv_usbd_control_respond(kdrv_usbd_status_respond_t status)
000000  4909              LDR      r1,|L27.40|
;;;1612   {
000002  b118              CBZ      r0,|L27.12|
;;;1613       if (status == KDRV_USBD_RESPOND_OK)
;;;1614           // respond ACK
;;;1615           UsbRegMaskedSet(REG_CXCFE, CX_DONE);
;;;1616       else if (status == KDRV_USBD_RESPOND_ERROR)
000004  2801              CMP      r0,#1
000006  d006              BEQ      |L27.22|
;;;1617           // respond STALL
;;;1618           UsbRegMaskedSet(REG_CXCFE, CX_STL | CX_DONE);
;;;1619       else
;;;1620       {
;;;1621           return KDRV_STATUS_ERROR;
000008  2001              MOVS     r0,#1
;;;1622       }
;;;1623   
;;;1624       return KDRV_STATUS_OK;
;;;1625   }
00000a  4770              BX       lr
                  |L27.12|
00000c  f8d10120          LDR      r0,[r1,#0x120]        ;1615
000010  f0400001          ORR      r0,r0,#1              ;1615
000014  e003              B        |L27.30|
                  |L27.22|
000016  f8d10120          LDR      r0,[r1,#0x120]        ;1618
00001a  f0400005          ORR      r0,r0,#5              ;1618
                  |L27.30|
00001e  f8c10120          STR      r0,[r1,#0x120]        ;1618
000022  2000              MOVS     r0,#0                 ;1624
000024  4770              BX       lr
;;;1626   
                          ENDP

000026  0000              DCW      0x0000
                  |L27.40|
                          DCD      0xc0100000

                          AREA ||i.kdrv_usbd_control_send||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_control_send PROC
;;;1532   
;;;1533   kdrv_status_t kdrv_usbd_control_send(uint8_t *buf, uint32_t size, uint32_t timeout_ms)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1534   {
;;;1535       uint32_t left_send = size;
;;;1536       const uint32_t cx_fifo_size = 64;
;;;1537       uint32_t tryMs = 0;
;;;1538       bool first_written = true;
;;;1539   
;;;1540       // to make sure cx fifo is empty
;;;1541       UsbRegMaskedSet(REG_CXCFE, CX_CLR);
000004  4e1a              LDR      r6,|L28.112|
000006  4681              MOV      r9,r0                 ;1534
000008  2500              MOVS     r5,#0                 ;1537
00000a  f8d60120          LDR      r0,[r6,#0x120]
00000e  4692              MOV      r10,r2                ;1534
000010  460c              MOV      r4,r1                 ;1535
000012  2701              MOVS     r7,#1                 ;1538
000014  f0400008          ORR      r0,r0,#8
000018  f8c60120          STR      r0,[r6,#0x120]
00001c  e023              B        |L28.102|
                  |L28.30|
;;;1542   
;;;1543       while (left_send > 0)
;;;1544       {
;;;1545           bool doTxfer = false;
;;;1546   
;;;1547           if (first_written || (UsbRegRead(REG_DEV_ISG0) & G0_CX_IN_INT_RO))
00001e  b91f              CBNZ     r7,|L28.40|
000020  f8d60144          LDR      r0,[r6,#0x144]
000024  0780              LSLS     r0,r0,#30
000026  d515              BPL      |L28.84|
                  |L28.40|
;;;1548           {
;;;1549               uint32_t transfer_size = MIN(cx_fifo_size, left_send);
000028  2c40              CMP      r4,#0x40
00002a  d901              BLS      |L28.48|
00002c  2040              MOVS     r0,#0x40
00002e  e000              B        |L28.50|
                  |L28.48|
000030  4620              MOV      r0,r4
                  |L28.50|
000032  4680              MOV      r8,r0
;;;1550               // note: there is no G0_CX_IN_INT_RO for first 64-byte write
;;;1551               // so we need to write it first
;;;1552               if (dma_fifo_transfer_sync_try((uint32_t *)buf, transfer_size, DMA_TARGET_ACC_CXF, WRITE_FIFO, 500))
000034  f44f70fa          MOV      r0,#0x1f4
000038  9000              STR      r0,[sp,#0]
00003a  2301              MOVS     r3,#1
00003c  2210              MOVS     r2,#0x10
00003e  4641              MOV      r1,r8
000040  4648              MOV      r0,r9
000042  f7fffffe          BL       dma_fifo_transfer_sync_try
000046  b128              CBZ      r0,|L28.84|
;;;1553               {
;;;1554                   doTxfer = true;
;;;1555                   tryMs = 0;
000048  2500              MOVS     r5,#0
;;;1556                   left_send -= transfer_size;
00004a  eba40408          SUB      r4,r4,r8
;;;1557                   buf += transfer_size;
00004e  44c1              ADD      r9,r9,r8
;;;1558                   first_written = false;
000050  462f              MOV      r7,r5
000052  e008              B        |L28.102|
                  |L28.84|
;;;1559               }
;;;1560           }
;;;1561   
;;;1562           if (!doTxfer)
;;;1563           {
;;;1564               osDelay(1);
000054  2001              MOVS     r0,#1
000056  f7fffffe          BL       osDelay
00005a  1c6d              ADDS     r5,r5,#1
;;;1565               ++tryMs;
;;;1566               if (tryMs >= timeout_ms)
00005c  4555              CMP      r5,r10
00005e  d302              BCC      |L28.102|
;;;1567                   return KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
000060  2007              MOVS     r0,#7
                  |L28.98|
;;;1568           }
;;;1569       }
;;;1570   
;;;1571       return KDRV_STATUS_OK;
;;;1572   }
000062  e8bd8ff8          POP      {r3-r11,pc}
                  |L28.102|
000066  2c00              CMP      r4,#0                 ;1543
000068  d1d9              BNE      |L28.30|
00006a  2000              MOVS     r0,#0                 ;1571
00006c  e7f9              B        |L28.98|
;;;1573   
                          ENDP

00006e  0000              DCW      0x0000
                  |L28.112|
                          DCD      0xc0100000

                          AREA ||i.kdrv_usbd_get_event||, CODE, READONLY, ALIGN=1

                  kdrv_usbd_get_event PROC
;;;1515   
;;;1516   kdrv_status_t kdrv_usbd_get_event(kdrv_usbd_event_t *uevent)
000000  b510              PUSH     {r4,lr}
;;;1517   {
;;;1518       int ret = pop_event_from_queue(uevent);
000002  f7fffffe          BL       pop_event_from_queue
;;;1519   
;;;1520       if (ret)
000006  b108              CBZ      r0,|L29.12|
;;;1521           return KDRV_STATUS_OK;
000008  2000              MOVS     r0,#0
;;;1522       else
;;;1523           return KDRV_STATUS_ERROR;
;;;1524   }
00000a  bd10              POP      {r4,pc}
                  |L29.12|
00000c  2001              MOVS     r0,#1                 ;1523
00000e  bd10              POP      {r4,pc}
;;;1525   
                          ENDP


                          AREA ||i.kdrv_usbd_initialize||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_initialize PROC
;;;1407   
;;;1408   kdrv_status_t kdrv_usbd_initialize(void)
000000  b510              PUSH     {r4,lr}
;;;1409   {
;;;1410       cb.notifyTid = 0;
000002  4c08              LDR      r4,|L30.36|
000004  2000              MOVS     r0,#0
;;;1411       cb.notifyFlag = 0x0;
000006  6020              STR      r0,[r4,#0]  ; cb
;;;1412       cb.ep0_halted = false;
000008  60a0              STR      r0,[r4,#8]  ; cb
00000a  7320              STRB     r0,[r4,#0xc]
;;;1413       cb.dev_desc = NULL;
;;;1414   
;;;1415       reset_event_queue();
00000c  6120              STR      r0,[r4,#0x10]  ; cb
00000e  f7fffffe          BL       reset_event_queue
;;;1416   
;;;1417       cb.evt_id = osEventFlagsNew(NULL);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       osEventFlagsNew
;;;1418   
;;;1419       init_reg_isr();
000018  6060              STR      r0,[r4,#4]  ; cb
00001a  f7fffffe          BL       init_reg_isr
;;;1420   
;;;1421       return KDRV_STATUS_OK;
00001e  2000              MOVS     r0,#0
;;;1422   }
000020  bd10              POP      {r4,pc}
;;;1423   
                          ENDP

000022  0000              DCW      0x0000
                  |L30.36|
                          DCD      ||.bss||

                          AREA ||i.kdrv_usbd_interrupt_receive||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_interrupt_receive PROC
;;;1787   
;;;1788   kdrv_status_t kdrv_usbd_interrupt_receive(uint32_t endpoint, uint32_t *buf, uint32_t *rxLen, uint32_t timeout_ms)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1789   {
000004  461e              MOV      r6,r3
000006  4614              MOV      r4,r2
000008  4689              MOV      r9,r1
;;;1790       FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
00000a  4d1a              LDR      r5,|L31.116|
;;;1791   
;;;1792       // find out which FIFO no for the IN endpoint address
;;;1793       int8_t fno = endpoint_to_fifo(endpoint);
00000c  f7fffffe          BL       endpoint_to_fifo
;;;1794   
;;;1795       // below do some error checking
;;;1796       {
;;;1797           if (fno == -1)
000010  1c41              ADDS     r1,r0,#1
000012  d009              BEQ      |L31.40|
;;;1798               return KDRV_STATUS_USBD_INVALID_ENDPOINT;
;;;1799   
;;;1800           if (fifo_cb[fno].transferType != TXFER_INT)
000014  eb000180          ADD      r1,r0,r0,LSL #2
000018  eb0501c1          ADD      r1,r5,r1,LSL #3
00001c  7b0a              LDRB     r2,[r1,#0xc]
00001e  2a03              CMP      r2,#3
000020  d004              BEQ      |L31.44|
;;;1801               return KDRV_STATUS_USBD_INVALID_TRANSFER;
000022  2008              MOVS     r0,#8
                  |L31.36|
;;;1802       }
;;;1803   
;;;1804       uint32_t fifo_bytecnt = UsbRegRead(fifo_cb[fno].byteCntReg) & BC_Fn;
;;;1805       // can transfer only minimum size betwwen FIFO byte count and user buffer residual size
;;;1806       uint32_t transfer_size = MIN(fifo_bytecnt, *rxLen);
;;;1807   
;;;1808       uint32_t tryMs = 0;
;;;1809       while (1)
;;;1810       {
;;;1811           if (true == dma_fifo_transfer_sync_try(buf, transfer_size, 0x1 << fno, READ_FIFO, 500))
;;;1812               break;
;;;1813   
;;;1814           if (timeout_ms != 0 && tryMs >= timeout_ms)
;;;1815               return KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
;;;1816   
;;;1817           osDelay(1);
;;;1818           ++tryMs;
;;;1819       }
;;;1820   
;;;1821       return KDRV_STATUS_OK;
;;;1822   }
000024  e8bd83f8          POP      {r3-r9,pc}
                  |L31.40|
000028  2006              MOVS     r0,#6                 ;1798
00002a  e7fb              B        |L31.36|
                  |L31.44|
00002c  6909              LDR      r1,[r1,#0x10]         ;1804
00002e  4a12              LDR      r2,|L31.120|
000030  5889              LDR      r1,[r1,r2]            ;1804
000032  6822              LDR      r2,[r4,#0]            ;1806
000034  f3c1010a          UBFX     r1,r1,#0,#11          ;1804
000038  428a              CMP      r2,r1                 ;1806
00003a  d800              BHI      |L31.62|
00003c  4611              MOV      r1,r2                 ;1806
                  |L31.62|
00003e  2500              MOVS     r5,#0                 ;1808
000040  2401              MOVS     r4,#1                 ;1811
000042  4688              MOV      r8,r1                 ;1806
000044  f44f77fa          MOV      r7,#0x1f4             ;1811
000048  4084              LSLS     r4,r4,r0              ;1811
                  |L31.74|
00004a  4622              MOV      r2,r4                 ;1811
00004c  2300              MOVS     r3,#0                 ;1811
00004e  4641              MOV      r1,r8                 ;1811
000050  4648              MOV      r0,r9                 ;1811
000052  9700              STR      r7,[sp,#0]            ;1811
000054  f7fffffe          BL       dma_fifo_transfer_sync_try
000058  b108              CBZ      r0,|L31.94|
00005a  2000              MOVS     r0,#0                 ;1821
00005c  e7e2              B        |L31.36|
                  |L31.94|
00005e  b11e              CBZ      r6,|L31.104|
000060  42b5              CMP      r5,r6                 ;1814
000062  d301              BCC      |L31.104|
000064  2007              MOVS     r0,#7                 ;1815
000066  e7dd              B        |L31.36|
                  |L31.104|
000068  2001              MOVS     r0,#1                 ;1817
00006a  f7fffffe          BL       osDelay
00006e  1c6d              ADDS     r5,r5,#1              ;1817
000070  e7eb              B        |L31.74|
;;;1823   
                          ENDP

000072  0000              DCW      0x0000
                  |L31.116|
                          DCD      ||.bss||+0x20
                  |L31.120|
                          DCD      0xc0100000

                          AREA ||i.kdrv_usbd_interrupt_send||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_interrupt_send PROC
;;;1746   
;;;1747   kdrv_status_t kdrv_usbd_interrupt_send(uint32_t endpoint, uint32_t *buf, uint32_t txLen, uint32_t timeout_ms)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1748   {
000004  461e              MOV      r6,r3
000006  4690              MOV      r8,r2
000008  4689              MOV      r9,r1
;;;1749       FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
00000a  4c1f              LDR      r4,|L32.136|
;;;1750   
;;;1751       // find out which FIFO no for the IN endpoint address
;;;1752       int8_t fno = endpoint_to_fifo(endpoint);
00000c  f7fffffe          BL       endpoint_to_fifo
;;;1753   
;;;1754       // below do some error checking
;;;1755       {
;;;1756           if (fno == -1)
000010  1c41              ADDS     r1,r0,#1
000012  d009              BEQ      |L32.40|
;;;1757               return KDRV_STATUS_USBD_INVALID_ENDPOINT;
;;;1758   
;;;1759           if (fifo_cb[fno].transferType != TXFER_INT)
000014  eb000180          ADD      r1,r0,r0,LSL #2
000018  eb0404c1          ADD      r4,r4,r1,LSL #3
00001c  7b21              LDRB     r1,[r4,#0xc]
00001e  2903              CMP      r1,#3
000020  d004              BEQ      |L32.44|
;;;1760               return KDRV_STATUS_USBD_INVALID_TRANSFER;
000022  2008              MOVS     r0,#8
                  |L32.36|
;;;1761       }
;;;1762   
;;;1763       // try to wait some time for FIFO empty
;;;1764       // FIXME: 3000 ?
;;;1765       for (uint32_t try = 0; try <= 3000; try ++)
;;;1766           if (UsbRegRead(REG_CXCFE) & (F_EMP_0 << fno))
;;;1767               break;
;;;1768   
;;;1769       // directly clear FIFO content before transmission
;;;1770       UsbRegMaskedSet(fifo_cb[fno].byteCntReg, FFRST);
;;;1771   
;;;1772       uint32_t tryMs = 0;
;;;1773       while (1)
;;;1774       {
;;;1775           if (true == dma_fifo_transfer_sync_try(buf, txLen, 0x1 << fno, WRITE_FIFO, 500))
;;;1776               break;
;;;1777   
;;;1778           if (timeout_ms != 0 && tryMs >= timeout_ms)
;;;1779               return KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
;;;1780   
;;;1781           osDelay(1);
;;;1782           ++tryMs;
;;;1783       }
;;;1784   
;;;1785       return KDRV_STATUS_OK;
;;;1786   }
000024  e8bd83f8          POP      {r3-r9,pc}
                  |L32.40|
000028  2006              MOVS     r0,#6                 ;1757
00002a  e7fb              B        |L32.36|
                  |L32.44|
00002c  2100              MOVS     r1,#0                 ;1765
00002e  4b17              LDR      r3,|L32.140|
000030  f44f7280          MOV      r2,#0x100             ;1766
000034  4082              LSLS     r2,r2,r0              ;1766
000036  f64035b8          MOV      r5,#0xbb8             ;1765
00003a  bf00              NOP                            ;1766
                  |L32.60|
00003c  f8d37120          LDR      r7,[r3,#0x120]        ;1766
000040  4217              TST      r7,r2                 ;1766
000042  d102              BNE      |L32.74|
000044  1c49              ADDS     r1,r1,#1              ;1766
000046  42a9              CMP      r1,r5                 ;1765
000048  d9f8              BLS      |L32.60|
                  |L32.74|
00004a  6921              LDR      r1,[r4,#0x10]         ;1770
00004c  4419              ADD      r1,r1,r3              ;1770
00004e  680a              LDR      r2,[r1,#0]            ;1770
000050  f4425280          ORR      r2,r2,#0x1000         ;1770
000054  600a              STR      r2,[r1,#0]            ;1770
000056  2500              MOVS     r5,#0                 ;1772
000058  2401              MOVS     r4,#1                 ;1775
00005a  f44f77fa          MOV      r7,#0x1f4             ;1775
00005e  4084              LSLS     r4,r4,r0              ;1775
                  |L32.96|
000060  4622              MOV      r2,r4                 ;1775
000062  2301              MOVS     r3,#1                 ;1775
000064  4641              MOV      r1,r8                 ;1775
000066  4648              MOV      r0,r9                 ;1775
000068  9700              STR      r7,[sp,#0]            ;1775
00006a  f7fffffe          BL       dma_fifo_transfer_sync_try
00006e  b108              CBZ      r0,|L32.116|
000070  2000              MOVS     r0,#0                 ;1785
000072  e7d7              B        |L32.36|
                  |L32.116|
000074  b11e              CBZ      r6,|L32.126|
000076  42b5              CMP      r5,r6                 ;1778
000078  d301              BCC      |L32.126|
00007a  2007              MOVS     r0,#7                 ;1779
00007c  e7d2              B        |L32.36|
                  |L32.126|
00007e  2001              MOVS     r0,#1                 ;1781
000080  f7fffffe          BL       osDelay
000084  1c6d              ADDS     r5,r5,#1              ;1781
000086  e7eb              B        |L32.96|
;;;1787   
                          ENDP

                  |L32.136|
                          DCD      ||.bss||+0x20
                  |L32.140|
                          DCD      0xc0100000

                          AREA ||i.kdrv_usbd_is_dev_configured||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_is_dev_configured PROC
;;;1507   
;;;1508   bool kdrv_usbd_is_dev_configured(void)
000000  4803              LDR      r0,|L33.16|
;;;1509   {
;;;1510       if (cb.config_state == CONFIG_CONFIGURED_STATE)
000002  69c0              LDR      r0,[r0,#0x1c]  ; cb
000004  2802              CMP      r0,#2
000006  d001              BEQ      |L33.12|
;;;1511           return true;
;;;1512       else
;;;1513           return false;
000008  2000              MOVS     r0,#0
;;;1514   }
00000a  4770              BX       lr
                  |L33.12|
00000c  2001              MOVS     r0,#1                 ;1511
00000e  4770              BX       lr
;;;1515   
                          ENDP

                  |L33.16|
                          DCD      ||.bss||

                          AREA ||i.kdrv_usbd_register_thread_notification||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_register_thread_notification PROC
;;;1525   
;;;1526   kdrv_status_t kdrv_usbd_register_thread_notification(osThreadId_t tid, uint32_t tflag)
000000  4a02              LDR      r2,|L34.12|
;;;1527   {
;;;1528       cb.notifyTid = tid;
;;;1529       cb.notifyFlag = tflag;
;;;1530       return KDRV_STATUS_OK;
000002  6091              STR      r1,[r2,#8]  ; cb
000004  6010              STR      r0,[r2,#0]  ; cb
000006  2000              MOVS     r0,#0
;;;1531   }
000008  4770              BX       lr
;;;1532   
                          ENDP

00000a  0000              DCW      0x0000
                  |L34.12|
                          DCD      ||.bss||

                          AREA ||i.kdrv_usbd_reset_device||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_reset_device PROC
;;;1432   
;;;1433   kdrv_status_t kdrv_usbd_reset_device()
000000  b570              PUSH     {r4-r6,lr}
;;;1434   {
;;;1435       // if it is not configured, no need to reset
;;;1436       if (!kdrv_usbd_is_dev_configured())
000002  f7fffffe          BL       kdrv_usbd_is_dev_configured
000006  b318              CBZ      r0,|L35.80|
;;;1437           return KDRV_STATUS_ERROR;
;;;1438   
;;;1439       // disable bus
;;;1440       kdrv_usbd_set_enable(false);
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       kdrv_usbd_set_enable
;;;1441   
;;;1442       // first reset all endpoints and terminate all in-progress transfer
;;;1443       FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
00000e  4d11              LDR      r5,|L35.84|
;;;1444       for (int fno = 0; fno < FIFO_NUM; fno++)
000010  f05f0400          MOVS.W   r4,#0
                  |L35.20|
;;;1445           if (fifo_cb[fno].enabled)
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  f8151030          LDRB     r1,[r5,r0,LSL #3]
00001c  b121              CBZ      r1,|L35.40|
;;;1446           {
;;;1447               kdrv_usbd_reset_endpoint(fifo_cb[fno].endpointAddress);
00001e  eb0500c0          ADD      r0,r5,r0,LSL #3
000022  6840              LDR      r0,[r0,#4]
000024  f7fffffe          BL       kdrv_usbd_reset_endpoint
                  |L35.40|
000028  1c64              ADDS     r4,r4,#1
00002a  2c04              CMP      r4,#4                 ;1444
00002c  dbf2              BLT      |L35.20|
;;;1448           }
;;;1449   
;;;1450       // some delay for USB bus, FIXME ?
;;;1451       osDelay(100);
00002e  2064              MOVS     r0,#0x64
000030  f7fffffe          BL       osDelay
;;;1452   
;;;1453       cb.ep0_halted = false;
000034  4907              LDR      r1,|L35.84|
000036  2000              MOVS     r0,#0
000038  3920              SUBS     r1,r1,#0x20
00003a  7308              STRB     r0,[r1,#0xc]
;;;1454       cb.config_state = CONFIG_DEFAULT_STATE;
;;;1455   
;;;1456       // re-init registers and isr
;;;1457       init_reg_isr();
00003c  61c8              STR      r0,[r1,#0x1c]  ; cb
00003e  f7fffffe          BL       init_reg_isr
;;;1458   
;;;1459       reset_event_queue();
000042  f7fffffe          BL       reset_event_queue
;;;1460   
;;;1461       // re-enable bus
;;;1462       kdrv_usbd_set_enable(true);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       kdrv_usbd_set_enable
;;;1463   
;;;1464       return KDRV_STATUS_OK;
00004c  2000              MOVS     r0,#0
;;;1465   }
00004e  bd70              POP      {r4-r6,pc}
                  |L35.80|
000050  2001              MOVS     r0,#1                 ;1437
000052  bd70              POP      {r4-r6,pc}
;;;1466   kdrv_status_t kdrv_usbd_set_string_descriptor(kdrv_usbd_string_descriptor_t *dev_str_desc)
                          ENDP

                  |L35.84|
                          DCD      ||.bss||+0x20

                          AREA ||i.kdrv_usbd_reset_endpoint||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_reset_endpoint PROC
;;;1657   
;;;1658   kdrv_status_t kdrv_usbd_reset_endpoint(uint32_t endpoint)
000000  b570              PUSH     {r4-r6,lr}
;;;1659   {
;;;1660       int8_t fno = endpoint_to_fifo(endpoint);
000002  f7fffffe          BL       endpoint_to_fifo
000006  4606              MOV      r6,r0
;;;1661   
;;;1662       if (fno == -1)
000008  1c40              ADDS     r0,r0,#1
00000a  d011              BEQ      |L36.48|
;;;1663           return KDRV_STATUS_USBD_INVALID_ENDPOINT;
;;;1664   
;;;1665       FIFO_Ctrl *fifo_cb = &cb.fifo_cbs[fno];
00000c  482e              LDR      r0,|L36.200|
00000e  eb060186          ADD      r1,r6,r6,LSL #2
000012  eb0004c1          ADD      r4,r0,r1,LSL #3
;;;1666   
;;;1667       UsbRegMaskedSet(fifo_cb->byteCntReg, FFRST);
000016  4d2d              LDR      r5,|L36.204|
000018  6b21              LDR      r1,[r4,#0x30]
00001a  4429              ADD      r1,r1,r5
00001c  680a              LDR      r2,[r1,#0]
00001e  f4425280          ORR      r2,r2,#0x1000
000022  600a              STR      r2,[r1,#0]
;;;1668   
;;;1669       if (fifo_cb->transferType == TXFER_BULK)
000024  f894102c          LDRB     r1,[r4,#0x2c]
000028  3420              ADDS     r4,r4,#0x20
00002a  2902              CMP      r1,#2
00002c  d002              BEQ      |L36.52|
00002e  e049              B        |L36.196|
                  |L36.48|
000030  2006              MOVS     r0,#6                 ;1663
;;;1670       {
;;;1671           if (fifo_cb->isTransferring)
;;;1672           {
;;;1673               // notify transfer done to user
;;;1674               if (fifo_cb->isBlockingCall)
;;;1675               {
;;;1676                   fifo_cb->cur_event = KDRV_USBD_EVENT_TRANSFER_TERMINATED;
;;;1677                   osEventFlagsSet(cb.evt_id, 0x1 << fno);
;;;1678               }
;;;1679               else
;;;1680               {
;;;1681                   notify_event_to_user(KDRV_USBD_EVENT_TRANSFER_TERMINATED, fifo_cb->endpointAddress, 0);
;;;1682               }
;;;1683               fifo_cb->isTransferring = false;
;;;1684           }
;;;1685   
;;;1686           uint8_t enpNo = fifo_cb->enpNo;
;;;1687           if (fifo_cb->endpointAddress & 0x80)
;;;1688           {
;;;1689               // for IN endpoints
;;;1690               UsbRegMaskedSet(REG_DEV_INMPS_1 + 4 * (enpNo - 1), RSTG_IEPn);
;;;1691               UsbRegMaskedClr(REG_DEV_INMPS_1 + 4 * (enpNo - 1), RSTG_IEPn);
;;;1692               UsbRegMaskedSet(REG_DEV_MISG1, MF0_IN_INT << fno);
;;;1693           }
;;;1694           else
;;;1695           {
;;;1696               // for OUT endpoints
;;;1697               UsbRegMaskedSet(REG_DEV_OUTMPS_1 + 4 * (enpNo - 1), RSTG_OEPn);
;;;1698               UsbRegMaskedClr(REG_DEV_OUTMPS_1 + 4 * (enpNo - 1), RSTG_OEPn);
;;;1699               UsbRegMaskedClr(REG_DEV_MISG1, (MF0_SPK_INT | MF0_OUT_INT) << (fno * 2));
;;;1700           }
;;;1701           clean_fifo_cb(fifo_cb);
;;;1702       }
;;;1703       return KDRV_STATUS_OK;
;;;1704   }
000032  bd70              POP      {r4-r6,pc}
                  |L36.52|
000034  7d21              LDRB     r1,[r4,#0x14]         ;1671
000036  b191              CBZ      r1,|L36.94|
000038  f8941025          LDRB     r1,[r4,#0x25]         ;1674
00003c  b141              CBZ      r1,|L36.80|
00003e  2109              MOVS     r1,#9                 ;1676
000040  f8841026          STRB     r1,[r4,#0x26]         ;1676
000044  2101              MOVS     r1,#1                 ;1677
000046  40b1              LSLS     r1,r1,r6              ;1677
000048  6840              LDR      r0,[r0,#4]            ;1677  ; cb
00004a  f7fffffe          BL       osEventFlagsSet
00004e  e004              B        |L36.90|
                  |L36.80|
000050  2200              MOVS     r2,#0                 ;1681
000052  2009              MOVS     r0,#9                 ;1681
000054  6861              LDR      r1,[r4,#4]            ;1681
000056  f7fffffe          BL       notify_event_to_user
                  |L36.90|
00005a  2000              MOVS     r0,#0                 ;1683
00005c  7520              STRB     r0,[r4,#0x14]         ;1683
                  |L36.94|
00005e  7860              LDRB     r0,[r4,#1]            ;1686
000060  7921              LDRB     r1,[r4,#4]            ;1687
000062  eb050080          ADD      r0,r5,r0,LSL #2       ;1697
000066  0609              LSLS     r1,r1,#24             ;1687
000068  d515              BPL      |L36.150|
00006a  f8d0115c          LDR      r1,[r0,#0x15c]        ;1690
00006e  f4415180          ORR      r1,r1,#0x1000         ;1690
000072  f8c0115c          STR      r1,[r0,#0x15c]        ;1690
000076  f8d0115c          LDR      r1,[r0,#0x15c]        ;1691
00007a  f4215180          BIC      r1,r1,#0x1000         ;1691
00007e  f8c0115c          STR      r1,[r0,#0x15c]        ;1691
000082  f8d51138          LDR      r1,[r5,#0x138]        ;1692
000086  f44f3080          MOV      r0,#0x10000           ;1692
00008a  40b0              LSLS     r0,r0,r6              ;1692
00008c  4381              BICS     r1,r1,r0              ;1692
00008e  4301              ORRS     r1,r1,r0              ;1692
000090  f8c51138          STR      r1,[r5,#0x138]        ;1692
000094  e013              B        |L36.190|
                  |L36.150|
000096  f8d0117c          LDR      r1,[r0,#0x17c]        ;1697
00009a  f4415180          ORR      r1,r1,#0x1000         ;1697
00009e  f8c0117c          STR      r1,[r0,#0x17c]        ;1697
0000a2  f8d0117c          LDR      r1,[r0,#0x17c]        ;1698
0000a6  f4215180          BIC      r1,r1,#0x1000         ;1698
0000aa  f8c0117c          STR      r1,[r0,#0x17c]        ;1698
0000ae  f8d50138          LDR      r0,[r5,#0x138]        ;1699
0000b2  0072              LSLS     r2,r6,#1              ;1699
0000b4  2103              MOVS     r1,#3                 ;1699
0000b6  4091              LSLS     r1,r1,r2              ;1699
0000b8  4388              BICS     r0,r0,r1              ;1699
0000ba  f8c50138          STR      r0,[r5,#0x138]        ;1699
                  |L36.190|
0000be  4620              MOV      r0,r4                 ;1701
0000c0  f7fffffe          BL       clean_fifo_cb
                  |L36.196|
0000c4  2000              MOVS     r0,#0                 ;1703
0000c6  bd70              POP      {r4-r6,pc}
;;;1705   
                          ENDP

                  |L36.200|
                          DCD      ||.bss||
                  |L36.204|
                          DCD      0xc0100000

                          AREA ||i.kdrv_usbd_set_device_descriptor||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_set_device_descriptor PROC
;;;1471   
;;;1472   kdrv_status_t kdrv_usbd_set_device_descriptor(
000000  b910              CBNZ     r0,|L37.8|
;;;1473       kdrv_usbd_speed_t speed,
;;;1474       kdrv_usbd_device_descriptor_t *dev_desc)
;;;1475   {
;;;1476       // for now support high speed only, FIXME
;;;1477       if (speed != KDRV_USBD_HIGH_SPEED)
;;;1478           return KDRV_STATUS_ERROR;
;;;1479   
;;;1480       if (dev_desc->bNumConfigurations > 1)
000002  7c48              LDRB     r0,[r1,#0x11]
000004  2801              CMP      r0,#1
000006  d901              BLS      |L37.12|
                  |L37.8|
;;;1481           return KDRV_STATUS_ERROR;
000008  2001              MOVS     r0,#1
;;;1482   
;;;1483       cb.dev_desc = dev_desc;
;;;1484   
;;;1485       return KDRV_STATUS_OK;
;;;1486   }
00000a  4770              BX       lr
                  |L37.12|
00000c  4801              LDR      r0,|L37.20|
00000e  6101              STR      r1,[r0,#0x10]         ;1485  ; cb
000010  2000              MOVS     r0,#0                 ;1485
000012  4770              BX       lr
;;;1487   
                          ENDP

                  |L37.20|
                          DCD      ||.bss||

                          AREA ||i.kdrv_usbd_set_device_qualifier_descriptor||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_set_device_qualifier_descriptor PROC
;;;1487   
;;;1488   kdrv_status_t kdrv_usbd_set_device_qualifier_descriptor(
000000  4801              LDR      r0,|L38.8|
;;;1489       kdrv_usbd_speed_t speed,
;;;1490       kdrv_usbd_device_qualifier_descriptor_t *dev_qual_desc)
;;;1491   {
;;;1492       cb.dev_qual_desc = dev_qual_desc;
;;;1493       return KDRV_STATUS_OK;
000002  6141              STR      r1,[r0,#0x14]  ; cb
000004  2000              MOVS     r0,#0
;;;1494   }
000006  4770              BX       lr
;;;1495   
                          ENDP

                  |L38.8|
                          DCD      ||.bss||

                          AREA ||i.kdrv_usbd_set_enable||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_set_enable PROC
;;;1495   
;;;1496   kdrv_status_t kdrv_usbd_set_enable(bool enable)
000000  4906              LDR      r1,|L39.28|
;;;1497   {
;;;1498       if (enable)
000002  2800              CMP      r0,#0
;;;1499           // Make PHY work properly, FIXME ?
;;;1500           UsbRegMaskedClr(REG_PHY_TST, TST_JSTA);
;;;1501       else
;;;1502           // Make PHY not work, FIXME ?
;;;1503           UsbRegMaskedSet(REG_PHY_TST, TST_JSTA);
000004  f8d10114          LDR      r0,[r1,#0x114]
000008  d002              BEQ      |L39.16|
00000a  f0200001          BIC      r0,r0,#1              ;1500
00000e  e001              B        |L39.20|
                  |L39.16|
000010  f0400001          ORR      r0,r0,#1
                  |L39.20|
000014  f8c10114          STR      r0,[r1,#0x114]
;;;1504   
;;;1505       return KDRV_STATUS_OK;
000018  2000              MOVS     r0,#0
;;;1506   }
00001a  4770              BX       lr
;;;1507   
                          ENDP

                  |L39.28|
                          DCD      0xc0100000

                          AREA ||i.kdrv_usbd_set_string_descriptor||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_set_string_descriptor PROC
;;;1465   }
;;;1466   kdrv_status_t kdrv_usbd_set_string_descriptor(kdrv_usbd_string_descriptor_t *dev_str_desc)
000000  4901              LDR      r1,|L40.8|
;;;1467   {
;;;1468       cb.dev_string_desc = dev_str_desc;
;;;1469       return KDRV_STATUS_OK;
000002  6188              STR      r0,[r1,#0x18]  ; cb
000004  2000              MOVS     r0,#0
;;;1470   }
000006  4770              BX       lr
;;;1471   
                          ENDP

                  |L40.8|
                          DCD      ||.bss||

                          AREA ||i.kdrv_usbd_uninitialize||, CODE, READONLY, ALIGN=2

                  kdrv_usbd_uninitialize PROC
;;;1423   
;;;1424   kdrv_status_t kdrv_usbd_uninitialize(void)
000000  b570              PUSH     {r4-r6,lr}
000002  4c09              LDR      r4,|L41.40|
;;;1425   {
000004  68a0              LDR      r0,[r4,#8]  ; empty_id
000006  b108              CBZ      r0,|L41.12|
000008  f7fffffe          BL       osSemaphoreRelease
                  |L41.12|
00000c  2500              MOVS     r5,#0
00000e  60a5              STR      r5,[r4,#8]  ; empty_id
000010  68e0              LDR      r0,[r4,#0xc]  ; filled_id
000012  b108              CBZ      r0,|L41.24|
000014  f7fffffe          BL       osSemaphoreRelease
                  |L41.24|
;;;1426       clean_event_queue();
;;;1427   
;;;1428       osEventFlagsDelete(cb.evt_id);
000018  4804              LDR      r0,|L41.44|
00001a  60e5              STR      r5,[r4,#0xc]  ; filled_id
00001c  6840              LDR      r0,[r0,#4]  ; cb
00001e  f7fffffe          BL       osEventFlagsDelete
;;;1429   
;;;1430       return KDRV_STATUS_OK;
000022  2000              MOVS     r0,#0
;;;1431   }
000024  bd70              POP      {r4-r6,pc}
;;;1432   
                          ENDP

000026  0000              DCW      0x0000
                  |L41.40|
                          DCD      ||.data||
                  |L41.44|
                          DCD      ||.bss||

                          AREA ||i.notify_event_to_user||, CODE, READONLY, ALIGN=2

                  notify_event_to_user PROC
;;;496    // put usb events to an event queue and notify user via thread flag
;;;497    static void notify_event_to_user(kdrv_usbd_event_name_t ename, uint32_t data1, uint32_t data2)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;498    {
000004  4c13              LDR      r4,|L42.84|
000006  f3600507          BFI      r5,r0,#0,#8
;;;499        kdrv_usbd_event_t uevent;
;;;500        uevent.ename = ename;
;;;501        uevent.data1 = data1;
00000a  460e              MOV      r6,r1
;;;502        uevent.data2 = data2;
00000c  4617              MOV      r7,r2
00000e  2100              MOVS     r1,#0
000010  68a0              LDR      r0,[r4,#8]  ; empty_id
000012  f7fffffe          BL       osSemaphoreAcquire
000016  b980              CBNZ     r0,|L42.58|
000018  6820              LDR      r0,[r4,#0]  ; eqWriteIdx
00001a  4a0f              LDR      r2,|L42.88|
00001c  eb000140          ADD      r1,r0,r0,LSL #1
000020  eb020181          ADD      r1,r2,r1,LSL #2
000024  1c40              ADDS     r0,r0,#1
000026  e88100e0          STM      r1,{r5-r7}
00002a  6020              STR      r0,[r4,#0]  ; eqWriteIdx
00002c  281e              CMP      r0,#0x1e
00002e  db01              BLT      |L42.52|
000030  2000              MOVS     r0,#0
000032  6020              STR      r0,[r4,#0]  ; eqWriteIdx
                  |L42.52|
000034  68e0              LDR      r0,[r4,#0xc]  ; filled_id
000036  f7fffffe          BL       osSemaphoreRelease
                  |L42.58|
;;;503        push_event_to_queue(uevent);
;;;504    
;;;505        if (cb.notifyTid)
00003a  4907              LDR      r1,|L42.88|
00003c  39c0              SUBS     r1,r1,#0xc0
00003e  6808              LDR      r0,[r1,#0]  ; cb
000040  2800              CMP      r0,#0
000042  d004              BEQ      |L42.78|
;;;506            osThreadFlagsSet(cb.notifyTid, cb.notifyFlag);
000044  6889              LDR      r1,[r1,#8]  ; cb
000046  e8bd41f0          POP      {r4-r8,lr}
00004a  f7ffbffe          B.W      osThreadFlagsSet
                  |L42.78|
;;;507    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;508    
                          ENDP

000052  0000              DCW      0x0000
                  |L42.84|
                          DCD      ||.data||
                  |L42.88|
                          DCD      ||.bss||+0xc0

                          AREA ||i.pop_event_from_queue||, CODE, READONLY, ALIGN=2

                  pop_event_from_queue PROC
;;;477    
;;;478    static int pop_event_from_queue(kdrv_usbd_event_t *event)
000000  b570              PUSH     {r4-r6,lr}
;;;479    {
;;;480        osStatus_t sts;
;;;481    
;;;482        sts = osSemaphoreAcquire(filled_id, 0);
000002  4c0e              LDR      r4,|L43.60|
000004  4605              MOV      r5,r0                 ;479
000006  2100              MOVS     r1,#0
000008  68e0              LDR      r0,[r4,#0xc]  ; filled_id
00000a  f7fffffe          BL       osSemaphoreAcquire
;;;483        // queue is empty
;;;484        if (sts != osOK)
00000e  b108              CBZ      r0,|L43.20|
;;;485            return 0;
000010  2000              MOVS     r0,#0
;;;486    
;;;487        *event = event_queue[eqReadIdx];
;;;488        ++eqReadIdx;
;;;489        if (eqReadIdx >= QLEN)
;;;490            eqReadIdx = 0;
;;;491    
;;;492        osSemaphoreRelease(empty_id);
;;;493        return 1;
;;;494    }
000012  bd70              POP      {r4-r6,pc}
                  |L43.20|
000014  6861              LDR      r1,[r4,#4]            ;487  ; eqReadIdx
000016  4a0a              LDR      r2,|L43.64|
000018  eb010041          ADD      r0,r1,r1,LSL #1       ;487
00001c  eb020080          ADD      r0,r2,r0,LSL #2       ;487
000020  1c49              ADDS     r1,r1,#1              ;487
000022  c80d              LDM      r0,{r0,r2,r3}         ;487
000024  e885000d          STM      r5,{r0,r2,r3}         ;487
000028  6061              STR      r1,[r4,#4]            ;489  ; eqReadIdx
00002a  291e              CMP      r1,#0x1e              ;489
00002c  db01              BLT      |L43.50|
00002e  2000              MOVS     r0,#0                 ;490
000030  6060              STR      r0,[r4,#4]            ;490  ; eqReadIdx
                  |L43.50|
000032  68a0              LDR      r0,[r4,#8]            ;492  ; empty_id
000034  f7fffffe          BL       osSemaphoreRelease
000038  2001              MOVS     r0,#1                 ;493
00003a  bd70              POP      {r4-r6,pc}
;;;495    
                          ENDP

                  |L43.60|
                          DCD      ||.data||
                  |L43.64|
                          DCD      ||.bss||+0xc0

                          AREA ||i.reset_event_queue||, CODE, READONLY, ALIGN=2

                  reset_event_queue PROC
;;;427    /* this function must not be used in ISR */
;;;428    static void reset_event_queue()
000000  b570              PUSH     {r4-r6,lr}
;;;429    {
;;;430        osStatus_t sts = osOK;
;;;431    
;;;432        if (empty_id != 0)
000002  4d0f              LDR      r5,|L44.64|
000004  2400              MOVS     r4,#0                 ;430
000006  68a8              LDR      r0,[r5,#8]            ;429  ; empty_id
000008  b118              CBZ      r0,|L44.18|
;;;433            sts = osSemaphoreRelease(empty_id);
00000a  f7fffffe          BL       osSemaphoreRelease
00000e  0004              MOVS     r4,r0
000010  d105              BNE      |L44.30|
                  |L44.18|
;;;434    
;;;435        if (sts == osOK)
;;;436            empty_id = osSemaphoreNew(QLEN, QLEN, NULL);
000012  211e              MOVS     r1,#0x1e
000014  2200              MOVS     r2,#0
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       osSemaphoreNew
00001c  60a8              STR      r0,[r5,#8]  ; empty_id
                  |L44.30|
;;;437    
;;;438        if (filled_id != 0)
00001e  68e8              LDR      r0,[r5,#0xc]  ; filled_id
000020  b110              CBZ      r0,|L44.40|
;;;439            sts = osSemaphoreRelease(filled_id);
000022  f7fffffe          BL       osSemaphoreRelease
000026  4604              MOV      r4,r0
                  |L44.40|
;;;440    
;;;441        if (sts == osOK)
000028  b92c              CBNZ     r4,|L44.54|
;;;442            filled_id = osSemaphoreNew(QLEN, 0, NULL);
00002a  2200              MOVS     r2,#0
00002c  4611              MOV      r1,r2
00002e  201e              MOVS     r0,#0x1e
000030  f7fffffe          BL       osSemaphoreNew
000034  60e8              STR      r0,[r5,#0xc]  ; filled_id
                  |L44.54|
;;;443    
;;;444        // reset read/write indices
;;;445        eqWriteIdx = 0;
000036  2000              MOVS     r0,#0
;;;446        eqReadIdx = 0;
000038  6028              STR      r0,[r5,#0]  ; eqWriteIdx
00003a  6068              STR      r0,[r5,#4]  ; eqReadIdx
;;;447    }
00003c  bd70              POP      {r4-r6,pc}
;;;448    
                          ENDP

00003e  0000              DCW      0x0000
                  |L44.64|
                          DCD      ||.data||

                          AREA ||i.send_host_configuration_descriptors||, CODE, READONLY, ALIGN=2

                  send_host_configuration_descriptors PROC
;;;896    
;;;897    static int8_t send_host_configuration_descriptors(kdrv_usbd_setup_packet_t *setup)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;898    {
000004  4604              MOV      r4,r0
;;;899        kdrv_usbd_device_descriptor_t *dev_desc = cb.dev_desc;
000006  482c              LDR      r0,|L45.184|
;;;900        uint32_t confIdx = setup->wValue & 0xFF;
000008  6901              LDR      r1,[r0,#0x10]  ; cb
00000a  78a0              LDRB     r0,[r4,#2]
00000c  b119              CBZ      r1,|L45.22|
;;;901    
;;;902        // some error checking
;;;903        if (!dev_desc ||
;;;904            dev_desc->bNumConfigurations > MAX_USBD_CONFIG ||
00000e  7c4a              LDRB     r2,[r1,#0x11]
000010  2a01              CMP      r2,#1
000012  d800              BHI      |L45.22|
;;;905            confIdx >= MAX_USBD_CONFIG)
000014  b110              CBZ      r0,|L45.28|
                  |L45.22|
;;;906        {
;;;907            return RESP_STALL;
000016  2003              MOVS     r0,#3
                  |L45.24|
;;;908        }
;;;909    
;;;910        kdrv_usbd_config_descriptor_t *conf_desc = dev_desc->config[confIdx];
;;;911    
;;;912        // create an temp buffer for combining all sub-descriptors
;;;913        uint8_t *buf_desc = malloc(conf_desc->wTotalLength);
;;;914    
;;;915        uint16_t txLen = MIN(conf_desc->wTotalLength, setup->wLength);
;;;916    
;;;917        // collect all sub-descriptos int one memory
;;;918        uint8_t offset = 0;
;;;919        memcpy(buf_desc, conf_desc, conf_desc->bLength);
;;;920        offset += conf_desc->bLength;
;;;921    
;;;922        for (int i = 0; i < conf_desc->bNumInterfaces; i++)
;;;923        {
;;;924            kdrv_usbd_interface_descriptor_t *intf_desc = conf_desc->interface[i];
;;;925            memcpy(buf_desc + offset, intf_desc, intf_desc->bLength);
;;;926            offset += intf_desc->bLength;
;;;927            for (int j = 0; j < intf_desc->bNumEndpoints; j++)
;;;928            {
;;;929                kdrv_usbd_endpoint_descriptor_t *endp_desc = intf_desc->endpoint[j];
;;;930                memcpy(buf_desc + offset, endp_desc, endp_desc->bLength);
;;;931                offset += endp_desc->bLength;
;;;932            }
;;;933        }
;;;934    
;;;935        bool sts = dma_fifo_transfer_sync_try((uint32_t *)buf_desc, txLen, DMA_TARGET_ACC_CXF, WRITE_FIFO, 50);
;;;936    
;;;937        free(buf_desc);
;;;938    
;;;939        if (sts)
;;;940            return RESP_ACK;
;;;941        else
;;;942            return RESP_NACK;
;;;943    }
000018  e8bd8ff8          POP      {r3-r11,pc}
                  |L45.28|
00001c  f8d15012          LDR      r5,[r1,#0x12]         ;910
000020  8868              LDRH     r0,[r5,#2]            ;913
000022  f7fffffe          BL       malloc
000026  4682              MOV      r10,r0                ;913
000028  8869              LDRH     r1,[r5,#2]            ;915
00002a  88e0              LDRH     r0,[r4,#6]            ;915
00002c  4281              CMP      r1,r0                 ;915
00002e  d300              BCC      |L45.50|
000030  4601              MOV      r1,r0                 ;915
                  |L45.50|
000032  468b              MOV      r11,r1                ;915
000034  782a              LDRB     r2,[r5,#0]            ;919
000036  4629              MOV      r1,r5                 ;919
000038  4650              MOV      r0,r10                ;919
00003a  f7fffffe          BL       __aeabi_memcpy
00003e  782c              LDRB     r4,[r5,#0]            ;920
000040  2000              MOVS     r0,#0                 ;922
000042  e024              B        |L45.142|
                  |L45.68|
000044  eb050088          ADD      r0,r5,r8,LSL #2       ;924
000048  f8d06009          LDR      r6,[r0,#9]            ;924
00004c  eb0a0004          ADD      r0,r10,r4             ;925
000050  4631              MOV      r1,r6                 ;925
000052  7832              LDRB     r2,[r6,#0]            ;925
000054  f7fffffe          BL       __aeabi_memcpy
000058  7830              LDRB     r0,[r6,#0]            ;926
00005a  2700              MOVS     r7,#0                 ;927
00005c  4420              ADD      r0,r0,r4              ;926
00005e  b2c4              UXTB     r4,r0                 ;926
000060  e010              B        |L45.132|
000062  bf00              NOP                            ;929
                  |L45.100|
000064  eb060087          ADD      r0,r6,r7,LSL #2       ;929
000068  f8d09009          LDR      r9,[r0,#9]            ;929
00006c  eb0a0004          ADD      r0,r10,r4             ;930
000070  4649              MOV      r1,r9                 ;930
000072  f8992000          LDRB     r2,[r9,#0]            ;930
000076  f7fffffe          BL       __aeabi_memcpy
00007a  f8990000          LDRB     r0,[r9,#0]            ;931
00007e  1c7f              ADDS     r7,r7,#1              ;931
000080  4420              ADD      r0,r0,r4              ;931
000082  b2c4              UXTB     r4,r0                 ;931
                  |L45.132|
000084  7930              LDRB     r0,[r6,#4]            ;927
000086  42b8              CMP      r0,r7                 ;927
000088  dcec              BGT      |L45.100|
00008a  f1080001          ADD      r0,r8,#1              ;922
                  |L45.142|
00008e  7929              LDRB     r1,[r5,#4]            ;922
000090  4680              MOV      r8,r0                 ;922
000092  4541              CMP      r1,r8                 ;922
000094  dcd6              BGT      |L45.68|
000096  2032              MOVS     r0,#0x32              ;935
000098  9000              STR      r0,[sp,#0]            ;935
00009a  2301              MOVS     r3,#1                 ;935
00009c  2210              MOVS     r2,#0x10              ;935
00009e  4659              MOV      r1,r11                ;935
0000a0  4650              MOV      r0,r10                ;935
0000a2  f7fffffe          BL       dma_fifo_transfer_sync_try
0000a6  4604              MOV      r4,r0                 ;935
0000a8  4650              MOV      r0,r10                ;937
0000aa  f7fffffe          BL       free
0000ae  b10c              CBZ      r4,|L45.180|
0000b0  2002              MOVS     r0,#2                 ;940
0000b2  e7b1              B        |L45.24|
                  |L45.180|
0000b4  2001              MOVS     r0,#1                 ;942
0000b6  e7af              B        |L45.24|
;;;944    
                          ENDP

                  |L45.184|
                          DCD      ||.bss||

                          AREA ||i.send_host_string_descriptor||, CODE, READONLY, ALIGN=2

                  send_host_string_descriptor PROC
;;;831    
;;;832    static int8_t send_host_string_descriptor(kdrv_usbd_setup_packet_t *setup,uint8_t type)
000000  b538              PUSH     {r3-r5,lr}
;;;833    {
000002  4602              MOV      r2,r0
;;;834        kdrv_usbd_string_descriptor_t* desc=cb.dev_string_desc;
000004  4814              LDR      r0,|L46.88|
000006  6980              LDR      r0,[r0,#0x18]  ; cb
;;;835    
;;;836        kdrv_usbd_prd_string_descriptor_t** desc_str=&cb.dev_string_desc->desc[0];
000008  1d03              ADDS     r3,r0,#4
;;;837    
;;;838        uint16_t txLen =0;
;;;839        bool sts=false;
;;;840        if(type==0)//language id
;;;841        {
;;;842            txLen = MIN(desc->bLength, setup->wLength);
;;;843            sts = dma_fifo_transfer_sync_try((uint32_t *)desc, txLen, DMA_TARGET_ACC_CXF, WRITE_FIFO, 50);
00000a  2432              MOVS     r4,#0x32
00000c  b131              CBZ      r1,|L46.28|
;;;844        }
;;;845        else if(type==1 || type==2 || type==3)//iManufacturer,iProduct,iSerialNumber
00000e  2901              CMP      r1,#1
000010  d00d              BEQ      |L46.46|
000012  2902              CMP      r1,#2
000014  d00b              BEQ      |L46.46|
000016  2903              CMP      r1,#3
000018  d009              BEQ      |L46.46|
00001a  e01a              B        |L46.82|
                  |L46.28|
00001c  7801              LDRB     r1,[r0,#0]            ;842
00001e  88d2              LDRH     r2,[r2,#6]            ;842
000020  4291              CMP      r1,r2                 ;842
000022  d300              BCC      |L46.38|
000024  4611              MOV      r1,r2                 ;842
                  |L46.38|
000026  2301              MOVS     r3,#1                 ;843
000028  2210              MOVS     r2,#0x10              ;843
00002a  9400              STR      r4,[sp,#0]            ;843
00002c  e00c              B        |L46.72|
                  |L46.46|
;;;846        {
;;;847            txLen = MIN(desc_str[type-1]->bLength, setup->wLength);
00002e  eb030081          ADD      r0,r3,r1,LSL #2
000032  f8505c04          LDR      r5,[r0,#-4]
000036  88d0              LDRH     r0,[r2,#6]
000038  7829              LDRB     r1,[r5,#0]
00003a  4281              CMP      r1,r0
00003c  d300              BCC      |L46.64|
00003e  4601              MOV      r1,r0
                  |L46.64|
;;;848            sts = dma_fifo_transfer_sync_try((uint32_t *)desc_str[type-1], txLen, DMA_TARGET_ACC_CXF, WRITE_FIFO, 50);
000040  2301              MOVS     r3,#1
000042  2210              MOVS     r2,#0x10
000044  4628              MOV      r0,r5
000046  9400              STR      r4,[sp,#0]
                  |L46.72|
000048  f7fffffe          BL       dma_fifo_transfer_sync_try
00004c  b108              CBZ      r0,|L46.82|
;;;849        }
;;;850    
;;;851        if (sts)
;;;852        {
;;;853            return RESP_ACK;
00004e  2002              MOVS     r0,#2
;;;854        }
;;;855        else
;;;856        {
;;;857            return RESP_NACK;
;;;858        }
;;;859    }
000050  bd38              POP      {r3-r5,pc}
                  |L46.82|
000052  2001              MOVS     r0,#1                 ;857
000054  bd38              POP      {r3-r5,pc}
;;;860    
                          ENDP

000056  0000              DCW      0x0000
                  |L46.88|
                          DCD      ||.bss||

                          AREA ||i.set_configuration||, CODE, READONLY, ALIGN=2

                  set_configuration PROC
;;;1045   
;;;1046   static int8_t set_configuration(kdrv_usbd_setup_packet_t *setup)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1047   {
;;;1048       int8_t resp = RESP_STALL;
;;;1049   
;;;1050       uint8_t config_val = setup->wValue & 0xFF;
000004  7880              LDRB     r0,[r0,#2]
000006  2503              MOVS     r5,#3                 ;1048
;;;1051       if (config_val == 0)
;;;1052       {
;;;1053           cb.config_state = CONFIG_ADDRESS_STATE;
000008  4b1a              LDR      r3,|L47.116|
00000a  f01004ff          ANDS     r4,r0,#0xff           ;1050
00000e  d005              BEQ      |L47.28|
000010  4618              MOV      r0,r3
;;;1054           // clear configuration set bit
;;;1055           UsbRegMaskedClr(REG_DEV_ADR, AFT_CONF);
;;;1056           resp = RESP_ACK;
;;;1057   
;;;1058           // FIXME clear FIFO-endpoint mapping ?
;;;1059       }
;;;1060       else
;;;1061       {
;;;1062           kdrv_usbd_config_descriptor_t *config;
;;;1063   
;;;1064           // compare with all configuration descriptos
;;;1065           for (int i = 0; i < cb.dev_desc->bNumConfigurations; i++)
000012  2200              MOVS     r2,#0
000014  6901              LDR      r1,[r0,#0x10]
;;;1066           {
;;;1067               config = cb.dev_desc->config[i];
000016  2712              MOVS     r7,#0x12
000018  7c4e              LDRB     r6,[r1,#0x11]         ;1065
00001a  e01b              B        |L47.84|
                  |L47.28|
00001c  2001              MOVS     r0,#1                 ;1053
00001e  61d8              STR      r0,[r3,#0x1c]         ;1055  ; cb
000020  4815              LDR      r0,|L47.120|
000022  f8d01104          LDR      r1,[r0,#0x104]        ;1055
000026  f0210180          BIC      r1,r1,#0x80           ;1055
00002a  f8c01104          STR      r1,[r0,#0x104]        ;1055
00002e  2502              MOVS     r5,#2                 ;1056
000030  e01c              B        |L47.108|
000032  bf00              NOP      
                  |L47.52|
000034  eb070082          ADD      r0,r7,r2,LSL #2
000038  4408              ADD      r0,r0,r1
00003a  6800              LDR      r0,[r0,#0]
;;;1068               if (config->bConfigurationValue == config_val)
00003c  f890c005          LDRB     r12,[r0,#5]
000040  45a4              CMP      r12,r4
000042  d106              BNE      |L47.82|
;;;1069               {
;;;1070                   cb.config_state = CONFIG_CONFIGURED_STATE;
000044  2102              MOVS     r1,#2
;;;1071                   resp = RESP_ACK;
000046  460d              MOV      r5,r1
;;;1072                   break;
;;;1073               }
;;;1074           }
;;;1075   
;;;1076           // FIXME? for only-one interface, should set up FIFO-endpont mapping now
;;;1077           if (resp == RESP_ACK && config->bNumInterfaces == 1)
000048  61d9              STR      r1,[r3,#0x1c]  ; cb
00004a  7901              LDRB     r1,[r0,#4]
00004c  2901              CMP      r1,#1
00004e  d004              BEQ      |L47.90|
000050  e007              B        |L47.98|
                  |L47.82|
000052  1c52              ADDS     r2,r2,#1              ;1072
                  |L47.84|
000054  4296              CMP      r6,r2                 ;1065
000056  dced              BGT      |L47.52|
000058  e008              B        |L47.108|
                  |L47.90|
;;;1078               init_fifo_configurations(config->interface[0]);
00005a  f8d00009          LDR      r0,[r0,#9]
00005e  f7fffffe          BL       init_fifo_configurations
                  |L47.98|
;;;1079   
;;;1080           if (resp == RESP_ACK)
;;;1081               notify_event_to_user(KDRV_USBD_EVENT_DEV_CONFIGURED, config_val, 0);
000062  2200              MOVS     r2,#0
000064  4621              MOV      r1,r4
000066  2005              MOVS     r0,#5
000068  f7fffffe          BL       notify_event_to_user
                  |L47.108|
;;;1082       }
;;;1083   
;;;1084       return resp;
00006c  4628              MOV      r0,r5
;;;1085   }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;1086   
                          ENDP

000072  0000              DCW      0x0000
                  |L47.116|
                          DCD      ||.bss||
                  |L47.120|
                          DCD      0xc0100000

                          AREA ||i.usbd_isr||, CODE, READONLY, ALIGN=1

                  usbd_isr PROC
;;;1256   // USB ISR
;;;1257   static void usbd_isr(void)
000000  f7ffbffe          B.W      handle_device_interrupts
;;;1258   {
;;;1259       handle_device_interrupts();
;;;1260   }
;;;1261   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||cb||
                          %        192
                  event_queue
                          %        360

                          AREA ||.data||, DATA, ALIGN=2

                  eqWriteIdx
                          DCD      0x00000000
                  eqReadIdx
                          DCD      0x00000000
                  empty_id
                          DCD      0x00000000
                  filled_id
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\scpu\\drivers\\src\\kdp520_usbd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_kdp520_usbd_c_cb____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___13_kdp520_usbd_c_cb____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_kdp520_usbd_c_cb____REVSH|
#line 223
|__asm___13_kdp520_usbd_c_cb____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_kdp520_usbd_c_cb____RRX|
#line 410
|__asm___13_kdp520_usbd_c_cb____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
