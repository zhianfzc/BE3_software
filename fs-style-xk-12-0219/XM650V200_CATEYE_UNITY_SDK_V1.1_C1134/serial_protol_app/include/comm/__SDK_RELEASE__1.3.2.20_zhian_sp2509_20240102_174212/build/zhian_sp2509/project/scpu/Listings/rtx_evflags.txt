; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\rtx_evflags.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\rtx_evflags.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\rtx_evflags.crf F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_evflags.c]
                          THUMB

                          AREA ||i.EventFlagsCheck||, CODE, READONLY, ALIGN=1

                  EventFlagsCheck PROC
;;;95     /// \return event flags before clearing or 0 if specified flags have not been set.
;;;96     static uint32_t EventFlagsCheck (os_event_flags_t *ef, uint32_t flags, uint32_t options) {
000000  0793              LSLS     r3,r2,#30
000002  d407              BMI      |L1.20|
;;;97     #if (EXCLUSIVE_ACCESS == 0)
;;;98       uint32_t primask;
;;;99     #endif
;;;100      uint32_t event_flags;
;;;101    
;;;102      if ((options & osFlagsNoClear) == 0U) {
;;;103    #if (EXCLUSIVE_ACCESS == 0)
;;;104        primask = __get_PRIMASK();
;;;105        __disable_irq();
;;;106    
;;;107        event_flags = ef->event_flags;
;;;108        if ((((options & osFlagsWaitAll) != 0U) && ((event_flags & flags) != flags)) ||
;;;109            (((options & osFlagsWaitAll) == 0U) && ((event_flags & flags) == 0U))) {
;;;110          event_flags = 0U;
;;;111        } else {
;;;112          ef->event_flags &= ~flags;
;;;113        }
;;;114    
;;;115        if (primask == 0U) {
;;;116          __enable_irq();
;;;117        }
;;;118    #else
;;;119        if ((options & osFlagsWaitAll) != 0U) {
000004  07d2              LSLS     r2,r2,#31
000006  f100000c          ADD      r0,r0,#0xc
00000a  d001              BEQ      |L1.16|
;;;120          event_flags = atomic_chk32_all(&ef->event_flags, flags);
00000c  f7ffbffe          B.W      __asm___13_rtx_evflags_c_ab3a5ffb__atomic_chk32_all
                  |L1.16|
;;;121        } else {
;;;122          event_flags = atomic_chk32_any(&ef->event_flags, flags);
000010  f7ffbffe          B.W      __asm___13_rtx_evflags_c_ab3a5ffb__atomic_chk32_any
                  |L1.20|
;;;123        }
;;;124    #endif
;;;125      } else {
;;;126        event_flags = ef->event_flags;
000014  68c0              LDR      r0,[r0,#0xc]
;;;127        if ((((options & osFlagsWaitAll) != 0U) && ((event_flags & flags) != flags)) ||
000016  07d3              LSLS     r3,r2,#31
000018  d002              BEQ      |L1.32|
00001a  ea310300          BICS     r3,r1,r0
00001e  d104              BNE      |L1.42|
                  |L1.32|
;;;128            (((options & osFlagsWaitAll) == 0U) && ((event_flags & flags) == 0U))) {
000020  f0020201          AND      r2,r2,#1
000024  4001              ANDS     r1,r1,r0
000026  430a              ORRS     r2,r2,r1
000028  d100              BNE      |L1.44|
                  |L1.42|
;;;129          event_flags = 0U;
00002a  2000              MOVS     r0,#0
                  |L1.44|
;;;130        }
;;;131      }
;;;132    
;;;133      return event_flags;
;;;134    }
00002c  4770              BX       lr
;;;135    
                          ENDP


                          AREA ||i.EventFlagsSet||, CODE, READONLY, ALIGN=1

                  EventFlagsSet PROC
;;;42     /// \return event flags after setting.
;;;43     static uint32_t EventFlagsSet (os_event_flags_t *ef, uint32_t flags) {
000000  300c              ADDS     r0,r0,#0xc
;;;44     #if (EXCLUSIVE_ACCESS == 0)
;;;45       uint32_t primask = __get_PRIMASK();
;;;46     #endif
;;;47       uint32_t event_flags;
;;;48     
;;;49     #if (EXCLUSIVE_ACCESS == 0)
;;;50       __disable_irq();
;;;51     
;;;52       ef->event_flags |= flags;
;;;53       event_flags = ef->event_flags;
;;;54     
;;;55       if (primask == 0U) {
;;;56         __enable_irq();
;;;57       }
;;;58     #else
;;;59       event_flags = atomic_set32(&ef->event_flags, flags);
000002  f7ffbffe          B.W      __asm___13_rtx_evflags_c_ab3a5ffb__atomic_set32
;;;60     #endif
;;;61     
;;;62       return event_flags;
;;;63     }
;;;64     
                          ENDP


                          AREA ||i.IsException||, CODE, READONLY, ALIGN=1

                  IsException PROC
;;;122    /// \return     true=exception, false=thread
;;;123    __STATIC_INLINE bool_t IsException (void) {
000000  f3ef8005          MRS      r0,IPSR
000004  2800              CMP      r0,#0
000006  d000              BEQ      |L3.10|
;;;124      return (__get_IPSR() != 0U);
000008  2001              MOVS     r0,#1
                  |L3.10|
;;;125    }
00000a  4770              BX       lr
;;;126    
                          ENDP


                          AREA ||i.IsIrqMasked||, CODE, READONLY, ALIGN=1

                  IsIrqMasked PROC
;;;128    /// \return     true=masked, false=not masked
;;;129    __STATIC_INLINE bool_t IsIrqMasked (void) {
000000  f3ef8010          MRS      r0,PRIMASK
000004  b918              CBNZ     r0,|L4.14|
000006  f3ef8011          MRS      r0,BASEPRI
;;;130    #if   ((defined(__ARM_ARCH_7M__)        && (__ARM_ARCH_7M__        != 0)) || \
;;;131           (defined(__ARM_ARCH_7EM__)       && (__ARM_ARCH_7EM__       != 0)) || \
;;;132           (defined(__ARM_ARCH_8M_MAIN__)   && (__ARM_ARCH_8M_MAIN__   != 0)) || \
;;;133           (defined(__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ != 0)))
;;;134      return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L4.16|
                  |L4.14|
00000e  2001              MOVS     r0,#1
                  |L4.16|
;;;135    #else
;;;136      return  (__get_PRIMASK() != 0U);
;;;137    #endif
;;;138    }
000010  4770              BX       lr
;;;139    
                          ENDP


                          AREA ||i.osEventFlagsClear||, CODE, READONLY, ALIGN=2

                  osEventFlagsClear PROC
;;;532    /// Clear the specified Event Flags.
;;;533    uint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;534      uint32_t event_flags;
;;;535    
;;;536      EvrRtxEventFlagsClear(ef_id, flags);
000006  f7fffffe          BL       EvrRtxEventFlagsClear
;;;537      if (IsException() || IsIrqMasked()) {
00000a  f7fffffe          BL       IsException
00000e  b910              CBNZ     r0,|L5.22|
000010  f7fffffe          BL       IsIrqMasked
000014  b128              CBZ      r0,|L5.34|
                  |L5.22|
;;;538        event_flags = svcRtxEventFlagsClear(ef_id, flags);
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  e8bd4070          POP      {r4-r6,lr}
00001e  f7ffbffe          B.W      svcRtxEventFlagsClear
                  |L5.34|
;;;539      } else {
;;;540        event_flags =  __svcEventFlagsClear(ef_id, flags);
000022  4628              MOV      r0,r5
000024  4621              MOV      r1,r4
000026  f8dfc008          LDR      r12,|L5.48|
00002a  df00              SVC      #0x0
;;;541      }
;;;542      return event_flags;
;;;543    }
00002c  bd70              POP      {r4-r6,pc}
;;;544    
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      svcRtxEventFlagsClear

                          AREA ||i.osEventFlagsDelete||, CODE, READONLY, ALIGN=2

                  osEventFlagsDelete PROC
;;;570    /// Delete an Event Flags object.
;;;571    osStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;572      osStatus_t status;
;;;573    
;;;574      EvrRtxEventFlagsDelete(ef_id);
000004  f7fffffe          BL       EvrRtxEventFlagsDelete
;;;575      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L6.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L6.36|
                  |L6.20|
;;;576        EvrRtxEventFlagsError(ef_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxEventFlagsError
;;;577        status = osErrorISR;
000020  4628              MOV      r0,r5
;;;578      } else {
;;;579        status = __svcEventFlagsDelete(ef_id);
;;;580      }
;;;581      return status;
;;;582    }
000022  bd70              POP      {r4-r6,pc}
                  |L6.36|
000024  4620              MOV      r0,r4                 ;579
000026  f8dfc008          LDR      r12,|L6.48|
00002a  df00              SVC      #0x0                  ;579
00002c  bd70              POP      {r4-r6,pc}
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      svcRtxEventFlagsDelete

                          AREA ||i.osEventFlagsGet||, CODE, READONLY, ALIGN=2

                  osEventFlagsGet PROC
;;;545    /// Get the current Event Flags.
;;;546    uint32_t osEventFlagsGet (osEventFlagsId_t ef_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;547      uint32_t event_flags;
;;;548    
;;;549      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L7.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b120              CBZ      r0,|L7.26|
                  |L7.16|
;;;550        event_flags = svcRtxEventFlagsGet(ef_id);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      svcRtxEventFlagsGet
                  |L7.26|
;;;551      } else {
;;;552        event_flags =  __svcEventFlagsGet(ef_id);
00001a  4620              MOV      r0,r4
00001c  f8dfc004          LDR      r12,|L7.36|
000020  df00              SVC      #0x0
;;;553      }
;;;554      return event_flags;
;;;555    }
000022  bd10              POP      {r4,pc}
;;;556    
                          ENDP

                  |L7.36|
                          DCD      svcRtxEventFlagsGet

                          AREA ||i.osEventFlagsGetName||, CODE, READONLY, ALIGN=2

                  osEventFlagsGetName PROC
;;;506    /// Get name of an Event Flags object.
;;;507    const char *osEventFlagsGetName (osEventFlagsId_t ef_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;508      const char *name;
;;;509    
;;;510      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L8.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b128              CBZ      r0,|L8.28|
                  |L8.16|
;;;511        EvrRtxEventFlagsGetName(ef_id, NULL);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxEventFlagsGetName
;;;512        name = NULL;
000018  2000              MOVS     r0,#0
;;;513      } else {
;;;514        name = __svcEventFlagsGetName(ef_id);
;;;515      }
;;;516      return name;
;;;517    }
00001a  bd10              POP      {r4,pc}
                  |L8.28|
00001c  4620              MOV      r0,r4                 ;514
00001e  f8dfc008          LDR      r12,|L8.40|
000022  df00              SVC      #0x0                  ;514
000024  bd10              POP      {r4,pc}
;;;518    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      svcRtxEventFlagsGetName

                          AREA ||i.osEventFlagsNew||, CODE, READONLY, ALIGN=2

                  osEventFlagsNew PROC
;;;492    /// Create and Initialize an Event Flags object.
;;;493    osEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;494      osEventFlagsId_t ef_id;
;;;495    
;;;496      EvrRtxEventFlagsNew(attr);
000004  f7fffffe          BL       EvrRtxEventFlagsNew
;;;497      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L9.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b130              CBZ      r0,|L9.34|
                  |L9.20|
;;;498        EvrRtxEventFlagsError(NULL, (int32_t)osErrorISR);
000014  f06f0105          MVN      r1,#5
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       EvrRtxEventFlagsError
;;;499        ef_id = NULL;
00001e  2000              MOVS     r0,#0
;;;500      } else {
;;;501        ef_id = __svcEventFlagsNew(attr);
;;;502      }
;;;503      return ef_id;
;;;504    }
000020  bd10              POP      {r4,pc}
                  |L9.34|
000022  4620              MOV      r0,r4                 ;501
000024  f8dfc004          LDR      r12,|L9.44|
000028  df00              SVC      #0x0                  ;501
00002a  bd10              POP      {r4,pc}
;;;505    
                          ENDP

                  |L9.44|
                          DCD      svcRtxEventFlagsNew

                          AREA ||i.osEventFlagsSet||, CODE, READONLY, ALIGN=2

                  osEventFlagsSet PROC
;;;519    /// Set the specified Event Flags.
;;;520    uint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;521      uint32_t event_flags;
;;;522    
;;;523      EvrRtxEventFlagsSet(ef_id, flags);
000006  f7fffffe          BL       EvrRtxEventFlagsSet
;;;524      if (IsException() || IsIrqMasked()) {
00000a  f7fffffe          BL       IsException
00000e  b910              CBNZ     r0,|L10.22|
000010  f7fffffe          BL       IsIrqMasked
000014  b1d0              CBZ      r0,|L10.76|
                  |L10.22|
;;;525        event_flags = isrRtxEventFlagsSet(ef_id, flags);
000016  4629              MOV      r1,r5
000018  b124              CBZ      r4,|L10.36|
00001a  7820              LDRB     r0,[r4,#0]
00001c  28f3              CMP      r0,#0xf3
00001e  d101              BNE      |L10.36|
000020  2900              CMP      r1,#0
000022  da06              BGE      |L10.50|
                  |L10.36|
000024  f06f0503          MVN      r5,#3
000028  4629              MOV      r1,r5
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       EvrRtxEventFlagsError
000030  e00a              B        |L10.72|
                  |L10.50|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       EventFlagsSet
000038  4605              MOV      r5,r0
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       osRtxPostProcess
000040  4629              MOV      r1,r5
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       EvrRtxEventFlagsSetDone
                  |L10.72|
000048  4628              MOV      r0,r5
;;;526      } else {
;;;527        event_flags =  __svcEventFlagsSet(ef_id, flags);
;;;528      }
;;;529      return event_flags;
;;;530    }
00004a  bd70              POP      {r4-r6,pc}
                  |L10.76|
00004c  4620              MOV      r0,r4                 ;527
00004e  4629              MOV      r1,r5                 ;527
000050  f8dfc004          LDR      r12,|L10.88|
000054  df00              SVC      #0x0                  ;527
000056  bd70              POP      {r4-r6,pc}
;;;531    
                          ENDP

                  |L10.88|
                          DCD      svcRtxEventFlagsSet

                          AREA ||i.osEventFlagsWait||, CODE, READONLY, ALIGN=2

                  osEventFlagsWait PROC
;;;557    /// Wait for one or more Event Flags to become signaled.
;;;558    uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461d              MOV      r5,r3
000006  4617              MOV      r7,r2
000008  460e              MOV      r6,r1
00000a  4604              MOV      r4,r0
;;;559      uint32_t event_flags;
;;;560    
;;;561      EvrRtxEventFlagsWait(ef_id, flags, options, timeout);
00000c  f7fffffe          BL       EvrRtxEventFlagsWait
;;;562      if (IsException() || IsIrqMasked()) {
000010  f7fffffe          BL       IsException
000014  b910              CBNZ     r0,|L11.28|
000016  f7fffffe          BL       IsIrqMasked
00001a  b328              CBZ      r0,|L11.104|
                  |L11.28|
;;;563        event_flags = isrRtxEventFlagsWait(ef_id, flags, options, timeout);
00001c  b12c              CBZ      r4,|L11.42|
00001e  7820              LDRB     r0,[r4,#0]
000020  28f3              CMP      r0,#0xf3
000022  d102              BNE      |L11.42|
000024  b90d              CBNZ     r5,|L11.42|
000026  2e00              CMP      r6,#0
000028  da06              BGE      |L11.56|
                  |L11.42|
00002a  f06f0503          MVN      r5,#3
00002e  4629              MOV      r1,r5
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       EvrRtxEventFlagsError
000036  e014              B        |L11.98|
                  |L11.56|
000038  463a              MOV      r2,r7
00003a  4631              MOV      r1,r6
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       EventFlagsCheck
000042  0005              MOVS     r5,r0
000044  d006              BEQ      |L11.84|
000046  4603              MOV      r3,r0
000048  463a              MOV      r2,r7
00004a  4631              MOV      r1,r6
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       EvrRtxEventFlagsWaitCompleted
000052  e006              B        |L11.98|
                  |L11.84|
000054  463a              MOV      r2,r7
000056  4631              MOV      r1,r6
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       EvrRtxEventFlagsWaitNotCompleted
00005e  f06f0502          MVN      r5,#2
                  |L11.98|
000062  4628              MOV      r0,r5
                  |L11.100|
;;;564      } else {
;;;565        event_flags =  __svcEventFlagsWait(ef_id, flags, options, timeout);
;;;566      }
;;;567      return event_flags;
;;;568    }
000064  e8bd81f0          POP      {r4-r8,pc}
                  |L11.104|
000068  4620              MOV      r0,r4                 ;565
00006a  4631              MOV      r1,r6                 ;565
00006c  463a              MOV      r2,r7                 ;565
00006e  462b              MOV      r3,r5                 ;565
000070  f8dfc004          LDR      r12,|L11.120|
000074  df00              SVC      #0x0                  ;565
000076  e7f5              B        |L11.100|
;;;569    
                          ENDP

                  |L11.120|
                          DCD      svcRtxEventFlagsWait

                          AREA ||i.osRtxEventFlagsPostProcess||, CODE, READONLY, ALIGN=2

                  osRtxEventFlagsPostProcess PROC
;;;140    /// \param[in]  ef              event flags object.
;;;141    static void osRtxEventFlagsPostProcess (os_event_flags_t *ef) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  6884              LDR      r4,[r0,#8]
000008  e019              B        |L12.62|
;;;142      os_thread_t *thread;
;;;143      os_thread_t *thread_next;
;;;144      uint32_t     event_flags;
;;;145    
;;;146      // Check if Threads are waiting for Event Flags
;;;147      thread = ef->thread_list;
;;;148      while (thread != NULL) {
;;;149        thread_next = thread->thread_next;
;;;150        event_flags = EventFlagsCheck(ef, thread->wait_flags, thread->flags_options);
00000a  bf00              NOP      
                  |L12.12|
00000c  f8942023          LDRB     r2,[r4,#0x23]
000010  4638              MOV      r0,r7
000012  68a6              LDR      r6,[r4,#8]
000014  6a61              LDR      r1,[r4,#0x24]
000016  f7fffffe          BL       EventFlagsCheck
00001a  0005              MOVS     r5,r0
;;;151        if (event_flags != 0U) {
00001c  d00e              BEQ      |L12.60|
;;;152          osRtxThreadListRemove(thread);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       osRtxThreadListRemove
;;;153          osRtxThreadWaitExit(thread, event_flags, FALSE);
000024  2200              MOVS     r2,#0
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       osRtxThreadWaitExit
;;;154          EvrRtxEventFlagsWaitCompleted(ef, thread->wait_flags, thread->flags_options, event_flags);
00002e  f8942023          LDRB     r2,[r4,#0x23]
000032  462b              MOV      r3,r5
000034  4638              MOV      r0,r7
000036  6a61              LDR      r1,[r4,#0x24]
000038  f7fffffe          BL       EvrRtxEventFlagsWaitCompleted
                  |L12.60|
;;;155        }
;;;156        thread = thread_next;
00003c  4634              MOV      r4,r6
                  |L12.62|
00003e  2c00              CMP      r4,#0                 ;148
000040  d1e4              BNE      |L12.12|
;;;157      }
;;;158    }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;159    
                          ENDP


                          AREA ||i.svcRtxEventFlagsClear||, CODE, READONLY, ALIGN=1

                  svcRtxEventFlagsClear PROC
;;;299    /// \note API identical to osEventFlagsClear
;;;300    static uint32_t svcRtxEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags) {
000000  b570              PUSH     {r4-r6,lr}
;;;301      os_event_flags_t *ef = osRtxEventFlagsId(ef_id);
000002  0004              MOVS     r4,r0
000004  d004              BEQ      |L13.16|
;;;302      uint32_t          event_flags;
;;;303    
;;;304      // Check parameters
;;;305      if ((ef == NULL) || (ef->id != osRtxIdEventFlags) ||
000006  7820              LDRB     r0,[r4,#0]
000008  28f3              CMP      r0,#0xf3
00000a  d101              BNE      |L13.16|
;;;306          ((flags & ~(((uint32_t)1U << osRtxEventFlagsLimit) - 1U)) != 0U)) {
00000c  2900              CMP      r1,#0
00000e  da06              BGE      |L13.30|
                  |L13.16|
;;;307        EvrRtxEventFlagsError(ef, (int32_t)osErrorParameter);
000010  f06f0503          MVN      r5,#3
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       EvrRtxEventFlagsError
;;;308        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;309        return ((uint32_t)osErrorParameter);
00001c  e008              B        |L13.48|
                  |L13.30|
00001e  f104000c          ADD      r0,r4,#0xc
000022  f7fffffe          BL       __asm___13_rtx_evflags_c_ab3a5ffb__atomic_clr32
;;;310      }
;;;311    
;;;312      // Clear Event Flags
;;;313      event_flags = EventFlagsClear(ef, flags);
000026  4605              MOV      r5,r0
;;;314    
;;;315      EvrRtxEventFlagsClearDone(ef, event_flags);
000028  4601              MOV      r1,r0
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       EvrRtxEventFlagsClearDone
                  |L13.48|
;;;316    
;;;317      return event_flags;
000030  4628              MOV      r0,r5
;;;318    }
000032  bd70              POP      {r4-r6,pc}
;;;319    
                          ENDP


                          AREA ||i.svcRtxEventFlagsDelete||, CODE, READONLY, ALIGN=2

                  svcRtxEventFlagsDelete PROC
;;;381    /// \note API identical to osEventFlagsDelete
;;;382    static osStatus_t svcRtxEventFlagsDelete (osEventFlagsId_t ef_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;383      os_event_flags_t *ef = osRtxEventFlagsId(ef_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L14.12|
;;;384      os_thread_t      *thread;
;;;385    
;;;386      // Check parameters
;;;387      if ((ef == NULL) || (ef->id != osRtxIdEventFlags)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f3              CMP      r0,#0xf3
00000a  d007              BEQ      |L14.28|
                  |L14.12|
;;;388        EvrRtxEventFlagsError(ef, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxEventFlagsError
;;;389        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;390        return osErrorParameter;
000018  4628              MOV      r0,r5
;;;391      }
;;;392    
;;;393      // Unblock waiting threads
;;;394      if (ef->thread_list != NULL) {
;;;395        do {
;;;396          thread = osRtxThreadListGet(osRtxObject(ef));
;;;397          osRtxThreadWaitExit(thread, (uint32_t)osErrorResource, FALSE);
;;;398        } while (ef->thread_list != NULL);
;;;399        osRtxThreadDispatch(NULL);
;;;400      }
;;;401    
;;;402      // Mark object as invalid
;;;403      ef->id = osRtxIdInvalid;
;;;404    
;;;405      // Free object memory
;;;406      if ((ef->flags & osRtxFlagSystemObject) != 0U) {
;;;407        if (osRtxInfo.mpi.event_flags != NULL) {
;;;408          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.event_flags, ef);
;;;409        } else {
;;;410          (void)osRtxMemoryFree(osRtxInfo.mem.common, ef);
;;;411        }
;;;412    #ifdef RTX_OBJ_MEM_USAGE
;;;413        osRtxEventFlagsMemUsage.cnt_free++;
;;;414    #endif
;;;415      }
;;;416    
;;;417      EvrRtxEventFlagsDestroyed(ef);
;;;418    
;;;419      return osOK;
;;;420    }
00001a  bd70              POP      {r4-r6,pc}
                  |L14.28|
00001c  68a0              LDR      r0,[r4,#8]            ;394
00001e  b168              CBZ      r0,|L14.60|
000020  f06f0502          MVN      r5,#2                 ;397
                  |L14.36|
000024  4620              MOV      r0,r4                 ;396
000026  f7fffffe          BL       osRtxThreadListGet
00002a  2200              MOVS     r2,#0                 ;397
00002c  4629              MOV      r1,r5                 ;397
00002e  f7fffffe          BL       osRtxThreadWaitExit
000032  68a0              LDR      r0,[r4,#8]            ;398
000034  2800              CMP      r0,#0                 ;398
000036  d1f5              BNE      |L14.36|
000038  f7fffffe          BL       osRtxThreadDispatch
                  |L14.60|
00003c  2000              MOVS     r0,#0                 ;403
00003e  7020              STRB     r0,[r4,#0]            ;403
000040  78a0              LDRB     r0,[r4,#2]            ;406
000042  07c0              LSLS     r0,r0,#31             ;406
000044  d010              BEQ      |L14.104|
000046  490b              LDR      r1,|L14.116|
000048  f8d10090          LDR      r0,[r1,#0x90]         ;407  ; osRtxInfo
00004c  b118              CBZ      r0,|L14.86|
00004e  4621              MOV      r1,r4                 ;408
000050  f7fffffe          BL       osRtxMemoryPoolFree
000054  e004              B        |L14.96|
                  |L14.86|
000056  f8d10080          LDR      r0,[r1,#0x80]         ;410  ; osRtxInfo
00005a  4621              MOV      r1,r4                 ;410
00005c  f7fffffe          BL       osRtxMemoryFree
                  |L14.96|
000060  4805              LDR      r0,|L14.120|
000062  6841              LDR      r1,[r0,#4]            ;413  ; osRtxEventFlagsMemUsage
000064  1c49              ADDS     r1,r1,#1              ;413
000066  6041              STR      r1,[r0,#4]            ;413  ; osRtxEventFlagsMemUsage
                  |L14.104|
000068  4620              MOV      r0,r4                 ;417
00006a  f7fffffe          BL       EvrRtxEventFlagsDestroyed
00006e  2000              MOVS     r0,#0                 ;419
000070  bd70              POP      {r4-r6,pc}
;;;421    
                          ENDP

000072  0000              DCW      0x0000
                  |L14.116|
                          DCD      osRtxInfo
                  |L14.120|
                          DCD      ||.data.os.evflags.obj||

                          AREA ||i.svcRtxEventFlagsGet||, CODE, READONLY, ALIGN=1

                  svcRtxEventFlagsGet PROC
;;;321    /// \note API identical to osEventFlagsGet
;;;322    static uint32_t svcRtxEventFlagsGet (osEventFlagsId_t ef_id) {
000000  b510              PUSH     {r4,lr}
;;;323      os_event_flags_t *ef = osRtxEventFlagsId(ef_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L15.12|
;;;324    
;;;325      // Check parameters
;;;326      if ((ef == NULL) || (ef->id != osRtxIdEventFlags)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f3              CMP      r0,#0xf3
00000a  d005              BEQ      |L15.24|
                  |L15.12|
;;;327        EvrRtxEventFlagsGet(ef, 0U);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxEventFlagsGet
;;;328        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;329        return 0U;
000014  2000              MOVS     r0,#0
;;;330      }
;;;331    
;;;332      EvrRtxEventFlagsGet(ef, ef->event_flags);
;;;333    
;;;334      return ef->event_flags;
;;;335    }
000016  bd10              POP      {r4,pc}
                  |L15.24|
000018  4620              MOV      r0,r4                 ;332
00001a  68e1              LDR      r1,[r4,#0xc]          ;332
00001c  f7fffffe          BL       EvrRtxEventFlagsGet
000020  68e0              LDR      r0,[r4,#0xc]          ;334
000022  bd10              POP      {r4,pc}
;;;336    
                          ENDP


                          AREA ||i.svcRtxEventFlagsGetName||, CODE, READONLY, ALIGN=1

                  svcRtxEventFlagsGetName PROC
;;;238    /// \note API identical to osEventFlagsGetName
;;;239    static const char *svcRtxEventFlagsGetName (osEventFlagsId_t ef_id) {
000000  b510              PUSH     {r4,lr}
;;;240      os_event_flags_t *ef = osRtxEventFlagsId(ef_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L16.12|
;;;241    
;;;242      // Check parameters
;;;243      if ((ef == NULL) || (ef->id != osRtxIdEventFlags)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f3              CMP      r0,#0xf3
00000a  d005              BEQ      |L16.24|
                  |L16.12|
;;;244        EvrRtxEventFlagsGetName(ef, NULL);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxEventFlagsGetName
;;;245        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;246        return NULL;
000014  2000              MOVS     r0,#0
;;;247      }
;;;248    
;;;249      EvrRtxEventFlagsGetName(ef, ef->name);
;;;250    
;;;251      return ef->name;
;;;252    }
000016  bd10              POP      {r4,pc}
                  |L16.24|
000018  4620              MOV      r0,r4                 ;249
00001a  6861              LDR      r1,[r4,#4]            ;249
00001c  f7fffffe          BL       EvrRtxEventFlagsGetName
000020  6860              LDR      r0,[r4,#4]            ;251
000022  bd10              POP      {r4,pc}
;;;253    
                          ENDP


                          AREA ||i.svcRtxEventFlagsNew||, CODE, READONLY, ALIGN=2

                  svcRtxEventFlagsNew PROC
;;;164    /// \note API identical to osEventFlagsNew
;;;165    static osEventFlagsId_t svcRtxEventFlagsNew (const osEventFlagsAttr_t *attr) {
000000  b570              PUSH     {r4-r6,lr}
;;;166      os_event_flags_t *ef;
;;;167      uint8_t           flags;
;;;168      const char       *name;
;;;169    
;;;170      // Process attributes
;;;171      if (attr != NULL) {
;;;172        name = attr->name;
;;;173        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
;;;174        ef   = attr->cb_mem;
;;;175        if (ef != NULL) {
;;;176          //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
;;;177          if ((((uint32_t)ef & 3U) != 0U) || (attr->cb_size < sizeof(os_event_flags_t))) {
;;;178            EvrRtxEventFlagsError(NULL, osRtxErrorInvalidControlBlock);
;;;179            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;180            return NULL;
;;;181          }
;;;182        } else {
;;;183          if (attr->cb_size != 0U) {
;;;184            EvrRtxEventFlagsError(NULL, osRtxErrorInvalidControlBlock);
;;;185            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;186            return NULL;
;;;187          }
;;;188        }
;;;189      } else {
;;;190        name = NULL;
;;;191        ef   = NULL;
;;;192      }
;;;193    
;;;194      // Allocate object memory if not provided
;;;195      if (ef == NULL) {
;;;196        if (osRtxInfo.mpi.event_flags != NULL) {
000002  4d22              LDR      r5,|L17.140|
000004  b188              CBZ      r0,|L17.42|
000006  6806              LDR      r6,[r0,#0]            ;175
000008  6884              LDR      r4,[r0,#8]            ;175
00000a  f06f0108          MVN      r1,#8                 ;178
00000e  b12c              CBZ      r4,|L17.28|
000010  07a2              LSLS     r2,r4,#30             ;177
000012  d105              BNE      |L17.32|
000014  68c0              LDR      r0,[r0,#0xc]          ;177
000016  2810              CMP      r0,#0x10              ;177
000018  d302              BCC      |L17.32|
00001a  e027              B        |L17.108|
                  |L17.28|
00001c  68c0              LDR      r0,[r0,#0xc]          ;183
00001e  b128              CBZ      r0,|L17.44|
                  |L17.32|
000020  2000              MOVS     r0,#0                 ;184
000022  f7fffffe          BL       EvrRtxEventFlagsError
000026  2000              MOVS     r0,#0                 ;186
;;;197          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;198          ef = osRtxMemoryPoolAlloc(osRtxInfo.mpi.event_flags);
;;;199        } else {
;;;200          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;201          ef = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_event_flags_t), 1U);
;;;202        }
;;;203    #ifdef RTX_OBJ_MEM_USAGE
;;;204        if (ef != NULL) {
;;;205          uint32_t used;
;;;206          osRtxEventFlagsMemUsage.cnt_alloc++;
;;;207          used = osRtxEventFlagsMemUsage.cnt_alloc - osRtxEventFlagsMemUsage.cnt_free;
;;;208          if (osRtxEventFlagsMemUsage.max_used < used) {
;;;209            osRtxEventFlagsMemUsage.max_used = used;
;;;210          }
;;;211        }
;;;212    #endif
;;;213        flags = osRtxFlagSystemObject;
;;;214      } else {
;;;215        flags = 0U;
;;;216      }
;;;217    
;;;218      if (ef != NULL) {
;;;219        // Initialize control block
;;;220        ef->id          = osRtxIdEventFlags;
;;;221        ef->flags       = flags;
;;;222        ef->name        = name;
;;;223        ef->thread_list = NULL;
;;;224        ef->event_flags = 0U;
;;;225    
;;;226        // Register post ISR processing function
;;;227        osRtxInfo.post_process.event_flags = osRtxEventFlagsPostProcess;
;;;228    
;;;229        EvrRtxEventFlagsCreated(ef, ef->name);
;;;230      } else {
;;;231        EvrRtxEventFlagsError(NULL, (int32_t)osErrorNoMemory);
;;;232      }
;;;233    
;;;234      return ef;
;;;235    }
000028  bd70              POP      {r4-r6,pc}
                  |L17.42|
00002a  2600              MOVS     r6,#0                 ;190
                  |L17.44|
00002c  f8d50090          LDR      r0,[r5,#0x90]         ;196  ; osRtxInfo
000030  b110              CBZ      r0,|L17.56|
000032  f7fffffe          BL       osRtxMemoryPoolAlloc
000036  e005              B        |L17.68|
                  |L17.56|
000038  2201              MOVS     r2,#1                 ;201
00003a  2110              MOVS     r1,#0x10              ;201
00003c  f8d50080          LDR      r0,[r5,#0x80]         ;201  ; osRtxInfo
000040  f7fffffe          BL       osRtxMemoryAlloc
                  |L17.68|
000044  0004              MOVS     r4,r0                 ;201
000046  d00b              BEQ      |L17.96|
000048  4811              LDR      r0,|L17.144|
00004a  6801              LDR      r1,[r0,#0]            ;206  ; osRtxEventFlagsMemUsage
00004c  1c49              ADDS     r1,r1,#1              ;206
00004e  6001              STR      r1,[r0,#0]            ;207  ; osRtxEventFlagsMemUsage
000050  6842              LDR      r2,[r0,#4]            ;207  ; osRtxEventFlagsMemUsage
000052  1a89              SUBS     r1,r1,r2              ;207
000054  6882              LDR      r2,[r0,#8]            ;208  ; osRtxEventFlagsMemUsage
000056  428a              CMP      r2,r1                 ;208
000058  d200              BCS      |L17.92|
00005a  6081              STR      r1,[r0,#8]            ;209  ; osRtxEventFlagsMemUsage
                  |L17.92|
00005c  2001              MOVS     r0,#1                 ;213
00005e  e006              B        |L17.110|
                  |L17.96|
000060  f06f0104          MVN      r1,#4                 ;231
000064  2000              MOVS     r0,#0                 ;231
000066  f7fffffe          BL       EvrRtxEventFlagsError
00006a  e00d              B        |L17.136|
                  |L17.108|
00006c  2000              MOVS     r0,#0                 ;215
                  |L17.110|
00006e  21f3              MOVS     r1,#0xf3              ;220
000070  7021              STRB     r1,[r4,#0]            ;220
000072  70a0              STRB     r0,[r4,#2]            ;221
000074  2000              MOVS     r0,#0                 ;223
000076  e9c46001          STRD     r6,r0,[r4,#4]         ;223
00007a  60e0              STR      r0,[r4,#0xc]          ;227
00007c  4805              LDR      r0,|L17.148|
00007e  6668              STR      r0,[r5,#0x64]         ;229  ; osRtxInfo
000080  4620              MOV      r0,r4                 ;229
000082  6861              LDR      r1,[r4,#4]            ;229
000084  f7fffffe          BL       EvrRtxEventFlagsCreated
                  |L17.136|
000088  4620              MOV      r0,r4                 ;234
00008a  bd70              POP      {r4-r6,pc}
;;;236    
                          ENDP

                  |L17.140|
                          DCD      osRtxInfo
                  |L17.144|
                          DCD      ||.data.os.evflags.obj||
                  |L17.148|
                          DCD      osRtxEventFlagsPostProcess

                          AREA ||i.svcRtxEventFlagsSet||, CODE, READONLY, ALIGN=1

                  svcRtxEventFlagsSet PROC
;;;255    /// \note API identical to osEventFlagsSet
;;;256    static uint32_t svcRtxEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;257      os_event_flags_t *ef = osRtxEventFlagsId(ef_id);
000004  0006              MOVS     r6,r0
000006  d004              BEQ      |L18.18|
;;;258      os_thread_t      *thread;
;;;259      os_thread_t      *thread_next;
;;;260      uint32_t          event_flags;
;;;261      uint32_t          event_flags0;
;;;262    
;;;263      // Check parameters
;;;264      if ((ef == NULL) || (ef->id != osRtxIdEventFlags) ||
000008  7830              LDRB     r0,[r6,#0]
00000a  28f3              CMP      r0,#0xf3
00000c  d101              BNE      |L18.18|
;;;265          ((flags & ~(((uint32_t)1U << osRtxEventFlagsLimit) - 1U)) != 0U)) {
00000e  2900              CMP      r1,#0
000010  da08              BGE      |L18.36|
                  |L18.18|
;;;266        EvrRtxEventFlagsError(ef, (int32_t)osErrorParameter);
000012  f06f0403          MVN      r4,#3
000016  4621              MOV      r1,r4
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       EvrRtxEventFlagsError
;;;267        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;268        return ((uint32_t)osErrorParameter);
00001e  4620              MOV      r0,r4
                  |L18.32|
;;;269      }
;;;270    
;;;271      // Set Event Flags
;;;272      event_flags = EventFlagsSet(ef, flags);
;;;273    
;;;274      // Check if Threads are waiting for Event Flags
;;;275      thread = ef->thread_list;
;;;276      while (thread != NULL) {
;;;277        thread_next = thread->thread_next;
;;;278        event_flags0 = EventFlagsCheck(ef, thread->wait_flags, thread->flags_options);
;;;279        if (event_flags0 != 0U) {
;;;280          if ((thread->flags_options & osFlagsNoClear) == 0U) {
;;;281            event_flags = event_flags0 & ~thread->wait_flags;
;;;282          } else {
;;;283            event_flags = event_flags0;
;;;284          }
;;;285          osRtxThreadListRemove(thread);
;;;286          osRtxThreadWaitExit(thread, event_flags0, FALSE);
;;;287          EvrRtxEventFlagsWaitCompleted(ef, thread->wait_flags, thread->flags_options, event_flags0);
;;;288        }
;;;289        thread = thread_next;
;;;290      }
;;;291      osRtxThreadDispatch(NULL);
;;;292    
;;;293      EvrRtxEventFlagsSetDone(ef, event_flags);
;;;294    
;;;295      return event_flags;
;;;296    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L18.36|
000024  4630              MOV      r0,r6                 ;272
000026  f7fffffe          BL       EventFlagsSet
00002a  4680              MOV      r8,r0                 ;272
00002c  68b4              LDR      r4,[r6,#8]            ;276
00002e  e021              B        |L18.116|
                  |L18.48|
000030  f8942023          LDRB     r2,[r4,#0x23]         ;278
000034  4630              MOV      r0,r6                 ;278
000036  68a7              LDR      r7,[r4,#8]            ;278
000038  6a61              LDR      r1,[r4,#0x24]         ;278
00003a  f7fffffe          BL       EventFlagsCheck
00003e  0005              MOVS     r5,r0                 ;278
000040  d017              BEQ      |L18.114|
000042  f8940023          LDRB     r0,[r4,#0x23]         ;280
000046  0780              LSLS     r0,r0,#30             ;280
000048  d403              BMI      |L18.82|
00004a  6a61              LDR      r1,[r4,#0x24]         ;281
00004c  ea250801          BIC      r8,r5,r1              ;281
000050  e000              B        |L18.84|
                  |L18.82|
000052  46a8              MOV      r8,r5                 ;283
                  |L18.84|
000054  4620              MOV      r0,r4                 ;285
000056  f7fffffe          BL       osRtxThreadListRemove
00005a  2200              MOVS     r2,#0                 ;286
00005c  4629              MOV      r1,r5                 ;286
00005e  4620              MOV      r0,r4                 ;286
000060  f7fffffe          BL       osRtxThreadWaitExit
000064  f8942023          LDRB     r2,[r4,#0x23]         ;287
000068  462b              MOV      r3,r5                 ;287
00006a  4630              MOV      r0,r6                 ;287
00006c  6a61              LDR      r1,[r4,#0x24]         ;287
00006e  f7fffffe          BL       EvrRtxEventFlagsWaitCompleted
                  |L18.114|
000072  463c              MOV      r4,r7                 ;289
                  |L18.116|
000074  2c00              CMP      r4,#0                 ;276
000076  d1db              BNE      |L18.48|
000078  2000              MOVS     r0,#0                 ;291
00007a  f7fffffe          BL       osRtxThreadDispatch
00007e  4641              MOV      r1,r8                 ;293
000080  4630              MOV      r0,r6                 ;293
000082  f7fffffe          BL       EvrRtxEventFlagsSetDone
000086  4640              MOV      r0,r8                 ;295
000088  e7ca              B        |L18.32|
;;;297    
                          ENDP


                          AREA ||i.svcRtxEventFlagsWait||, CODE, READONLY, ALIGN=2

                  svcRtxEventFlagsWait PROC
;;;338    /// \note API identical to osEventFlagsWait
;;;339    static uint32_t svcRtxEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461f              MOV      r7,r3
000006  4690              MOV      r8,r2
000008  460e              MOV      r6,r1
;;;340      os_event_flags_t *ef = osRtxEventFlagsId(ef_id);
00000a  0004              MOVS     r4,r0
00000c  d004              BEQ      |L19.24|
;;;341      os_thread_t      *thread;
;;;342      uint32_t          event_flags;
;;;343    
;;;344      // Check parameters
;;;345      if ((ef == NULL) || (ef->id != osRtxIdEventFlags) ||
00000e  7820              LDRB     r0,[r4,#0]
000010  28f3              CMP      r0,#0xf3
000012  d101              BNE      |L19.24|
;;;346          ((flags & ~(((uint32_t)1U << osRtxEventFlagsLimit) - 1U)) != 0U)) {
000014  2e00              CMP      r6,#0
000016  da06              BGE      |L19.38|
                  |L19.24|
;;;347        EvrRtxEventFlagsError(ef, (int32_t)osErrorParameter);
000018  f06f0503          MVN      r5,#3
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       EvrRtxEventFlagsError
;;;348        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;349        return ((uint32_t)osErrorParameter);
000024  e02e              B        |L19.132|
                  |L19.38|
;;;350      }
;;;351    
;;;352      // Check Event Flags
;;;353      event_flags = EventFlagsCheck(ef, flags, options);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       EventFlagsCheck
00002c  0005              MOVS     r5,r0
;;;354      if (event_flags != 0U) {
00002e  d006              BEQ      |L19.62|
;;;355        EvrRtxEventFlagsWaitCompleted(ef, flags, options, event_flags);
000030  4603              MOV      r3,r0
000032  4642              MOV      r2,r8
000034  4631              MOV      r1,r6
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       EvrRtxEventFlagsWaitCompleted
00003c  e022              B        |L19.132|
                  |L19.62|
;;;356      } else {
;;;357        // Check if timeout is specified
;;;358        if (timeout != 0U) {
00003e  b1d7              CBZ      r7,|L19.118|
;;;359          EvrRtxEventFlagsWaitPending(ef, flags, options, timeout);
000040  463b              MOV      r3,r7
000042  4642              MOV      r2,r8
000044  4631              MOV      r1,r6
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       EvrRtxEventFlagsWaitPending
;;;360          // Suspend current Thread
;;;361          if (osRtxThreadWaitEnter(osRtxThreadWaitingEventFlags, timeout)) {
00004c  4639              MOV      r1,r7
00004e  2043              MOVS     r0,#0x43
000050  f7fffffe          BL       osRtxThreadWaitEnter
000054  b148              CBZ      r0,|L19.106|
000056  480d              LDR      r0,|L19.140|
;;;362            thread = osRtxThreadGetRunning();
;;;363            osRtxThreadListPut(osRtxObject(ef), thread);
000058  6945              LDR      r5,[r0,#0x14]  ; osRtxInfo
00005a  4620              MOV      r0,r4
00005c  4629              MOV      r1,r5
00005e  f7fffffe          BL       osRtxThreadListPut
;;;364            // Store waiting flags and options
;;;365            thread->wait_flags = flags;
;;;366            thread->flags_options = (uint8_t)options;
000062  626e              STR      r6,[r5,#0x24]
000064  f8858023          STRB     r8,[r5,#0x23]
000068  e002              B        |L19.112|
                  |L19.106|
;;;367          } else {
;;;368            EvrRtxEventFlagsWaitTimeout(ef);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       EvrRtxEventFlagsWaitTimeout
                  |L19.112|
;;;369          }
;;;370          event_flags = (uint32_t)osErrorTimeout;
000070  f06f0501          MVN      r5,#1
000074  e006              B        |L19.132|
                  |L19.118|
;;;371        } else {
;;;372          EvrRtxEventFlagsWaitNotCompleted(ef, flags, options);
000076  4642              MOV      r2,r8
000078  4631              MOV      r1,r6
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       EvrRtxEventFlagsWaitNotCompleted
;;;373          event_flags = (uint32_t)osErrorResource;
000080  f06f0502          MVN      r5,#2
                  |L19.132|
;;;374        }
;;;375      }
;;;376    
;;;377      return event_flags;
000084  4628              MOV      r0,r5
;;;378    }
000086  e8bd81f0          POP      {r4-r8,pc}
;;;379    
                          ENDP

00008a  0000              DCW      0x0000
                  |L19.140|
                          DCD      osRtxInfo

                          AREA ||.data.os.evflags.obj||, DATA, ALIGN=2

                  osRtxEventFlagsMemUsage
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_evflags.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___13_rtx_evflags_c_ab3a5ffb____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb____REVSH|
#line 223
|__asm___13_rtx_evflags_c_ab3a5ffb____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb____RRX|
#line 410
|__asm___13_rtx_evflags_c_ab3a5ffb____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_wr8|
#line 464 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_core_cm.h"
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_wr8| PROC
#line 464

 mov r2,r0
1
 ldrexb r0,[r2]
 strexb r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_set32|
#line 511
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_set32| PROC
#line 511

 mov r2,r0
1
 ldrex r0,[r2]
 orr r0,r0,r1
 strex r3,r0,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_clr32|
#line 570
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_clr32| PROC
#line 570

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F2
 b %B1
2
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_chk32_all|
#line 630
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_chk32_all| PROC
#line 630

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 and r4,r0,r1
 cmp r4,r1
 beq %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_chk32_any|
#line 705
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_chk32_any| PROC
#line 705

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 tst r0,r1
 bne %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_inc32|
#line 772
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_inc32| PROC
#line 772

 mov r2,r0
1
 ldrex r0,[r2]
 adds r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_inc16_lt|
#line 821
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_inc16_lt| PROC
#line 821

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 cmp r1,r0
 bhi %F2
 clrex
 pop {r4,pc}
2
 adds r4,r0,#1
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_inc16_lim|
#line 882
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_inc16_lim| PROC
#line 882

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 adds r4,r0,#1
 cmp r1,r4
 bhi %F2
 movs r4,#0
2
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_dec32|
#line 940
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_dec32| PROC
#line 940

 mov r2,r0
1
 ldrex r0,[r2]
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_dec32_nz|
#line 988
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_dec32_nz| PROC
#line 988

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_dec16_nz|
#line 1044
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_dec16_nz| PROC
#line 1044

 mov r2,r0
1
 ldrexh r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strexh r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_link_get|
#line 1100
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_link_get| PROC
#line 1100

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 ldr r1,[r0]
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_evflags_c_ab3a5ffb__atomic_link_put|
#line 1156
|__asm___13_rtx_evflags_c_ab3a5ffb__atomic_link_put| PROC
#line 1156

1
 ldr r2,[r0]
 str r2,[r1]
 dmb
 ldrex r2,[r0]
 ldr r3,[r1]
 cmp r3,r2
 bne %B1
 strex r3,r1,[r0]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP

;*** End   embedded assembler ***
