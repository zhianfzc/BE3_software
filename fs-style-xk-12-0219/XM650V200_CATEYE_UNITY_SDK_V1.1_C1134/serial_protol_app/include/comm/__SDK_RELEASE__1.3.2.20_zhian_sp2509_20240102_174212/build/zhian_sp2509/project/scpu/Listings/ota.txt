; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ota.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ota.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\ota.crf ..\..\..\..\scpu\middleware\ota\ota.c]
                          THUMB

                          AREA ||i.Drv_OTA_Get_Version||, CODE, READONLY, ALIGN=1

                  Drv_OTA_Get_Version PROC
;;;1715   
;;;1716   void Drv_OTA_Get_Version( OTA_FLASHt * stota )
000000  b510              PUSH     {r4,lr}
;;;1717   {
000002  b0a0              SUB      sp,sp,#0x80
000004  4604              MOV      r4,r0
;;;1718       UINT32 nchecksum=0;
;;;1719       system_info sys_info = { 0 };
000006  217c              MOVS     r1,#0x7c
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memclr4
;;;1720       kl520_api_get_device_info( &sys_info );
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       kl520_api_get_device_info
;;;1721   
;;;1722       stota->send_response.cmd_stat = stota->receive_cmd.cmd_stat;
000014  8960              LDRH     r0,[r4,#0xa]
000016  8760              STRH     r0,[r4,#0x3a]
;;;1723       stota->send_response.action_number = stota->receive_cmd.action_number;
000018  7ba0              LDRB     r0,[r4,#0xe]
00001a  f884003e          STRB     r0,[r4,#0x3e]
;;;1724   
;;;1725       stota->temp_buffer_index = 0;
00001e  2100              MOVS     r1,#0
;;;1726   
;;;1727   
;;;1728       *( (UINT32 *)(stota->temp_buffer+stota->temp_buffer_index)  ) = sys_info.unique_id;
000020  66a1              STR      r1,[r4,#0x68]
000022  6e62              LDR      r2,[r4,#0x64]
000024  9800              LDR      r0,[sp,#0]
;;;1729       stota->temp_buffer_index++;
000026  6010              STR      r0,[r2,#0]
000028  6ea0              LDR      r0,[r4,#0x68]
00002a  1c40              ADDS     r0,r0,#1
;;;1730   
;;;1731   //	dbg_msg_flash( "Uniqe ID....0x%x", sys_info.unique_id );
;;;1732   
;;;1733       *( (UINT32 *)(stota->temp_buffer+stota->temp_buffer_index) ) = sys_info.spl_version;
00002c  66a0              STR      r0,[r4,#0x68]
00002e  6e63              LDR      r3,[r4,#0x64]
000030  9a01              LDR      r2,[sp,#4]
000032  f8432020          STR      r2,[r3,r0,LSL #2]
;;;1734       stota->temp_buffer_index++;
000036  6ea0              LDR      r0,[r4,#0x68]
000038  1c40              ADDS     r0,r0,#1
;;;1735   
;;;1736   //	dbg_msg_flash( "SPL ID....0x%x", sys_info.spl_version );
;;;1737   
;;;1738       *( (UINT32 *)(stota->temp_buffer+stota->temp_buffer_index)  ) = sys_info.fw_scpu_version.date;
00003a  66a0              STR      r0,[r4,#0x68]
00003c  6e63              LDR      r3,[r4,#0x64]
00003e  9a03              LDR      r2,[sp,#0xc]
000040  f8432020          STR      r2,[r3,r0,LSL #2]
;;;1739       stota->temp_buffer_index++;
000044  6ea0              LDR      r0,[r4,#0x68]
000046  1c40              ADDS     r0,r0,#1
;;;1740   
;;;1741   //	dbg_msg_flash( "SCPU ID....0x%x", sys_info.fw_scpu_version );
;;;1742   
;;;1743   
;;;1744       *( (UINT32 *)(stota->temp_buffer+stota->temp_buffer_index)  ) = sys_info.fw_ncpu_version.date;
000048  66a0              STR      r0,[r4,#0x68]
00004a  6e63              LDR      r3,[r4,#0x64]
00004c  9a05              LDR      r2,[sp,#0x14]
00004e  f8432020          STR      r2,[r3,r0,LSL #2]
;;;1745       stota->temp_buffer_index++;
000052  6ea0              LDR      r0,[r4,#0x68]
000054  1c40              ADDS     r0,r0,#1
;;;1746   
;;;1747       //	dbg_msg_flash( "NCPU ID....0x%x", sys_info.fw_ncpu_version );
;;;1748   
;;;1749       //model
;;;1750       *( (UINT32 *)(stota->temp_buffer+stota->temp_buffer_index)  ) = 0;
000056  66a0              STR      r0,[r4,#0x68]
000058  6e62              LDR      r2,[r4,#0x64]
00005a  f8421020          STR      r1,[r2,r0,LSL #2]
;;;1751       stota->temp_buffer_index++;
00005e  6ea0              LDR      r0,[r4,#0x68]
;;;1752   
;;;1753   //	dbg_msg_flash( "NCPU ID....0x%x", sys_info.fw_ncpu_version );
;;;1754   
;;;1755       nchecksum = Drv_utility_checksum( (UINT8 *)stota->temp_buffer , 0
000060  f64f71ff          MOV      r1,#0xffff
000064  1c40              ADDS     r0,r0,#1              ;1751
000066  ea010280          AND      r2,r1,r0,LSL #2
00006a  66a0              STR      r0,[r4,#0x68]
00006c  2100              MOVS     r1,#0
00006e  6e60              LDR      r0,[r4,#0x64]
000070  f7fffffe          BL       Drv_utility_checksum
;;;1756                                                                               , stota->temp_buffer_index*sizeof(stota->temp_buffer_index) );
;;;1757   
;;;1758       nchecksum+= ((stota->send_response.status&0xFF) + (stota->send_response.status>>8)&0xFF );
000074  f8b4104a          LDRH     r1,[r4,#0x4a]
000078  eb012111          ADD      r1,r1,r1,LSR #8
00007c  fa50f081          UXTAB    r0,r0,r1
;;;1759       stota->send_response.check_sum = nchecksum;
;;;1760   
;;;1761       kl520_api_free_device_info(&sys_info);
000080  6460              STR      r0,[r4,#0x44]
000082  4668              MOV      r0,sp
000084  f7fffffe          BL       kl520_api_free_device_info
;;;1762   }
000088  b020              ADD      sp,sp,#0x80
00008a  bd10              POP      {r4,pc}
;;;1763   
                          ENDP


                          AREA ||i.Drv_OTA_Set_Flow||, CODE, READONLY, ALIGN=1

                  Drv_OTA_Set_Flow PROC
;;;1893   
;;;1894   void Drv_OTA_Set_Flow( OTA_FLASHt * _stOTA, enum eOTA_flow _eOTA  )
000000  7001              STRB     r1,[r0,#0]
;;;1895   {
;;;1896       _stOTA->flow = _eOTA;
;;;1897   }
000002  4770              BX       lr
;;;1898   
                          ENDP


                          AREA ||i.Drv_OTA_Thread||, CODE, READONLY, ALIGN=2

                  Drv_OTA_Thread PROC
;;;2204   
;;;2205   void Drv_OTA_Thread( void )
000000  b500              PUSH     {lr}
;;;2206   {
000002  b089              SUB      sp,sp,#0x24
;;;2207       #if ( OTA_TIMING_DEBUG_EN == YES)
;;;2208       _flash_gpio_debug();
;;;2209       #endif
;;;2210   
;;;2211   #if CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_LWCOM
;;;2212   #if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;2213   #ifdef COM_BUS_RESPONSE_REQUEST_PIN
;;;2214       kl520_com_init(KL520_COM_HAS_ADDITIONAL_IO);
;;;2215   #else
;;;2216       kl520_com_init(KL520_COM_NORMAL);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       kl520_com_init
;;;2217   #endif
;;;2218   #endif
;;;2219   #endif
;;;2220   
;;;2221       #if (CFG_OTA_EN == YES)
;;;2222       osThreadAttr_t attr = {
;;;2223           .stack_size = 512
;;;2224       };
;;;2225       stOTA.flow = eOTA_init;
;;;2226       ota_tid = osThreadNew( (osThreadFunc_t)Drv_OTA_main, NULL, &attr );
;;;2227       #endif
;;;2228   
;;;2229   #if CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_LWCOM
;;;2230   #if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;2231       osThreadAttr_t attr_com = {
00000a  2224              MOVS     r2,#0x24
00000c  4906              LDR      r1,|L3.40|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;2232           .stack_size = 1792
;;;2233       };
;;;2234       com_bus_tid = osThreadNew( (osThreadFunc_t)kl520_com_thread, NULL, &attr_com );
000014  466a              MOV      r2,sp
000016  2100              MOVS     r1,#0
000018  4804              LDR      r0,|L3.44|
00001a  f7fffffe          BL       osThreadNew
00001e  4904              LDR      r1,|L3.48|
000020  6188              STR      r0,[r1,#0x18]  ; com_bus_tid
;;;2235   #endif
;;;2236   #endif
;;;2237   }
000022  b009              ADD      sp,sp,#0x24
000024  bd00              POP      {pc}
;;;2238   
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      ||.constdata||
                  |L3.44|
                          DCD      kl520_com_thread
                  |L3.48|
                          DCD      ||.data||

                          AREA ||i.Drv_OTA_init||, CODE, READONLY, ALIGN=2

                  Drv_OTA_init PROC
;;;1085   
;;;1086   void Drv_OTA_init(OTA_FLASHt * stota)
000000  4a0f              LDR      r2,|L4.64|
;;;1087   {
;;;1088   #if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;1089   
;;;1090       stota->receive_cmd.ptr = 	(UINT8 *)driver_ssp_ctx.Rx_buffer;
;;;1091       stota->receive_cmd.ptr_index = (UINT32 *)driver_ssp_ctx.Rx_buffer_index;		//&gu8OTA_Rx_buffer_index;
;;;1092       *stota->receive_cmd.ptr_index = 0;
;;;1093   
;;;1094       stota->send_response.ptr = 	(UINT8 *)driver_ssp_ctx.Tx_buffer;   //gu8OTA_Tx_buffer;
;;;1095       stota->send_response.ptr_index = (UINT32 *)driver_ssp_ctx.Tx_buffer_index;	//&gu8OTA_Tx_buffer_index;
;;;1096       *stota->send_response.ptr_index = 0;
;;;1097   
;;;1098       stota->send_response.buf_max_size = driver_ssp_ctx.buffer_max_size;
;;;1099   
;;;1100   #else
;;;1101       stota->receive_cmd.ptr = gu8OTA_Rx_buffer;
;;;1102       stota->receive_cmd.ptr_index = &gu8OTA_Rx_buffer_index;
000002  f102030c          ADD      r3,r2,#0xc
000006  6891              LDR      r1,[r2,#8]  ; gu8OTA_Rx_buffer
000008  e9e01308          STRD     r1,r3,[r0,#0x20]!
;;;1103       *stota->receive_cmd.ptr_index = 0;
00000c  2100              MOVS     r1,#0
;;;1104   
;;;1105       stota->send_response.ptr = gu8OTA_Rx_buffer;
00000e  6019              STR      r1,[r3,#0]
000010  6892              LDR      r2,[r2,#8]  ; gu8OTA_Rx_buffer
;;;1106       stota->send_response.ptr_index = &gu8OTA_Tx_buffer_index;
000012  6302              STR      r2,[r0,#0x30]
000014  1d1a              ADDS     r2,r3,#4
;;;1107       *stota->send_response.ptr_index = 0;
000016  6342              STR      r2,[r0,#0x34]
;;;1108   #endif
;;;1109   
;;;1110       #if (  CFG_OTA_FLASH_BUF_ENABLE == YES)
;;;1111       stota->temp_buffer = (UINT32 *)KDP_DDR_OTA_FLASH_BUF_START_ADDR;
000018  6011              STR      r1,[r2,#0]
00001a  4a0a              LDR      r2,|L4.68|
00001c  e9c02111          STRD     r2,r1,[r0,#0x44]
;;;1112       stota->temp_buffer_index = 0;
;;;1113       stota->temp_buffer_size = KDP_DDR_OTA_FLASH_BUF_RESERVED;
000020  f44f5200          MOV      r2,#0x2000
;;;1114       #endif
;;;1115   
;;;1116       stota->target_sectors = 0;
000024  64c2              STR      r2,[r0,#0x4c]
000026  f8a0105a          STRH     r1,[r0,#0x5a]
;;;1117       stota->pass_sector_count = 0;
;;;1118       stota->sector_offset = 0;
00002a  6501              STR      r1,[r0,#0x50]
;;;1119       stota->bin_type = eOTA_bin_null;
00002c  2206              MOVS     r2,#6
00002e  6541              STR      r1,[r0,#0x54]
000030  f880205c          STRB     r2,[r0,#0x5c]
;;;1120       stota->target_bytes = 0;
;;;1121   
;;;1122   #if 1
;;;1123       stota->ddr_ptr = (UINT32 *) KDP_DDR_OTA_IMAGE_BUF_START_ADDR;		//for bin file
000034  4a04              LDR      r2,|L4.72|
000036  6601              STR      r1,[r0,#0x60]
000038  e9c0211a          STRD     r2,r1,[r0,#0x68]
;;;1124   #else
;;;1125       stota->ddr_ptr = (UINT32 *)kdp_ddr_reserve(16*1024*1024);
;;;1126   #endif
;;;1127       stota->ddr_ptr_index = 0;
;;;1128   
;;;1129   }
00003c  4770              BX       lr
;;;1130   
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      ||.data||
                  |L4.68|
                          DCD      0x61f43600
                  |L4.72|
                          DCD      0x61f45600

                          AREA ||i.Drv_OTA_main||, CODE, READONLY, ALIGN=2

                  Drv_OTA_main PROC
;;;1944   
;;;1945   void Drv_OTA_main( void )
000000  b508              PUSH     {r3,lr}
;;;1946   {
;;;1947       UINT32  countinuous_empty_count = 0;
;;;1948       UINT32  countinuous_empty_target = 10;
;;;1949   
;;;1950       static UINT16   nstat;
;;;1951       static UINT16   ptr_rx_count = 0;
;;;1952       static UINT16 nretry_acc = 0;
;;;1953       UINT16 nretry_acc_target =  3;
000002  2003              MOVS     r0,#3
000004  2500              MOVS     r5,#0                 ;1947
;;;1954   
;;;1955   #if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;1956       UINT16 response_TO = 0;
;;;1957       UINT16 response_TO_target = 100;
;;;1958   #else
;;;1959       UINT16 pre_count = 0;
;;;1960   #endif
;;;1961   
;;;1962       osThreadFlagsWait( FLAGS_FLASH_START, osFlagsWaitAny, osWaitForever);
000006  1f02              SUBS     r2,r0,#4
000008  9000              STR      r0,[sp,#0]
00000a  260a              MOVS     r6,#0xa               ;1948
00000c  46aa              MOV      r10,r5                ;1959
00000e  4629              MOV      r1,r5
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       osThreadFlagsWait
;;;1963   
;;;1964   #if CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_LWCOM
;;;1965   #if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;1966   #if (UART_INIT_AFTER_OTA == YES)
;;;1967   #ifdef COM_BUS_RESPONSE_REQUEST_PIN
;;;1968       kl520_com_init(KL520_COM_HAS_ADDITIONAL_IO);
;;;1969   #else
;;;1970       kl520_com_init(KL520_COM_NORMAL);
;;;1971   #endif
;;;1972   #endif
;;;1973   #endif
;;;1974   #endif
;;;1975   
;;;1976   #if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
;;;1977       kdp_uart_read( stCom_type.uart_port, gu8OTA_Rx_buffer, KDP_DDR_DRV_COM_BUS_RESERVED );                        //read case
000016  f8df80f8          LDR      r8,|L5.272|
00001a  4c3e              LDR      r4,|L5.276|
00001c  0272              LSLS     r2,r6,#9
00001e  f8980001          LDRB     r0,[r8,#1]  ; stCom_type
000022  68a1              LDR      r1,[r4,#8]  ; gu8OTA_Rx_buffer
000024  f7fffffe          BL       kdp_uart_read
;;;1978   #endif
;;;1979   
;;;1980       #if( OTA_LOG_EN == YES )
;;;1981       dbg_msg_flash("[OTA] flash machine Start-- !!");
;;;1982       #endif
;;;1983   
;;;1984       kl520_measure_stamp(E_MEASURE_THR_OTA_RDY);
;;;1985       while(1)
;;;1986       {
;;;1987           //dbg_msg_flash("[OTA] Start !!");
;;;1988           if( *stOTA.receive_cmd.ptr_index == 0  )
000028  4f3b              LDR      r7,|L5.280|
00002a  46a9              MOV      r9,r5                 ;1977
;;;1989           {
;;;1990               countinuous_empty_count++;
;;;1991               if( countinuous_empty_count > countinuous_empty_target ){
;;;1992                   countinuous_empty_count = countinuous_empty_target;
;;;1993                       osDelay( 10 );
;;;1994               }
;;;1995               else{
;;;1996                   osDelay( 2 );
;;;1997               }
;;;1998           }
;;;1999           else
;;;2000           {
;;;2001               countinuous_empty_count = 0;
;;;2002           }
;;;2003   
;;;2004           switch( stOTA.flow )
00002c  f04f0b04          MOV      r11,#4
                  |L5.48|
000030  6a78              LDR      r0,[r7,#0x24]         ;1988  ; stOTA
000032  6800              LDR      r0,[r0,#0]            ;1988
000034  b140              CBZ      r0,|L5.72|
000036  2500              MOVS     r5,#0                 ;2001
                  |L5.56|
000038  7838              LDRB     r0,[r7,#0]  ; stOTA
00003a  2805              CMP      r0,#5
00003c  d2f8              BCS      |L5.48|
00003e  e8dff000          TBB      [pc,r0]
000042  0d13              DCB      0x0d,0x13
000044  50105600          DCB      0x50,0x10,0x56,0x00
                  |L5.72|
000048  1c6d              ADDS     r5,r5,#1
00004a  42b5              CMP      r5,r6                 ;1991
00004c  d902              BLS      |L5.84|
00004e  4635              MOV      r5,r6                 ;1992
000050  200a              MOVS     r0,#0xa               ;1993
000052  e000              B        |L5.86|
                  |L5.84|
000054  2002              MOVS     r0,#2                 ;1996
                  |L5.86|
000056  f7fffffe          BL       osDelay
00005a  e7ed              B        |L5.56|
;;;2005           {
;;;2006               case eOTA_init:
;;;2007                   Drv_OTA_init( &stOTA );
00005c  482e              LDR      r0,|L5.280|
00005e  f7fffffe          BL       Drv_OTA_init
;;;2008                   stOTA.flow = eOTA_idle;
;;;2009                   break;
;;;2010               case eOTA_packet_analyze:
;;;2011   #if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;2012                   //SPI read data check
;;;2013                   if( *stOTA.receive_cmd.ptr_index > 0  )
;;;2014                   {
;;;2015                       while( kdp_ssp_statemachine( &driver_ssp_ctx, e_spi_rx ) == e_spi_ret_rxbusy )
;;;2016                       {
;;;2017                           delay_us(200);
;;;2018                       }
;;;2019                       #if( OTA_TIMING_DEBUG_EN == YES )
;;;2020                       //Rx check done
;;;2021                       kdp520_gpio_setdata( 1<<27);
;;;2022                       kdp520_gpio_cleardata( 1<<27);
;;;2023                       kdp520_gpio_setdata( 1<<27);
;;;2024                       kdp520_gpio_cleardata( 1<<27);
;;;2025                       #endif
;;;2026   
;;;2027                       kdp_ssp_statemachine( &driver_ssp_ctx, e_spi_disable );
;;;2028                       #if ( OTA_LOG_EN == YES )
;;;2029                       //dbg_msg_flash("[OTA] check slave Rx busy OK");
;;;2030                       #endif
;;;2031                   }
;;;2032                   else
;;;2033                   {
;;;2034                       #if ( OTA_LOG_EN == YES )
;;;2035                       //dbg_msg_flash("[OTA] check slave Rx no data 2");
;;;2036                       #endif
;;;2037                       continue;
;;;2038                   }
;;;2039   #else
;;;2040   #if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
;;;2041                   *stOTA.receive_cmd.ptr_index = kdp_uart_GetRxCount( stCom_type.dev_id );
;;;2042   #endif
;;;2043                   if(  *stOTA.receive_cmd.ptr_index ==  0  )
;;;2044                   {
;;;2045                       break;//    stOTA.flow = eOTA_idle; //sleep or others!!
;;;2046                   }
;;;2047                   else        //add
;;;2048                   {
;;;2049                       if(  pre_count != *stOTA.receive_cmd.ptr_index )
;;;2050                       {
;;;2051                           pre_count = *stOTA.receive_cmd.ptr_index;
;;;2052                           delay_ms(1);
;;;2053                           continue;
;;;2054                       }
;;;2055                   }
;;;2056   #endif
;;;2057   
;;;2058                   if(  ( nstat = drv_ota_packet_analyze( &stOTA ) ) == FLASH_PACKET_OK )
;;;2059                   {
;;;2060                       #if( OTA_LOG_EN == YES )
;;;2061                       dbg_msg_flash("[OTA] Packet head and tail check OK");
;;;2062                       #endif
;;;2063   
;;;2064                       nstat = drv_flash_main( &stOTA );
;;;2065                       stOTA.receive_cmd.busy_flag = 0;
;;;2066                       stOTA.flow = eOTA_response_doing;
;;;2067                   }
;;;2068                   else
;;;2069                   {
;;;2070                       stOTA.receive_cmd.busy_flag = 0;
;;;2071                       if( nstat ==  PACKET_HEAD_CHECK_ERROR )
;;;2072                       {
;;;2073                         #if( OTA_LOG_EN == YES )
;;;2074                           dbg_msg_flash("[OTA] Packet head error");
;;;2075                           #endif
;;;2076                           //goto report error
;;;2077                           stOTA.flow = eOTA_response_doing;
;;;2078                       }
;;;2079                       if( nstat ==  PACKET_TAIL_CHECK_ERROR  )
;;;2080                       {
;;;2081                           if( ptr_rx_count > 0  &&  ptr_rx_count == *stOTA.receive_cmd.ptr_index )
;;;2082                           {
;;;2083                               nretry_acc ++;
;;;2084                               delay_ms(1);
;;;2085                               if( nretry_acc >= nretry_acc_target )
;;;2086                               {
;;;2087                                   #if( OTA_LOG_EN == YES )
;;;2088                                   dbg_msg_flash("[OTA] Packet tail error timeout, ignore this packet! ");
;;;2089                                   #endif
;;;2090                                   nretry_acc = 0;
;;;2091   #if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;2092                                   //stOTA.flow = eOTA_idle;
;;;2093                                   stOTA.flow = eOTA_response_doing;
;;;2094   #else
;;;2095                                   stOTA.flow = eOTA_response_doing;
;;;2096   #endif
;;;2097                               }
;;;2098                               else
;;;2099                               {
;;;2100                                   //stOTA.flow = eOTA_packet_analyze;		//any good case
;;;2101                               }
;;;2102                           }
;;;2103                           ptr_rx_count = *stOTA.receive_cmd.ptr_index;
;;;2104                       }
;;;2105                   }
;;;2106                   break;
;;;2107               case	eOTA_response_doing:
;;;2108                 #if( OTA_LOG_EN == YES )
;;;2109                   dbg_msg_flash("[OTA] Packet response doing");
;;;2110                   #endif
;;;2111   
;;;2112   #if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;2113                   kdp_ssp_clear_rxhw( driver_ssp_ctx.reg_base_address );
;;;2114                   kdp_ssp_clear_txhw( driver_ssp_ctx.reg_base_address );
;;;2115   #endif
;;;2116   
;;;2117                   Drv_OTA_packet_response( &stOTA, nstat ) ;
;;;2118   
;;;2119   #if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;2120   
;;;2121                   Drv_OTA_Traffic_enable();
;;;2122   
;;;2123   #ifdef COM_BUS_RESPONSE_REQUEST_PIN
;;;2124                   if (stCom_type.flags == KL520_COM_HAS_ADDITIONAL_IO)
;;;2125                   {
;;;2126                       kdp_slave_request_active();
;;;2127                   }
;;;2128   #endif
;;;2129   
;;;2130                   while( kdp_ssp_get_tx_done_flag( &driver_ssp_ctx ) == 0 )
;;;2131                   {
;;;2132                       delay_ms(30);
;;;2133                       response_TO ++;
;;;2134                       if(response_TO > response_TO_target)
;;;2135                       {
;;;2136                           response_TO = 0;
;;;2137                           #if( OTA_LOG_EN == YES )
;;;2138                           dbg_msg_flash("[OTA] Packet SPI Rx TimeOut");
;;;2139                           #endif
;;;2140                           break;
;;;2141                       }
;;;2142                   }
;;;2143                   response_TO = 0;
;;;2144                   #if( OTA_LOG_EN == YES )
;;;2145                   dbg_msg_flash("[OTA] Packet response Pre-done");
;;;2146                   #endif
;;;2147                   while( kdp_ssp_statemachine( &driver_ssp_ctx, e_spi_rx ) == e_spi_ret_rxbusy )
;;;2148                   {
;;;2149                           delay_us(30);
;;;2150                   }
;;;2151   
;;;2152                   Drv_OTA_Clear_all_sw_buffer();
;;;2153   #endif
;;;2154   
;;;2155   #if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;2156   #if( OTA_LOG_EN == YES )
;;;2157                   dbg_msg_flash("[OTA] Packet response done");
;;;2158   #ifdef COM_BUS_RESPONSE_REQUEST_PIN
;;;2159                   if (stCom_type.flags == KL520_COM_HAS_ADDITIONAL_IO)
;;;2160                   {
;;;2161                       kdp_slave_request_inactive();
;;;2162                   }
;;;2163   #endif
;;;2164   #endif
;;;2165   #endif
;;;2166   
;;;2167                   stOTA.flow = eOTA_idle;
;;;2168                   //break;
;;;2169   
;;;2170               case eOTA_idle:
;;;2171                   nretry_acc = 0;
;;;2172   
;;;2173   #if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;2174   
;;;2175   #elif ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
;;;2176                   kdp_uart_read( stCom_type.uart_port, gu8OTA_Rx_buffer, KDP_DDR_DRV_COM_BUS_RESERVED );                        //read case
;;;2177   #endif
;;;2178                   *stOTA.receive_cmd.ptr_index = 0 ;
;;;2179                   *stOTA.send_response.ptr_index = 0;
;;;2180                   stOTA.flow = eOTA_packet_analyze;
;;;2181                   #if( OTA_TIMING_DEBUG_EN == YES )
;;;2182                   dbg_msg_flash("[OTA] wait!!");
;;;2183                   #endif
;;;2184   
;;;2185                   #if( OTA_TIMING_DEBUG_EN == YES )
;;;2186                   kdp520_gpio_setdata( 1<<25 );
;;;2187                   kdp520_gpio_cleardata( 1<<25 );
;;;2188                   kdp520_gpio_setdata( 1<<25 );
;;;2189                   kdp520_gpio_cleardata( 1<<25 );
;;;2190                   #endif
;;;2191                   break;
;;;2192               case eOTA_error_report:
;;;2193                   stOTA.flow = eOTA_idle;
000062  f887b000          STRB     r11,[r7,#0]
;;;2194                   break;
000066  e7e3              B        |L5.48|
000068  f8980002          LDRB     r0,[r8,#2]            ;2041  ; stCom_type
00006c  f7fffffe          BL       kdp_uart_GetRxCount
000070  6a79              LDR      r1,[r7,#0x24]         ;2041  ; stOTA
000072  2800              CMP      r0,#0                 ;2043
000074  6008              STR      r0,[r1,#0]            ;2043
000076  d0db              BEQ      |L5.48|
000078  4550              CMP      r0,r10                ;2049
00007a  d005              BEQ      |L5.136|
00007c  fa1ffa80          UXTH     r10,r0                ;2051
000080  2001              MOVS     r0,#1                 ;2052
000082  f7fffffe          BL       delay_ms
000086  e7d3              B        |L5.48|
                  |L5.136|
000088  4823              LDR      r0,|L5.280|
00008a  f7fffffe          BL       drv_ota_packet_analyze
00008e  8020              STRH     r0,[r4,#0]            ;2058
000090  2866              CMP      r0,#0x66              ;2058
000092  d01d              BEQ      |L5.208|
000094  f887901c          STRB     r9,[r7,#0x1c]         ;2070
000098  28e0              CMP      r0,#0xe0              ;2071
00009a  d01f              BEQ      |L5.220|
00009c  28e1              CMP      r0,#0xe1              ;2079
00009e  d1c7              BNE      |L5.48|
0000a0  8860              LDRH     r0,[r4,#2]            ;2081  ; ptr_rx_count
0000a2  b188              CBZ      r0,|L5.200|
0000a4  6a79              LDR      r1,[r7,#0x24]         ;2081  ; stOTA
0000a6  6809              LDR      r1,[r1,#0]            ;2081
0000a8  4281              CMP      r1,r0                 ;2081
0000aa  d10d              BNE      |L5.200|
0000ac  88a0              LDRH     r0,[r4,#4]            ;2083  ; nretry_acc
0000ae  1c40              ADDS     r0,r0,#1              ;2083
0000b0  80a0              STRH     r0,[r4,#4]            ;2083
0000b2  2001              MOVS     r0,#1                 ;2084
0000b4  f7fffffe          BL       delay_ms
0000b8  88a1              LDRH     r1,[r4,#4]            ;2085  ; nretry_acc
0000ba  9800              LDR      r0,[sp,#0]            ;2085
0000bc  4281              CMP      r1,r0                 ;2085
0000be  d303              BCC      |L5.200|
0000c0  f8a49004          STRH     r9,[r4,#4]            ;2090
0000c4  2002              MOVS     r0,#2                 ;2095
0000c6  7038              STRB     r0,[r7,#0]            ;2095
                  |L5.200|
0000c8  6a78              LDR      r0,[r7,#0x24]         ;2103  ; stOTA
0000ca  8800              LDRH     r0,[r0,#0]            ;2103
0000cc  8060              STRH     r0,[r4,#2]            ;2103
0000ce  e7af              B        |L5.48|
                  |L5.208|
0000d0  4811              LDR      r0,|L5.280|
0000d2  f7fffffe          BL       drv_flash_main
0000d6  8020              STRH     r0,[r4,#0]            ;2064
0000d8  f887901c          STRB     r9,[r7,#0x1c]         ;2065
                  |L5.220|
0000dc  2002              MOVS     r0,#2                 ;2077
                  |L5.222|
0000de  7038              STRB     r0,[r7,#0]            ;2077
0000e0  e7a6              B        |L5.48|
0000e2  8821              LDRH     r1,[r4,#0]            ;2117  ; nstat
0000e4  480c              LDR      r0,|L5.280|
0000e6  f7fffffe          BL       Drv_OTA_packet_response
0000ea  f887b000          STRB     r11,[r7,#0]           ;2167
0000ee  f8a49004          STRH     r9,[r4,#4]            ;2171
0000f2  f8980001          LDRB     r0,[r8,#1]            ;2176  ; stCom_type
0000f6  f44f52a0          MOV      r2,#0x1400            ;2176
0000fa  68a1              LDR      r1,[r4,#8]            ;2176  ; gu8OTA_Rx_buffer
0000fc  f7fffffe          BL       kdp_uart_read
000100  6a79              LDR      r1,[r7,#0x24]         ;2178  ; stOTA
000102  2001              MOVS     r0,#1                 ;2180
000104  f8c19000          STR      r9,[r1,#0]            ;2179
000108  6d79              LDR      r1,[r7,#0x54]         ;2179  ; stOTA
00010a  f8c19000          STR      r9,[r1,#0]            ;2191
00010e  e7e6              B        |L5.222|
;;;2195               default:
;;;2196                   break;
;;;2197           }
;;;2198       }
;;;2199   }
;;;2200   
                          ENDP

                  |L5.272|
                          DCD      stCom_type
                  |L5.276|
                          DCD      ||.data||
                  |L5.280|
                          DCD      ||.bss||

                          AREA ||i.Drv_OTA_packet_response||, CODE, READONLY, ALIGN=2

                  Drv_OTA_packet_response PROC
;;;1763   
;;;1764   void Drv_OTA_packet_response( OTA_FLASHt * stota, UINT16 status )
000000  b510              PUSH     {r4,lr}
;;;1765   {
000002  4604              MOV      r4,r0
;;;1766   
;;;1767       UINT8	*ptr = stota->send_response.ptr;
;;;1768       UINT32	*ptr_indedx = stota->send_response.ptr_index;
;;;1769   
;;;1770       UINT8	ncmd = stota->receive_cmd.cmd_stat;
000004  6d42              LDR      r2,[r0,#0x54]
000006  7a80              LDRB     r0,[r0,#0xa]
;;;1771       UINT32	nchecksum = 0;
;;;1772   
;;;1773       stota->send_response.head = ~( FLASH_HEAD_RX );
000008  4b56              LDR      r3,|L6.356|
;;;1774       stota->send_response.host_number = stota->receive_cmd.host_number;
00000a  6363              STR      r3,[r4,#0x34]
00000c  8923              LDRH     r3,[r4,#8]
00000e  8723              STRH     r3,[r4,#0x38]
;;;1775       stota->send_response.tail = FLASH_TAIL;
000010  f6470387          MOV      r3,#0x7887
000014  f8a43048          STRH     r3,[r4,#0x48]
;;;1776   
;;;1777       #if( NIR_RGB_OTA_EN==1 )
;;;1778       stota->send_response.action_number = stota->receive_cmd.action_number;
000018  7ba3              LDRB     r3,[r4,#0xe]
00001a  f884303e          STRB     r3,[r4,#0x3e]
;;;1779       #endif
;;;1780   
;;;1781   
;;;1782       //--- error message
;;;1783       if( status == PACKET_HEAD_CHECK_ERROR || status ==PACKET_TAIL_CHECK_ERROR || status == FLASH_DRV_FAIL )
00001e  29e0              CMP      r1,#0xe0
000020  d00b              BEQ      |L6.58|
000022  29e1              CMP      r1,#0xe1
000024  d009              BEQ      |L6.58|
000026  29e2              CMP      r1,#0xe2
000028  d007              BEQ      |L6.58|
;;;1784       {
;;;1785           stota->send_response.status = FLASH_STATUS_FAIL;
;;;1786       }
;;;1787       else if( status >=FLASH_STATUS_COMPARE_FAIL && status <= FLASH_STATUS_CRC_FAIL )
00002a  f5a1436e          SUB      r3,r1,#0xee00
00002e  3be0              SUBS     r3,r3,#0xe0
000030  2b05              CMP      r3,#5
000032  d805              BHI      |L6.64|
;;;1788       {
;;;1789           stota->send_response.status  = status;
000034  f8a4104a          STRH     r1,[r4,#0x4a]
000038  e08f              B        |L6.346|
                  |L6.58|
00003a  f64e60ee          MOV      r0,#0xeeee            ;1785
00003e  e010              B        |L6.98|
                  |L6.64|
;;;1790   
;;;1791           dbg_msg_flash("CRC error 0x%x", status );
;;;1792       }
;;;1793       else if( status == FLASH_DRV_PROGRAM_FAIL )
000040  29e3              CMP      r1,#0xe3
000042  d00c              BEQ      |L6.94|
;;;1794       {
;;;1795           stota->send_response.status = FLASH_STATUS_PROGRAM_FAIL;		//if program fail
;;;1796   
;;;1797       }
;;;1798       else
;;;1799       {
;;;1800           //--- program or read
;;;1801           stota->send_response.status = FLASH_STATUS_OK;
000044  f6470155          MOV      r1,#0x7855
000048  f8a4104a          STRH     r1,[r4,#0x4a]
;;;1802           stota->send_response.cmd_stat = ncmd;
00004c  8760              STRH     r0,[r4,#0x3a]
;;;1803   
;;;1804           if( ncmd == FLASH_PROGRAM_ACT || ncmd == FLASH_CMD_ACT || ncmd == FLASH_ERASE_SECTOR_ACT || ncmd == FLASH_UI_MODEL_INFO )
00004e  28f0              CMP      r0,#0xf0
000050  d00a              BEQ      |L6.104|
000052  b148              CBZ      r0,|L6.104|
000054  28f2              CMP      r0,#0xf2
000056  d007              BEQ      |L6.104|
000058  28fe              CMP      r0,#0xfe
00005a  d005              BEQ      |L6.104|
00005c  e009              B        |L6.114|
                  |L6.94|
00005e  f64e60e2          MOV      r0,#0xeee2            ;1795
                  |L6.98|
000062  f8a4004a          STRH     r0,[r4,#0x4a]         ;1795
000066  e078              B        |L6.346|
                  |L6.104|
;;;1805           {
;;;1806               stota->send_response.sector_index = 0;
000068  2100              MOVS     r1,#0
00006a  87a1              STRH     r1,[r4,#0x3c]
;;;1807               stota->send_response.data_size = 0;
00006c  f8a41040          STRH     r1,[r4,#0x40]
;;;1808               stota->send_response.check_sum = 0;
000070  6461              STR      r1,[r4,#0x44]
                  |L6.114|
;;;1809   
;;;1810           }
;;;1811           if( ncmd == FLASH_MODEL_SIZE )
000072  28fa              CMP      r0,#0xfa
000074  d008              BEQ      |L6.136|
;;;1812           {
;;;1813               nchecksum = ((stota->send_response.status&0xFF) + (stota->send_response.status>>8)&0xFF );
;;;1814               nchecksum += ((stota->second_last_start_add>>24)&0xFF)+((stota->second_last_start_add>>16)&0xFF)
;;;1815                               +((stota->second_last_start_add>>8)&0xFF)+((stota->second_last_start_add>>0)&0xFF);
;;;1816               nchecksum += ((stota->model_size>>24)&0xFF)+((stota->model_size>>16)&0xFF)
;;;1817                               +((stota->model_size>>8)&0xFF)+((stota->model_size>>0)&0xFF);
;;;1818               stota->send_response.check_sum = nchecksum;
;;;1819   
;;;1820           }
;;;1821   
;;;1822           if( ncmd == FLASH_READ_ACT )
000076  28f1              CMP      r0,#0xf1
000078  d01f              BEQ      |L6.186|
;;;1823           {
;;;1824   
;;;1825               stota->send_response.sector_index = stota->receive_cmd.sector_index;
;;;1826               stota->send_response.data_size = *stota->send_response.ptr_index;
;;;1827   
;;;1828   
;;;1829               //dbg_msg_flash("[OTA] Read checksum 1, size: %d",stota->send_response.data_size  );
;;;1830   //			nchecksum = Drv_utility_checksum( ptr , 0, *ptr_indedx );
;;;1831               ptr = stota->receive_cmd.ptr;
;;;1832               nchecksum = Drv_utility_checksum( ptr , 0, stota->send_response.data_size );
;;;1833   
;;;1834               //dbg_msg_flash("[OTA] Read checksum 2");
;;;1835   
;;;1836               nchecksum+= ( (stota->send_response.data_size&0xFF)  +  (stota->send_response.data_size>>8)&0xFF );
;;;1837               nchecksum+= ( (stota->send_response.sector_index&0xFF) + (stota->send_response.sector_index>>8)&0xFF );
;;;1838               nchecksum+= ((stota->send_response.status&0xFF) + (stota->send_response.status>>8)&0xFF );
;;;1839               stota->send_response.check_sum = nchecksum;
;;;1840           }
;;;1841   
;;;1842   #if( NIR_RGB_OTA_EN==1 )
;;;1843           if( ncmd == FLASH_READ_RGB_ACT || ncmd == FLASH_READ_NIR_ACT || ncmd == FLASH_READ_ALL_ACT)
00007a  28e2              CMP      r0,#0xe2
00007c  d039              BEQ      |L6.242|
00007e  28e1              CMP      r0,#0xe1
000080  d037              BEQ      |L6.242|
000082  28e3              CMP      r0,#0xe3
000084  d035              BEQ      |L6.242|
000086  e05c              B        |L6.322|
                  |L6.136|
000088  f8d40094          LDR      r0,[r4,#0x94]         ;1814
00008c  f3c04107          UBFX     r1,r0,#16,#8          ;1814
000090  eb016110          ADD      r1,r1,r0,LSR #24      ;1814
000094  f3c02207          UBFX     r2,r0,#8,#8           ;1814
000098  4411              ADD      r1,r1,r2              ;1814
00009a  b2c0              UXTB     r0,r0                 ;1814
00009c  4401              ADD      r1,r1,r0              ;1814
00009e  f8d400a0          LDR      r0,[r4,#0xa0]         ;1816
0000a2  31cd              ADDS     r1,r1,#0xcd           ;1816
0000a4  f3c04207          UBFX     r2,r0,#16,#8          ;1816
0000a8  eb026210          ADD      r2,r2,r0,LSR #24      ;1816
0000ac  f3c02307          UBFX     r3,r0,#8,#8           ;1816
0000b0  441a              ADD      r2,r2,r3              ;1816
0000b2  b2c0              UXTB     r0,r0                 ;1816
0000b4  4410              ADD      r0,r0,r2              ;1816
0000b6  4408              ADD      r0,r0,r1              ;1816
0000b8  e042              B        |L6.320|
                  |L6.186|
0000ba  f8340f0c          LDRH     r0,[r4,#0xc]!         ;1825
0000be  2100              MOVS     r1,#0                 ;1832
0000c0  8620              STRH     r0,[r4,#0x30]         ;1825
0000c2  8810              LDRH     r0,[r2,#0]            ;1826
0000c4  b282              UXTH     r2,r0                 ;1826
0000c6  86a2              STRH     r2,[r4,#0x34]         ;1826
0000c8  6960              LDR      r0,[r4,#0x14]         ;1832
0000ca  f7fffffe          BL       Drv_utility_checksum
0000ce  8ea1              LDRH     r1,[r4,#0x34]         ;1836
0000d0  eb012111          ADD      r1,r1,r1,LSR #8       ;1836
0000d4  fa50f081          UXTAB    r0,r0,r1              ;1836
0000d8  8e21              LDRH     r1,[r4,#0x30]         ;1837
0000da  eb012111          ADD      r1,r1,r1,LSR #8       ;1837
0000de  fa50f081          UXTAB    r0,r0,r1              ;1837
0000e2  8fe1              LDRH     r1,[r4,#0x3e]         ;1838
0000e4  eb012111          ADD      r1,r1,r1,LSR #8       ;1838
0000e8  fa50f081          UXTAB    r0,r0,r1              ;1838
0000ec  63a0              STR      r0,[r4,#0x38]         ;1839
0000ee  3c0c              SUBS     r4,r4,#0xc            ;1839
0000f0  e027              B        |L6.322|
                  |L6.242|
;;;1844           {
;;;1845               stota->send_response.sector_index = stota->receive_cmd.sector_index;
0000f2  89a3              LDRH     r3,[r4,#0xc]
0000f4  87a3              STRH     r3,[r4,#0x3c]
;;;1846               stota->send_response.data_size = *stota->send_response.ptr_index;
0000f6  8811              LDRH     r1,[r2,#0]
0000f8  f8a41040          STRH     r1,[r4,#0x40]
;;;1847               stota->send_response.packet_ddr_ptr = stota->receive_cmd.packet_ddr_ptr;
0000fc  6b21              LDR      r1,[r4,#0x30]
;;;1848   
;;;1849               if(ncmd == FLASH_READ_RGB_ACT){
;;;1850                   stota->send_response.packet_ddr_ptr = KDP_DDR_TEST_RGB_IMG_ADDR;
0000fe  6621              STR      r1,[r4,#0x60]
000100  4919              LDR      r1,|L6.360|
000102  28e2              CMP      r0,#0xe2              ;1849
000104  d001              BEQ      |L6.266|
;;;1851               }
;;;1852               else if(ncmd == FLASH_READ_NIR_ACT){
000106  28e1              CMP      r0,#0xe1
000108  d01e              BEQ      |L6.328|
                  |L6.266|
;;;1853                   stota->send_response.packet_ddr_ptr = KDP_DDR_TEST_NIR_IMG_ADDR;
;;;1854               }
;;;1855               else if(ncmd == FLASH_READ_ALL_ACT){
;;;1856                   stota->send_response.packet_ddr_ptr = KDP_DDR_TEST_RGB_IMG_ADDR;    //KDP_DDR_TEST_RGB_IMG_ADDR + KDP_DDR_TEST_NIR_IMG_ADDR + KDP_DDR_TEST_INF_IMG_ADDR
;;;1857               }
;;;1858               else{
;;;1859                   stota->send_response.packet_ddr_ptr = KDP_DDR_TEST_RGB_IMG_ADDR;    //Init packet_ddr_ptr
;;;1860               }
;;;1861   
;;;1862               nchecksum = Drv_utility_checksum( (UINT8 *)stota->send_response.packet_ddr_ptr + stota->send_response.sector_index*4096			//packet_ddr_ptr+dector_index*4096 = real_address
00010a  4608              MOV      r0,r1
00010c  f8c41060          STR.W    r1,[r4,#0x60]
                  |L6.272|
000110  8811              LDRH     r1,[r2,#0]
000112  eb003003          ADD      r0,r0,r3,LSL #12
000116  b28a              UXTH     r2,r1
000118  2100              MOVS     r1,#0
00011a  f7fffffe          BL       Drv_utility_checksum
;;;1863                                                               , 0, *ptr_indedx );
;;;1864   
;;;1865               nchecksum+= ( (stota->send_response.data_size&0xFF)  +  (stota->send_response.data_size>>8)&0xFF );
00011e  f8b41040          LDRH     r1,[r4,#0x40]
000122  eb012111          ADD      r1,r1,r1,LSR #8
000126  fa50f081          UXTAB    r0,r0,r1
;;;1866               nchecksum+= ( (stota->send_response.sector_index&0xFF) + (stota->send_response.sector_index>>8)&0xFF );
00012a  8fa1              LDRH     r1,[r4,#0x3c]
00012c  eb012111          ADD      r1,r1,r1,LSR #8
000130  fa50f081          UXTAB    r0,r0,r1
;;;1867               nchecksum+= ((stota->send_response.status&0xFF) + (stota->send_response.status>>8)&0xFF );
000134  f8b4104a          LDRH     r1,[r4,#0x4a]
000138  eb012111          ADD      r1,r1,r1,LSR #8
00013c  fa50f081          UXTAB    r0,r0,r1
                  |L6.320|
000140  6460              STR      r0,[r4,#0x44]         ;1818
                  |L6.322|
;;;1868               stota->send_response.check_sum = nchecksum;
;;;1869           }
;;;1870   #endif
;;;1871   
;;;1872           if( ( stota->receive_cmd.cmd_stat == FLASH_CMD_ACT ) && ( stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SW_VERSION ) )
000142  8960              LDRH     r0,[r4,#0xa]
000144  b118              CBZ      r0,|L6.334|
000146  e008              B        |L6.346|
                  |L6.328|
000148  4808              LDR      r0,|L6.364|
00014a  6620              STR      r0,[r4,#0x60]         ;1853
00014c  e7e0              B        |L6.272|
                  |L6.334|
00014e  7ba0              LDRB     r0,[r4,#0xe]
000150  2805              CMP      r0,#5
000152  d102              BNE      |L6.346|
;;;1873           {
;;;1874               Drv_OTA_Get_Version( stota );
000154  4620              MOV      r0,r4
000156  f7fffffe          BL       Drv_OTA_Get_Version
                  |L6.346|
;;;1875           }
;;;1876   
;;;1877       }
;;;1878   
;;;1879       //-------------- packet data into Uart FIFO ----------------------
;;;1880   #if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;1881       Drv_SPI_Slave_Tx( stota , &driver_ssp_ctx );
;;;1882       kdp_ssp_pre_write_to_fifo( &driver_ssp_ctx, 5 );
;;;1883   #else
;;;1884       Drv_Uart_Tx_send(stota);
00015a  4620              MOV      r0,r4
00015c  e8bd4010          POP      {r4,lr}
000160  f7ffbffe          B.W      Drv_Uart_Tx_send
;;;1885   #endif
;;;1886   
;;;1887       return;
;;;1888   
;;;1889   }
;;;1890   
                          ENDP

                  |L6.356|
                          DCD      0x8778a55a
                  |L6.360|
                          DCD      0x61e30000
                  |L6.364|
                          DCD      0x61ea5300

                          AREA ||i.Drv_Uart2_Tx_arrange||, CODE, READONLY, ALIGN=1

                  Drv_Uart2_Tx_arrange PROC
;;;1324   #if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
;;;1325   void Drv_Uart2_Tx_arrange( void * data_ptr , UINT16 len)
000000  b570              PUSH     {r4-r6,lr}
;;;1326   {
;;;1327   #if ( ( CFG_COM_BUS_TYPE&COM_BUS_UART0 ) == COM_BUS_UART0 )
;;;1328       kdp_uart_dev_id uart_dev = UART0_DEV;
;;;1329   #elif ( ( CFG_COM_BUS_TYPE&COM_BUS_UART1 ) == COM_BUS_UART1 )
;;;1330       kdp_uart_dev_id uart_dev = UART1_DEV;
;;;1331   #elif ( ( CFG_COM_BUS_TYPE&COM_BUS_UART2 ) == COM_BUS_UART2 )
;;;1332       kdp_uart_dev_id uart_dev = UART2_DEV;
000002  2502              MOVS     r5,#2
000004  4604              MOV      r4,r0                 ;1326
;;;1333   #elif ( ( CFG_COM_BUS_TYPE&COM_BUS_UART3 ) == COM_BUS_UART3 )
;;;1334       kdp_uart_dev_id uart_dev = UART3_DEV;
;;;1335   #elif ( ( CFG_COM_BUS_TYPE&COM_BUS_UART4 ) == COM_BUS_UART4 )
;;;1336       kdp_uart_dev_id uart_dev = UART4_DEV;
;;;1337   #else
;;;1338       kdp_uart_dev_id uart_dev = NULL;
;;;1339   #endif
;;;1340   
;;;1341       if( len == 1 )
000006  2901              CMP      r1,#1
000008  d019              BEQ      |L7.62|
;;;1342       {
;;;1343           kdp_uart_write(uart_dev, (UINT8 *)data_ptr, 1 );
;;;1344       }
;;;1345       else if( len == 2 )
00000a  2902              CMP      r1,#2
00000c  d00b              BEQ      |L7.38|
;;;1346       {
;;;1347           kdp_uart_write(uart_dev, ((UINT8 *)data_ptr)+1, 1 );
;;;1348           kdp_uart_write(uart_dev, ((UINT8 *)data_ptr)+0, 1 );
;;;1349       }
;;;1350       else if( len == 4 )
00000e  2904              CMP      r1,#4
000010  d118              BNE      |L7.68|
;;;1351       {
;;;1352           kdp_uart_write(uart_dev, ((UINT8 *)data_ptr)+3, 1 );
000012  2201              MOVS     r2,#1
000014  1ce1              ADDS     r1,r4,#3
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       kdp_uart_write
;;;1353           kdp_uart_write(uart_dev, ((UINT8 *)data_ptr)+2, 1 );
00001c  2201              MOVS     r2,#1
00001e  1ca1              ADDS     r1,r4,#2
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       kdp_uart_write
                  |L7.38|
000026  2201              MOVS     r2,#1                 ;1347
000028  1c61              ADDS     r1,r4,#1              ;1347
00002a  4628              MOV      r0,r5                 ;1347
00002c  f7fffffe          BL       kdp_uart_write
000030  2201              MOVS     r2,#1                 ;1348
000032  4621              MOV      r1,r4                 ;1348
                  |L7.52|
000034  4628              MOV      r0,r5                 ;1348
000036  e8bd4070          POP      {r4-r6,lr}            ;1348
00003a  f7ffbffe          B.W      kdp_uart_write
                  |L7.62|
00003e  2201              MOVS     r2,#1                 ;1343
000040  4601              MOV      r1,r0                 ;1343
000042  e7f7              B        |L7.52|
                  |L7.68|
;;;1354           kdp_uart_write(uart_dev, ((UINT8 *)data_ptr)+1, 1 );
;;;1355           kdp_uart_write(uart_dev, ((UINT8 *)data_ptr)+0, 1 );
;;;1356       }
;;;1357       else
;;;1358       {
;;;1359           //error
;;;1360       }
;;;1361   
;;;1362   }
000044  bd70              POP      {r4-r6,pc}
;;;1363   
                          ENDP


                          AREA ||i.Drv_Uart_Tx_send||, CODE, READONLY, ALIGN=1

                  Drv_Uart_Tx_send PROC
;;;1363   
;;;1364   void Drv_Uart_Tx_send( OTA_FLASHt * stota )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1365   {
;;;1366       UINT16	i = 0;
000004  2500              MOVS     r5,#0
000006  4604              MOV      r4,r0                 ;1365
;;;1367       UINT16	ntemp = 0;
000008  46aa              MOV      r10,r5
00000a  f8ad5000          STRH     r5,[sp,#0]
;;;1368   #if( NIR_RGB_OTA_EN==1 )
;;;1369       UINT32	noffset =0;
;;;1370   #endif
;;;1371   
;;;1372   
;;;1373       #if( PRINT_FLASH_MECHINE_DEBUG_EN == YES )
;;;1374       kdp_printf("------\r\n");
;;;1375       kdp_printf("head 0x%x \r\n", stota->send_response.head);
;;;1376       kdp_printf("host number 0x%x \r\n", stota->send_response.host_number);
;;;1377       #endif
;;;1378   
;;;1379   
;;;1380       Drv_Uart2_Tx_arrange( &stota->send_response.head, sizeof(stota->send_response.head) );
00000e  2104              MOVS     r1,#4
000010  3034              ADDS     r0,r0,#0x34
000012  f7fffffe          BL       Drv_Uart2_Tx_arrange
;;;1381       Drv_Uart2_Tx_arrange( &stota->send_response.host_number, sizeof(stota->send_response.host_number) );
000016  2102              MOVS     r1,#2
000018  f1040038          ADD      r0,r4,#0x38
00001c  f7fffffe          BL       Drv_Uart2_Tx_arrange
;;;1382   
;;;1383   
;;;1384       if(  stota->send_response.status == FLASH_STATUS_FAIL )
000020  f8b4104a          LDRH     r1,[r4,#0x4a]
;;;1385       {
;;;1386           #if( PRINT_FLASH_MECHINE_DEBUG_EN == YES )
;;;1387           kdp_printf("Status 0xEEEE\r\n");
;;;1388           kdp_printf("Tail 0x7887\r\n");
;;;1389           #endif
;;;1390   
;;;1391           Drv_Uart2_Tx_arrange( &stota->send_response.status, sizeof(stota->send_response.status) );
000024  f104024a          ADD      r2,r4,#0x4a
000028  f5a1436e          SUB      r3,r1,#0xee00         ;1384
;;;1392           Drv_Uart2_Tx_arrange( &stota->send_response.tail, sizeof(stota->send_response.tail) );
00002c  f1040848          ADD      r8,r4,#0x48
000030  3bee              SUBS     r3,r3,#0xee           ;1384
000032  d01b              BEQ      |L8.108|
;;;1393   
;;;1394           return;
;;;1395       }
;;;1396   
;;;1397       //normal status
;;;1398       if(   stota->send_response.cmd_stat == FLASH_PROGRAM_ACT )
000034  8f60              LDRH     r0,[r4,#0x3a]
000036  28f0              CMP      r0,#0xf0
000038  d018              BEQ      |L8.108|
;;;1399       {
;;;1400               //send program data
;;;1401           #if( PRINT_FLASH_MECHINE_DEBUG_EN == YES )
;;;1402           kdp_printf("program response 0x7855\r\n");
;;;1403           #endif
;;;1404   
;;;1405           Drv_Uart2_Tx_arrange( &stota->send_response.status, sizeof(stota->send_response.status) );
;;;1406   
;;;1407       }
;;;1408   
;;;1409       else if(  stota->send_response.cmd_stat == FLASH_READ_ACT )
;;;1410       {
;;;1411           Drv_Uart2_Tx_arrange( &stota->send_response.status, sizeof(stota->send_response.status) );
;;;1412           Drv_Uart2_Tx_arrange( &stota->send_response.sector_index, sizeof(stota->send_response.sector_index) );
00003a  f104073c          ADD      r7,r4,#0x3c
;;;1413           Drv_Uart2_Tx_arrange( &stota->send_response.data_size, sizeof(stota->send_response.data_size) );
00003e  1d3e              ADDS     r6,r7,#4
;;;1414   
;;;1415           //dbg_msg_flash("   [OTA] Tx send Tx_size.. pre 0x%x", *stota->send_response.ptr_index);
;;;1416           //dbg_msg_flash("   [OTA] Data size  0x%x", stota->send_response.data_size );
;;;1417   
;;;1418           //send read data
;;;1419           //a lot of data
;;;1420           *stota->send_response.ptr_index = 0 ;
;;;1421   
;;;1422           for(  i=0 ; i< stota->send_response.data_size; i++  )
;;;1423           {
;;;1424               ntemp = *( ( (UINT8 *)stota->send_response.ptr ) + i );
;;;1425               Drv_Uart2_Tx_arrange( (UINT8 *)&ntemp, 1);
;;;1426               *stota->send_response.ptr_index = *stota->send_response.ptr_index + 1 ;
;;;1427   
;;;1428               if( (i%255 ==0) && (i>0) )
;;;1429               {
;;;1430                   delay_ms(1);
;;;1431               }
;;;1432   
;;;1433               #if  0//( PRINT_FLASH_MECHINE_DEBUG_EN == YES )
;;;1434               //-----debug use--------
;;;1435               kdp_printf("0x%X ", ntemp );
;;;1436               if( i%16 ==0 && i >0 )
;;;1437               {
;;;1438                   kdp_printf("\r\n");
;;;1439               }
;;;1440               #endif
;;;1441           }
;;;1442   
;;;1443           //dbg_msg_flash("   [OTA] Tx send Tx_size.. after 0x%x", *stota->send_response.ptr_index);
;;;1444           //send checksum
;;;1445           Drv_Uart2_Tx_arrange( &stota->send_response.check_sum, sizeof(stota->send_response.check_sum) );
000040  f1040b44          ADD      r11,r4,#0x44
000044  f04f09ff          MOV      r9,#0xff              ;1428
000048  28f1              CMP      r0,#0xf1              ;1409
00004a  d012              BEQ      |L8.114|
;;;1446   
;;;1447       }
;;;1448       #if( NIR_RGB_OTA_EN==1 )
;;;1449       else if(  stota->send_response.cmd_stat == FLASH_READ_NIR_ACT ||  stota->send_response.cmd_stat == FLASH_READ_RGB_ACT ||  stota->send_response.cmd_stat == FLASH_READ_ALL_ACT  )
00004c  28e1              CMP      r0,#0xe1
00004e  d046              BEQ      |L8.222|
000050  28e2              CMP      r0,#0xe2
000052  d044              BEQ      |L8.222|
000054  28e3              CMP      r0,#0xe3
000056  d042              BEQ      |L8.222|
;;;1450       {
;;;1451           Drv_Uart2_Tx_arrange( &stota->send_response.status, sizeof(stota->send_response.status) );
;;;1452           Drv_Uart2_Tx_arrange( &stota->send_response.sector_index, sizeof(stota->send_response.sector_index) );
;;;1453           Drv_Uart2_Tx_arrange( &stota->send_response.data_size, sizeof(stota->send_response.data_size) );
;;;1454   
;;;1455           noffset =stota->send_response.sector_index*4096;
;;;1456   
;;;1457   //        dbg_msg_flash("[OTA] RGB res doing!! %d", *stota->send_response.ptr_index );
;;;1458   
;;;1459               //send read data
;;;1460               //a lot of data
;;;1461           for(  i=0 ; i< *stota->send_response.ptr_index; i++  )
;;;1462           {
;;;1463               //dbg_msg_flash("       [OTA] RGB address 0x:%x ", (UINT32)(stota->send_response.packet_ddr_ptr+ noffset + i ));
;;;1464               ntemp = *( (UINT8 *)stota->send_response.packet_ddr_ptr+ noffset + i );
;;;1465               Drv_Uart2_Tx_arrange( (UINT8 *)&ntemp, 1);
;;;1466   
;;;1467               if( (i%255 ==0) && (i>0) )
;;;1468               {
;;;1469                   delay_ms(1);
;;;1470               }
;;;1471   
;;;1472               #if  0//( PRINT_FLASH_MECHINE_DEBUG_EN == YES )
;;;1473               //-----debug use--------
;;;1474               kdp_printf("0x%X ", ntemp );
;;;1475               if( i%16 ==0 && i >0 )
;;;1476               {
;;;1477                   kdp_printf("\r\n");
;;;1478               }
;;;1479               #endif
;;;1480           }
;;;1481           //send checksum
;;;1482           Drv_Uart2_Tx_arrange( &stota->send_response.check_sum, sizeof(stota->send_response.check_sum) );
;;;1483   
;;;1484       }
;;;1485       #endif
;;;1486       else if( stota->send_response.cmd_stat == FLASH_ERASE_SECTOR_ACT  )
000058  28f2              CMP      r0,#0xf2
00005a  d007              BEQ      |L8.108|
;;;1487       {
;;;1488           #if( PRINT_FLASH_MECHINE_DEBUG_EN == YES )
;;;1489           kdp_printf("erase response 0x7855\r\n");
;;;1490           #endif
;;;1491           Drv_Uart2_Tx_arrange( &stota->send_response.status, sizeof(stota->send_response.status) );
;;;1492   
;;;1493       }
;;;1494       else if( stota->send_response.cmd_stat == FLASH_CMD_ACT )
00005c  b130              CBZ      r0,|L8.108|
;;;1495       {
;;;1496           #if( PRINT_FLASH_MECHINE_DEBUG_EN == YES )
;;;1497           kdp_printf("cmd action response 0x7855\r\n");
;;;1498           #endif
;;;1499           Drv_Uart2_Tx_arrange( &stota->send_response.status, sizeof(stota->send_response.status) );
;;;1500   
;;;1501       }
;;;1502       else if( stota->send_response.cmd_stat == FLASH_DATA_TO_DDR_ACT  || stota->send_response.cmd_stat == FLASH_UI_MODEL_INFO )
00005e  28f3              CMP      r0,#0xf3
000060  d004              BEQ      |L8.108|
000062  28fe              CMP      r0,#0xfe
000064  d002              BEQ      |L8.108|
;;;1503       {
;;;1504           Drv_Uart2_Tx_arrange( &stota->send_response.status, sizeof(stota->send_response.status) );
;;;1505       }
;;;1506       else if( stota->send_response.cmd_stat == FLASH_MODEL_SIZE )
000066  28fa              CMP      r0,#0xfa
000068  d062              BEQ      |L8.304|
00006a  e032              B        |L8.210|
                  |L8.108|
00006c  2102              MOVS     r1,#2                 ;1391
00006e  4610              MOV      r0,r2                 ;1391
000070  e02d              B        |L8.206|
                  |L8.114|
000072  2102              MOVS     r1,#2                 ;1411
000074  4610              MOV      r0,r2                 ;1411
000076  f7fffffe          BL       Drv_Uart2_Tx_arrange
00007a  2102              MOVS     r1,#2                 ;1412
00007c  4638              MOV      r0,r7                 ;1412
00007e  f7fffffe          BL       Drv_Uart2_Tx_arrange
000082  2102              MOVS     r1,#2                 ;1413
000084  4630              MOV      r0,r6                 ;1413
000086  f7fffffe          BL       Drv_Uart2_Tx_arrange
00008a  6d61              LDR      r1,[r4,#0x54]         ;1420
00008c  464e              MOV      r6,r9                 ;1428
00008e  f8c1a000          STR      r10,[r1,#0]           ;1422
000092  e016              B        |L8.194|
                  |L8.148|
000094  6d20              LDR      r0,[r4,#0x50]         ;1424
000096  2101              MOVS     r1,#1                 ;1425
000098  5d40              LDRB     r0,[r0,r5]            ;1424
00009a  f8ad0000          STRH     r0,[sp,#0]            ;1424
00009e  4668              MOV      r0,sp                 ;1425
0000a0  f7fffffe          BL       Drv_Uart2_Tx_arrange
0000a4  6d60              LDR      r0,[r4,#0x54]         ;1426
0000a6  6801              LDR      r1,[r0,#0]            ;1426
0000a8  1c49              ADDS     r1,r1,#1              ;1426
0000aa  6001              STR      r1,[r0,#0]            ;1428
0000ac  fbb5f0f6          UDIV     r0,r5,r6              ;1428
0000b0  fb065010          MLS      r0,r6,r0,r5           ;1428
0000b4  b918              CBNZ     r0,|L8.190|
0000b6  b115              CBZ      r5,|L8.190|
0000b8  2001              MOVS     r0,#1                 ;1430
0000ba  f7fffffe          BL       delay_ms
                  |L8.190|
0000be  1c6d              ADDS     r5,r5,#1              ;1430
0000c0  b2ad              UXTH     r5,r5                 ;1422
                  |L8.194|
0000c2  f8b40040          LDRH     r0,[r4,#0x40]         ;1422
0000c6  42a8              CMP      r0,r5                 ;1422
0000c8  d8e4              BHI      |L8.148|
                  |L8.202|
0000ca  2104              MOVS     r1,#4                 ;1445
0000cc  4658              MOV      r0,r11                ;1445
                  |L8.206|
;;;1507       {
;;;1508           Drv_Uart2_Tx_arrange( &stota->send_response.status, sizeof(stota->send_response.status) );
;;;1509           Drv_Uart2_Tx_arrange( &stota->second_last_start_add, sizeof(stota->second_last_start_add) );
;;;1510           Drv_Uart2_Tx_arrange( &stota->model_size, sizeof(stota->model_size) );
;;;1511           Drv_Uart2_Tx_arrange( &stota->send_response.check_sum, sizeof(stota->send_response.check_sum) );
0000ce  f7fffffe          BL       Drv_Uart2_Tx_arrange
                  |L8.210|
;;;1512       }
;;;1513   
;;;1514   
;;;1515       #if( PRINT_FLASH_MECHINE_DEBUG_EN == YES )
;;;1516       kdp_printf("Tail 0x7887\r\n");
;;;1517       #endif
;;;1518       Drv_Uart2_Tx_arrange( &stota->send_response.tail, sizeof(stota->send_response.tail) );
0000d2  2102              MOVS     r1,#2
0000d4  4640              MOV      r0,r8
0000d6  f7fffffe          BL       Drv_Uart2_Tx_arrange
;;;1519       return;
;;;1520   
;;;1521   }
0000da  e8bd8ff8          POP      {r3-r11,pc}
                  |L8.222|
0000de  2102              MOVS     r1,#2                 ;1451
0000e0  4610              MOV      r0,r2                 ;1451
0000e2  f7fffffe          BL       Drv_Uart2_Tx_arrange
0000e6  2102              MOVS     r1,#2                 ;1452
0000e8  4638              MOV      r0,r7                 ;1452
0000ea  f7fffffe          BL       Drv_Uart2_Tx_arrange
0000ee  2102              MOVS     r1,#2                 ;1453
0000f0  4630              MOV      r0,r6                 ;1453
0000f2  f7fffffe          BL       Drv_Uart2_Tx_arrange
0000f6  8fa0              LDRH     r0,[r4,#0x3c]         ;1455
0000f8  464f              MOV      r7,r9                 ;1428
0000fa  0306              LSLS     r6,r0,#12             ;1455
0000fc  e013              B        |L8.294|
                  |L8.254|
0000fe  6e20              LDR      r0,[r4,#0x60]         ;1464
000100  1971              ADDS     r1,r6,r5              ;1464
000102  5c40              LDRB     r0,[r0,r1]            ;1464
000104  f8ad0000          STRH     r0,[sp,#0]            ;1464
000108  2101              MOVS     r1,#1                 ;1465
00010a  4668              MOV      r0,sp                 ;1465
00010c  f7fffffe          BL       Drv_Uart2_Tx_arrange
000110  fbb5f0f7          UDIV     r0,r5,r7              ;1467
000114  fb075010          MLS      r0,r7,r0,r5           ;1467
000118  b918              CBNZ     r0,|L8.290|
00011a  b115              CBZ      r5,|L8.290|
00011c  2001              MOVS     r0,#1                 ;1469
00011e  f7fffffe          BL       delay_ms
                  |L8.290|
000122  1c6d              ADDS     r5,r5,#1              ;1469
000124  b2ad              UXTH     r5,r5                 ;1461
                  |L8.294|
000126  6d60              LDR      r0,[r4,#0x54]         ;1461
000128  6800              LDR      r0,[r0,#0]            ;1461
00012a  42a8              CMP      r0,r5                 ;1461
00012c  d8e7              BHI      |L8.254|
00012e  e7cc              B        |L8.202|
                  |L8.304|
000130  2102              MOVS     r1,#2                 ;1508
000132  4610              MOV      r0,r2                 ;1508
000134  f7fffffe          BL       Drv_Uart2_Tx_arrange
000138  2104              MOVS     r1,#4                 ;1509
00013a  f1040094          ADD      r0,r4,#0x94           ;1509
00013e  f7fffffe          BL       Drv_Uart2_Tx_arrange
000142  2104              MOVS     r1,#4                 ;1510
000144  f10400a0          ADD      r0,r4,#0xa0           ;1510
000148  f7fffffe          BL       Drv_Uart2_Tx_arrange
00014c  e7bd              B        |L8.202|
;;;1522   
                          ENDP


                          AREA ||i.Drv_flash_action_doing||, CODE, READONLY, ALIGN=2

                  Drv_flash_action_doing PROC
;;;145    
;;;146    UINT16 Drv_flash_action_doing( OTA_FLASHt * stota )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;147    {
000004  4604              MOV      r4,r0
;;;148        //#define BOOT_STATE_CONFIRMED        0x1
;;;149        //#define BOOT_STATE_FIRST_BOOT       0x2
;;;150        //#define BOOT_STATE_POST_FIRST_BOOT  0x4
;;;151        //#define BOOT_STATE_NOT_CONFIRMED    0x8
;;;152        UINT16 ret = FLASH_DRV_OK;
;;;153        #if( OTA_USER_BACKUP == YES )
;;;154        int area = 0;
;;;155        #endif
;;;156    
;;;157        if( stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_PROC_DONE )
000006  7b80              LDRB     r0,[r0,#0xe]
000008  2601              MOVS     r6,#1                 ;152
00000a  2500              MOVS     r5,#0
00000c  2806              CMP      r0,#6
00000e  d014              BEQ      |L9.58|
;;;158        {
;;;159            if( stota->bin_type == eOTA_bin_scpu ){
;;;160                //scpu
;;;161                // if(  boot_cfg_0.scpu_cfg.flag == BOOT_STATE_FIRST_BOOT )
;;;162                // {
;;;163                //     ota_burn_in_config( 1 );
;;;164                //     #if( OTA_LOG_EN == YES )
;;;165                //     dbg_msg_flash("[OTA cfg] config scpu burn in area0");
;;;166                //     #endif
;;;167                // }
;;;168                // else if(  boot_cfg_1.scpu_cfg.flag == BOOT_STATE_FIRST_BOOT )
;;;169                // {
;;;170                //     ota_burn_in_config( 2 );
;;;171                //     #if( OTA_LOG_EN == YES )
;;;172                //     dbg_msg_flash("[OTA cfg] config scpu burn in area1");
;;;173                //     #endif
;;;174                // }
;;;175            }
;;;176            else if(  stota->bin_type == eOTA_bin_ncpu )
;;;177            {
;;;178                //ncpu
;;;179                // if(  boot_cfg_0.ncpu_cfg.flag == BOOT_STATE_FIRST_BOOT )
;;;180                // {
;;;181                //     ota_burn_in_config( 1 );
;;;182                //     #if( OTA_LOG_EN == YES )
;;;183                //     dbg_msg_flash("[OTA cfg] config ncpu burn in area1");
;;;184                //     #endif
;;;185                // }
;;;186                // else if(  boot_cfg_1.ncpu_cfg.flag == BOOT_STATE_FIRST_BOOT )
;;;187                // {
;;;188                //     ota_burn_in_config( 2 );
;;;189                //     #if( OTA_LOG_EN == YES )
;;;190                //     dbg_msg_flash("[OTA cfg] config ncpu burn in area1");
;;;191                //     #endif
;;;192                // }
;;;193            }
;;;194            else if( stota->bin_type == eOTA_bin_fw_info )
;;;195            {
;;;196                //OK do nothing
;;;197                #if( OTA_USER_BACKUP == YES)
;;;198                area = ota_user_select_wait_active_area(USER_PARTITION_FW_INFO);
;;;199                #if( OTA_LOG_EN == YES )
;;;200                dbg_msg_flash("[OTA cfg] fw_info wait-act area:%d", area );
;;;201                #endif
;;;202                #endif
;;;203            }
;;;204            else if( stota->bin_type == eOTA_bin_all_model )
;;;205            {
;;;206                //OK do nothing
;;;207                #if( OTA_USER_BACKUP == YES)
;;;208                area = ota_user_select_wait_active_area(USER_PARTITION_MODEL);
;;;209                #if( OTA_LOG_EN == YES )
;;;210                dbg_msg_flash("[OTA cfg] all model wait-act area:%d", area );
;;;211                #endif
;;;212                #endif
;;;213            }
;;;214            else if( stota->bin_type == eOTA_bin_ui_image )
;;;215            {
;;;216                //OK do nothing
;;;217                #if( OTA_USER_BACKUP == YES)
;;;218                area = ota_user_select_wait_active_area(USER_PARTITION_UI_IMG);
;;;219                #if( OTA_LOG_EN == YES )
;;;220                dbg_msg_flash("[OTA cfg] UI wait-act area:%d", area );
;;;221                #endif
;;;222                #endif
;;;223            }
;;;224            else if ( stota->bin_type == eOTA_bin_partial_model )
;;;225            {
;;;226                #if( OTA_USER_BACKUP == YES)
;;;227                area = ota_user_select_wait_active_area(USER_PARTITION_MODEL);
;;;228                #if( OTA_LOG_EN == YES )
;;;229                dbg_msg_flash("[OTA cfg] partial model wait-act area:%d", area );
;;;230                #endif
;;;231                #endif
;;;232            }
;;;233            else
;;;234            {
;;;235                ret = FLASH_STATUS_PROGRAM_FAIL;
;;;236            }
;;;237            //write boot config
;;;238            stota->target_sectors = 0;
;;;239            stota->sector_offset = 0;
;;;240            stota->sector_acc = 0xFFFF;
;;;241            stota->bin_type = eOTA_bin_null;
;;;242        }
;;;243        else if( stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_SCPU
;;;244        || stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_NCPU
;;;245        || stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_MODEL
;;;246        || stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_IMAGE_UPDATE
;;;247        || stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_FW_INFO
;;;248        || stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_MODEL_PARTIAL)
;;;249        {
;;;250            if( stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_SCPU )
;;;251            {
;;;252                ota_update_scpu_flag_status(  );	//change which one is not in the confirmed state then assigned to first_boot
;;;253                if(boot_cfg_1.scpu_cfg.flag == BOOT_STATE_FIRST_BOOT  )
000010  4f46              LDR      r7,|L9.300|
000012  f04f0802          MOV      r8,#2                 ;159
000016  2807              CMP      r0,#7                 ;243
000018  d028              BEQ      |L9.108|
00001a  2808              CMP      r0,#8                 ;244
00001c  d039              BEQ      |L9.146|
;;;254                {
;;;255                    #if( OTA_LOG_EN == YES )
;;;256                    dbg_msg_flash("[OTA cfg] config scpu1");
;;;257                    #endif
;;;258                    stota->sector_offset = SCPU1_START_SECTOR_INDEX;	//select scpu 1
;;;259                }
;;;260                else
;;;261                {
;;;262                    #if( OTA_LOG_EN == YES )
;;;263                    dbg_msg_flash("[OTA cfg] config scpu0");
;;;264                    #endif
;;;265                    stota->sector_offset = SCPU0_START_SECTOR_INDEX;	//select scpu 0
;;;266                }
;;;267                stota->target_sectors = (SCPU_SIZE>>12);
;;;268                #if( OTA_LOG_EN == YES )
;;;269                dbg_msg_flash("[OTA cfg] config scpu sector size: %d", stota->target_sectors );
;;;270                #endif
;;;271                stota->sector_acc = 0;
;;;272                stota->bin_type = eOTA_bin_scpu;//scpu bin
;;;273                stota->target_bytes = SCPU_IMAGE_SIZE;		//need to update with new code
;;;274    //            stota->ddr_ptr = (UINT32 *) KDP_DDR_OTA_IMAGE_BUF_START_ADDR;		//for bin file
;;;275            }
;;;276            else if( stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_NCPU )
;;;277            {
;;;278                ota_update_ncpu_flag_status();
;;;279                if(boot_cfg_1.ncpu_cfg.flag == BOOT_STATE_FIRST_BOOT  )
;;;280                {
;;;281                    #if( OTA_LOG_EN == YES )
;;;282                    dbg_msg_flash("[OTA cfg] config ncpu1");
;;;283                    #endif
;;;284                    stota->sector_offset = NCPU1_START_SECTOR_INDEX;	//select ncpu 1
;;;285                }
;;;286                else
;;;287                {
;;;288                    #if( OTA_LOG_EN == YES )
;;;289                    dbg_msg_flash("[OTA cfg] config ncpu0");
;;;290                    #endif
;;;291                    stota->sector_offset = NCPU0_START_SECTOR_INDEX;	//select ncpu 0
;;;292                }
;;;293                stota->target_sectors = ( NCPU_SIZE >> 12 );
;;;294                #if( OTA_LOG_EN == YES )
;;;295                dbg_msg_flash("[OTA cfg] config ncpu sector size: %d", stota->target_sectors );
;;;296                #endif
;;;297    
;;;298                stota->sector_acc = 0;
;;;299                stota->bin_type = eOTA_bin_ncpu;//ncpu bin
;;;300                stota->target_bytes = NCPU_IMAGE_SIZE;		//need to update with new code
;;;301    //            stota->ddr_ptr = (UINT32 *) KDP_DDR_OTA_IMAGE_BUF_START_ADDR;		//for bin file
;;;302            }
;;;303            else if( stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_MODEL )
;;;304            {
;;;305                #if( OTA_USER_BACKUP == YES )
;;;306    
;;;307                #if( OTA_USER_BACKUP_SEPERATE == YES )
;;;308                area = ota_user_check_on_going_area(USER_PARTITION_MODEL);
;;;309                if( area < 0 )
;;;310                {
;;;311                    return FLASH_STATUS_MODEL_AREA_FAIL;
;;;312                }
;;;313                #else
;;;314                area = ota_user_select_inactive_area(USER_PARTITION_MODEL);
;;;315                #endif
;;;316    
;;;317                #if( OTA_LOG_EN == YES )
;;;318                dbg_msg_flash("[OTA cfg] all model area:%d", area );
;;;319                #endif
;;;320                if( area == 1 ){
;;;321                    stota->sector_offset = MODEL_START_SECTOR_INDEX_1;    //model
;;;322                }
;;;323                else{
;;;324                    stota->sector_offset = MODEL_START_SECTOR_INDEX;    //model
;;;325                }
;;;326    
;;;327                #else
;;;328                stota->sector_offset = MODEL_START_SECTOR_INDEX;    //model
;;;329                #endif
;;;330    
;;;331                stota->sector_acc = 0;
;;;332                stota->bin_type = eOTA_bin_all_model;//model bin
;;;333                //remove        stota->target_sectors = ( MODEL_IMAGE_SIZE >> 12 );
;;;334                //remove        stota->target_bytes = MODEL_IMAGE_SIZE;
;;;335                stota->ddr_ptr = (UINT32 *)KDP_DDR_MODEL_START_ADDR;		//for bin file
00001e  f04f41c0          MOV      r1,#0x60000000
000022  2809              CMP      r0,#9                 ;245
000024  d04a              BEQ      |L9.188|
000026  280a              CMP      r0,#0xa               ;246
000028  d050              BEQ      |L9.204|
00002a  280b              CMP      r0,#0xb               ;247
00002c  d057              BEQ      |L9.222|
00002e  280c              CMP      r0,#0xc               ;248
000030  d061              BEQ      |L9.246|
;;;336            }
;;;337            else if( stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_IMAGE_UPDATE )
;;;338            {
;;;339                #if( OTA_USER_BACKUP == YES )
;;;340                #if( OTA_LOG_EN == YES )
;;;341                dbg_msg_flash("[OTA cfg] UI area:%d", area );
;;;342                #endif
;;;343                area = ota_user_select_inactive_area(USER_PARTITION_UI_IMG);
;;;344                if( area == 1 ){
;;;345                    stota->sector_offset = USR_IMAGE_START_SECTOR_INDEX_1;    //model
;;;346                }
;;;347                else{
;;;348                    stota->sector_offset = USR_IMAGE_START_SECTOR_INDEX;    //model
;;;349                }
;;;350    
;;;351                #else
;;;352                stota->sector_offset = USR_IMAGE_START_SECTOR_INDEX;    //model
;;;353                #endif
;;;354                stota->sector_acc = 0;
;;;355                stota->bin_type = eOTA_bin_ui_image;
;;;356                //stota->target_sectors = ( USR_FLASH_LAST_ADDR - USR_FLASH_SETTINGS_ADDR )>>12;
;;;357                //stota->target_bytes = ( USR_FLASH_LAST_ADDR - USR_FLASH_SETTINGS_ADDR );
;;;358                stota->ddr_ptr = (UINT32 *) KDP_DDR_MODEL_START_ADDR;   //for bin file
;;;359            }
;;;360            else if( stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_FW_INFO )
;;;361            {
;;;362                #if( OTA_USER_BACKUP == YES )
;;;363                area = ota_user_select_inactive_area(USER_PARTITION_FW_INFO);
;;;364    
;;;365                #if( OTA_USER_BACKUP_SEPERATE == YES )
;;;366                area = ota_user_select_inactive_area(USER_PARTITION_MODEL);
;;;367                #endif
;;;368    
;;;369                #if( OTA_LOG_EN == YES )
;;;370                dbg_msg_flash("[OTA cfg] fw info area:%d", area );
;;;371                #endif
;;;372                if( area == 1 ){
;;;373                    stota->sector_offset = FW_INFO_START_SECTOR_INDEX_1;
;;;374                }
;;;375                else{
;;;376                    stota->sector_offset = FW_INFO_START_SECTOR_INDEX;
;;;377                }
;;;378                #else
;;;379                stota->sector_offset = FW_INFO_START_SECTOR_INDEX;
;;;380                #endif
;;;381                stota->sector_acc = 0;
;;;382                stota->bin_type = eOTA_bin_fw_info;
;;;383    //            stota->target_sectors = ( KDP_FLASH_FW_INFO_SIZE >> 12 );
;;;384    //            stota->target_bytes = KDP_FLASH_FW_INFO_SIZE;
;;;385                stota->ddr_ptr = (UINT32 *) KDP_DDR_OTA_IMAGE_BUF_START_ADDR;   //for bin file
;;;386            }
;;;387            else if( stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_MODEL_PARTIAL )
;;;388            {
;;;389                #if( OTA_USER_BACKUP == YES )
;;;390    
;;;391                #if( OTA_USER_BACKUP_SEPERATE == YES )
;;;392                area = ota_user_check_on_going_area(USER_PARTITION_MODEL);
;;;393                if( area < 0 )
;;;394                {
;;;395                    return FLASH_STATUS_MODEL_AREA_FAIL;
;;;396                }
;;;397                #else
;;;398                area = ota_user_select_inactive_area(USER_PARTITION_MODEL);
;;;399                #endif
;;;400    
;;;401                #if( OTA_LOG_EN == YES )
;;;402                dbg_msg_flash("[OTA cfg] partial model area:%d", area );
;;;403                #endif
;;;404                if(area == 1){
;;;405                    //calculation size
;;;406                    stota->sector_offset = (KDP_FLASH_ALL_MODELS_ADDR_1 + stota->second_last_start_add)>>12;    //model
;;;407                }
;;;408                else{
;;;409                    //calculation size
;;;410                    stota->sector_offset = (KDP_FLASH_ALL_MODELS_ADDR + stota->second_last_start_add)>>12;    //model
;;;411                }
;;;412    
;;;413                #else
;;;414                //calculation size
;;;415                stota->sector_offset = (KDP_FLASH_ALL_MODELS_ADDR + stota->second_last_start_add)>>12;    //model
;;;416                #endif
;;;417                #if( OTA_LOG_EN == YES )
;;;418                dbg_msg_flash("[OTA cfg] partial model start address in flash: m_start 0x%x , second_last_address:0x%x", KDP_FLASH_ALL_MODELS_ADDR , stota->second_last_start_add  );
;;;419                dbg_msg_flash("[OTA cfg] partial model start sector: x%x", stota->sector_offset );
;;;420                dbg_msg_flash("[OTA cfg] ..........." );
;;;421                #endif
;;;422                stota->sector_acc = 0;
;;;423                stota->bin_type = eOTA_bin_partial_model;//partial model bin
;;;424                stota->target_sectors = stota->model_size>>12;      //( MODEL_IMAGE_SIZE >> 12 );
;;;425                stota->target_bytes = stota->model_size;    //MODEL_IMAGE_SIZE;
;;;426                stota->ddr_ptr = (UINT32 *)KDP_DDR_MODEL_START_ADDR;        //for bin file
;;;427            }
;;;428            stota->ddr_ptr_index = 0;
;;;429            stota->CRC = 0;
;;;430            stota->pass_sector_count = 0;
;;;431        }
;;;432        else
;;;433        {
;;;434            ret = 	FLASH_DRV_NOTHING;
000032  2688              MOVS     r6,#0x88
                  |L9.52|
;;;435        }
;;;436        return ret;
000034  4630              MOV      r0,r6
;;;437    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L9.58|
00003a  f894007c          LDRB     r0,[r4,#0x7c]         ;159
00003e  b158              CBZ      r0,|L9.88|
000040  2801              CMP      r0,#1                 ;176
000042  d009              BEQ      |L9.88|
000044  2804              CMP      r0,#4                 ;194
000046  d007              BEQ      |L9.88|
000048  2802              CMP      r0,#2                 ;204
00004a  d005              BEQ      |L9.88|
00004c  2803              CMP      r0,#3                 ;214
00004e  d003              BEQ      |L9.88|
000050  2805              CMP      r0,#5                 ;224
000052  d001              BEQ      |L9.88|
000054  f64e66e2          MOV      r6,#0xeee2            ;235
                  |L9.88|
000058  f8a4507a          STRH     r5,[r4,#0x7a]         ;238
00005c  f8445f74          STR      r5,[r4,#0x74]!        ;239
000060  f64f70ff          MOV      r0,#0xffff            ;240
000064  80a0              STRH     r0,[r4,#4]            ;240
000066  2006              MOVS     r0,#6                 ;241
000068  7220              STRB     r0,[r4,#8]            ;241
00006a  e7e3              B        |L9.52|
                  |L9.108|
00006c  f7fffffe          BL       ota_update_scpu_flag_status
000070  68b8              LDR      r0,[r7,#8]            ;253  ; boot_cfg_1
000072  2802              CMP      r0,#2                 ;253
000074  d00a              BEQ      |L9.140|
000076  f8c48074          STR      r8,[r4,#0x74]         ;265
                  |L9.122|
00007a  2028              MOVS     r0,#0x28              ;267
00007c  f8a4007a          STRH     r0,[r4,#0x7a]         ;267
000080  f8a45078          STRH     r5,[r4,#0x78]         ;271
000084  f884507c          STRB     r5,[r4,#0x7c]         ;272
000088  0300              LSLS     r0,r0,#12             ;273
00008a  e012              B        |L9.178|
                  |L9.140|
00008c  2041              MOVS     r0,#0x41              ;258
00008e  6760              STR      r0,[r4,#0x74]         ;258
000090  e7f3              B        |L9.122|
                  |L9.146|
000092  f7fffffe          BL       ota_update_ncpu_flag_status
000096  6978              LDR      r0,[r7,#0x14]         ;279  ; boot_cfg_1
000098  2802              CMP      r0,#2                 ;279
00009a  d00d              BEQ      |L9.184|
00009c  202a              MOVS     r0,#0x2a              ;291
                  |L9.158|
00009e  6760              STR      r0,[r4,#0x74]         ;293
0000a0  2010              MOVS     r0,#0x10              ;293
0000a2  f8a4007a          STRH     r0,[r4,#0x7a]         ;293
0000a6  f8a45078          STRH     r5,[r4,#0x78]         ;298
0000aa  2001              MOVS     r0,#1                 ;299
0000ac  f884007c          STRB     r0,[r4,#0x7c]         ;299
0000b0  0400              LSLS     r0,r0,#16             ;300
                  |L9.178|
0000b2  f8c40080          STR      r0,[r4,#0x80]         ;300
0000b6  e032              B        |L9.286|
                  |L9.184|
0000b8  2069              MOVS     r0,#0x69              ;284
0000ba  e7f0              B        |L9.158|
                  |L9.188|
0000bc  f44f70a2          MOV      r0,#0x144             ;328
0000c0  6760              STR      r0,[r4,#0x74]         ;331
0000c2  f8a45078          STRH     r5,[r4,#0x78]         ;331
0000c6  f884807c          STRB     r8,[r4,#0x7c]         ;332
0000ca  e026              B        |L9.282|
                  |L9.204|
0000cc  f64070d3          MOV      r0,#0xfd3             ;352
0000d0  6760              STR      r0,[r4,#0x74]         ;354
0000d2  f8a45078          STRH     r5,[r4,#0x78]         ;354
0000d6  2003              MOVS     r0,#3                 ;355
0000d8  f884007c          STRB     r0,[r4,#0x7c]         ;355
0000dc  e01d              B        |L9.282|
                  |L9.222|
0000de  f2401043          MOV      r0,#0x143             ;379
0000e2  6760              STR      r0,[r4,#0x74]         ;381
0000e4  f8a45078          STRH     r5,[r4,#0x78]         ;381
0000e8  2004              MOVS     r0,#4                 ;382
0000ea  f884007c          STRB     r0,[r4,#0x7c]         ;382
0000ee  4810              LDR      r0,|L9.304|
0000f0  f8c40088          STR      r0,[r4,#0x88]         ;385
0000f4  e013              B        |L9.286|
                  |L9.246|
0000f6  f8d40094          LDR      r0,[r4,#0x94]         ;415
0000fa  f50010a2          ADD      r0,r0,#0x144000       ;415
0000fe  0b00              LSRS     r0,r0,#12             ;415
000100  6760              STR      r0,[r4,#0x74]         ;422
000102  f8a45078          STRH     r5,[r4,#0x78]         ;422
000106  2005              MOVS     r0,#5                 ;423
000108  f884007c          STRB     r0,[r4,#0x7c]         ;423
00010c  f8d400a0          LDR      r0,[r4,#0xa0]         ;424
000110  0b02              LSRS     r2,r0,#12             ;424
000112  f8a4207a          STRH     r2,[r4,#0x7a]         ;424
000116  f8c40080          STR      r0,[r4,#0x80]         ;425
                  |L9.282|
00011a  f8c41088          STR      r1,[r4,#0x88]         ;426
                  |L9.286|
00011e  f8c4508c          STR      r5,[r4,#0x8c]         ;429
000122  f8c45090          STR      r5,[r4,#0x90]         ;430
000126  6725              STR      r5,[r4,#0x70]         ;430
000128  e784              B        |L9.52|
;;;438    
                          ENDP

00012a  0000              DCW      0x0000
                  |L9.300|
                          DCD      boot_cfg_1
                  |L9.304|
                          DCD      0x61f45600

                          AREA ||i.Drv_flash_erase_area||, CODE, READONLY, ALIGN=2

                  Drv_flash_erase_area PROC
;;;101    
;;;102    void Drv_flash_erase_area( UINT32 start_address_index )
000000  b570              PUSH     {r4-r6,lr}
;;;103    {
;;;104        if(  boot_cfg_0.scpu_cfg.flag  == BOOT_STATE_FIRST_BOOT
000002  4d1c              LDR      r5,|L10.116|
;;;105        &&
;;;106        boot_cfg_1.scpu_cfg.flag  == BOOT_STATE_FIRST_BOOT )
000004  4e1c              LDR      r6,|L10.120|
000006  4604              MOV      r4,r0                 ;103
000008  68a9              LDR      r1,[r5,#8]  ; boot_cfg_0
00000a  68b0              LDR      r0,[r6,#8]            ;104
00000c  2902              CMP      r1,#2                 ;104
00000e  d101              BNE      |L10.20|
000010  2802              CMP      r0,#2
000012  d02e              BEQ      |L10.114|
                  |L10.20|
;;;107        {
;;;108            #if( OTA_LOG_EN == YES )
;;;109            dbg_msg_flash("[OTA cfg] SCPU area erase fail");
;;;110            #endif
;;;111            return ;
;;;112        }
;;;113    
;;;114        if(  boot_cfg_0.ncpu_cfg.flag  == BOOT_STATE_FIRST_BOOT
000014  696a              LDR      r2,[r5,#0x14]  ; boot_cfg_0
000016  2a02              CMP      r2,#2
000018  d102              BNE      |L10.32|
;;;115            &&
;;;116            boot_cfg_1.ncpu_cfg.flag  == BOOT_STATE_FIRST_BOOT )
00001a  6972              LDR      r2,[r6,#0x14]  ; boot_cfg_1
00001c  2a02              CMP      r2,#2
00001e  d028              BEQ      |L10.114|
                  |L10.32|
;;;117        {
;;;118            #if( OTA_LOG_EN == YES )
;;;119            dbg_msg_flash("[OTA cfg] NCPU area erase fail");
;;;120            #endif
;;;121            return ;
;;;122        }
;;;123    
;;;124        if(  boot_cfg_0.scpu_cfg.flag  == BOOT_STATE_FIRST_BOOT && start_address_index==SCPU0_START_SECTOR_INDEX )
000020  2902              CMP      r1,#2
000022  d101              BNE      |L10.40|
000024  2c02              CMP      r4,#2
000026  d002              BEQ      |L10.46|
                  |L10.40|
;;;125        {
;;;126            kdp_memxfer_flash_sector_multi_erase( SCPU0_START_SECTOR_INDEX*4096, SCPU0_END_SECTOR_INDEX*4096  );
;;;127        }
;;;128        else if(  boot_cfg_1.scpu_cfg.flag  == BOOT_STATE_FIRST_BOOT && start_address_index==SCPU1_START_SECTOR_INDEX )
000028  2802              CMP      r0,#2
00002a  d005              BEQ      |L10.56|
00002c  e00b              B        |L10.70|
                  |L10.46|
00002e  f44f3124          MOV      r1,#0x29000           ;126
000032  f44f5000          MOV      r0,#0x2000            ;126
000036  e004              B        |L10.66|
                  |L10.56|
000038  2c41              CMP      r4,#0x41
00003a  d104              BNE      |L10.70|
;;;129        {
;;;130            #if( OTA_LOG_EN == YES )
;;;131            dbg_msg_flash("[OTA cfg] NCPU area erase start sec: %d. end sec: %d", SCPU1_START_SECTOR_INDEX , SCPU1_END_SECTOR_INDEX );
;;;132            #endif
;;;133            kdp_memxfer_flash_sector_multi_erase( SCPU1_START_SECTOR_INDEX*4096, SCPU1_END_SECTOR_INDEX*4096  );
00003c  f44f21d0          MOV      r1,#0x68000
000040  0320              LSLS     r0,r4,#12
                  |L10.66|
000042  f7fffffe          BL       kdp_memxfer_flash_sector_multi_erase
                  |L10.70|
;;;134        }
;;;135    
;;;136        if( boot_cfg_0.ncpu_cfg.flag == BOOT_STATE_FIRST_BOOT && start_address_index==NCPU0_START_SECTOR_INDEX )
000046  6968              LDR      r0,[r5,#0x14]  ; boot_cfg_0
000048  2802              CMP      r0,#2
00004a  d101              BNE      |L10.80|
00004c  2c2a              CMP      r4,#0x2a
00004e  d00b              BEQ      |L10.104|
                  |L10.80|
;;;137        {
;;;138            kdp_memxfer_flash_sector_multi_erase( NCPU0_START_SECTOR_INDEX*4096, NCPU0_END_SECTOR_INDEX*4096 );
;;;139        }
;;;140        else if( boot_cfg_1.ncpu_cfg.flag == BOOT_STATE_FIRST_BOOT && start_address_index==NCPU1_START_SECTOR_INDEX  )
000050  6970              LDR      r0,[r6,#0x14]  ; boot_cfg_1
000052  2802              CMP      r0,#2
000054  d10d              BNE      |L10.114|
000056  2c69              CMP      r4,#0x69
000058  d10b              BNE      |L10.114|
;;;141        {
;;;142            kdp_memxfer_flash_sector_multi_erase( NCPU1_START_SECTOR_INDEX*4096, NCPU1_END_SECTOR_INDEX*4096 );
00005a  f44f21f0          MOV      r1,#0x78000
00005e  0320              LSLS     r0,r4,#12
                  |L10.96|
000060  e8bd4070          POP      {r4-r6,lr}
000064  f7ffbffe          B.W      kdp_memxfer_flash_sector_multi_erase
                  |L10.104|
000068  f44f3164          MOV      r1,#0x39000           ;138
00006c  f44f3028          MOV      r0,#0x2a000           ;138
000070  e7f6              B        |L10.96|
                  |L10.114|
;;;143        }
;;;144    }
000072  bd70              POP      {r4-r6,pc}
;;;145    
                          ENDP

                  |L10.116|
                          DCD      boot_cfg_0
                  |L10.120|
                          DCD      boot_cfg_1

                          AREA ||i.Drv_utility_checksum||, CODE, READONLY, ALIGN=1

                  Drv_utility_checksum PROC
;;;1130   
;;;1131   UINT32	Drv_utility_checksum( UINT8 * buf, UINT16 start, UINT16 end )
000000  b510              PUSH     {r4,lr}
;;;1132   {
000002  4603              MOV      r3,r0
;;;1133       UINT32 ntemp = 0;
000004  2000              MOVS     r0,#0
000006  e002              B        |L11.14|
                  |L11.8|
;;;1134   #if 1
;;;1135       UINT32 i ;
;;;1136       for( i = start ; i < end; i++  )
;;;1137       {
;;;1138           ntemp += *(buf+i);
000008  5c5c              LDRB     r4,[r3,r1]
00000a  1c49              ADDS     r1,r1,#1
00000c  4420              ADD      r0,r0,r4
                  |L11.14|
00000e  4291              CMP      r1,r2                 ;1136
000010  d3fa              BCC      |L11.8|
;;;1139       }
;;;1140   #else
;;;1141   
;;;1142       do
;;;1143       {
;;;1144           ntemp += *(buf+ (end--) );
;;;1145       } while( (int)end >= start );
;;;1146   
;;;1147   #endif
;;;1148   
;;;1149       return	ntemp;
;;;1150   }
000012  bd10              POP      {r4,pc}
;;;1151   
                          ENDP


                          AREA ||i.drv_flash_main||, CODE, READONLY, ALIGN=2

                  drv_flash_main PROC
;;;586    
;;;587    UINT16 drv_flash_main( OTA_FLASHt * stota  )
000000  b5f8              PUSH     {r3-r7,lr}
;;;588    {
;;;589        UINT32  addr;
;;;590        UINT32  i, ntemp_index=0 , ntemp_index2=0 ;
;;;591        UINT32  *ptr;
;;;592    
;;;593    #if ( (CFG_SNAPSHOT_ENABLE == 1 || CFG_SNAPSHOT_ENABLE == 2) && (NIR_RGB_OTA_EN == 1) )
;;;594        UINT16  ntime_out = 0;
;;;595        UINT16  ntime_out_target = 5;
;;;596        UINT16  ntime_out_interval = 100;		//1000ms is 1s
;;;597    #endif
;;;598    
;;;599        UINT16  ret = 0xFF;
;;;600        UINT16  end_sector = 0;
;;;601        #if ( OTA_CRC_CHECK_EN==YES )
;;;602        UINT32  crc_result;
;;;603        UINT32  crc_target;
;;;604        #endif
;;;605        #if(OTA_USER_BACKUP==YES)
;;;606        UINT8   temp;
;;;607        #endif
;;;608    
;;;609        addr = stota->receive_cmd.sector_index * st_flash_info.sector_size_Bytes;
000002  4a78              LDR      r2,|L12.484|
000004  8981              LDRH     r1,[r0,#0xc]
000006  4604              MOV      r4,r0                 ;588
000008  89d2              LDRH     r2,[r2,#0xe]  ; st_flash_info
;;;610    
;;;611        switch( stota->receive_cmd.cmd_stat )
00000a  2500              MOVS     r5,#0
00000c  fb01f002          MUL      r0,r1,r2              ;609
000010  8962              LDRH     r2,[r4,#0xa]
000012  2af3              CMP      r2,#0xf3
000014  d074              BEQ      |L12.256|
000016  dc07              BGT      |L12.40|
000018  b15a              CBZ      r2,|L12.50|
00001a  2af0              CMP      r2,#0xf0
00001c  d071              BEQ      |L12.258|
00001e  2af1              CMP      r2,#0xf1
000020  d070              BEQ      |L12.260|
000022  2af2              CMP      r2,#0xf2
                  |L12.36|
000024  d10e              BNE      |L12.68|
000026  e0c2              B        |L12.430|
                  |L12.40|
000028  2afa              CMP      r2,#0xfa
00002a  d06c              BEQ      |L12.262|
00002c  2afd              CMP      r2,#0xfd
00002e  d1f9              BNE      |L12.36|
000030  e012              B        |L12.88|
                  |L12.50|
;;;612        {
;;;613            case eflash_init:
;;;614    
;;;615                //action number check
;;;616                #if ( NIR_RGB_OTA_EN == 1 )
;;;617                if(  stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_INIT
000032  7ba0              LDRB     r0,[r4,#0xe]
000034  2801              CMP      r0,#1
000036  d006              BEQ      |L12.70|
;;;618                        || stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SW_VERSION )
000038  2805              CMP      r0,#5
00003a  d004              BEQ      |L12.70|
;;;619                {
;;;620        			if( kdp_memxfer_init(MEMXFER_OPS_CPU, MEMXFER_OPS_CPU) != 1)
;;;621        			{
;;;622        				return FLASH_DRV_FAIL;
;;;623        			}
;;;624        			else
;;;625        			{
;;;626        			    kl520_api_face_close();
;;;627        			}
;;;628    
;;;629                    //read boot config
;;;630                    // dbg_msg_console("ota_get_active_scpu_partition");
;;;631                    // ota_get_active_scpu_partition();
;;;632                    // ota_get_active_ncpu_partition();
;;;633                }
;;;634                else if( stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_SEL_MODEL_PARTIAL )
00003c  280c              CMP      r0,#0xc
00003e  d001              BEQ      |L12.68|
;;;635                {
;;;636                    //do nothing
;;;637                }
;;;638                else if( stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_PROC_DONE )
000040  2806              CMP      r0,#6
000042  d009              BEQ      |L12.88|
                  |L12.68|
000044  e0c5              B        |L12.466|
                  |L12.70|
000046  2101              MOVS     r1,#1                 ;620
000048  4608              MOV      r0,r1                 ;620
00004a  f7fffffe          BL       kdp_memxfer_init
00004e  2801              CMP      r0,#1                 ;620
000050  d172              BNE      |L12.312|
000052  f7fffffe          BL       kl520_api_face_close
000056  e0bc              B        |L12.466|
                  |L12.88|
;;;639                {
;;;640                        goto FLASH_Large_process;
;;;641                }
;;;642    
;;;643                if(  stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_NIR )
;;;644                {
;;;645                    //call active
;;;646                    //kl520_api_snapshot_fdfr_catch(MIPI_CAM_NIR);
;;;647    #if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;648                    osDelay(100);
;;;649                    kl520_api_face_close();
;;;650    #endif
;;;651                }
;;;652                else if(  stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_RGB )
;;;653                {
;;;654                    //call active
;;;655                    //kl520_api_snapshot_fdfr_catch(MIPI_CAM_RGB);
;;;656    #if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
;;;657                    osDelay(100);
;;;658                    kl520_api_face_close();
;;;659    #endif
;;;660                }
;;;661    
;;;662    
;;;663                #else
;;;664                if(  stota->receive_cmd.action_number != 0x01 )		return FLASH_DRV_FAIL;
;;;665                #endif
;;;666    
;;;667                break;
;;;668    FLASH_Large_process:
;;;669            case eflash_large_program:
;;;670                ntemp_index =0;
;;;671                ntemp_index2 = KDP_DDR_TEST_RGB_IMG_SIZE;
;;;672    
;;;673                #if( OTA_LOG_EN == YES )
;;;674                dbg_msg_flash("[OTA] receive bin size, size:%d--", stota->ddr_ptr_index);
;;;675                #endif
;;;676    
;;;677                #if( OTA_LOG_EN == YES )
;;;678                dbg_msg_flash("[OTA] flash bin type %d--", stota->bin_type);
;;;679                #endif
;;;680    
;;;681                //check valid size!!
;;;682                if ( ota_bin_check(stota , &ptr ) == FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL )
000058  4669              MOV      r1,sp
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       ota_bin_check
000060  4601              MOV      r1,r0
000062  f64e60e3          MOV      r0,#0xeee3
000066  4281              CMP      r1,r0
000068  d02f              BEQ      |L12.202|
;;;683                {
;;;684                    return FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;685                }
;;;686    
;;;687                //erase area
;;;688                Drv_flash_erase_area( stota->sector_offset );
00006a  6f60              LDR      r0,[r4,#0x74]
00006c  f7fffffe          BL       Drv_flash_erase_area
;;;689                #if( OTA_LOG_EN == YES )
;;;690                dbg_msg_flash("[OTA] Start Program --");
;;;691                dbg_msg_flash("[OTA] dst: %#X, src: %#X, size: %#X --", (UINT32)stota->sector_offset<<12 ,(UINT32)stota->ddr_ptr, stota->target_bytes );
;;;692                #endif
;;;693    
;;;694                //program area
;;;695                if( kdp_memxfer_ddr_to_flash((UINT32)stota->sector_offset<<12 ,(UINT32)stota->ddr_ptr, stota->target_bytes ) == 0 )
000070  6f60              LDR      r0,[r4,#0x74]
000072  f8d42080          LDR      r2,[r4,#0x80]
000076  0300              LSLS     r0,r0,#12
000078  f8d41088          LDR      r1,[r4,#0x88]
00007c  f7fffffe          BL       kdp_memxfer_ddr_to_flash
;;;696                {
;;;697                    #if( OTA_LOG_EN == YES )
;;;698                    dbg_msg_flash("[OTA] Large Program fail");
;;;699                    #endif
;;;700                    return FLASH_STATUS_PROGRAM_FAIL;
000080  f64e66e2          MOV      r6,#0xeee2
000084  b300              CBZ      r0,|L12.200|
;;;701                }
;;;702    
;;;703                #if ( OTA_CRC_CHECK_EN == YES )
;;;704    
;;;705                if( stota->bin_type == eOTA_bin_ui_image )   //no check
000086  f894007c          LDRB     r0,[r4,#0x7c]
00008a  2803              CMP      r0,#3
00008c  d055              BEQ      |L12.314|
;;;706                {
;;;707                    //no data compare
;;;708                    goto final_check;
;;;709                }
;;;710                else if( stota->bin_type == eOTA_bin_all_model || stota->bin_type == eOTA_bin_partial_model )    //partial model
00008e  2802              CMP      r0,#2
000090  d001              BEQ      |L12.150|
000092  2805              CMP      r0,#5
000094  d10b              BNE      |L12.174|
                  |L12.150|
;;;711                {
;;;712                    kdp_model_reload_model_info(FALSE);
000096  2000              MOVS     r0,#0
000098  f7fffffe          BL       kdp_model_reload_model_info
;;;713                    #if ( OTA_USER_BACKUP == YES )
;;;714                    //step1 check wait area
;;;715                    if( ota_get_wait_active_area( USER_PARTITION_FW_INFO ) == 1 )   //sync with fw_info
;;;716                    {
;;;717                        #if( OTA_LOG_EN == YES )
;;;718                        dbg_msg_flash("[OTA fw info] set 1");
;;;719                        #endif
;;;720                        temp =0;    //pre area
;;;721                        kdp_set_model_offset(KDP_FLASH_ALL_MODEL_OFFSET_1);
;;;722                        kdp_set_fwinfo_offset(KDP_FLASH_FW_INFO_OFFSET_1);
;;;723                    }
;;;724                    else
;;;725                    {
;;;726                        #if( OTA_LOG_EN == YES )
;;;727                        dbg_msg_flash("[OTA fw info] set 0");
;;;728                        #endif
;;;729                        temp =1;
;;;730                        kdp_set_model_offset(0);
;;;731                        kdp_set_fwinfo_offset(0);
;;;732                    }
;;;733                    //step2 set to this area
;;;734                    #if ( OTA_LOG_EN == YES )
;;;735                    dbg_msg_flash("[fw reload] load info offest : 0x%x", kdp_get_fwinfo_offset() );
;;;736                    dbg_msg_flash("[fw reload] model offest : 0x%x", kdp_get_model_offset() );
;;;737                    #endif
;;;738                    //step3 roll back to another area
;;;739                    kdp_model_info_reload();
;;;740                    //crc check
;;;741                     stota->ddr_ptr_index = kdp_clc_all_model_size();
;;;742                     #if( OTA_LOG_EN == YES )
;;;743                     dbg_msg_flash("[OTA] model start address 0x%x", stota->sector_offset );
;;;744                     #endif
;;;745    
;;;746    
;;;747                    #else
;;;748                    //crc check
;;;749                     stota->ddr_ptr_index = kdp_clc_all_model_size();
00009c  f7fffffe          BL       kdp_clc_all_model_size
;;;750                     #if( OTA_LOG_EN == YES )
;;;751                     dbg_msg_flash("[OTA] model start address 0x%x", stota->sector_offset );
;;;752                     #endif
;;;753                    //step3 roll back to another area
;;;754                    kdp_model_info_reload();
0000a0  f8c4008c          STR      r0,[r4,#0x8c]
0000a4  f7fffffe          BL       kdp_model_info_reload
;;;755                    #endif
;;;756    
;;;757                    #if( OTA_USER_BACKUP == YES )
;;;758                    stota->sector_offset = MODEL_START_SECTOR_INDEX + (kdp_get_model_offset()>>12);        //for partial mode , read from model start
;;;759    
;;;760                    #else
;;;761                    stota->sector_offset = MODEL_START_SECTOR_INDEX;        //for partial mode , read from model start
0000a8  f44f70a2          MOV      r0,#0x144
0000ac  6760              STR      r0,[r4,#0x74]
                  |L12.174|
;;;762                    #endif
;;;763                }
;;;764                else
;;;765                {
;;;766                    //data compare
;;;767                }
;;;768    
;;;769                #else
;;;770                if( stota->bin_type == eOTA_bin_all_model /*|| stota->bin_type == eOTA_bin_ui_image*/ || stota->bin_type == eOTA_bin_partial_model )   //no check
;;;771                {
;;;772                    goto final_check;
;;;773                }
;;;774                #endif
;;;775    
;;;776                #if( OTA_LOG_EN == YES )
;;;777                dbg_msg_flash("[OTA] temp address: 0x%x", ptr);
;;;778                dbg_msg_flash("[OTA]read size: %d", stota->ddr_ptr_index );
;;;779    
;;;780                dbg_msg_flash("[OTA]start read sector address: 0x%x", (stota->sector_offset *4096) );
;;;781                #endif
;;;782    
;;;783                *(ptr+0) = 0x12;
0000ae  9800              LDR      r0,[sp,#0]
0000b0  2112              MOVS     r1,#0x12
;;;784                *(ptr+1) = 0xFF;
0000b2  6001              STR      r1,[r0,#0]
0000b4  21ff              MOVS     r1,#0xff
;;;785                *(ptr+2) = 0xFF;
0000b6  6041              STR      r1,[r0,#4]
;;;786                //read back and check
;;;787                if( kdp_memxfer_flash_to_ddr( (UINT32)ptr ,(UINT32)stota->sector_offset << 12, stota->ddr_ptr_index ) != 0 )
0000b8  6081              STR      r1,[r0,#8]
0000ba  6f61              LDR      r1,[r4,#0x74]
0000bc  f8d4208c          LDR      r2,[r4,#0x8c]
0000c0  0309              LSLS     r1,r1,#12
0000c2  f7fffffe          BL       kdp_memxfer_flash_to_ddr
0000c6  b108              CBZ      r0,|L12.204|
                  |L12.200|
;;;788                {
;;;789                    #if( OTA_LOG_EN == YES )
;;;790                    dbg_msg_flash("[OTA] Large Read fail");
;;;791                    #endif
;;;792                    return	FLASH_STATUS_PROGRAM_FAIL;
0000c8  4630              MOV      r0,r6
                  |L12.202|
;;;793                }
;;;794    
;;;795                #if ( OTA_CRC_CHECK_EN == YES )
;;;796    
;;;797                if( stota->bin_type == eOTA_bin_all_model || stota->bin_type == eOTA_bin_partial_model )    //partial model
;;;798                {
;;;799                    crc_result =  ota_crc32( (UINT8 *)ptr, stota->ddr_ptr_index );
;;;800                    crc_target =  drv_read_all_model_crc();
;;;801                    #if( OTA_LOG_EN == YES )
;;;802                    dbg_msg_flash("[OTA] start CRC check");
;;;803                    dbg_msg_flash("CRC result is 0x%x",crc_result );
;;;804                    #endif
;;;805    
;;;806                    if( crc_result != crc_target )
;;;807                    {
;;;808                        dbg_msg_flash("CRC error is 0x%x, target: 0x%x", crc_result, crc_target );
;;;809                        return  FLASH_STATUS_CRC_FAIL;
;;;810                    }
;;;811                    dbg_msg_flash("CRC check Done");
;;;812                    goto final_check;
;;;813                }
;;;814                #endif
;;;815    
;;;816                #if( OTA_LOG_EN == YES )
;;;817                dbg_msg_flash("[OTA] Compare large data --");
;;;818                #endif
;;;819                //error code and doing data compare or CRC check
;;;820                #if ( OTA_CRC_CHECK_EN == YES )
;;;821                if(stota->bin_type == eOTA_bin_all_model  ||  stota->bin_type == eOTA_bin_partial_model )    //all model and partial model
;;;822                {
;;;823    
;;;824                }
;;;825                else
;;;826                {
;;;827                    for( i =0; i < (stota->ddr_ptr_index>>2); i++ )
;;;828                    {
;;;829                        #if( OTA_LOG_EN == YES )
;;;830                        if(0)//( (i%4096) ==0)
;;;831                        {
;;;832                            dbg_msg_flash("[OTA] Large compare: %d rx: 0x%x, org: 0x%x,", i,*(ptr+i), *(stota->ddr_ptr+i));
;;;833                        }
;;;834                        #endif
;;;835    
;;;836                        if( *(ptr+i) != *(stota->ddr_ptr+i) )
;;;837                        {
;;;838    
;;;839                            #if( OTA_LOG_EN == YES )
;;;840                            dbg_msg_flash("[OTA] Large compare fail");
;;;841                            #endif
;;;842    
;;;843                            return  FLASH_STATUS_COMPARE_FAIL;
;;;844                        }
;;;845                        stota->pass_sector_count+=4;
;;;846                    }
;;;847                }
;;;848    
;;;849    
;;;850    
;;;851                #else
;;;852                for( i =0; i < (stota->ddr_ptr_index>>2); i++ )
;;;853                {
;;;854                    #if( OTA_LOG_EN == YES )
;;;855    //                if( (i%4096) ==0)
;;;856    //                {
;;;857    //                    dbg_msg_flash("[OTA] Large compare: %d rx: 0x%x, org: 0x%x,", i,*(ptr+i), *(stota->ddr_ptr+i));
;;;858    //                }
;;;859                    #endif
;;;860    
;;;861                    if( *(ptr+i) != *(stota->ddr_ptr+i) )
;;;862                    {
;;;863    
;;;864                        #if( OTA_LOG_EN == YES )
;;;865                        dbg_msg_flash("[OTA] Large compare fail");
;;;866                        #endif
;;;867    
;;;868                        return  FLASH_STATUS_COMPARE_FAIL;
;;;869                    }
;;;870                    stota->pass_sector_count+=4;
;;;871                }
;;;872                #endif
;;;873    
;;;874                stota->pass_sector_count >>= 12;
;;;875                if( (stota->pass_sector_count) !=  ( stota->target_sectors) )
;;;876                {
;;;877                    #if( OTA_LOG_EN == YES )
;;;878                    dbg_msg_flash("[OTA] Pass count error 2: %d, %d", stota->pass_sector_count, stota->target_sectors );
;;;879                    #endif
;;;880                    return	FLASH_STATUS_COMPARE_FAIL;
;;;881                }
;;;882                final_check:
;;;883                #if( OTA_LOG_EN == YES )
;;;884                dbg_msg_flash("[OTA] Large program procedure Done --");
;;;885                #endif
;;;886                stota->sn_cpu_status = 0;
;;;887                break;
;;;888            case eflash_store_DDR:
;;;889                //need to verify first
;;;890                ntemp_index = stota->receive_cmd.data_size>>2;
;;;891                ntemp_index2 = stota->ddr_ptr_index>>2;
;;;892    
;;;893                ptr = (UINT32 *)(stota->receive_cmd.ptr + stota->receive_cmd.data_offset);
;;;894    
;;;895                for( i = 0; i < ntemp_index ; i++ )
;;;896                {
;;;897                    *( stota->ddr_ptr + ntemp_index2+i ) = *( ptr+ i );
;;;898                }
;;;899                stota->ddr_ptr_index += (  ntemp_index * 4 );
;;;900                #if( OTA_LOG_EN == YES )
;;;901                dbg_msg_flash("[OTA] ntemp_index2+ntemp_index * 4: %d",  ntemp_index * 4);
;;;902                #endif
;;;903                break;
;;;904            case eflash_program:
;;;905                #if( OTA_LOG_EN == YES )
;;;906                dbg_msg_flash("[OTA] Program ing, sector: %d", stota->receive_cmd.sector_index );
;;;907                #endif
;;;908    
;;;909                if( kdp_memxfer_ddr_to_flash( (UINT32)addr, (UINT32)stota->receive_cmd.ptr+stota->receive_cmd.data_offset,
;;;910                                                    stota->receive_cmd.data_size) == 0 )
;;;911                {
;;;912                #if( OTA_LOG_EN == YES )
;;;913                    dbg_msg_flash("[OTA] Program fail");
;;;914                #endif
;;;915                    return FLASH_DRV_FAIL;
;;;916                }
;;;917    
;;;918                #if( OTA_LOG_EN == YES )
;;;919                dbg_msg_flash("[OTA] Program Done");
;;;920                #endif
;;;921                break;
;;;922            case eflash_read:
;;;923                #if( OTA_LOG_EN == YES )
;;;924                dbg_msg_flash("[OTA] Read ing");
;;;925                #endif
;;;926                #if 1   //( CFG_COM_BUS_TYPE == COM_BUS_TYPE_SSP1 )
;;;927                    *stota->send_response.ptr_index = 0;		//clear buf index
;;;928                    *stota->receive_cmd.ptr_index = 0;			//clear buf index
;;;929    
;;;930                    if ( kdp_memxfer_flash_to_ddr( (UINT32)stota->receive_cmd.ptr ,(UINT32)addr,  stota->receive_cmd.data_size ) != 0 )
;;;931                    {
;;;932                        #if( OTA_LOG_EN == YES )
;;;933                        dbg_msg_flash("[OTA] Read fail");
;;;934                        #endif
;;;935                        return FLASH_DRV_FAIL;
;;;936                    }
;;;937                    stota->send_response.data_size = stota->receive_cmd.data_size;
;;;938                    *stota->send_response.ptr_index = stota->receive_cmd.data_size;
;;;939                    #if( OTA_LOG_EN == YES )
;;;940                    dbg_msg_flash("[OTA] Read size : %d", stota->receive_cmd.data_size);
;;;941                    dbg_msg_flash("[OTA] Read Done");
;;;942                    #endif
;;;943                #else
;;;944    //				dbg_msg_flash("   [OTA] flash read ");
;;;945                    *stota->send_response.ptr_index = 0;		//clear buf index
;;;946    
;;;947                    //if( kdp_memxfer_flash_to_ddr(stota->send_response.ptr, add , stota->receive_cmd.data_size ) != 0 )
;;;948                    if(kdp_flash_read_data( addr , stota->send_response.ptr , stota->receive_cmd.data_size ) == 0 )
;;;949                    {
;;;950                        return FLASH_DRV_FAIL;
;;;951                    }
;;;952                    stota->send_response.data_size = stota->receive_cmd.data_size;
;;;953                    *stota->send_response.ptr_index = stota->receive_cmd.data_size;
;;;954                    //dbg_msg_flash("   [OTA] flash done ");
;;;955                #endif
;;;956            break;
;;;957            case eflash_erase:
;;;958                #if( OTA_LOG_EN == YES )
;;;959                dbg_msg_flash("[OTA] erase ing");
;;;960                #endif
;;;961                end_sector = stota->receive_cmd.data_offset;
;;;962    
;;;963                if ( kdp_memxfer_flash_sector_multi_erase( stota->receive_cmd.sector_index*4096, end_sector*4096 ) != 0 )
;;;964                {
;;;965                    #if( OTA_LOG_EN == YES )
;;;966                    dbg_msg_flash("[OTA] erase fail");
;;;967                    #endif
;;;968                    return FLASH_DRV_FAIL;
;;;969                }
;;;970                #if( OTA_LOG_EN == YES )
;;;971                dbg_msg_flash("Done");
;;;972                #endif
;;;973                break;
;;;974            case eflash_ui_image_info:
;;;975                if(0)//( stota->sector_offset != USR_IMAGE_START_SECTOR_INDEX)
;;;976                {
;;;977                    return FLASH_DRV_FAIL;
;;;978                }
;;;979            break;
;;;980    #if ( (CFG_SNAPSHOT_ENABLE == 1 || CFG_SNAPSHOT_ENABLE == 2) && (NIR_RGB_OTA_EN == 1) )
;;;981            case eflash_NIR:
;;;982                if( (stota->receive_cmd.packet_ddr_ptr = kl520_api_snapshot_addr(0) ) == 0 )
;;;983                {
;;;984                    osDelay(ntime_out_interval);
;;;985                    //call wait
;;;986                    ntime_out++;
;;;987                    osDelay( ntime_out_interval );
;;;988                    if( ntime_out > ntime_out_target )
;;;989                    {
;;;990                        return FLASH_DRV_FAIL;
;;;991                    }
;;;992                }
;;;993                *stota->send_response.ptr_index = stota->receive_cmd.data_size;
;;;994                break;
;;;995    
;;;996            case eflash_RGB:
;;;997            case eflash_ALL:
;;;998                if( (stota->receive_cmd.packet_ddr_ptr = kl520_api_snapshot_addr(1) )== 0)
;;;999                {
;;;1000                   osDelay(ntime_out_interval);
;;;1001                   //call wait
;;;1002                   ntime_out++;
;;;1003                   osDelay( ntime_out_interval );
;;;1004                   if( ntime_out > ntime_out_target )
;;;1005                   {
;;;1006                       return FLASH_DRV_FAIL;
;;;1007                   }
;;;1008               }
;;;1009               *stota->send_response.ptr_index = stota->receive_cmd.data_size;
;;;1010               break;
;;;1011   #endif
;;;1012           case eflash_model_size:
;;;1013               //do nothing here
;;;1014   
;;;1015               #if( OTA_USER_BACKUP == YES )
;;;1016               //step1 check wait area
;;;1017               if( ota_get_wait_active_area( USER_PARTITION_FW_INFO ) == 1 )
;;;1018               {
;;;1019                   #if( OTA_LOG_EN == YES )
;;;1020                   dbg_msg_flash("[OTA fw info] set 1"); //....ok
;;;1021                   #endif
;;;1022                   temp =0;    //pre area
;;;1023                   kdp_set_fwinfo_offset( KDP_FLASH_FW_INFO_OFFSET_1 );
;;;1024               }
;;;1025               else
;;;1026               {
;;;1027                   #if( OTA_LOG_EN == YES )
;;;1028                   dbg_msg_flash("[OTA fw info] set 0");
;;;1029                   #endif
;;;1030                   temp =1;
;;;1031                   kdp_set_fwinfo_offset(0);
;;;1032               }
;;;1033               //step2 set to this area
;;;1034   
;;;1035               #if ( OTA_LOG_EN == YES )
;;;1036               dbg_msg_flash("[fw reload] load info offest : 0x%x", kdp_get_fwinfo_offset() );
;;;1037               #endif
;;;1038   
;;;1039               //step3 roll back to another area
;;;1040               #endif
;;;1041               kdp_model_info_reload();
;;;1042   
;;;1043               #if( OTA_USER_BACKUP == YES )
;;;1044               kdp_set_fwinfo_offset( temp* KDP_FLASH_FW_INFO_OFFSET_1 ); //roll back
;;;1045               #endif
;;;1046   
;;;1047               if( kdp_model_info_get( &stota->second_last_start_add, &stota->last_start_add, &stota->model_size ) == 0 )
;;;1048               {
;;;1049                   ret =   FLASH_STATUS_READ_CONFIG_FAIL;
;;;1050               }
;;;1051   
;;;1052               #if( OTA_LOG_EN == YES )
;;;1053               dbg_msg_flash("[OTA] part model size: %d", stota->model_size );
;;;1054               dbg_msg_flash("[OTA] part model ofsset: 0x%X", stota->second_last_start_add );
;;;1055               #endif
;;;1056   
;;;1057   
;;;1058               break;
;;;1059           case eflash_idle:
;;;1060   
;;;1061               break;
;;;1062           default:
;;;1063   
;;;1064               break;
;;;1065       }
;;;1066   
;;;1067   
;;;1068   
;;;1069       if( stota->receive_cmd.cmd_stat == FLASH_CMD_ACT )
;;;1070       {
;;;1071           ret = Drv_flash_action_doing( stota );
;;;1072           if( ret != FLASH_DRV_NOTHING )
;;;1073           {
;;;1074               return ret;
;;;1075           }
;;;1076       }
;;;1077   
;;;1078   
;;;1079       return FLASH_DRV_OK;
;;;1080   
;;;1081   
;;;1082   }
0000ca  bdf8              POP      {r3-r7,pc}
                  |L12.204|
0000cc  f894007c          LDRB     r0,[r4,#0x7c]         ;797
0000d0  2802              CMP      r0,#2                 ;797
0000d2  d008              BEQ      |L12.230|
0000d4  2805              CMP      r0,#5                 ;797
0000d6  d006              BEQ      |L12.230|
0000d8  2000              MOVS     r0,#0                 ;827
0000da  f64e63e0          MOV      r3,#0xeee0            ;843
0000de  f8d4108c          LDR      r1,[r4,#0x8c]         ;591
0000e2  9a00              LDR      r2,[sp,#0]            ;827
0000e4  e01c              B        |L12.288|
                  |L12.230|
0000e6  f8d4108c          LDR      r1,[r4,#0x8c]         ;799
0000ea  9800              LDR      r0,[sp,#0]            ;799
0000ec  f7fffffe          BL       ota_crc32
0000f0  4606              MOV      r6,r0                 ;799
0000f2  f7fffffe          BL       drv_read_all_model_crc
0000f6  4286              CMP      r6,r0                 ;806
0000f8  d01f              BEQ      |L12.314|
0000fa  f64e60e5          MOV      r0,#0xeee5            ;809
                  |L12.254|
0000fe  bdf8              POP      {r3-r7,pc}
                  |L12.256|
000100  e01e              B        |L12.320|
                  |L12.258|
000102  e03b              B        |L12.380|
                  |L12.260|
000104  e042              B        |L12.396|
                  |L12.262|
000106  e05b              B        |L12.448|
                  |L12.264|
000108  f8d46088          LDR      r6,[r4,#0x88]         ;836
00010c  f8527020          LDR      r7,[r2,r0,LSL #2]     ;836
000110  f8566020          LDR      r6,[r6,r0,LSL #2]     ;836
000114  42be              CMP      r6,r7                 ;836
000116  d10d              BNE      |L12.308|
000118  6f26              LDR      r6,[r4,#0x70]         ;845
00011a  1d36              ADDS     r6,r6,#4              ;845
00011c  1c40              ADDS     r0,r0,#1              ;845
00011e  6726              STR      r6,[r4,#0x70]         ;845
                  |L12.288|
000120  ebb00f91          CMP      r0,r1,LSR #2          ;827
000124  d3f0              BCC      |L12.264|
000126  6f20              LDR      r0,[r4,#0x70]         ;874
000128  0b00              LSRS     r0,r0,#12             ;874
00012a  6720              STR      r0,[r4,#0x70]         ;875
00012c  f8b4107a          LDRH     r1,[r4,#0x7a]         ;875
000130  4288              CMP      r0,r1                 ;875
000132  d002              BEQ      |L12.314|
                  |L12.308|
000134  4618              MOV      r0,r3                 ;880
000136  e7e2              B        |L12.254|
                  |L12.312|
000138  e040              B        |L12.444|
                  |L12.314|
00013a  f8a45084          STRH     r5,[r4,#0x84]         ;886
00013e  e048              B        |L12.466|
                  |L12.320|
000140  8a20              LDRH     r0,[r4,#0x10]         ;890
000142  8d23              LDRH     r3,[r4,#0x28]         ;893
000144  0881              LSRS     r1,r0,#2              ;890
000146  f8d4008c          LDR      r0,[r4,#0x8c]         ;891
00014a  0882              LSRS     r2,r0,#2              ;891
00014c  6a20              LDR      r0,[r4,#0x20]         ;893
00014e  4418              ADD      r0,r0,r3              ;893
000150  9000              STR      r0,[sp,#0]            ;895
000152  2000              MOVS     r0,#0                 ;895
000154  0092              LSLS     r2,r2,#2              ;897
000156  e008              B        |L12.362|
                  |L12.344|
000158  9b00              LDR      r3,[sp,#0]            ;897
00015a  f8d46088          LDR      r6,[r4,#0x88]         ;897
00015e  eb020580          ADD      r5,r2,r0,LSL #2       ;897
000162  f8533020          LDR      r3,[r3,r0,LSL #2]     ;897
000166  5173              STR      r3,[r6,r5]            ;897
000168  1c40              ADDS     r0,r0,#1              ;897
                  |L12.362|
00016a  4288              CMP      r0,r1                 ;895
00016c  d3f4              BCC      |L12.344|
00016e  f8d4008c          LDR      r0,[r4,#0x8c]         ;899
000172  eb000081          ADD      r0,r0,r1,LSL #2       ;899
000176  f8c4008c          STR      r0,[r4,#0x8c]         ;903
00017a  e02a              B        |L12.466|
                  |L12.380|
00017c  8d22              LDRH     r2,[r4,#0x28]         ;909
00017e  6a21              LDR      r1,[r4,#0x20]         ;909
000180  4411              ADD      r1,r1,r2              ;909
000182  8a22              LDRH     r2,[r4,#0x10]         ;909
000184  f7fffffe          BL       kdp_memxfer_ddr_to_flash
000188  b1c0              CBZ      r0,|L12.444|
00018a  e022              B        |L12.466|
                  |L12.396|
00018c  6d61              LDR      r1,[r4,#0x54]         ;927
00018e  600d              STR      r5,[r1,#0]            ;928
000190  6a61              LDR      r1,[r4,#0x24]         ;928
000192  600d              STR      r5,[r1,#0]            ;930
000194  6a23              LDR      r3,[r4,#0x20]         ;930
000196  4601              MOV      r1,r0                 ;930
000198  8a22              LDRH     r2,[r4,#0x10]         ;930
00019a  4618              MOV      r0,r3                 ;930
00019c  f7fffffe          BL       kdp_memxfer_flash_to_ddr
0001a0  b960              CBNZ     r0,|L12.444|
0001a2  8a20              LDRH     r0,[r4,#0x10]         ;937
0001a4  f8a40040          STRH     r0,[r4,#0x40]         ;937
0001a8  6d61              LDR      r1,[r4,#0x54]         ;938
0001aa  6008              STR      r0,[r1,#0]            ;956
0001ac  e011              B        |L12.466|
                  |L12.430|
0001ae  8d20              LDRH     r0,[r4,#0x28]         ;961
0001b0  0302              LSLS     r2,r0,#12             ;963
0001b2  0308              LSLS     r0,r1,#12             ;963
0001b4  4611              MOV      r1,r2                 ;963
0001b6  f7fffffe          BL       kdp_memxfer_flash_sector_multi_erase
0001ba  b150              CBZ      r0,|L12.466|
                  |L12.444|
0001bc  20e2              MOVS     r0,#0xe2              ;968
0001be  e79e              B        |L12.254|
                  |L12.448|
0001c0  f7fffffe          BL       kdp_model_info_reload
0001c4  f10402a0          ADD      r2,r4,#0xa0           ;1047
0001c8  1f11              SUBS     r1,r2,#4              ;1047
0001ca  f1040094          ADD      r0,r4,#0x94           ;1047
0001ce  f7fffffe          BL       kdp_model_info_get
                  |L12.466|
0001d2  8960              LDRH     r0,[r4,#0xa]          ;1069
0001d4  b920              CBNZ     r0,|L12.480|
0001d6  4620              MOV      r0,r4                 ;1071
0001d8  f7fffffe          BL       Drv_flash_action_doing
0001dc  2888              CMP      r0,#0x88              ;1072
0001de  d18e              BNE      |L12.254|
                  |L12.480|
0001e0  2001              MOVS     r0,#1                 ;1079
0001e2  e78c              B        |L12.254|
;;;1083   
                          ENDP

                  |L12.484|
                          DCD      st_flash_info

                          AREA ||i.drv_ota_packet_analyze||, CODE, READONLY, ALIGN=2

                  drv_ota_packet_analyze PROC
;;;1151   
;;;1152   UINT8 drv_ota_packet_analyze( OTA_FLASHt * stota )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1153   {
000004  4605              MOV      r5,r0
;;;1154       UINT32	i = 0;
;;;1155       UINT8		*ptr = stota->receive_cmd.ptr;
;;;1156       UINT32	*ptr_indedx = stota->receive_cmd.ptr_index;
;;;1157       UINT32	nhead_index = 0xFFFFFFFF;
;;;1158       UINT32	ncheck_sum = 0;
;;;1159   
;;;1160   
;;;1161   #if( OTA_TIMING_DEBUG_EN == YES )
;;;1162       kdp520_gpio_setdata( 1<<24);
;;;1163       kdp520_gpio_cleardata( 1<<24);
;;;1164       kdp520_gpio_setdata( 1<<24);
;;;1165       kdp520_gpio_cleardata( 1<<24);
;;;1166   #endif
;;;1167   
;;;1168   #if( OTA_LOG_EN == YES )
;;;1169       //dbg_msg_flash("   [OTA] Analyze 1..");
;;;1170       //dbg_msg_flash("[OTA] Packet Rx size: %d", *ptr_indedx );
;;;1171   #endif
;;;1172   
;;;1173       stota->receive_cmd.busy_flag = 1;		//flash controller is busy
000006  2001              MOVS     r0,#1
000008  e9d56708          LDRD     r6,r7,[r5,#0x20]
00000c  7728              STRB     r0,[r5,#0x1c]
;;;1174   
;;;1175       //-----------------------
;;;1176       //packet tail  check
;;;1177       //-----------------------
;;;1178       if(	(*(ptr + (*ptr_indedx) -1)  !=  FLASH_TAIL_1) || ( *(ptr + (*ptr_indedx) -2 )  != FLASH_TAIL_2 ) )
00000e  6839              LDR      r1,[r7,#0]
000010  1e70              SUBS     r0,r6,#1
000012  2400              MOVS     r4,#0                 ;1154
000014  5c08              LDRB     r0,[r1,r0]
000016  2887              CMP      r0,#0x87
000018  d179              BNE      |L13.270|
00001a  1eb0              SUBS     r0,r6,#2
00001c  5c08              LDRB     r0,[r1,r0]
00001e  2878              CMP      r0,#0x78
000020  d175              BNE      |L13.270|
000022  1f09              SUBS     r1,r1,#4
;;;1179       {
;;;1180           return PACKET_TAIL_CHECK_ERROR;
;;;1181       }
;;;1182   
;;;1183       //-----------------------
;;;1184       //-----	head check ------
;;;1185       //-----------------------
;;;1186       for( i = 0; i < ( *ptr_indedx-4 ); i++ )
000024  e00d              B        |L13.66|
                  |L13.38|
;;;1187       {
;;;1188           if(	 (*(ptr + i + 0 ) == FLASH_HEAD_RX_1) && (*(ptr +i +  1 ) == FLASH_HEAD_RX_2 )
000026  5d30              LDRB     r0,[r6,r4]
000028  2878              CMP      r0,#0x78
00002a  d109              BNE      |L13.64|
00002c  1930              ADDS     r0,r6,r4
00002e  7842              LDRB     r2,[r0,#1]
000030  2a87              CMP      r2,#0x87
000032  d105              BNE      |L13.64|
;;;1189               && (*(ptr +i +  2 ) == FLASH_HEAD_RX_3) && (*(ptr +i +  3 ) == FLASH_HEAD_RX_4 )	)
000034  7882              LDRB     r2,[r0,#2]
000036  2a5a              CMP      r2,#0x5a
000038  d102              BNE      |L13.64|
00003a  78c2              LDRB     r2,[r0,#3]
00003c  2aa5              CMP      r2,#0xa5
00003e  d003              BEQ      |L13.72|
                  |L13.64|
000040  1c64              ADDS     r4,r4,#1
                  |L13.66|
000042  42a1              CMP      r1,r4                 ;1186
000044  d8ef              BHI      |L13.38|
000046  e045              B        |L13.212|
                  |L13.72|
;;;1190           {
;;;1191               nhead_index = i;
;;;1192               *(ptr + i + 0 ) = 0;
000048  2200              MOVS     r2,#0
;;;1193               *(ptr +i +  1 ) = 0;
00004a  1931              ADDS     r1,r6,r4
00004c  5532              STRB     r2,[r6,r4]            ;1192
00004e  704a              STRB     r2,[r1,#1]
;;;1194               break;
;;;1195           }
;;;1196       }
;;;1197       if( nhead_index == 0xFFFFFFFF  )
000050  1c61              ADDS     r1,r4,#1
000052  d03f              BEQ      |L13.212|
;;;1198       {
;;;1199           return PACKET_HEAD_CHECK_ERROR;
;;;1200       }
;;;1201   
;;;1202       #if( OTA_TIMING_DEBUG_EN == YES )
;;;1203       kdp520_gpio_setdata( 1<<24);
;;;1204       kdp520_gpio_cleardata( 1<<24);
;;;1205       kdp520_gpio_setdata( 1<<24);
;;;1206       kdp520_gpio_cleardata( 1<<24);
;;;1207       kdp520_gpio_setdata( 1<<24);
;;;1208       kdp520_gpio_cleardata( 1<<24);
;;;1209       kdp520_gpio_setdata( 1<<24);
;;;1210       kdp520_gpio_cleardata( 1<<24);
;;;1211       #endif
;;;1212   
;;;1213       stota->receive_cmd.head = FLASH_HEAD_RX;							//receive data from device
000054  4940              LDR      r1,|L13.344|
;;;1214       stota->receive_cmd.host_number = *(ptr+nhead_index+4)<<8 | *(ptr+nhead_index+5);
000056  6069              STR      r1,[r5,#4]
000058  8881              LDRH     r1,[r0,#4]
00005a  ba49              REV16    r1,r1
00005c  8129              STRH     r1,[r5,#8]
;;;1215       stota->receive_cmd.cmd_stat = 	*(ptr+nhead_index+6)<<8  |  *(ptr+nhead_index+7) ;
00005e  88c1              LDRH     r1,[r0,#6]
000060  ba49              REV16    r1,r1
000062  8169              STRH     r1,[r5,#0xa]
;;;1216   
;;;1217       stota->receive_cmd.action_number = 0;
000064  73aa              STRB     r2,[r5,#0xe]
;;;1218   
;;;1219       if( stota->receive_cmd.cmd_stat == FLASH_PROGRAM_ACT )
000066  29f0              CMP      r1,#0xf0
000068  d037              BEQ      |L13.218|
;;;1220       {
;;;1221           stota->receive_cmd.sector_index= ( *( ptr+nhead_index+8) << 8 ) | *(ptr+nhead_index + 9);
;;;1222           stota->receive_cmd.action_number = 0;
;;;1223           stota->receive_cmd.data_size=	( *( ptr+nhead_index+10) << 8 ) | *(ptr+nhead_index+11);
;;;1224   
;;;1225           stota->receive_cmd.data_offset = nhead_index+12;
;;;1226   
;;;1227           ncheck_sum = Drv_utility_checksum( ptr, nhead_index+6, *ptr_indedx - 6 );
;;;1228       }
;;;1229       else if( stota->receive_cmd.cmd_stat == FLASH_DATA_TO_DDR_ACT )		// add
00006a  29f3              CMP      r1,#0xf3
00006c  d035              BEQ      |L13.218|
;;;1230       {
;;;1231   
;;;1232           stota->receive_cmd.sector_index= ( *( ptr+nhead_index+8) << 8 ) | *(ptr+nhead_index + 9);
;;;1233           stota->receive_cmd.action_number = 0;
;;;1234           stota->receive_cmd.data_size=	( *( ptr+nhead_index+10) << 8 ) | *(ptr+nhead_index+11);
;;;1235   
;;;1236           stota->receive_cmd.data_offset = nhead_index+12;
;;;1237   
;;;1238           ncheck_sum = Drv_utility_checksum( ptr, nhead_index+6, *ptr_indedx - 6 );
;;;1239   
;;;1240       }
;;;1241   
;;;1242   #if( NIR_RGB_OTA_EN==1 )
;;;1243       else if( stota->receive_cmd.cmd_stat == FLASH_READ_ACT ||
00006e  29f1              CMP      r1,#0xf1
000070  d03e              BEQ      |L13.240|
;;;1244                stota->receive_cmd.cmd_stat == FLASH_READ_NIR_ACT ||
000072  29e1              CMP      r1,#0xe1
000074  d03c              BEQ      |L13.240|
;;;1245                stota->receive_cmd.cmd_stat == FLASH_READ_ALL_ACT ||
000076  29e3              CMP      r1,#0xe3
000078  d03a              BEQ      |L13.240|
;;;1246                stota->receive_cmd.cmd_stat == FLASH_READ_RGB_ACT )
00007a  29e2              CMP      r1,#0xe2
00007c  d038              BEQ      |L13.240|
;;;1247   #else
;;;1248           else if( stota->receive_cmd.cmd_stat == FLASH_READ_ACT )
;;;1249   #endif
;;;1250       {
;;;1251               //dbg_msg_flash("   [OTA] Analyze read..");
;;;1252   
;;;1253           #if( NIR_RGB_OTA_EN==1 )
;;;1254           stota->receive_cmd.action_number = *(ptr+nhead_index+8) ;
;;;1255           #endif
;;;1256           stota->receive_cmd.sector_index =	( *( ptr+nhead_index+8) << 8 ) | *(ptr+nhead_index + 9);
;;;1257           stota->receive_cmd.data_size=	( *( ptr+nhead_index+10) << 8 ) | *(ptr+nhead_index+11);
;;;1258           stota->receive_cmd.data_offset = 0;
;;;1259           ncheck_sum = Drv_utility_checksum( ptr, nhead_index+6, *ptr_indedx - 6 );
;;;1260       }
;;;1261       else if( stota->receive_cmd.cmd_stat == FLASH_ERASE_SECTOR_ACT )
00007e  29f2              CMP      r1,#0xf2
000080  d046              BEQ      |L13.272|
;;;1262       {
;;;1263           stota->receive_cmd.sector_index =	( *( ptr+nhead_index+8) << 8 ) | *(ptr+nhead_index + 9);			//start sector
;;;1264           stota->receive_cmd.data_offset =	( *( ptr+nhead_index+10) << 8 ) | *(ptr+nhead_index + 11);		//end sector
;;;1265   
;;;1266           stota->receive_cmd.data_size=	0;
;;;1267           ncheck_sum = Drv_utility_checksum( ptr, nhead_index+6, *ptr_indedx - 6 );
;;;1268       }
;;;1269       else if( stota->receive_cmd.cmd_stat == FLASH_UI_MODEL_INFO )
000082  29fe              CMP      r1,#0xfe
000084  d04c              BEQ      |L13.288|
;;;1270       {
;;;1271           stota->sector_offset = 0;
;;;1272           stota->target_bytes = ( *( ptr+nhead_index+12) << 24 ) | (*( ptr+nhead_index+13) << 16 )| (*( ptr+nhead_index+14) << 8 )| (*( ptr+nhead_index+15) << 0 );
;;;1273           stota->target_sectors = stota->target_bytes>>12;
;;;1274           #if( OTA_LOG_EN == YES )
;;;1275           dbg_msg_flash("[OTA cfg] 0xFE target_sectors : %d", stota->target_sectors );
;;;1276           #endif
;;;1277           ncheck_sum = Drv_utility_checksum( ptr, nhead_index+6, *ptr_indedx - 6 );
;;;1278       }
;;;1279       else if ( stota->receive_cmd.cmd_stat == FLASH_MODEL_SIZE )
000086  29fa              CMP      r1,#0xfa
000088  d057              BEQ      |L13.314|
;;;1280       {
;;;1281           if(  (*ptr_indedx-6) <= (nhead_index+6) )
;;;1282           {
;;;1283               return PACKET_TAIL_CHECK_ERROR;
;;;1284           }
;;;1285           ncheck_sum = Drv_utility_checksum( ptr, nhead_index+6, *ptr_indedx - 6 );
;;;1286       }
;;;1287       else	// if( stota->receive_cmd.cmd_stat == FLASH_CMD_ACT )
;;;1288       {
;;;1289           stota->receive_cmd.action_number = *( ptr+nhead_index + 8 );
00008a  7a00              LDRB     r0,[r0,#8]
00008c  73a8              STRB     r0,[r5,#0xe]
;;;1290           //action
;;;1291   #if CFG_SNAPSHOT_ENABLE == 2
;;;1292           #if( NIR_RGB_OTA_EN==1 )
;;;1293           if(  stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_NIR )
;;;1294           {
;;;1295               //call NIR capture
;;;1296               kl520_api_snapshot_fdfr_catch(MIPI_CAM_NIR);
;;;1297           }
;;;1298           else if(  stota->receive_cmd.action_number == FLASH_CMD_ACT_NUM_RGB )
;;;1299           {
;;;1300               //call RGB capture
;;;1301               kl520_api_snapshot_fdfr_catch(MIPI_CAM_RGB);
;;;1302           }
;;;1303           #endif
;;;1304   #endif
;;;1305           stota->receive_cmd.sector_index = 0;
00008e  81aa              STRH     r2,[r5,#0xc]
;;;1306           stota->receive_cmd.data_size=	0;
000090  822a              STRH     r2,[r5,#0x10]
;;;1307           ncheck_sum = Drv_utility_checksum( ptr, nhead_index+6, *ptr_indedx - 6 );
000092  8838              LDRH     r0,[r7,#0]
000094  4690              MOV      r8,r2                 ;1305
000096  1f80              SUBS     r0,r0,#6
000098  b282              UXTH     r2,r0
00009a  1da0              ADDS     r0,r4,#6
00009c  b281              UXTH     r1,r0
00009e  4630              MOV      r0,r6
0000a0  f7fffffe          BL       Drv_utility_checksum
;;;1308           stota->receive_cmd.data_offset = 0;
0000a4  f8a58028          STRH     r8,[r5,#0x28]
                  |L13.168|
;;;1309       }
;;;1310   
;;;1311       stota->receive_cmd.check_sum = ( *( ptr+ (*ptr_indedx) -6 ) << 24 ) | (*(ptr+nhead_index+ (*ptr_indedx) -5 )<<16 ) |
0000a8  6839              LDR      r1,[r7,#0]
0000aa  1ee2              SUBS     r2,r4,#3
0000ac  198b              ADDS     r3,r1,r6
0000ae  1f64              SUBS     r4,r4,#5
0000b0  5c9f              LDRB     r7,[r3,r2]
0000b2  1fb2              SUBS     r2,r6,#6
0000b4  1f36              SUBS     r6,r6,#4
0000b6  5c8a              LDRB     r2,[r1,r2]
0000b8  5d1b              LDRB     r3,[r3,r4]
0000ba  5d89              LDRB     r1,[r1,r6]
0000bc  041b              LSLS     r3,r3,#16
0000be  ea476202          ORR      r2,r7,r2,LSL #24
0000c2  ea432101          ORR      r1,r3,r1,LSL #8
0000c6  430a              ORRS     r2,r2,r1
;;;1312                                      ( *( ptr+ (*ptr_indedx) -4 ) << 8 ) | *(ptr+nhead_index+ (*ptr_indedx) -3 );
;;;1313   
;;;1314       stota->receive_cmd.tail = FLASH_TAIL;
0000c8  f6470187          MOV      r1,#0x7887
0000cc  616a              STR      r2,[r5,#0x14]
0000ce  8329              STRH     r1,[r5,#0x18]
;;;1315   
;;;1316       //check sum error
;;;1317       if( stota->receive_cmd.check_sum != ncheck_sum  )
0000d0  4282              CMP      r2,r0
0000d2  d03f              BEQ      |L13.340|
                  |L13.212|
;;;1318       {
;;;1319           return PACKET_HEAD_CHECK_ERROR;
0000d4  20e0              MOVS     r0,#0xe0
                  |L13.214|
;;;1320       }
;;;1321       return FLASH_PACKET_OK;	//exist good data
;;;1322   }
0000d6  e8bd81f0          POP      {r4-r8,pc}
                  |L13.218|
0000da  8901              LDRH     r1,[r0,#8]            ;1221
0000dc  ba49              REV16    r1,r1                 ;1221
0000de  81a9              STRH     r1,[r5,#0xc]          ;1221
0000e0  73aa              STRB     r2,[r5,#0xe]          ;1222
0000e2  8940              LDRH     r0,[r0,#0xa]          ;1223
0000e4  ba40              REV16    r0,r0                 ;1223
0000e6  8228              STRH     r0,[r5,#0x10]         ;1223
0000e8  f104000c          ADD      r0,r4,#0xc            ;1225
0000ec  8528              STRH     r0,[r5,#0x28]         ;1225
0000ee  e008              B        |L13.258|
                  |L13.240|
0000f0  7a01              LDRB     r1,[r0,#8]            ;1254
0000f2  73a9              STRB     r1,[r5,#0xe]          ;1254
0000f4  8901              LDRH     r1,[r0,#8]            ;1256
0000f6  ba49              REV16    r1,r1                 ;1256
0000f8  81a9              STRH     r1,[r5,#0xc]          ;1256
0000fa  8940              LDRH     r0,[r0,#0xa]          ;1257
0000fc  ba40              REV16    r0,r0                 ;1257
0000fe  8228              STRH     r0,[r5,#0x10]         ;1257
000100  852a              STRH     r2,[r5,#0x28]         ;1258
                  |L13.258|
000102  8838              LDRH     r0,[r7,#0]            ;1227
000104  1f80              SUBS     r0,r0,#6              ;1227
000106  b282              UXTH     r2,r0                 ;1227
000108  1da0              ADDS     r0,r4,#6              ;1227
00010a  b281              UXTH     r1,r0                 ;1227
00010c  e01e              B        |L13.332|
                  |L13.270|
00010e  e019              B        |L13.324|
                  |L13.272|
000110  8901              LDRH     r1,[r0,#8]            ;1263
000112  ba49              REV16    r1,r1                 ;1263
000114  81a9              STRH     r1,[r5,#0xc]          ;1263
000116  8940              LDRH     r0,[r0,#0xa]          ;1264
000118  ba40              REV16    r0,r0                 ;1264
00011a  8528              STRH     r0,[r5,#0x28]         ;1264
00011c  822a              STRH     r2,[r5,#0x10]         ;1266
00011e  e7f0              B        |L13.258|
                  |L13.288|
000120  676a              STR      r2,[r5,#0x74]         ;1272
000122  68c1              LDR      r1,[r0,#0xc]          ;1272
000124  7bc0              LDRB     r0,[r0,#0xf]          ;1272
000126  ba09              REV      r1,r1                 ;1272
000128  f02101ff          BIC      r1,r1,#0xff           ;1272
00012c  4301              ORRS     r1,r1,r0              ;1272
00012e  0b08              LSRS     r0,r1,#12             ;1273
000130  f8c51080          STR      r1,[r5,#0x80]         ;1273
000134  f8a5007a          STRH     r0,[r5,#0x7a]         ;1273
000138  e7e3              B        |L13.258|
                  |L13.314|
00013a  6838              LDR      r0,[r7,#0]            ;1281
00013c  1da1              ADDS     r1,r4,#6              ;1281
00013e  1f80              SUBS     r0,r0,#6              ;1281
000140  4288              CMP      r0,r1                 ;1281
000142  d801              BHI      |L13.328|
                  |L13.324|
000144  20e1              MOVS     r0,#0xe1              ;1283
000146  e7c6              B        |L13.214|
                  |L13.328|
000148  b282              UXTH     r2,r0                 ;1285
00014a  b289              UXTH     r1,r1                 ;1285
                  |L13.332|
00014c  4630              MOV      r0,r6                 ;1285
00014e  f7fffffe          BL       Drv_utility_checksum
000152  e7a9              B        |L13.168|
                  |L13.340|
000154  2066              MOVS     r0,#0x66              ;1321
000156  e7be              B        |L13.214|
;;;1323   
                          ENDP

                  |L13.344|
                          DCD      0x78875aa5

                          AREA ||i.drv_read_all_model_crc||, CODE, READONLY, ALIGN=2

                  drv_read_all_model_crc PROC
;;;564    
;;;565    UINT32 drv_read_all_model_crc(void)
000000  b538              PUSH     {r3-r5,lr}
;;;566    {
;;;567        UINT32  crc_r;
;;;568        kdp_memxfer_flash_to_ddr((uint32_t)&crc_r, MODEL_MGR_FLASH_ADDR_MODEL_INFO+kdp_crc_offset_in_fwinfo()+kdp_get_fwinfo_offset() , 4);
000002  f7fffffe          BL       kdp_crc_offset_in_fwinfo
000006  4604              MOV      r4,r0
000008  f7fffffe          BL       kdp_get_fwinfo_offset
00000c  4904              LDR      r1,|L14.32|
00000e  4420              ADD      r0,r0,r4
000010  4401              ADD      r1,r1,r0
000012  2204              MOVS     r2,#4
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       kdp_memxfer_flash_to_ddr
;;;569        return crc_r;
00001a  9800              LDR      r0,[sp,#0]
;;;570    }
00001c  bd38              POP      {r3-r5,pc}
;;;571    
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      0x00143004

                          AREA ||i.drv_read_each_model_crc||, CODE, READONLY, ALIGN=2

                  drv_read_each_model_crc PROC
;;;571    
;;;572    UINT32 drv_read_each_model_crc(uint8_t idx)
000000  b538              PUSH     {r3-r5,lr}
;;;573    {
000002  4604              MOV      r4,r0
;;;574        UINT32  crc_r;
;;;575        kdp_memxfer_flash_to_ddr((uint32_t)&crc_r,
000004  f7fffffe          BL       kdp_crc_offset_in_fwinfo
000008  4605              MOV      r5,r0
00000a  f7fffffe          BL       kdp_get_fwinfo_offset
00000e  4428              ADD      r0,r0,r5
000010  4904              LDR      r1,|L15.36|
000012  eb000084          ADD      r0,r0,r4,LSL #2
000016  4401              ADD      r1,r1,r0
000018  2204              MOVS     r2,#4
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       kdp_memxfer_flash_to_ddr
;;;576                                 MODEL_MGR_FLASH_ADDR_MODEL_INFO+kdp_crc_offset_in_fwinfo()+kdp_get_fwinfo_offset() + idx*4+4
;;;577                                 , 4);
;;;578        return crc_r;
000020  9800              LDR      r0,[sp,#0]
;;;579    }
000022  bd38              POP      {r3-r5,pc}
;;;580    
                          ENDP

                  |L15.36|
                          DCD      0x00143008

                          AREA ||i.ota_bin_check||, CODE, READONLY, ALIGN=1

                  ota_bin_check PROC
;;;438    
;;;439    UINT16 ota_bin_check( OTA_FLASHt * stota, UINT32 **ptr )
000000  b510              PUSH     {r4,lr}
;;;440    {
;;;441        *ptr = stota->ddr_ptr;
000002  f8d02088          LDR      r2,[r0,#0x88]
;;;442    
;;;443        //check valid size!!
;;;444        if( stota->bin_type == eOTA_bin_scpu )
000006  600a              STR      r2,[r1,#0]
000008  f890307c          LDRB     r3,[r0,#0x7c]
;;;445        {
;;;446            if( stota->ddr_ptr_index != KDP_FLASH_FW_SCPU_SIZE )
;;;447            {
;;;448                #if( OTA_LOG_EN == YES )
;;;449                dbg_msg_flash("[OTA] scpu bin size error , size:%d--", stota->ddr_ptr_index);   //20200217 add
;;;450                #endif
;;;451                stota->sn_cpu_status =  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
00000c  f64e62e3          MOV      r2,#0xeee3
000010  b153              CBZ      r3,|L16.40|
;;;452                return  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;453                //break;
;;;454            }
;;;455            #if( OTA_LOG_EN == YES )
;;;456            dbg_msg_flash("[OTA] scpu flash bin pass"); //20200217 add
;;;457            #endif
;;;458        }
;;;459        else if( stota->bin_type == eOTA_bin_ncpu )
000012  2b01              CMP      r3,#1
000014  d00e              BEQ      |L16.52|
;;;460        {
;;;461            if( stota->ddr_ptr_index != KDP_FLASH_FW_NCPU_SIZE )
;;;462            {
;;;463                #if( OTA_LOG_EN == YES )
;;;464                dbg_msg_flash("[OTA] ncpu bin size error , size:%d--", stota->ddr_ptr_index);   //20200217 add
;;;465                #endif
;;;466                stota->sn_cpu_status =  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;467                return  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;468                //break;
;;;469            }
;;;470            #if( OTA_LOG_EN == YES )
;;;471            dbg_msg_flash("[OTA] ncpu flash bin pass"); //20200217 add
;;;472            #endif
;;;473        }
;;;474        else if( stota->bin_type == eOTA_bin_all_model )
000016  2b02              CMP      r3,#2
000018  d012              BEQ      |L16.64|
;;;475        {
;;;476            if( stota->ddr_ptr_index != stota->target_bytes )
;;;477            {
;;;478                #if( OTA_LOG_EN == YES )
;;;479                dbg_msg_flash("[OTA] model flash bin faiel: 0x%x", stota->ddr_ptr_index );
;;;480                #endif
;;;481                stota->sn_cpu_status =  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;482                return  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;483            }
;;;484            #if( OTA_LOG_EN == YES )
;;;485            dbg_msg_flash("[OTA] model flash bin pass");
;;;486            #endif
;;;487        }
;;;488        else if( stota->bin_type == eOTA_bin_ui_image )
00001a  2b03              CMP      r3,#3
00001c  d015              BEQ      |L16.74|
;;;489        {
;;;490            if( stota->ddr_ptr_index != stota->target_bytes )
;;;491            {
;;;492                #if( OTA_LOG_EN == YES )
;;;493                dbg_msg_flash("[OTA] Image UI flash bin fail: 0x%x", stota->ddr_ptr_index );
;;;494                #endif
;;;495                stota->sn_cpu_status =  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;496                return  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;497            }
;;;498            //find 4 aligned address
;;;499            *ptr = (UINT32 *)KDP_DDR_MODEL_START_ADDR + stota->ddr_ptr_index;
;;;500            while( ((UINT32)(*ptr)%4) != 0 ){
;;;501                (*ptr)=(*ptr)+1;
;;;502                #if( OTA_LOG_EN == YES )
;;;503                dbg_msg_flash("[OTA] read buf address: 0x%X", ptr);
;;;504                #endif
;;;505            }
;;;506            #if( OTA_LOG_EN == YES )
;;;507            dbg_msg_flash("[OTA] Image UI flash bin pass");
;;;508            #endif
;;;509        }
;;;510        else if( stota->bin_type == eOTA_bin_fw_info )
00001e  2b04              CMP      r3,#4
000020  d00e              BEQ      |L16.64|
;;;511        {
;;;512            if( stota->ddr_ptr_index != stota->target_bytes )
;;;513            {
;;;514                #if( OTA_LOG_EN == YES )
;;;515                dbg_msg_flash("[OTA] fw info flash bin fail: 0x%x", stota->ddr_ptr_index );
;;;516                #endif
;;;517                stota->sn_cpu_status =  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;518                return  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;519            }
;;;520            #if( OTA_LOG_EN == YES )
;;;521            dbg_msg_flash("[OTA] fw info flash bin pass");
;;;522            #endif
;;;523        }
;;;524        else if( stota->bin_type == eOTA_bin_partial_model )  //partial model
000022  2b05              CMP      r3,#5
000024  d021              BEQ      |L16.106|
000026  e02a              B        |L16.126|
                  |L16.40|
000028  f8d0108c          LDR      r1,[r0,#0x8c]         ;446
00002c  f5b13f20          CMP      r1,#0x28000           ;446
000030  d125              BNE      |L16.126|
000032  e028              B        |L16.134|
                  |L16.52|
000034  f8d0108c          LDR      r1,[r0,#0x8c]         ;461
000038  f5b13f80          CMP      r1,#0x10000           ;461
00003c  d11f              BNE      |L16.126|
00003e  e022              B        |L16.134|
                  |L16.64|
000040  f8d03080          LDR      r3,[r0,#0x80]         ;476
000044  f8d0108c          LDR      r1,[r0,#0x8c]         ;476
000048  e017              B        |L16.122|
                  |L16.74|
00004a  f8d04080          LDR      r4,[r0,#0x80]         ;490
00004e  f8d0308c          LDR      r3,[r0,#0x8c]         ;490
000052  42a3              CMP      r3,r4                 ;490
000054  d113              BNE      |L16.126|
000056  f04f40c0          MOV      r0,#0x60000000        ;499
00005a  eb000083          ADD      r0,r0,r3,LSL #2       ;499
00005e  e000              B        |L16.98|
                  |L16.96|
000060  1d00              ADDS     r0,r0,#4              ;500
                  |L16.98|
000062  6008              STR      r0,[r1,#0]            ;500
000064  0782              LSLS     r2,r0,#30             ;500
000066  d1fb              BNE      |L16.96|
000068  e00d              B        |L16.134|
                  |L16.106|
;;;525        {
;;;526            if( (stota->ddr_ptr_index != stota->target_bytes) || (stota->ddr_ptr_index != stota->model_size) )
00006a  f8d03080          LDR      r3,[r0,#0x80]
00006e  f8d0108c          LDR      r1,[r0,#0x8c]
000072  4299              CMP      r1,r3
000074  d103              BNE      |L16.126|
000076  f8d030a0          LDR      r3,[r0,#0xa0]
                  |L16.122|
00007a  4299              CMP      r1,r3                 ;476
00007c  d003              BEQ      |L16.134|
                  |L16.126|
;;;527            {
;;;528                #if( OTA_LOG_EN == YES )
;;;529                dbg_msg_flash("[OTA] partial model flash bin fail: 0x%x", stota->ddr_ptr_index );
;;;530                dbg_msg_flash("[OTA] partial model target size: 0x%x", stota->model_size );
;;;531                #endif
;;;532                stota->sn_cpu_status =  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;533                return  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
;;;534            }
;;;535    
;;;536            #if (OTA_CRC_CHECK_EN==NO)
;;;537            //find 4 aligned address
;;;538            *ptr = (UINT32 *)KDP_DDR_MODEL_START_ADDR + stota->ddr_ptr_index;
;;;539            while( ((UINT32)(*ptr)%4) != 0 ){
;;;540                (*ptr)=(*ptr)+1;
;;;541                #if( OTA_LOG_EN == YES )
;;;542                dbg_msg_flash("[OTA] read buf address: 0x%X", ptr);
;;;543                #endif
;;;544            }
;;;545            #endif
;;;546    
;;;547            #if( OTA_LOG_EN == YES )
;;;548            dbg_msg_flash("[OTA] partial model flash bin pass");
;;;549            #endif
;;;550        }
;;;551        else
;;;552        {
;;;553            stota->sn_cpu_status =  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
00007e  f8a02084          STRH     r2,[r0,#0x84]
;;;554            #if( OTA_LOG_EN == YES )
;;;555            dbg_msg_flash("[OTA] bin type fatal fail");
;;;556            #endif
;;;557            return  FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL;
000082  4610              MOV      r0,r2
;;;558            //break;
;;;559        }
;;;560    
;;;561        return FLASH_STATUS_OK;
;;;562    }
000084  bd10              POP      {r4,pc}
                  |L16.134|
000086  f6470055          MOV      r0,#0x7855            ;561
00008a  bd10              POP      {r4,pc}
;;;563    
                          ENDP


                          AREA ||i.ota_thread_event_set||, CODE, READONLY, ALIGN=2

                  ota_thread_event_set PROC
;;;2238   
;;;2239   void ota_thread_event_set(void)
000000  4802              LDR      r0,|L17.12|
;;;2240   {
;;;2241       set_thread_event( ota_tid , FLAGS_FLASH_START);
000002  2102              MOVS     r1,#2
000004  6940              LDR      r0,[r0,#0x14]  ; ota_tid
000006  f7ffbffe          B.W      set_thread_event
;;;2242   }
;;;2243   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L17.12|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  stOTA
                          %        164

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000700
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  4d525f53          DCB      "MR_SUCCESS",0
000004  55434345
000008  535300  
00000b  00                DCB      0
00000c  4d525f52          DCB      "MR_REJECTED",0
000010  454a4543
000014  54454400
000018  4d525f41          DCB      "MR_ABORTED",0
00001c  424f5254
000020  454400  
000023  00                DCB      0
000024  4d525f46          DCB      "MR_FAILED_DEV_OPEN_FAIL",0
000028  41494c45
00002c  445f4445
000030  565f4f50
000034  454e5f46
000038  41494c00
00003c  4d525f46          DCB      "MR_FAILED_UNKNOWN_REASON",0
000040  41494c45
000044  445f554e
000048  4b4e4f57
00004c  4e5f5245
000050  41534f4e
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
000058  4d525f46          DCB      "MR_FAILED_INVALID_PARAM",0
00005c  41494c45
000060  445f494e
000064  56414c49
000068  445f5041
00006c  52414d00
000070  4d525f46          DCB      "MR_FAILED_OOM",0
000074  41494c45
000078  445f4f4f
00007c  4d00    
00007e  00                DCB      0
00007f  00                DCB      0
000080  4d525f46          DCB      "MR_FAILED_UNKNOWN_USER",0
000084  41494c45
000088  445f554e
00008c  4b4e4f57
000090  4e5f5553
000094  455200  
000097  00                DCB      0
000098  4d525f46          DCB      "MR_FAILED_MAX_USER",0
00009c  41494c45
0000a0  445f4d41
0000a4  585f5553
0000a8  455200  
0000ab  00                DCB      0
0000ac  4d525f46          DCB      "MR_FAILED_FACE_ENROLLED",0
0000b0  41494c45
0000b4  445f4641
0000b8  43455f45
0000bc  4e524f4c
0000c0  4c454400
0000c4  4d525f46          DCB      "MR_FAILED_LIVENESS_CHECK",0
0000c8  41494c45
0000cc  445f4c49
0000d0  56454e45
0000d4  53535f43
0000d8  4845434b
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
0000e0  4d525f46          DCB      "MR_FAILED_TIME_OUT",0
0000e4  41494c45
0000e8  445f5449
0000ec  4d455f4f
0000f0  555400  
0000f3  00                DCB      0
0000f4  4d525f46          DCB      "MR_FAILED_AUTHORIZATION",0
0000f8  41494c45
0000fc  445f4155
000100  54484f52
000104  495a4154
000108  494f4e00
00010c  4d525f46          DCB      "MR_FAILED_READ_FILE",0
000110  41494c45
000114  445f5245
000118  41445f46
00011c  494c4500
000120  4d525f46          DCB      "MR_FAILED_WRITE_FILE",0
000124  41494c45
000128  445f5752
00012c  4954455f
000130  46494c45
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
000138  4d525f46          DCB      "MR_FAILED_NO_ENCRYPT",0
00013c  41494c45
000140  445f4e4f
000144  5f454e43
000148  52595054
00014c  00      
00014d  00                DCB      0
00014e  00                DCB      0
00014f  00                DCB      0
000150  4d525f46          DCB      "MR_FAILED_STORE_ERR",0
000154  41494c45
000158  445f5354
00015c  4f52455f
000160  45525200
000164  4d525f46          DCB      "MR_FAILED_NO_IMG",0
000168  41494c45
00016c  445f4e4f
000170  5f494d47
000174  00      
000175  00                DCB      0
000176  00                DCB      0
000177  00                DCB      0
000178  4d525f46          DCB      "MR_FAILED_NO_IDX",0
00017c  41494c45
000180  445f4e4f
000184  5f494458
000188  00      
000189  00                DCB      0
00018a  00                DCB      0
00018b  00                DCB      0
00018c  4d525f46          DCB      "MR_FAILED_BUF_OVERFLOW",0
000190  41494c45
000194  445f4255
000198  465f4f56
00019c  4552464c
0001a0  4f5700  
0001a3  00                DCB      0
0001a4  4d525f46          DCB      "MR_FAILED_MASS_DATA_HEAD_EMPTY",0
0001a8  41494c45
0001ac  445f4d41
0001b0  53535f44
0001b4  4154415f
0001b8  48454144
0001bc  5f454d50
0001c0  545900  
0001c3  00                DCB      0
0001c4  4d525f46          DCB      "MR_FAILED_MASS_DATA_DB_ABNORMAL",0
0001c8  41494c45
0001cc  445f4d41
0001d0  53535f44
0001d4  4154415f
0001d8  44425f41
0001dc  424e4f52
0001e0  4d414c00
0001e4  4d525f46          DCB      "MR_FAILED_MASS_DATA_FM_ABNORMAL",0
0001e8  41494c45
0001ec  445f4d41
0001f0  53535f44
0001f4  4154415f
0001f8  464d5f41
0001fc  424e4f52
000200  4d414c00
000204  4d525f46          DCB      "MR_FAILED_NOT_READY",0
000208  41494c45
00020c  445f4e4f
000210  545f5245
000214  41445900
000218  4d525f46          DCB      "MR_FAILED_EXISTED_USER",0
00021c  41494c45
000220  445f4558
000224  49535445
000228  445f5553
00022c  455200  
00022f  00                DCB      0
000230  4d525f46          DCB      "MR_FAILED_IDX_OVERFLOW",0
000234  41494c45
000238  445f4944
00023c  585f4f56
000240  4552464c
000244  4f5700  
000247  00                DCB      0
000248  4d525f43          DCB      "MR_CONTIUNOUS",0
00024c  4f4e5449
000250  554e4f55
000254  5300    
000256  00                DCB      0
000257  00                DCB      0
000258  4d525f53          DCB      "MR_SUCCESS_BUT_DEL_USER",0
00025c  55434345
000260  53535f42
000264  55545f44
000268  454c5f55
00026c  53455200
000270  4d525f46          DCB      "MR_FAILED_INVALID_CMD",0
000274  41494c45
000278  445f494e
00027c  56414c49
000280  445f434d
000284  4400    
000286  00                DCB      0
000287  00                DCB      0
000288  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  nstat
000000  0000              DCB      0x00,0x00
                  ptr_rx_count
000002  0000              DCW      0x0000
                  nretry_acc
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  gu8OTA_Rx_buffer
                          DCD      0x61f82200
                  gu8OTA_Rx_buffer_index
                          DCD      0x00000000
                  gu8OTA_Tx_buffer_index
                          DCD      0x00000000
                  ota_tid
                          DCD      0x00000000
                  com_bus_tid
                          DCD      0x00000000

                          AREA ||area_number.24||, DATA, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.data||
                  gu8OTA_Tx_buffer
                          DCD      0x61f80e00

                          AREA ||i._str_uart_reply||, COMGROUP=_str_uart_reply, CODE, READONLY, ALIGN=2

                  _str_uart_reply PROC
;;;201    #pragma diag_suppress 111
;;;202    inline char *_str_uart_reply(enum uart_reply_result result)
000000  2814              CMP      r0,#0x14
;;;203    {
;;;204        switch (result)
000002  d04e              BEQ      |L114.162|
000004  dc0d              BGT      |L114.34|
000006  2814              CMP      r0,#0x14
000008  d22d              BCS      |L114.102|
00000a  e8dff000          TBB      [pc,r0]
00000e  2e30              DCB      0x2e,0x30
000010  322c3436          DCB      0x32,0x2c,0x34,0x36
000014  383a3c3e          DCB      0x38,0x3a,0x3c,0x3e
000018  402c4244          DCB      0x40,0x2c,0x42,0x44
00001c  462c2c2c          DCB      0x46,0x2c,0x2c,0x2c
000020  2c48              DCB      0x2c,0x48
                  |L114.34|
000022  2832              CMP      r0,#0x32
000024  d04d              BEQ      |L114.194|
000026  dc10              BGT      |L114.74|
000028  2818              CMP      r0,#0x18
00002a  d042              BEQ      |L114.178|
00002c  dc06              BGT      |L114.60|
00002e  2815              CMP      r0,#0x15
000030  d039              BEQ      |L114.166|
000032  2816              CMP      r0,#0x16
000034  d039              BEQ      |L114.170|
000036  2817              CMP      r0,#0x17
000038  d115              BNE      |L114.102|
00003a  e038              B        |L114.174|
                  |L114.60|
00003c  2819              CMP      r0,#0x19
00003e  d03a              BEQ      |L114.182|
000040  2830              CMP      r0,#0x30
000042  d03a              BEQ      |L114.186|
000044  2831              CMP      r0,#0x31
000046  d10e              BNE      |L114.102|
000048  e039              B        |L114.190|
                  |L114.74|
00004a  2836              CMP      r0,#0x36
00004c  d041              BEQ      |L114.210|
00004e  dc06              BGT      |L114.94|
000050  2833              CMP      r0,#0x33
000052  d038              BEQ      |L114.198|
000054  2834              CMP      r0,#0x34
000056  d038              BEQ      |L114.202|
000058  2835              CMP      r0,#0x35
00005a  d104              BNE      |L114.102|
00005c  e037              B        |L114.206|
                  |L114.94|
00005e  2840              CMP      r0,#0x40
000060  d039              BEQ      |L114.214|
000062  28ff              CMP      r0,#0xff
000064  d039              BEQ      |L114.218|
                  |L114.102|
;;;205        {
;;;206            CMD_REPLY_RESULT_MACRO(TO_STR)
;;;207        default:
;;;208            break;
;;;209        }
;;;210        
;;;211        return "";
000066  481e              LDR      r0,|L114.224|
;;;212    }
000068  4770              BX       lr
00006a  481e              LDR      r0,|L114.228|
00006c  4770              BX       lr
00006e  481e              LDR      r0,|L114.232|
000070  4770              BX       lr
000072  481e              LDR      r0,|L114.236|
000074  4770              BX       lr
000076  481e              LDR      r0,|L114.240|
000078  4770              BX       lr
00007a  481e              LDR      r0,|L114.244|
00007c  4770              BX       lr
00007e  481e              LDR      r0,|L114.248|
000080  4770              BX       lr
000082  481e              LDR      r0,|L114.252|
000084  4770              BX       lr
000086  481e              LDR      r0,|L114.256|
000088  4770              BX       lr
00008a  481e              LDR      r0,|L114.260|
00008c  4770              BX       lr
00008e  481e              LDR      r0,|L114.264|
000090  4770              BX       lr
000092  481e              LDR      r0,|L114.268|
000094  4770              BX       lr
000096  481e              LDR      r0,|L114.272|
000098  4770              BX       lr
00009a  481e              LDR      r0,|L114.276|
00009c  4770              BX       lr
00009e  481e              LDR      r0,|L114.280|
0000a0  4770              BX       lr
                  |L114.162|
0000a2  481e              LDR      r0,|L114.284|
0000a4  4770              BX       lr
                  |L114.166|
0000a6  481e              LDR      r0,|L114.288|
0000a8  4770              BX       lr
                  |L114.170|
0000aa  481e              LDR      r0,|L114.292|
0000ac  4770              BX       lr
                  |L114.174|
0000ae  481e              LDR      r0,|L114.296|
0000b0  4770              BX       lr
                  |L114.178|
0000b2  481e              LDR      r0,|L114.300|
0000b4  4770              BX       lr
                  |L114.182|
0000b6  481e              LDR      r0,|L114.304|
0000b8  4770              BX       lr
                  |L114.186|
0000ba  481e              LDR      r0,|L114.308|
0000bc  4770              BX       lr
                  |L114.190|
0000be  481e              LDR      r0,|L114.312|
0000c0  4770              BX       lr
                  |L114.194|
0000c2  481e              LDR      r0,|L114.316|
0000c4  4770              BX       lr
                  |L114.198|
0000c6  481e              LDR      r0,|L114.320|
0000c8  4770              BX       lr
                  |L114.202|
0000ca  481e              LDR      r0,|L114.324|
0000cc  4770              BX       lr
                  |L114.206|
0000ce  481e              LDR      r0,|L114.328|
0000d0  4770              BX       lr
                  |L114.210|
0000d2  481e              LDR      r0,|L114.332|
0000d4  4770              BX       lr
                  |L114.214|
0000d6  481e              LDR      r0,|L114.336|
0000d8  4770              BX       lr
                  |L114.218|
0000da  481e              LDR      r0,|L114.340|
0000dc  4770              BX       lr
;;;213    #pragma diag_warning 111
                          ENDP

0000de  0000              DCW      0x0000
                  |L114.224|
                          DCD      ||.conststring||+0x288
                  |L114.228|
                          DCD      ||.conststring||
                  |L114.232|
                          DCD      ||.conststring||+0xc
                  |L114.236|
                          DCD      ||.conststring||+0x18
                  |L114.240|
                          DCD      ||.conststring||+0x24
                  |L114.244|
                          DCD      ||.conststring||+0x3c
                  |L114.248|
                          DCD      ||.conststring||+0x58
                  |L114.252|
                          DCD      ||.conststring||+0x70
                  |L114.256|
                          DCD      ||.conststring||+0x80
                  |L114.260|
                          DCD      ||.conststring||+0x98
                  |L114.264|
                          DCD      ||.conststring||+0xac
                  |L114.268|
                          DCD      ||.conststring||+0xc4
                  |L114.272|
                          DCD      ||.conststring||+0xe0
                  |L114.276|
                          DCD      ||.conststring||+0xf4
                  |L114.280|
                          DCD      ||.conststring||+0x10c
                  |L114.284|
                          DCD      ||.conststring||+0x120
                  |L114.288|
                          DCD      ||.conststring||+0x138
                  |L114.292|
                          DCD      ||.conststring||+0x150
                  |L114.296|
                          DCD      ||.conststring||+0x164
                  |L114.300|
                          DCD      ||.conststring||+0x178
                  |L114.304|
                          DCD      ||.conststring||+0x18c
                  |L114.308|
                          DCD      ||.conststring||+0x1a4
                  |L114.312|
                          DCD      ||.conststring||+0x1c4
                  |L114.316|
                          DCD      ||.conststring||+0x1e4
                  |L114.320|
                          DCD      ||.conststring||+0x204
                  |L114.324|
                          DCD      ||.conststring||+0x218
                  |L114.328|
                          DCD      ||.conststring||+0x230
                  |L114.332|
                          DCD      ||.conststring||+0x248
                  |L114.336|
                          DCD      ||.conststring||+0x258
                  |L114.340|
                          DCD      ||.conststring||+0x270

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\scpu\\middleware\\ota\\ota.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_ota_c_091a15df____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___5_ota_c_091a15df____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_ota_c_091a15df____REVSH|
#line 223
|__asm___5_ota_c_091a15df____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_ota_c_091a15df____RRX|
#line 410
|__asm___5_ota_c_091a15df____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
