; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\kdp520_i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\kdp520_i2c.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\kdp520_i2c.crf ..\..\..\..\scpu\drivers\src\kdp520_i2c.c]
                          THUMB

                          AREA ||i._get_i2c_dev_drv||, CODE, READONLY, ALIGN=2

                  _get_i2c_dev_drv PROC
;;;722    
;;;723    static inline void _get_i2c_dev_drv(
000000  b130              CBZ      r0,|L1.16|
;;;724            enum i2c_adap_id id, struct core_device **lpdev, struct core_i2c_driver **lpdrv)
;;;725    {
;;;726        switch (id) {
000002  2801              CMP      r0,#1
000004  d103              BNE      |L1.14|
;;;727    #if CFG_I2C_0_ENABLE == YES        
;;;728        case I2C_ADAP_0:
;;;729            *lpdev = &kdp520_i2c_0;
;;;730            *lpdrv = &kdp520_i2c_0_driver;
;;;731            break;
;;;732    #endif
;;;733    #if CFG_I2C_1_ENABLE == YES    
;;;734        case I2C_ADAP_1:
;;;735            *lpdev = &kdp520_i2c_1;
000006  4805              LDR      r0,|L1.28|
;;;736            *lpdrv = &kdp520_i2c_1_driver;        
000008  6008              STR      r0,[r1,#0]
00000a  4805              LDR      r0,|L1.32|
                  |L1.12|
00000c  6010              STR      r0,[r2,#0]            ;730
                  |L1.14|
;;;737            break;
;;;738    #endif
;;;739    #if CFG_I2C_2_ENABLE == YES    
;;;740        case I2C_ADAP_2:
;;;741            *lpdev = &kdp520_i2c_2;
;;;742            *lpdrv = &kdp520_i2c_2_driver;        
;;;743            break;
;;;744    #endif
;;;745    #if CFG_I2C_3_ENABLE == YES    
;;;746        case I2C_ADAP_3:
;;;747            *lpdev = &kdp520_i2c_3;
;;;748            *lpdrv = &kdp520_i2c_3_driver;        
;;;749            break;
;;;750    #endif    
;;;751        default:;
;;;752        }    
;;;753    }
00000e  4770              BX       lr
                  |L1.16|
000010  4804              LDR      r0,|L1.36|
000012  6008              STR      r0,[r1,#0]            ;730
000014  4802              LDR      r0,|L1.32|
000016  3860              SUBS     r0,r0,#0x60           ;730
000018  e7f8              B        |L1.12|
;;;754    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      kdp520_i2c_1
                  |L1.32|
                          DCD      ||.data||+0x64
                  |L1.36|
                          DCD      kdp520_i2c_0

                          AREA ||i._i2c_transfer||, CODE, READONLY, ALIGN=1

                  _i2c_transfer PROC
;;;260    
;;;261    static int _i2c_transfer(struct kdp520_i2c_context *i2c_ctx, struct i2c_msg *msgs, int num)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;262    {
000004  4606              MOV      r6,r0
;;;263        int ret = -KDP_FRAMEWORK_ERRNO_IO;
;;;264        int try;
;;;265    
;;;266        mutex_lock(&i2c_ctx->lock);
000006  300c              ADDS     r0,r0,#0xc
000008  4617              MOV      r7,r2                 ;262
00000a  4688              MOV      r8,r1                 ;262
00000c  4681              MOV      r9,r0
00000e  f7fffffe          BL       mutex_lock
;;;267        
;;;268        for (ret = 0, try = 0; try <= i2c_ctx->retries; try++) {
000012  2400              MOVS     r4,#0
000014  4625              MOV      r5,r4
000016  e008              B        |L2.42|
                  |L2.24|
;;;269            ret = i2c_ctx->master_xfer(i2c_ctx, msgs, num);
000018  6933              LDR      r3,[r6,#0x10]
00001a  463a              MOV      r2,r7
00001c  4641              MOV      r1,r8
00001e  4630              MOV      r0,r6
000020  4798              BLX      r3
000022  4604              MOV      r4,r0
;;;270            if (ret != -KDP_FRAMEWORK_ERRNO_AGAIN)
000024  1d00              ADDS     r0,r0,#4
000026  d103              BNE      |L2.48|
000028  1c6d              ADDS     r5,r5,#1
                  |L2.42|
00002a  6870              LDR      r0,[r6,#4]            ;268
00002c  42a8              CMP      r0,r5                 ;268
00002e  daf3              BGE      |L2.24|
                  |L2.48|
000030  4648              MOV      r0,r9                 ;268
;;;271                break;
;;;272        }
;;;273        
;;;274        mutex_unlock(&i2c_ctx->lock);
000032  f7fffffe          BL       mutex_unlock
;;;275        
;;;276        return ret;
000036  4620              MOV      r0,r4
;;;277    }
000038  e8bd87f0          POP      {r4-r10,pc}
;;;278    
                          ENDP


                          AREA ||i._kdp520_i2c_getgsr||, CODE, READONLY, ALIGN=1

                  _kdp520_i2c_getgsr PROC
;;;84     
;;;85     u32 _kdp520_i2c_getgsr(struct kdp520_i2c_context *i2c_ctx)
000000  6800              LDR      r0,[r0,#0]
;;;86     {
;;;87         u32 tmp;
;;;88     
;;;89         tmp = inw(((u8*)i2c_ctx->base + I2C_REG_TGSR));
000002  6940              LDR      r0,[r0,#0x14]
;;;90     
;;;91         return ((tmp >> 10) & 0x7);
000004  f3c02082          UBFX     r0,r0,#10,#3
;;;92     }
000008  4770              BX       lr
;;;93     
                          ENDP


                          AREA ||i._kdp520_i2c_init||, CODE, READONLY, ALIGN=2

                  _kdp520_i2c_init PROC
;;;416    
;;;417    static int _kdp520_i2c_init(struct core_device *core_d)
000000  b500              PUSH     {lr}
;;;418    {
;;;419        int i2c_id = core_d->uuid;
000002  6880              LDR      r0,[r0,#8]
;;;420        struct kdp520_i2c_context *ctx = &i2c_ctx_s[i2c_id];
000004  490d              LDR      r1,|L4.60|
000006  eb000080          ADD      r0,r0,r0,LSL #2
00000a  eb010180          ADD      r1,r1,r0,LSL #2
;;;421    
;;;422        u32 bus_speed = 0;
;;;423    
;;;424        outw(((u8*)ctx->base + I2C_REG_TGSR), (I2C_GSR_Value << 10) | I2C_TSR_Value);
00000e  f2414005          MOV      r0,#0x1405
000012  680a              LDR      r2,[r1,#0]
000014  6150              STR      r0,[r2,#0x14]
000016  688a              LDR      r2,[r1,#8]            ;418
000018  b172              CBZ      r2,|L4.56|
;;;425    
;;;426        bus_speed = ctx->params.bus_speed;
;;;427        if (bus_speed > 0) {
;;;428            u32 bits = ((APB_CLOCK - (bus_speed * _kdp520_i2c_getgsr(ctx))) / ( 2 * bus_speed)) - 2;
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       _kdp520_i2c_getgsr
000020  4b07              LDR      r3,|L4.64|
000022  fb023010          MLS      r0,r2,r0,r3
000026  0052              LSLS     r2,r2,#1
000028  fbb0f0f2          UDIV     r0,r0,r2
00002c  1e80              SUBS     r0,r0,#2
;;;429            if (bits < BIT10) 
00002e  f5b06f80          CMP      r0,#0x400
000032  d201              BCS      |L4.56|
;;;430                outw(((u8*)ctx->base + I2C_REG_CLOCKDIV), bits);
000034  6809              LDR      r1,[r1,#0]
000036  6088              STR      r0,[r1,#8]
                  |L4.56|
;;;431            else {
;;;432                dbg_msg(" APB_CLOCK=%d, i_SCLout=%d",APB_CLOCK, bus_speed);
;;;433                dbg_msg("Pclk is to fast to form i2c clock, fail ");
;;;434            }
;;;435        }
;;;436    
;;;437    #if I2C_INTERRUPT_ENABLE
;;;438        ctx->evt_isr_id = osEventFlagsNew(NULL);
;;;439    
;;;440        //register IRQ
;;;441        switch (ctx->irq)
;;;442        {
;;;443    #if CFG_I2C_0_ENABLE == YES
;;;444            case IIC_FTIIC010_0_IRQ:
;;;445                NVIC_SetVector((IRQn_Type)IIC_FTIIC010_0_IRQ, (uint32_t)i2c0_isr);
;;;446                break;
;;;447    #endif
;;;448    #if CFG_I2C_1_ENABLE == YES
;;;449            case IIC_FTIIC010_1_IRQ:
;;;450                NVIC_SetVector((IRQn_Type)IIC_FTIIC010_1_IRQ, (uint32_t)i2c1_isr);
;;;451                break;
;;;452    #endif
;;;453    #if CFG_I2C_2_ENABLE == YES
;;;454            case IIC_FTIIC010_2_IRQ:
;;;455                NVIC_SetVector((IRQn_Type)IIC_FTIIC010_2_IRQ, (uint32_t)i2c2_isr);
;;;456                break;
;;;457    #endif
;;;458    #if CFG_I2C_3_ENABLE == YES
;;;459            case IIC_FTIIC010_3_IRQ:
;;;460                NVIC_SetVector((IRQn_Type)IIC_FTIIC010_3_IRQ, (uint32_t)i2c3_isr);
;;;461                break;
;;;462    #endif
;;;463            default:
;;;464                break;
;;;465        }
;;;466        
;;;467        //enable IRQ
;;;468        if (osKernelRunning == osKernelGetState())
;;;469        {
;;;470            NVIC_EnableIRQ((IRQn_Type)(ctx->irq));
;;;471        }
;;;472        else
;;;473        {
;;;474            NVIC_DisableIRQ((IRQn_Type)(ctx->irq));
;;;475        }
;;;476    #endif
;;;477    
;;;478        return 0;
000038  2000              MOVS     r0,#0
;;;479    }
00003a  bd00              POP      {pc}
;;;480    
                          ENDP

                  |L4.60|
                          DCD      ||.bss||
                  |L4.64|
                          DCD      0x05f5e100

                          AREA ||i._kdp520_i2c_power||, CODE, READONLY, ALIGN=2

                  _kdp520_i2c_power PROC
;;;372    
;;;373    static int _kdp520_i2c_power(struct core_device *core_d, BOOL onoff)
000000  b510              PUSH     {r4,lr}
;;;374    {
;;;375        int i2c_id = core_d->uuid;
000002  6880              LDR      r0,[r0,#8]
;;;376        struct kdp520_i2c_context *i2c_ctx = &i2c_ctx_s[i2c_id];
000004  4a1c              LDR      r2,|L5.120|
000006  eb000080          ADD      r0,r0,r0,LSL #2
;;;377    
;;;378        switch (i2c_ctx->base) {
00000a  f8522020          LDR      r2,[r2,r0,LSL #2]
;;;379            case IIC_FTIIC010_0_PA_BASE:
;;;380                masked_outw(SCU_REG_APBCLKG, 
00000e  481b              LDR      r0,|L5.124|
000010  f1b24f41          CMP      r2,#0xc1000000        ;378
000014  d009              BEQ      |L5.42|
000016  4b1a              LDR      r3,|L5.128|
000018  18d2              ADDS     r2,r2,r3              ;378
00001a  d00e              BEQ      |L5.58|
00001c  f5b21f80          CMP      r2,#0x100000          ;378
000020  d01a              BEQ      |L5.88|
000022  f5b21f00          CMP      r2,#0x200000          ;378
000026  d111              BNE      |L5.76|
000028  e01e              B        |L5.104|
                  |L5.42|
00002a  6e02              LDR      r2,[r0,#0x60]
00002c  f0220204          BIC      r2,r2,#4
000030  b101              CBZ      r1,|L5.52|
000032  2104              MOVS     r1,#4
                  |L5.52|
000034  f0010104          AND      r1,r1,#4
;;;381                            ((onoff) ? (SCU_REG_APBCLKG_PCLK_EN_I2C0_PCLK) : (0)), 
;;;382                            SCU_REG_APBCLKG_PCLK_EN_I2C0_PCLK);
;;;383                break;
000038  e006              B        |L5.72|
                  |L5.58|
;;;384            case IIC_FTIIC010_1_PA_BASE:
;;;385                masked_outw(SCU_REG_APBCLKG, 
00003a  6e02              LDR      r2,[r0,#0x60]
00003c  f0220208          BIC      r2,r2,#8
000040  b101              CBZ      r1,|L5.68|
000042  2108              MOVS     r1,#8
                  |L5.68|
000044  f0010108          AND      r1,r1,#8
                  |L5.72|
000048  430a              ORRS     r2,r2,r1              ;380
00004a  6602              STR      r2,[r0,#0x60]         ;380
                  |L5.76|
;;;386                            ((onoff) ? (SCU_REG_APBCLKG_PCLK_EN_I2C1_PCLK) : (0)), 
;;;387                            SCU_REG_APBCLKG_PCLK_EN_I2C1_PCLK);
;;;388                break;
;;;389            case IIC_FTIIC010_2_PA_BASE:
;;;390                masked_outw(SCU_REG_APBCLKG, 
;;;391                            ((onoff) ? (SCU_REG_APBCLKG_PCLK_EN_I2C2_PCLK) : (0)), 
;;;392                            SCU_REG_APBCLKG_PCLK_EN_I2C2_PCLK);
;;;393                break;
;;;394            case IIC_FTIIC010_3_PA_BASE:
;;;395                masked_outw(SCU_REG_APBCLKG, 
;;;396                            ((onoff) ? (SCU_REG_APBCLKG_PCLK_EN_I2C3_PCLK) : (0)), 
;;;397                            SCU_REG_APBCLKG_PCLK_EN_I2C3_PCLK);
;;;398                break;
;;;399            default:;
;;;400            
;;;401        }
;;;402        delay_us(500);
00004c  f44f70fa          MOV      r0,#0x1f4
000050  f7fffffe          BL       delay_us
;;;403    
;;;404        return 0;
000054  2000              MOVS     r0,#0
;;;405    }
000056  bd10              POP      {r4,pc}
                  |L5.88|
000058  6e02              LDR      r2,[r0,#0x60]         ;390
00005a  f0220210          BIC      r2,r2,#0x10           ;390
00005e  b101              CBZ      r1,|L5.98|
000060  2110              MOVS     r1,#0x10              ;390
                  |L5.98|
000062  f0010110          AND      r1,r1,#0x10           ;390
000066  e7ef              B        |L5.72|
                  |L5.104|
000068  6e02              LDR      r2,[r0,#0x60]         ;395
00006a  f0220220          BIC      r2,r2,#0x20           ;395
00006e  b101              CBZ      r1,|L5.114|
000070  2120              MOVS     r1,#0x20              ;395
                  |L5.114|
000072  f0010120          AND      r1,r1,#0x20           ;395
000076  e7e7              B        |L5.72|
;;;406    
                          ENDP

                  |L5.120|
                          DCD      ||.bss||
                  |L5.124|
                          DCD      0xc2300000
                  |L5.128|
                          DCD      0x3ef00000

                          AREA ||i._kdp520_i2c_probe||, CODE, READONLY, ALIGN=2

                  _kdp520_i2c_probe PROC
;;;325    
;;;326    static int _kdp520_i2c_probe(struct core_device *core_d)
000000  b570              PUSH     {r4-r6,lr}
;;;327    {
;;;328        struct kdp520_i2c_context *i2c_ctx;
;;;329    
;;;330        int i2c_id = core_d->uuid;
;;;331        if (i2c_id >= I2C_ADAP_MAX) {
000002  6885              LDR      r5,[r0,#8]
000004  2d04              CMP      r5,#4
000006  db08              BLT      |L6.26|
;;;332            err_msg("%s: err: i2c_id %d out of range\n", __func__, i2c_id);
000008  462b              MOV      r3,r5
00000a  4a16              LDR      r2,|L6.100|
00000c  a116              ADR      r1,|L6.104|
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       kdp_level_printf
;;;333            return -1;
000014  f04f30ff          MOV      r0,#0xffffffff
;;;334        }
;;;335    
;;;336        i2c_ctx = &i2c_ctx_s[i2c_id];
;;;337        
;;;338        if(mutex_i2c == NULL)
;;;339            mutex_i2c = osMutexNew(NULL);
;;;340        
;;;341        switch (i2c_id) {
;;;342        case I2C_ADAP_3:
;;;343            i2c_ctx->base = IIC_FTIIC010_3_PA_BASE;
;;;344            break;
;;;345        case I2C_ADAP_2:
;;;346            i2c_ctx->base = IIC_FTIIC010_2_PA_BASE;
;;;347            break;
;;;348        case I2C_ADAP_1:
;;;349            i2c_ctx->base = IIC_FTIIC010_1_PA_BASE;
;;;350            break;
;;;351        case I2C_ADAP_0:
;;;352        default:
;;;353            i2c_ctx->base = IIC_FTIIC010_0_PA_BASE;
;;;354            break;
;;;355        }
;;;356    #if I2C_INTERRUPT_ENABLE
;;;357            i2c_ctx->irq = IIC_FTIIC010_0_IRQ + i2c_id;
;;;358    #endif
;;;359    
;;;360        i2c_ctx->retries = 5;
;;;361        i2c_ctx->master_xfer = _kdp520_i2c_xfer;
;;;362    
;;;363        mutex_create(&i2c_ctx->lock);
;;;364    
;;;365        return 0;
;;;366    }
000018  bd70              POP      {r4-r6,pc}
                  |L6.26|
00001a  491c              LDR      r1,|L6.140|
00001c  4e1c              LDR      r6,|L6.144|
00001e  eb050085          ADD      r0,r5,r5,LSL #2       ;336
000022  eb010480          ADD      r4,r1,r0,LSL #2       ;336
000026  6830              LDR      r0,[r6,#0]            ;338  ; mutex_i2c
000028  b918              CBNZ     r0,|L6.50|
00002a  2000              MOVS     r0,#0                 ;339
00002c  f7fffffe          BL       osMutexNew
000030  6030              STR      r0,[r6,#0]            ;339  ; mutex_i2c
                  |L6.50|
000032  2d01              CMP      r5,#1                 ;341
000034  d014              BEQ      |L6.96|
000036  2d02              CMP      r5,#2                 ;341
000038  d006              BEQ      |L6.72|
00003a  2d03              CMP      r5,#3                 ;341
00003c  d002              BEQ      |L6.68|
00003e  f04f4041          MOV      r0,#0xc1000000        ;353
000042  e002              B        |L6.74|
                  |L6.68|
000044  4813              LDR      r0,|L6.148|
000046  e000              B        |L6.74|
                  |L6.72|
000048  4813              LDR      r0,|L6.152|
                  |L6.74|
00004a  6020              STR      r0,[r4,#0]            ;360
00004c  2005              MOVS     r0,#5                 ;360
00004e  6060              STR      r0,[r4,#4]            ;361
000050  4812              LDR      r0,|L6.156|
000052  6120              STR      r0,[r4,#0x10]         ;363
000054  f104000c          ADD      r0,r4,#0xc            ;363
000058  f7fffffe          BL       mutex_create
00005c  2000              MOVS     r0,#0                 ;365
00005e  bd70              POP      {r4-r6,pc}
                  |L6.96|
000060  480f              LDR      r0,|L6.160|
000062  e7f2              B        |L6.74|
;;;367    
                          ENDP

                  |L6.100|
                          DCD      ||.constdata||
                  |L6.104|
000068  25733a20          DCB      "%s: err: i2c_id %d out of range\n",0
00006c  6572723a
000070  20693263
000074  5f696420
000078  2564206f
00007c  7574206f
000080  66207261
000084  6e67650a
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L6.140|
                          DCD      ||.bss||
                  |L6.144|
                          DCD      ||.data||
                  |L6.148|
                          DCD      0xc1300000
                  |L6.152|
                          DCD      0xc1200000
                  |L6.156|
                          DCD      _kdp520_i2c_xfer
                  |L6.160|
                          DCD      0xc1100000

                          AREA ||i._kdp520_i2c_read||, CODE, READONLY, ALIGN=2

                  _kdp520_i2c_read PROC
;;;536    
;;;537    static int _kdp520_i2c_read(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;538            struct core_device *core_d, u8 slave_addr, u16 reg, u16 reg_len, u8 *data)
;;;539    {
000004  460e              MOV      r6,r1
;;;540    	int ret;
;;;541        int i2c_id = core_d->uuid;
000006  6880              LDR      r0,[r0,#8]
;;;542        struct kdp520_i2c_context *ctx = &i2c_ctx_s[i2c_id];
000008  491b              LDR      r1,|L7.120|
00000a  eb000080          ADD      r0,r0,r0,LSL #2
;;;543    
;;;544        u8 paddr[2];
;;;545        
;;;546        osMutexAcquire(mutex_i2c, osWaitForever);
00000e  4f1b              LDR      r7,|L7.124|
000010  b085              SUB      sp,sp,#0x14           ;539
000012  eb010880          ADD      r8,r1,r0,LSL #2       ;542
000016  461c              MOV      r4,r3                 ;539
000018  4615              MOV      r5,r2                 ;539
00001a  f8dd9030          LDR      r9,[sp,#0x30]         ;541
00001e  f04f31ff          MOV      r1,#0xffffffff
000022  6838              LDR      r0,[r7,#0]  ; mutex_i2c
000024  f7fffffe          BL       osMutexAcquire
;;;547        
;;;548        if (2 == reg_len) {
;;;549            paddr[0] = ((reg >> 8) & 0xff);
;;;550            paddr[1] = reg & 0XFF;
000028  b2e8              UXTB     r0,r5
00002a  2c02              CMP      r4,#2                 ;548
00002c  d01d              BEQ      |L7.106|
;;;551        }
;;;552        else {
;;;553            paddr[0] = (reg & 0XFF);
00002e  f88d0010          STRB     r0,[sp,#0x10]
                  |L7.50|
;;;554        }
;;;555    
;;;556    	struct i2c_msg msgs[] = {
000032  4913              LDR      r1,|L7.128|
;;;557    		{
;;;558    			.addr = slave_addr,
;;;559    			.flags = I2C_MASTER_WRITE,
;;;560    			.len = reg_len,
;;;561    			.buf = paddr,
;;;562    		},
;;;563    		{
;;;564    			.addr = slave_addr,
;;;565    			.flags = I2C_MASTER_READ,
;;;566    			.len = 1,
;;;567    			.buf = data,
;;;568    		},
;;;569    	};
;;;570    
;;;571    	ret = _i2c_transfer(ctx, msgs, 2);
000034  2202              MOVS     r2,#2
000036  6948              LDR      r0,[r1,#0x14]         ;556  ; <Data9>
000038  69c9              LDR      r1,[r1,#0x1c]         ;556  ; <Data9>
00003a  9000              STR      r0,[sp,#0]            ;556
00003c  9102              STR      r1,[sp,#8]            ;556
00003e  a804              ADD      r0,sp,#0x10           ;556
000040  f8ad6000          STRH     r6,[sp,#0]            ;556
000044  9001              STR      r0,[sp,#4]            ;556
000046  f88d4003          STRB     r4,[sp,#3]            ;556
00004a  f8ad6008          STRH     r6,[sp,#8]            ;556
00004e  4669              MOV      r1,sp
000050  4640              MOV      r0,r8
000052  f8cd900c          STR      r9,[sp,#0xc]
000056  f7fffffe          BL       _i2c_transfer
00005a  4604              MOV      r4,r0
;;;572    
;;;573        osMutexRelease(mutex_i2c);
00005c  6838              LDR      r0,[r7,#0]  ; mutex_i2c
00005e  f7fffffe          BL       osMutexRelease
;;;574            
;;;575    	return ret;
;;;576    }
000062  b005              ADD      sp,sp,#0x14
000064  4620              MOV      r0,r4                 ;575
000066  e8bd83f0          POP      {r4-r9,pc}
                  |L7.106|
00006a  0a29              LSRS     r1,r5,#8              ;549
00006c  f88d1010          STRB     r1,[sp,#0x10]         ;549
000070  f88d0011          STRB     r0,[sp,#0x11]         ;550
000074  e7dd              B        |L7.50|
;;;577    static int _kdp520_i2c_read_bytes(
                          ENDP

000076  0000              DCW      0x0000
                  |L7.120|
                          DCD      ||.bss||
                  |L7.124|
                          DCD      ||.data||
                  |L7.128|
                          DCD      ||.constdata||

                          AREA ||i._kdp520_i2c_read_bytes||, CODE, READONLY, ALIGN=2

                  _kdp520_i2c_read_bytes PROC
;;;576    }
;;;577    static int _kdp520_i2c_read_bytes(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;578            struct core_device *core_d, u8 slave_addr, u16 reg, u16 reg_len, u8 *data, u8 data_len)
;;;579    {
000004  460e              MOV      r6,r1
;;;580    	int ret;
;;;581        int i2c_id = core_d->uuid;
000006  6880              LDR      r0,[r0,#8]
000008  b086              SUB      sp,sp,#0x18           ;579
;;;582        struct kdp520_i2c_context *ctx = &i2c_ctx_s[i2c_id];
00000a  491c              LDR      r1,|L8.124|
00000c  eb000080          ADD      r0,r0,r0,LSL #2
;;;583    
;;;584        u8 paddr[2];
;;;585        
;;;586        osMutexAcquire(mutex_i2c, osWaitForever);
000010  4f1b              LDR      r7,|L8.128|
000012  e9dda90e          LDRD     r10,r9,[sp,#0x38]     ;579
000016  eb010880          ADD      r8,r1,r0,LSL #2       ;582
00001a  461c              MOV      r4,r3                 ;579
00001c  4615              MOV      r5,r2                 ;579
00001e  f04f31ff          MOV      r1,#0xffffffff
000022  6838              LDR      r0,[r7,#0]  ; mutex_i2c
000024  f7fffffe          BL       osMutexAcquire
;;;587        
;;;588        if (2 == reg_len) {
;;;589            paddr[0] = ((reg >> 8) & 0xff);
;;;590            paddr[1] = reg & 0XFF;
000028  b2e8              UXTB     r0,r5
00002a  2c02              CMP      r4,#2                 ;588
00002c  d01f              BEQ      |L8.110|
;;;591        }
;;;592        else {
;;;593            paddr[0] = (reg & 0XFF);
00002e  f88d0010          STRB     r0,[sp,#0x10]
                  |L8.50|
;;;594        }
;;;595    
;;;596    	struct i2c_msg msgs[] = {
000032  4914              LDR      r1,|L8.132|
;;;597    		{
;;;598    			.addr = slave_addr,
;;;599    			.flags = I2C_MASTER_WRITE,
;;;600    			.len = reg_len,
;;;601    			.buf = paddr,
;;;602    		},
;;;603    		{
;;;604    			.addr = slave_addr,
;;;605    			.flags = I2C_MASTER_READ,
;;;606    			.len = data_len,
;;;607    			.buf = data,
;;;608    		},
;;;609    	};
;;;610    
;;;611    	ret = _i2c_transfer(ctx, msgs, 2);
000034  2202              MOVS     r2,#2
000036  6a48              LDR      r0,[r1,#0x24]         ;596  ; <Data10>
000038  6ac9              LDR      r1,[r1,#0x2c]         ;596  ; <Data10>
00003a  9000              STR      r0,[sp,#0]            ;596
00003c  9102              STR      r1,[sp,#8]            ;596
00003e  a804              ADD      r0,sp,#0x10           ;596
000040  f8ad6000          STRH     r6,[sp,#0]            ;596
000044  9001              STR      r0,[sp,#4]            ;596
000046  f8ad6008          STRH     r6,[sp,#8]            ;596
00004a  f88d4003          STRB     r4,[sp,#3]            ;596
00004e  f88d900b          STRB     r9,[sp,#0xb]          ;596
000052  4669              MOV      r1,sp
000054  4640              MOV      r0,r8
000056  f8cda00c          STR      r10,[sp,#0xc]
00005a  f7fffffe          BL       _i2c_transfer
00005e  4604              MOV      r4,r0
;;;612    
;;;613        osMutexRelease(mutex_i2c);
000060  6838              LDR      r0,[r7,#0]  ; mutex_i2c
000062  f7fffffe          BL       osMutexRelease
;;;614        
;;;615    	return ret;
;;;616    }
000066  b006              ADD      sp,sp,#0x18
000068  4620              MOV      r0,r4                 ;615
00006a  e8bd87f0          POP      {r4-r10,pc}
                  |L8.110|
00006e  0a29              LSRS     r1,r5,#8              ;589
000070  f88d1010          STRB     r1,[sp,#0x10]         ;589
000074  f88d0011          STRB     r0,[sp,#0x11]         ;590
000078  e7db              B        |L8.50|
;;;617    
                          ENDP

00007a  0000              DCW      0x0000
                  |L8.124|
                          DCD      ||.bss||
                  |L8.128|
                          DCD      ||.data||
                  |L8.132|
                          DCD      ||.constdata||

                          AREA ||i._kdp520_i2c_remove||, CODE, READONLY, ALIGN=1

                  _kdp520_i2c_remove PROC
;;;367    
;;;368    static int _kdp520_i2c_remove(struct core_device *core_d)
000000  2000              MOVS     r0,#0
;;;369    {
;;;370        return 0;
;;;371    }
000002  4770              BX       lr
;;;372    
                          ENDP


                          AREA ||i._kdp520_i2c_reset||, CODE, READONLY, ALIGN=2

                  _kdp520_i2c_reset PROC
;;;480    
;;;481    static int _kdp520_i2c_reset(struct core_device *core_d)
000000  6880              LDR      r0,[r0,#8]
;;;482    {
;;;483        int i2c_id = core_d->uuid;
;;;484        struct kdp520_i2c_context *ctx = &i2c_ctx_s[i2c_id];
000002  490a              LDR      r1,|L10.44|
000004  eb000080          ADD      r0,r0,r0,LSL #2
000008  eb010180          ADD      r1,r1,r0,LSL #2
;;;485    
;;;486        u32 ts;
;;;487        outw((u8*)ctx->base + I2C_REG_CONTROL, 1);
00000c  2001              MOVS     r0,#1
00000e  680a              LDR      r2,[r1,#0]
000010  6010              STR      r0,[r2,#0]
000012  6809              LDR      r1,[r1,#0]
;;;488        for (ts = 0; ts < 50000; ts++) {
000014  2000              MOVS     r0,#0
000016  f24c3250          MOV      r2,#0xc350
                  |L10.26|
;;;489            if (!(inw(((u8*)ctx->base + I2C_REG_CONTROL)) & 0x1)) {
00001a  680b              LDR      r3,[r1,#0]
00001c  07db              LSLS     r3,r3,#31
00001e  d002              BEQ      |L10.38|
000020  1c40              ADDS     r0,r0,#1
000022  4290              CMP      r0,r2                 ;488
000024  d3f9              BCC      |L10.26|
                  |L10.38|
;;;490                break;
;;;491            }
;;;492        }
;;;493        
;;;494        //dbg_msg("_kdp520_i2c_reset ts = %u", ts);
;;;495    
;;;496        return 0;    
000026  2000              MOVS     r0,#0
;;;497    }
000028  4770              BX       lr
;;;498    
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      ||.bss||

                          AREA ||i._kdp520_i2c_set_params||, CODE, READONLY, ALIGN=2

                  _kdp520_i2c_set_params PROC
;;;406    
;;;407    static int _kdp520_i2c_set_params(struct core_device *core_d, struct kdp520_i2c_params *params)
000000  6880              LDR      r0,[r0,#8]
;;;408    {
;;;409        int i2c_id = core_d->uuid;
;;;410        struct kdp520_i2c_context *ctx = &i2c_ctx_s[i2c_id];
000002  4a04              LDR      r2,|L11.20|
000004  eb000080          ADD      r0,r0,r0,LSL #2
000008  eb020080          ADD      r0,r2,r0,LSL #2
;;;411    
;;;412        memcpy((void*)(&ctx->params), params, sizeof(ctx->params));
00000c  6809              LDR      r1,[r1,#0]
;;;413        
;;;414        return 0;
00000e  6081              STR      r1,[r0,#8]
000010  2000              MOVS     r0,#0
;;;415    }
000012  4770              BX       lr
;;;416    
                          ENDP

                  |L11.20|
                          DCD      ||.bss||

                          AREA ||i._kdp520_i2c_write||, CODE, READONLY, ALIGN=2

                  _kdp520_i2c_write PROC
;;;498    
;;;499    static int _kdp520_i2c_write(
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;500            struct core_device *core_d, u8 slave_addr, u16 reg, u16 reg_len, u8 data)
;;;501    {
000004  4689              MOV      r9,r1
;;;502        int ret;
;;;503        int i2c_id = core_d->uuid;
000006  6880              LDR      r0,[r0,#8]
;;;504        struct kdp520_i2c_context *ctx = &i2c_ctx_s[i2c_id];
000008  4918              LDR      r1,|L12.108|
00000a  eb000080          ADD      r0,r0,r0,LSL #2
;;;505    
;;;506        u8 paddr[3];
;;;507        
;;;508        osMutexAcquire(mutex_i2c, osWaitForever);
00000e  4f18              LDR      r7,|L12.112|
000010  eb010880          ADD      r8,r1,r0,LSL #2       ;504
000014  461c              MOV      r4,r3                 ;501
000016  4615              MOV      r5,r2                 ;501
000018  9e0a              LDR      r6,[sp,#0x28]         ;503
00001a  f04f31ff          MOV      r1,#0xffffffff
00001e  6838              LDR      r0,[r7,#0]  ; mutex_i2c
000020  f7fffffe          BL       osMutexAcquire
;;;509        
;;;510        
;;;511        if (2 == reg_len) {
;;;512            paddr[0] = ((reg >> 8) & 0xff);
;;;513            paddr[1] = reg & 0XFF;
000024  b2e8              UXTB     r0,r5
000026  2c02              CMP      r4,#2                 ;511
000028  d018              BEQ      |L12.92|
;;;514            paddr[2] = data;
;;;515        }
;;;516        else {
;;;517            paddr[0] = (reg & 0XFF);
00002a  f88d0000          STRB     r0,[sp,#0]
;;;518            paddr[1] = data;        
00002e  f88d6001          STRB     r6,[sp,#1]
                  |L12.50|
;;;519        }
;;;520        
;;;521        struct i2c_msg msgs[] = {
000032  2000              MOVS     r0,#0
000034  9001              STR      r0,[sp,#4]
000036  f8ad9004          STRH     r9,[sp,#4]
00003a  1c64              ADDS     r4,r4,#1
00003c  f88d4007          STRB     r4,[sp,#7]
000040  f8cdd008          STR      sp,[sp,#8]
;;;522            {
;;;523                .addr = slave_addr,
;;;524                .flags = I2C_MASTER_WRITE,
;;;525                .len = reg_len + 1,
;;;526                .buf = paddr,
;;;527            }
;;;528        };
;;;529        
;;;530        ret = _i2c_transfer(ctx, msgs, 1);
000044  2201              MOVS     r2,#1
000046  a901              ADD      r1,sp,#4
000048  4640              MOV      r0,r8
00004a  f7fffffe          BL       _i2c_transfer
00004e  4604              MOV      r4,r0
;;;531        
;;;532        osMutexRelease(mutex_i2c);
000050  6838              LDR      r0,[r7,#0]  ; mutex_i2c
000052  f7fffffe          BL       osMutexRelease
;;;533        
;;;534        return ret;
000056  4620              MOV      r0,r4
;;;535    }
000058  e8bd83fe          POP      {r1-r9,pc}
                  |L12.92|
00005c  0a29              LSRS     r1,r5,#8              ;512
00005e  f88d1000          STRB     r1,[sp,#0]            ;512
000062  f88d0001          STRB     r0,[sp,#1]            ;513
000066  f88d6002          STRB     r6,[sp,#2]            ;514
00006a  e7e2              B        |L12.50|
;;;536    
                          ENDP

                  |L12.108|
                          DCD      ||.bss||
                  |L12.112|
                          DCD      ||.data||

                          AREA ||i._kdp520_i2c_xfer||, CODE, READONLY, ALIGN=1

                  _kdp520_i2c_xfer PROC
;;;231    
;;;232    static int _kdp520_i2c_xfer(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;233            struct kdp520_i2c_context *i2c_ctx, struct i2c_msg *msgs, int num)
;;;234    {
;;;235        int ret = 0;
000004  2700              MOVS     r7,#0
000006  4615              MOV      r5,r2                 ;234
000008  468a              MOV      r10,r1                ;234
00000a  4681              MOV      r9,r0                 ;234
;;;236        int i;
;;;237        u32 cnt = 0;
00000c  463e              MOV      r6,r7
;;;238        //enable i2c clock
;;;239        
;;;240        for (i = 0; i < num; ++i) {
00000e  463c              MOV      r4,r7
;;;241            ret = _kdp520_i2c_xfer_msg(i2c_ctx, &msgs[i], (i == (num - 1)));
000010  f1a20801          SUB      r8,r2,#1
000014  e00c              B        |L13.48|
                  |L13.22|
000016  4544              CMP      r4,r8
000018  d101              BNE      |L13.30|
00001a  2201              MOVS     r2,#1
00001c  e000              B        |L13.32|
                  |L13.30|
00001e  2200              MOVS     r2,#0
                  |L13.32|
000020  eb0a01c4          ADD      r1,r10,r4,LSL #3
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       _kdp520_i2c_xfer_msg
00002a  0007              MOVS     r7,r0
;;;242            if (0 != ret)
00002c  d104              BNE      |L13.56|
00002e  1c64              ADDS     r4,r4,#1
                  |L13.48|
000030  42ac              CMP      r4,r5                 ;240
000032  dbf0              BLT      |L13.22|
000034  e000              B        |L13.56|
                  |L13.54|
000036  1c76              ADDS     r6,r6,#1              ;240
                  |L13.56|
000038  f8d90000          LDR      r0,[r9,#0]            ;240
00003c  6840              LDR      r0,[r0,#4]            ;240
00003e  0740              LSLS     r0,r0,#29             ;240
000040  d504              BPL      |L13.76|
;;;243                break;
;;;244        }
;;;245    
;;;246        while (_kdp_i2c_check_busy(i2c_ctx->base)){
;;;247            delay_us(1);
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       delay_us
;;;248            if (I2C_WAIT_INT_TIMEOUT_CNT < cnt)
000048  2e1f              CMP      r6,#0x1f
00004a  d9f4              BLS      |L13.54|
                  |L13.76|
;;;249            {
;;;250                dbg_msg("_kdp_i2c_check_busy time out :%d", cnt);
;;;251                break;
;;;252            }
;;;253            cnt++;
;;;254        }
;;;255    
;;;256        //disable i2c clock
;;;257    
;;;258        return ret;
00004c  4638              MOV      r0,r7
;;;259    }
00004e  e8bd87f0          POP      {r4-r10,pc}
;;;260    
                          ENDP


                          AREA ||i._kdp520_i2c_xfer_msg||, CODE, READONLY, ALIGN=1

                  _kdp520_i2c_xfer_msg PROC
;;;159    
;;;160    static int _kdp520_i2c_xfer_msg(
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;161            struct kdp520_i2c_context *i2c_ctx, struct i2c_msg *msg, BOOL is_stop)
;;;162    {
;;;163        int ret, i;
;;;164    
;;;165        u32 base = i2c_ctx->base;    
;;;166        u16 slave_addr = msg->addr;    
;;;167        u16 flags = msg->flags;
000004  6804              LDR      r4,[r0,#0]
000006  7888              LDRB     r0,[r1,#2]
;;;168        u16 len = msg->len;
000008  78ce              LDRB     r6,[r1,#3]
;;;169        u8 *buf = msg->buf;
;;;170        
;;;171        BOOL is_read = (flags & I2C_MASTER_READ);
00000a  f0100701          ANDS     r7,r0,#1
00000e  7808              LDRB     r0,[r1,#0]            ;166
000010  f8d19004          LDR      r9,[r1,#4]
;;;172    
;;;173        //dbg_msg("kdp520_i2c_xfer_msg base=%x slave_addr=%x len=%d is_stop=%d", base, slave_addr, len, is_stop);
;;;174        if (is_read)
;;;175            outw(base + I2C_REG_DATA, I2C_RD(slave_addr));
000014  ea4f6040          LSL      r0,r0,#25
000018  4693              MOV      r11,r2                ;162
00001a  ea4f6010          LSR      r0,r0,#24
00001e  d000              BEQ      |L14.34|
000020  1c40              ADDS     r0,r0,#1              ;162
                  |L14.34|
;;;176        else
;;;177            outw(base + I2C_REG_DATA, I2C_WR(slave_addr));
000022  60e0              STR      r0,[r4,#0xc]
;;;178    
;;;179    #if I2C_INTERRUPT_ENABLE
;;;180        if (osKernelRunning == osKernelGetState())
;;;181        {
;;;182            outw(base + I2C_REG_CONTROL, I2C_CTRL_ENABLE | I2C_CTRL_DRIRQ | I2C_CTRL_TBEN | I2C_CTRL_START);
;;;183        }
;;;184        else
;;;185        {
;;;186            outw(base + I2C_REG_CONTROL, I2C_CTRL_ENABLE | I2C_CTRL_TBEN | I2C_CTRL_START);
;;;187        }
;;;188        
;;;189        ret = _kdp_i2c_wait(i2c_ctx, I2C_STATUS_TD);
;;;190    #else
;;;191        outw(base + I2C_REG_CONTROL, I2C_CTRL_ENABLE | I2C_CTRL_TBEN | I2C_CTRL_START);
000024  2096              MOVS     r0,#0x96
000026  6020              STR      r0,[r4,#0]
;;;192        ret = _kdp_i2c_wait(base, I2C_STATUS_TD);
000028  2120              MOVS     r1,#0x20
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       _kdp_i2c_wait
;;;193    #endif
;;;194        if (0 == ret)
000030  2800              CMP      r0,#0
000032  d124              BNE      |L14.126|
;;;195        {
;;;196    #if I2C_INTERRUPT_ENABLE
;;;197            u32 ctrl = I2C_CTRL_ENABLE | I2C_CTRL_DRIRQ | I2C_CTRL_TBEN;
;;;198    #else
;;;199            u32 ctrl = I2C_CTRL_ENABLE | I2C_CTRL_TBEN;
000034  f04f0886          MOV      r8,#0x86
;;;200    #endif
;;;201            for (i = 0; i < len; ++i) {
000038  2500              MOVS     r5,#0
;;;202                if ((is_stop) && (i == len - 1)) {
00003a  f1a60a01          SUB      r10,r6,#1
00003e  e01c              B        |L14.122|
                  |L14.64|
000040  f1bb0f00          CMP      r11,#0
000044  d008              BEQ      |L14.88|
000046  4555              CMP      r5,r10
000048  d106              BNE      |L14.88|
;;;203                    if (is_read)
00004a  b117              CBZ      r7,|L14.82|
;;;204                        ctrl |= I2C_CTRL_NAK | I2C_CTRL_STOP;
00004c  f0480860          ORR      r8,r8,#0x60
000050  e006              B        |L14.96|
                  |L14.82|
;;;205                    else
;;;206                        ctrl |= I2C_CTRL_STOP;
000052  f0480820          ORR      r8,r8,#0x20
000056  e000              B        |L14.90|
                  |L14.88|
;;;207                }
;;;208                    
;;;209                if (!is_read)
000058  b917              CBNZ     r7,|L14.96|
                  |L14.90|
;;;210                    outw(base + I2C_REG_DATA, buf[i]);
00005a  f8190005          LDRB     r0,[r9,r5]
00005e  60e0              STR      r0,[r4,#0xc]
                  |L14.96|
;;;211                
;;;212                outw(base + I2C_REG_CONTROL, ctrl);
000060  f8c48000          STR      r8,[r4,#0]
;;;213                
;;;214    #if I2C_INTERRUPT_ENABLE
;;;215                ret = _kdp_i2c_wait(i2c_ctx, I2C_STATUS_TD);
;;;216    #else
;;;217                ret = _kdp_i2c_wait(base, I2C_STATUS_TD);
000064  2120              MOVS     r1,#0x20
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       _kdp_i2c_wait
;;;218    #endif
;;;219                if (ret)
00006c  2800              CMP      r0,#0
00006e  d106              BNE      |L14.126|
;;;220                    break;
;;;221                
;;;222                if (is_read)
000070  b117              CBZ      r7,|L14.120|
;;;223                    buf[i] = (u8)(inw(base + I2C_REG_DATA) & 0xFF);
000072  68e1              LDR      r1,[r4,#0xc]
000074  f8091005          STRB     r1,[r9,r5]
                  |L14.120|
000078  1c6d              ADDS     r5,r5,#1
                  |L14.122|
00007a  42b5              CMP      r5,r6                 ;201
00007c  dbe0              BLT      |L14.64|
                  |L14.126|
;;;224            }
;;;225        }
;;;226    
;;;227        //kdp520_i2c_reset(i2c_ctx);
;;;228    
;;;229        return ret;
;;;230    }
00007e  e8bd9ff0          POP      {r4-r12,pc}
;;;231    
                          ENDP


                          AREA ||i._kdp_i2c_wait||, CODE, READONLY, ALIGN=1

                  _kdp_i2c_wait PROC
;;;140    #else
;;;141    static int _kdp_i2c_wait(int base, uint32_t mask)
000000  b530              PUSH     {r4,r5,lr}
;;;142    {
;;;143        int ret = -KDP_FRAMEWORK_ERRNO_IO;
000002  f04f33ff          MOV      r3,#0xffffffff
;;;144        uint32_t stat, ts;
;;;145    
;;;146        //for (ts = 0; ts < 55000; ts++) {
;;;147        for (ts = 0; ts < 1000; ts++) { // normally ts ~=200
000006  2200              MOVS     r2,#0
000008  f44f757a          MOV      r5,#0x3e8
                  |L15.12|
;;;148            stat = inw(base + I2C_REG_STATUS);
00000c  6844              LDR      r4,[r0,#4]
;;;149            outw(base + I2C_REG_STATUS, stat);
00000e  6044              STR      r4,[r0,#4]
;;;150            if ((stat & mask) == mask) {
000010  ea310404          BICS     r4,r1,r4
000014  d004              BEQ      |L15.32|
000016  1c52              ADDS     r2,r2,#1
000018  42aa              CMP      r2,r5                 ;147
00001a  d3f7              BCC      |L15.12|
                  |L15.28|
;;;151                ret = 0;//it means ok
;;;152                break;
;;;153            }
;;;154        }
;;;155    
;;;156        return ret;
00001c  4618              MOV      r0,r3
;;;157    }
00001e  bd30              POP      {r4,r5,pc}
                  |L15.32|
000020  2300              MOVS     r3,#0                 ;151
000022  e7fb              B        |L15.28|
;;;158    #endif
                          ENDP


                          AREA ||i.kdp_drv_i2c_init||, CODE, READONLY, ALIGN=1

                  kdp_drv_i2c_init PROC
;;;754    
;;;755    int kdp_drv_i2c_init(enum i2c_adap_id id, unsigned long bus_speed, BOOL force)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;756    {
;;;757        int ret = -1;
;;;758        struct core_device *dev = NULL;
000004  2400              MOVS     r4,#0
000006  4616              MOV      r6,r2                 ;756
000008  460f              MOV      r7,r1                 ;756
00000a  f04f35ff          MOV      r5,#0xffffffff        ;757
;;;759        struct core_i2c_driver *drv = NULL;
00000e  9400              STR      r4,[sp,#0]
;;;760        _get_i2c_dev_drv(id, &dev, &drv);
000010  aa01              ADD      r2,sp,#4
000012  4669              MOV      r1,sp
000014  9401              STR      r4,[sp,#4]
000016  f7fffffe          BL       _get_i2c_dev_drv
;;;761    
;;;762        if (dev && drv)
00001a  9a00              LDR      r2,[sp,#0]
00001c  b362              CBZ      r2,|L16.120|
00001e  9801              LDR      r0,[sp,#4]
000020  b350              CBZ      r0,|L16.120|
;;;763        {        
;;;764            if ((drv->inited) && (force)) {
000022  f8901058          LDRB     r1,[r0,#0x58]
000026  b159              CBZ      r1,|L16.64|
000028  b1be              CBZ      r6,|L16.90|
;;;765                drv->power_mgr.power(dev, FALSE);
00002a  6b03              LDR      r3,[r0,#0x30]
00002c  2100              MOVS     r1,#0
00002e  4610              MOV      r0,r2
000030  4798              BLX      r3
;;;766                drv->remove(dev);
000032  9801              LDR      r0,[sp,#4]
000034  6841              LDR      r1,[r0,#4]
000036  9800              LDR      r0,[sp,#0]
000038  4788              BLX      r1
;;;767                drv->inited = FALSE;
00003a  9801              LDR      r0,[sp,#4]
00003c  f8804058          STRB     r4,[r0,#0x58]
                  |L16.64|
;;;768            }
;;;769            
;;;770            if (!(drv->inited)) {
;;;771                drv->probe(dev);
000040  9801              LDR      r0,[sp,#4]
000042  6801              LDR      r1,[r0,#0]
000044  9800              LDR      r0,[sp,#0]
000046  4788              BLX      r1
;;;772                drv->power_mgr.power(dev, TRUE);
000048  9801              LDR      r0,[sp,#4]
00004a  2101              MOVS     r1,#1
00004c  6b02              LDR      r2,[r0,#0x30]
00004e  9800              LDR      r0,[sp,#0]
000050  4790              BLX      r2
;;;773                drv->inited = TRUE;
000052  9901              LDR      r1,[sp,#4]
000054  2001              MOVS     r0,#1
000056  f8810058          STRB     r0,[r1,#0x58]
                  |L16.90|
;;;774            }
;;;775            {
;;;776                struct kdp520_i2c_params params;
;;;777                params.bus_speed = bus_speed;
;;;778                drv->set_params(dev, &params);
00005a  9801              LDR      r0,[sp,#4]
00005c  9702              STR      r7,[sp,#8]
00005e  a902              ADD      r1,sp,#8
000060  6c02              LDR      r2,[r0,#0x40]
000062  9800              LDR      r0,[sp,#0]
000064  4790              BLX      r2
;;;779                drv->init(dev);
000066  9801              LDR      r0,[sp,#4]
000068  6c41              LDR      r1,[r0,#0x44]
00006a  9800              LDR      r0,[sp,#0]
00006c  4788              BLX      r1
;;;780                drv->reset(dev); 
00006e  9801              LDR      r0,[sp,#4]
000070  6c81              LDR      r1,[r0,#0x48]
000072  9800              LDR      r0,[sp,#0]
000074  4788              BLX      r1
;;;781            }
;;;782            
;;;783            ret = 0;
000076  2500              MOVS     r5,#0
                  |L16.120|
;;;784        }
;;;785        
;;;786        return ret;
;;;787    }
000078  b004              ADD      sp,sp,#0x10
00007a  4628              MOV      r0,r5                 ;786
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;788    
                          ENDP


                          AREA ||i.kdp_drv_i2c_read||, CODE, READONLY, ALIGN=1

                  kdp_drv_i2c_read PROC
;;;801    
;;;802    int kdp_drv_i2c_read(enum i2c_adap_id id, u8 subaddr, u16 reg, u8 reg_len, u8 *lpdata)
000000  b5fe              PUSH     {r1-r7,lr}
;;;803    {
000002  460f              MOV      r7,r1
;;;804        int ret = -1;
;;;805        
;;;806        struct core_device *dev = NULL;
000004  2100              MOVS     r1,#0
000006  4616              MOV      r6,r2                 ;803
;;;807        struct core_i2c_driver *drv = NULL;
000008  9101              STR      r1,[sp,#4]
;;;808        _get_i2c_dev_drv(id, &dev, &drv);
00000a  9102              STR      r1,[sp,#8]
00000c  461d              MOV      r5,r3                 ;803
00000e  9c08              LDR      r4,[sp,#0x20]         ;806
000010  aa02              ADD      r2,sp,#8
000012  a901              ADD      r1,sp,#4
000014  f7fffffe          BL       _get_i2c_dev_drv
;;;809        
;;;810        ret = drv->read(dev, subaddr, reg, reg_len, lpdata);    
000018  9802              LDR      r0,[sp,#8]
00001a  9400              STR      r4,[sp,#0]
00001c  462b              MOV      r3,r5
00001e  6d04              LDR      r4,[r0,#0x50]
000020  4632              MOV      r2,r6
000022  4639              MOV      r1,r7
000024  9801              LDR      r0,[sp,#4]
000026  47a0              BLX      r4
;;;811        
;;;812        return ret;
;;;813    }
000028  bdfe              POP      {r1-r7,pc}
;;;814    
                          ENDP


                          AREA ||i.kdp_drv_i2c_read_bytes||, CODE, READONLY, ALIGN=1

                  kdp_drv_i2c_read_bytes PROC
;;;814    
;;;815    int kdp_drv_i2c_read_bytes(enum i2c_adap_id id, u8 subaddr, u16 reg, u8 reg_len, u8 *lpdata, u8 data_len)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;816    {
000004  4688              MOV      r8,r1
;;;817        int ret = -1;
;;;818        
;;;819        struct core_device *dev = NULL;
000006  2100              MOVS     r1,#0
000008  e9dd470a          LDRD     r4,r7,[sp,#0x28]      ;816
00000c  4616              MOV      r6,r2                 ;816
;;;820        struct core_i2c_driver *drv = NULL;
00000e  9102              STR      r1,[sp,#8]
;;;821        _get_i2c_dev_drv(id, &dev, &drv);
000010  9103              STR      r1,[sp,#0xc]
000012  461d              MOV      r5,r3                 ;816
000014  aa03              ADD      r2,sp,#0xc
000016  a902              ADD      r1,sp,#8
000018  f7fffffe          BL       _get_i2c_dev_drv
00001c  e9cd4700          STRD     r4,r7,[sp,#0]
;;;822        
;;;823        ret = drv->readbytes(dev, subaddr, reg, reg_len, lpdata, data_len);    
000020  9803              LDR      r0,[sp,#0xc]
000022  462b              MOV      r3,r5
000024  4632              MOV      r2,r6
000026  6d44              LDR      r4,[r0,#0x54]
000028  4641              MOV      r1,r8
00002a  9802              LDR      r0,[sp,#8]
00002c  47a0              BLX      r4
;;;824        
;;;825        return ret;
;;;826    }
00002e  b004              ADD      sp,sp,#0x10
000030  e8bd81f0          POP      {r4-r8,pc}
;;;827    
                          ENDP


                          AREA ||i.kdp_drv_i2c_write||, CODE, READONLY, ALIGN=1

                  kdp_drv_i2c_write PROC
;;;788    
;;;789    int kdp_drv_i2c_write(enum i2c_adap_id id, u8 subaddr, u16 reg, u8 reg_len, u8 data)
000000  b5fe              PUSH     {r1-r7,lr}
;;;790    {
000002  460f              MOV      r7,r1
;;;791        int ret = -1;
;;;792        
;;;793        struct core_device *dev = NULL;
000004  2100              MOVS     r1,#0
000006  4616              MOV      r6,r2                 ;790
;;;794        struct core_i2c_driver *drv = NULL;
000008  9101              STR      r1,[sp,#4]
;;;795        _get_i2c_dev_drv(id, &dev, &drv);
00000a  9102              STR      r1,[sp,#8]
00000c  461d              MOV      r5,r3                 ;790
00000e  9c08              LDR      r4,[sp,#0x20]         ;793
000010  aa02              ADD      r2,sp,#8
000012  a901              ADD      r1,sp,#4
000014  f7fffffe          BL       _get_i2c_dev_drv
;;;796        
;;;797        ret = drv->write(dev, subaddr, reg, reg_len, data);    
000018  9802              LDR      r0,[sp,#8]
00001a  9400              STR      r4,[sp,#0]
00001c  462b              MOV      r3,r5
00001e  6cc4              LDR      r4,[r0,#0x4c]
000020  4632              MOV      r2,r6
000022  4639              MOV      r1,r7
000024  9801              LDR      r0,[sp,#4]
000026  47a0              BLX      r4
;;;798        
;;;799        return ret;
;;;800    }
000028  bdfe              POP      {r1-r7,pc}
;;;801    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  i2c_ctx_s
                          %        80

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  __func__
000000  5f6b6470          DCB      0x5f,0x6b,0x64,0x70
000004  3532305f          DCB      0x35,0x32,0x30,0x5f
000008  6932635f          DCB      0x69,0x32,0x63,0x5f
00000c  70726f62          DCB      0x70,0x72,0x6f,0x62
000010  65000000          DCB      0x65,0x00,0x00,0x00
000014  0000              DCW      0x0000
000016  0000              DCB      0x00,0x00
                          DCD      0x00000000
00001c  0000              DCW      0x0000
00001e  0101              DCB      0x01,0x01
                          DCD      0x00000000
000024  0000              DCW      0x0000
000026  0000              DCB      0x00,0x00
                          DCD      0x00000000
00002c  0000              DCW      0x0000
00002e  0100              DCB      0x01,0x00
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  mutex_i2c
                          DCD      0x00000000
                  kdp520_i2c_0_driver
                          DCD      _kdp520_i2c_probe
                          DCD      _kdp520_i2c_remove
                          DCD      kdp520_i2c_0
000010  6b647035          DCB      0x6b,0x64,0x70,0x35
000014  32305f69          DCB      0x32,0x30,0x5f,0x69
000018  32635f30          DCB      0x32,0x63,0x5f,0x30
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          %        8
                          DCD      _kdp520_i2c_power
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      _kdp520_i2c_set_params
                          DCD      _kdp520_i2c_init
                          DCD      _kdp520_i2c_reset
                          DCD      _kdp520_i2c_write
                          DCD      _kdp520_i2c_read
                          DCD      _kdp520_i2c_read_bytes
00005c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0000c350
                  kdp520_i2c_1_driver
                          DCD      _kdp520_i2c_probe
                          DCD      _kdp520_i2c_remove
                          DCD      kdp520_i2c_1
000070  6b647035          DCB      0x6b,0x64,0x70,0x35
000074  32305f69          DCB      0x32,0x30,0x5f,0x69
000078  32635f31          DCB      0x32,0x63,0x5f,0x31
00007c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          %        8
                          DCD      _kdp520_i2c_power
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      _kdp520_i2c_set_params
                          DCD      _kdp520_i2c_init
                          DCD      _kdp520_i2c_reset
                          DCD      _kdp520_i2c_write
                          DCD      _kdp520_i2c_read
                          DCD      _kdp520_i2c_read_bytes
0000bc  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0000c350

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\scpu\\drivers\\src\\kdp520_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp520_i2c_c_cb8aa7be____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___12_kdp520_i2c_c_cb8aa7be____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp520_i2c_c_cb8aa7be____REVSH|
#line 223
|__asm___12_kdp520_i2c_c_cb8aa7be____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp520_i2c_c_cb8aa7be____RRX|
#line 410
|__asm___12_kdp520_i2c_c_cb8aa7be____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
