; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\kdp_crc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\kdp_crc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\kdp_crc.crf ..\..\..\..\scpu\drivers\system\kdp_crc.c]
                          THUMB

                          AREA ||i.SHA1Input||, CODE, READONLY, ALIGN=1

                  SHA1Input PROC
;;;168     */
;;;169    int SHA1Input(    SHA1Context    *context,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;170                      const uint8_t  *message_array,
;;;171                      unsigned       length)
;;;172    {
000004  0015              MOVS     r5,r2
000006  460e              MOV      r6,r1
000008  4604              MOV      r4,r0
00000a  d014              BEQ      |L1.54|
;;;173        if (!length)
;;;174        {
;;;175            return shaSuccess;
;;;176        }
;;;177    
;;;178        if (!context || !message_array)
00000c  b134              CBZ      r4,|L1.28|
00000e  b12e              CBZ      r6,|L1.28|
;;;179        {
;;;180            return shaNull;
;;;181        }
;;;182    
;;;183        if (context->Computed)
000010  6e20              LDR      r0,[r4,#0x60]
000012  b128              CBZ      r0,|L1.32|
;;;184        {
;;;185            context->Corrupted = shaStateError;
000014  2003              MOVS     r0,#3
;;;186    
;;;187            return shaStateError;
000016  6660              STR      r0,[r4,#0x64]
                  |L1.24|
;;;188        }
;;;189    
;;;190        if (context->Corrupted)
;;;191        {
;;;192             return context->Corrupted;
;;;193        }
;;;194        while(length-- && !context->Corrupted)
;;;195        {
;;;196        context->Message_Block[context->Message_Block_Index++] =
;;;197                        (*message_array & 0xFF);
;;;198    
;;;199        context->Length_Low += 8;
;;;200        if (context->Length_Low == 0)
;;;201        {
;;;202            context->Length_High++;
;;;203            if (context->Length_High == 0)
;;;204            {
;;;205                /* Message is too long */
;;;206                context->Corrupted = 1;
;;;207            }
;;;208        }
;;;209    
;;;210        if (context->Message_Block_Index == 64)
;;;211        {
;;;212            SHA1ProcessMessageBlock(context);
;;;213        }
;;;214    
;;;215        message_array++;
;;;216        }
;;;217    
;;;218        return shaSuccess;
;;;219    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L1.28|
00001c  2001              MOVS     r0,#1                 ;180
00001e  e7fb              B        |L1.24|
                  |L1.32|
000020  6e60              LDR      r0,[r4,#0x64]         ;190
000022  2800              CMP      r0,#0                 ;190
000024  d1f8              BNE      |L1.24|
000026  f104071e          ADD      r7,r4,#0x1e           ;196
00002a  f04f0801          MOV      r8,#1                 ;180
                  |L1.46|
00002e  1e6d              SUBS     r5,r5,#1              ;180
000030  d301              BCC      |L1.54|
000032  6e60              LDR      r0,[r4,#0x64]         ;194
000034  b108              CBZ      r0,|L1.58|
                  |L1.54|
000036  2000              MOVS     r0,#0                 ;218
000038  e7ee              B        |L1.24|
                  |L1.58|
00003a  f9b4001c          LDRSH    r0,[r4,#0x1c]         ;196
00003e  7832              LDRB     r2,[r6,#0]            ;196
000040  1c41              ADDS     r1,r0,#1              ;196
000042  83a1              STRH     r1,[r4,#0x1c]         ;196
000044  55c2              STRB     r2,[r0,r7]            ;196
000046  6960              LDR      r0,[r4,#0x14]         ;199
000048  3008              ADDS     r0,r0,#8              ;199
00004a  6160              STR      r0,[r4,#0x14]         ;200
00004c  d105              BNE      |L1.90|
00004e  69a0              LDR      r0,[r4,#0x18]         ;202
000050  1c40              ADDS     r0,r0,#1              ;202
000052  61a0              STR      r0,[r4,#0x18]         ;203
000054  d101              BNE      |L1.90|
000056  f8c48064          STR      r8,[r4,#0x64]         ;206
                  |L1.90|
00005a  8ba0              LDRH     r0,[r4,#0x1c]         ;210
00005c  2840              CMP      r0,#0x40              ;210
00005e  d102              BNE      |L1.102|
000060  4620              MOV      r0,r4                 ;212
000062  f7fffffe          BL       SHA1ProcessMessageBlock
                  |L1.102|
000066  1c76              ADDS     r6,r6,#1              ;212
000068  e7e1              B        |L1.46|
;;;220    
                          ENDP


                          AREA ||i.SHA1PadMessage||, CODE, READONLY, ALIGN=1

                  SHA1PadMessage PROC
;;;352    
;;;353    void SHA1PadMessage(SHA1Context *context)
000000  b570              PUSH     {r4-r6,lr}
;;;354    {
000002  4604              MOV      r4,r0
;;;355        /*
;;;356         *  Check to see if the current message block is too small to hold
;;;357         *  the initial padding bits and length.  If so, we will pad the
;;;358         *  block, process it, and then continue padding into a second
;;;359         *  block.
;;;360         */
;;;361        if (context->Message_Block_Index > 55)
000004  f9b0001c          LDRSH    r0,[r0,#0x1c]
;;;362        {
;;;363            context->Message_Block[context->Message_Block_Index++] = 0x80;
000008  2380              MOVS     r3,#0x80
00000a  1c41              ADDS     r1,r0,#1
00000c  b20a              SXTH     r2,r1
00000e  f104051e          ADD      r5,r4,#0x1e
000012  2600              MOVS     r6,#0
;;;364            while(context->Message_Block_Index < 64)
;;;365            {
;;;366                context->Message_Block[context->Message_Block_Index++] = 0;
;;;367            }
;;;368    
;;;369            SHA1ProcessMessageBlock(context);
;;;370    
;;;371            while(context->Message_Block_Index < 56)
;;;372            {
;;;373                context->Message_Block[context->Message_Block_Index++] = 0;
;;;374            }
;;;375        }
;;;376        else
;;;377        {
;;;378            context->Message_Block[context->Message_Block_Index++] = 0x80;
000014  83a2              STRH     r2,[r4,#0x1c]
000016  2837              CMP      r0,#0x37              ;361
000018  5543              STRB     r3,[r0,r5]
00001a  dc03              BGT      |L2.36|
00001c  e015              B        |L2.74|
                  |L2.30|
00001e  1c41              ADDS     r1,r0,#1              ;366
000020  83a1              STRH     r1,[r4,#0x1c]         ;366
000022  5546              STRB     r6,[r0,r5]            ;366
                  |L2.36|
000024  f9b4001c          LDRSH    r0,[r4,#0x1c]         ;364
000028  2840              CMP      r0,#0x40              ;364
00002a  dbf8              BLT      |L2.30|
00002c  4620              MOV      r0,r4                 ;369
00002e  f7fffffe          BL       SHA1ProcessMessageBlock
000032  e002              B        |L2.58|
                  |L2.52|
000034  1c41              ADDS     r1,r0,#1              ;373
000036  83a1              STRH     r1,[r4,#0x1c]         ;373
000038  5546              STRB     r6,[r0,r5]            ;373
                  |L2.58|
00003a  f9b4001c          LDRSH    r0,[r4,#0x1c]         ;371
00003e  2838              CMP      r0,#0x38              ;371
000040  dbf8              BLT      |L2.52|
000042  e006              B        |L2.82|
                  |L2.68|
;;;379            while(context->Message_Block_Index < 56)
;;;380            {
;;;381    
;;;382                context->Message_Block[context->Message_Block_Index++] = 0;
000044  1c41              ADDS     r1,r0,#1
000046  83a1              STRH     r1,[r4,#0x1c]
000048  5546              STRB     r6,[r0,r5]
                  |L2.74|
00004a  f9b4001c          LDRSH    r0,[r4,#0x1c]         ;379
00004e  2838              CMP      r0,#0x38              ;379
000050  dbf8              BLT      |L2.68|
                  |L2.82|
;;;383            }
;;;384        }
;;;385    
;;;386        /*
;;;387         *  Store the message length as the last 8 octets
;;;388         */
;;;389        context->Message_Block[56] = context->Length_High >> 24;
000052  69a0              LDR      r0,[r4,#0x18]
000054  0e01              LSRS     r1,r0,#24
000056  f8841056          STRB     r1,[r4,#0x56]
;;;390        context->Message_Block[57] = context->Length_High >> 16;
00005a  0c01              LSRS     r1,r0,#16
00005c  f8841057          STRB     r1,[r4,#0x57]
;;;391        context->Message_Block[58] = context->Length_High >> 8;
000060  0a01              LSRS     r1,r0,#8
000062  f8841058          STRB     r1,[r4,#0x58]
;;;392        context->Message_Block[59] = context->Length_High;
000066  f8840059          STRB     r0,[r4,#0x59]
;;;393        context->Message_Block[60] = context->Length_Low >> 24;
00006a  6960              LDR      r0,[r4,#0x14]
00006c  0e01              LSRS     r1,r0,#24
00006e  f884105a          STRB     r1,[r4,#0x5a]
;;;394        context->Message_Block[61] = context->Length_Low >> 16;
000072  0c01              LSRS     r1,r0,#16
000074  f884105b          STRB     r1,[r4,#0x5b]
;;;395        context->Message_Block[62] = context->Length_Low >> 8;
000078  0a01              LSRS     r1,r0,#8
00007a  f884105c          STRB     r1,[r4,#0x5c]
;;;396        context->Message_Block[63] = context->Length_Low;
00007e  f884005d          STRB     r0,[r4,#0x5d]
;;;397    
;;;398        SHA1ProcessMessageBlock(context);
000082  4620              MOV      r0,r4
000084  e8bd4070          POP      {r4-r6,lr}
000088  f7ffbffe          B.W      SHA1ProcessMessageBlock
;;;399    }
;;;400    
                          ENDP


                          AREA ||i.SHA1ProcessMessageBlock||, CODE, READONLY, ALIGN=2

                  SHA1ProcessMessageBlock PROC
;;;241     */
;;;242    void SHA1ProcessMessageBlock(SHA1Context *context)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;243    {
;;;244        const uint32_t K[] =    {       /* Constants defined in SHA-1   */
000004  4c5b              LDR      r4,|L3.372|
000006  b0d6              SUB      sp,sp,#0x158          ;243
;;;245                                0x5A827999,
;;;246                                0x6ED9EBA1,
;;;247                                0x8F1BBCDC,
;;;248                                0xCA62C1D6
;;;249                                };
;;;250        int           t;                 /* Loop counter                */
;;;251        uint32_t      temp;              /* Temporary word value        */
;;;252        uint32_t      W[80];             /* Word sequence               */
000008  466e              MOV      r6,sp
00000a  cc1e              LDM      r4,{r1-r4}            ;244
00000c  468a              MOV      r10,r1                ;244
00000e  4693              MOV      r11,r2                ;244
000010  469e              MOV      lr,r3                 ;244
;;;253        uint32_t      A, B, C, D, E;     /* Word buffers                */
;;;254    
;;;255        /*
;;;256         *  Initialize the first 16 words in the array W
;;;257         */
;;;258        for(t = 0; t < 16; t++)
000012  2100              MOVS     r1,#0
000014  f8cd4154          STR.W    r4,[sp,#0x154]        ;252
                  |L3.24|
;;;259        {
;;;260            W[t] = context->Message_Block[t * 4] << 24;
000018  eb000281          ADD      r2,r0,r1,LSL #2
00001c  f8123f1e          LDRB     r3,[r2,#0x1e]!
000020  061b              LSLS     r3,r3,#24
000022  f8463021          STR      r3,[r6,r1,LSL #2]
;;;261            W[t] |= context->Message_Block[t * 4 + 1] << 16;
000026  7854              LDRB     r4,[r2,#1]
000028  ea434304          ORR      r3,r3,r4,LSL #16
00002c  f8463021          STR      r3,[r6,r1,LSL #2]
;;;262            W[t] |= context->Message_Block[t * 4 + 2] << 8;
000030  7894              LDRB     r4,[r2,#2]
000032  ea432304          ORR      r3,r3,r4,LSL #8
000036  f8463021          STR      r3,[r6,r1,LSL #2]
;;;263            W[t] |= context->Message_Block[t * 4 + 3];
00003a  78d2              LDRB     r2,[r2,#3]
00003c  4313              ORRS     r3,r3,r2
00003e  f8463021          STR      r3,[r6,r1,LSL #2]
000042  1c49              ADDS     r1,r1,#1
000044  2910              CMP      r1,#0x10              ;258
000046  dbe7              BLT      |L3.24|
;;;264        }
;;;265    
;;;266        for(t = 16; t < 80; t++)
000048  f05f0110          MOVS.W   r1,#0x10
                  |L3.76|
;;;267        {
;;;268           W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
00004c  eb060281          ADD      r2,r6,r1,LSL #2
000050  f8523c0c          LDR      r3,[r2,#-0xc]
000054  f8524c20          LDR      r4,[r2,#-0x20]
000058  4063              EORS     r3,r3,r4
00005a  f8524c38          LDR      r4,[r2,#-0x38]
00005e  f8522c40          LDR      r2,[r2,#-0x40]
000062  4054              EORS     r4,r4,r2
000064  4063              EORS     r3,r3,r4
000066  ea4f72f3          ROR      r2,r3,#31
00006a  f8462021          STR      r2,[r6,r1,LSL #2]
00006e  1c49              ADDS     r1,r1,#1
000070  2950              CMP      r1,#0x50              ;266
000072  dbeb              BLT      |L3.76|
;;;269        }
;;;270    
;;;271        A = context->Intermediate_Hash[0];
000074  6802              LDR      r2,[r0,#0]
;;;272        B = context->Intermediate_Hash[1];
000076  9254              STR      r2,[sp,#0x150]
000078  6843              LDR      r3,[r0,#4]
;;;273        C = context->Intermediate_Hash[2];
00007a  9353              STR      r3,[sp,#0x14c]
00007c  6884              LDR      r4,[r0,#8]
;;;274        D = context->Intermediate_Hash[3];
00007e  9452              STR      r4,[sp,#0x148]
000080  68c1              LDR      r1,[r0,#0xc]
;;;275        E = context->Intermediate_Hash[4];
000082  9151              STR      r1,[sp,#0x144]
000084  6905              LDR      r5,[r0,#0x10]
;;;276    
;;;277        for(t = 0; t < 20; t++)
000086  2700              MOVS     r7,#0
000088  46b1              MOV      r9,r6                 ;252
00008a  9550              STR      r5,[sp,#0x140]        ;252
                  |L3.140|
;;;278        {
;;;279            temp =  SHA1CircularShift(5,A) +
00008c  f8596027          LDR      r6,[r9,r7,LSL #2]
000090  ea210803          BIC      r8,r1,r3
000094  eb066cf2          ADD      r12,r6,r2,ROR #27
000098  ea030604          AND      r6,r3,r4
00009c  ea460608          ORR      r6,r6,r8
0000a0  4435              ADD      r5,r5,r6
0000a2  eb0c0605          ADD      r6,r12,r5
;;;280                    ((B & C) | ((~B) & D)) + E + W[t] + K[0];
;;;281            E = D;
0000a6  460d              MOV      r5,r1
;;;282            D = C;
0000a8  4621              MOV      r1,r4
;;;283            C = SHA1CircularShift(30,B);
0000aa  ea4f04b3          ROR      r4,r3,#2
0000ae  4456              ADD      r6,r6,r10             ;279
;;;284    
;;;285            B = A;
0000b0  4613              MOV      r3,r2
;;;286            A = temp;
0000b2  1c7f              ADDS     r7,r7,#1
0000b4  4632              MOV      r2,r6
0000b6  2f14              CMP      r7,#0x14              ;277
0000b8  dbe8              BLT      |L3.140|
;;;287        }
;;;288    
;;;289        for(t = 20; t < 40; t++)
0000ba  2614              MOVS     r6,#0x14
0000bc  ea4f0709          MOV.W    r7,r9                 ;252
                  |L3.192|
;;;290        {
;;;291            temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];
0000c0  ea830804          EOR      r8,r3,r4
0000c4  f857c026          LDR      r12,[r7,r6,LSL #2]
0000c8  ea880801          EOR      r8,r8,r1
0000cc  eb0c6cf2          ADD      r12,r12,r2,ROR #27
0000d0  4445              ADD      r5,r5,r8
0000d2  44ac              ADD      r12,r12,r5
;;;292            E = D;
0000d4  460d              MOV      r5,r1
;;;293            D = C;
0000d6  4621              MOV      r1,r4
;;;294            C = SHA1CircularShift(30,B);
0000d8  ea4f04b3          ROR      r4,r3,#2
0000dc  44dc              ADD      r12,r12,r11           ;291
;;;295            B = A;
0000de  4613              MOV      r3,r2
;;;296            A = temp;
0000e0  1c76              ADDS     r6,r6,#1
0000e2  4662              MOV      r2,r12
0000e4  2e28              CMP      r6,#0x28              ;289
0000e6  dbeb              BLT      |L3.192|
;;;297        }
;;;298    
;;;299        for(t = 40; t < 60; t++)
0000e8  2628              MOVS     r6,#0x28
0000ea  46b9              MOV      r9,r7                 ;252
                  |L3.236|
;;;300        {
;;;301            temp = SHA1CircularShift(5,A) +
0000ec  ea040801          AND      r8,r4,r1
0000f0  f8597026          LDR      r7,[r9,r6,LSL #2]
;;;302                   ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];
;;;303            E = D;
;;;304            D = C;
;;;305            C = SHA1CircularShift(30,B);
;;;306            B = A;
;;;307            A = temp;
0000f4  1c76              ADDS     r6,r6,#1
0000f6  eb076cf2          ADD      r12,r7,r2,ROR #27     ;301
0000fa  ea440701          ORR      r7,r4,r1              ;301
0000fe  401f              ANDS     r7,r7,r3              ;301
000100  ea470708          ORR      r7,r7,r8              ;301
000104  443d              ADD      r5,r5,r7              ;301
000106  eb0c0705          ADD      r7,r12,r5             ;301
00010a  460d              MOV      r5,r1                 ;303
00010c  4621              MOV      r1,r4                 ;304
00010e  ea4f04b3          ROR      r4,r3,#2              ;305
000112  4477              ADD      r7,r7,lr              ;301
000114  4613              MOV      r3,r2                 ;306
000116  463a              MOV      r2,r7
000118  2e3c              CMP      r6,#0x3c              ;299
00011a  dbe7              BLT      |L3.236|
;;;308        }
;;;309    
;;;310        for(t = 60; t < 80; t++)
00011c  263c              MOVS     r6,#0x3c
00011e  46cc              MOV      r12,r9                ;252
                  |L3.288|
;;;311        {
;;;312            temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];
000120  f85c7026          LDR      r7,[r12,r6,LSL #2]
;;;313            E = D;
;;;314            D = C;
;;;315            C = SHA1CircularShift(30,B);
;;;316            B = A;
;;;317            A = temp;
000124  1c76              ADDS     r6,r6,#1
000126  eb0768f2          ADD      r8,r7,r2,ROR #27      ;312
00012a  ea830704          EOR      r7,r3,r4              ;312
00012e  404f              EORS     r7,r7,r1              ;312
000130  443d              ADD      r5,r5,r7              ;312
000132  eb080705          ADD      r7,r8,r5              ;312
000136  9d55              LDR      r5,[sp,#0x154]        ;312
000138  2e50              CMP      r6,#0x50              ;310
00013a  442f              ADD      r7,r7,r5              ;312
00013c  460d              MOV      r5,r1                 ;313
00013e  4621              MOV      r1,r4                 ;314
000140  ea4f04b3          ROR      r4,r3,#2              ;315
000144  4613              MOV      r3,r2                 ;316
000146  463a              MOV      r2,r7
000148  dbea              BLT      |L3.288|
;;;318        }
;;;319    
;;;320        context->Intermediate_Hash[0] += A;
00014a  9e54              LDR      r6,[sp,#0x150]
00014c  19f2              ADDS     r2,r6,r7
00014e  6002              STR      r2,[r0,#0]
;;;321        context->Intermediate_Hash[1] += B;
000150  9a53              LDR      r2,[sp,#0x14c]
000152  441a              ADD      r2,r2,r3
000154  6042              STR      r2,[r0,#4]
;;;322        context->Intermediate_Hash[2] += C;
000156  9a52              LDR      r2,[sp,#0x148]
000158  4422              ADD      r2,r2,r4
00015a  6082              STR      r2,[r0,#8]
;;;323        context->Intermediate_Hash[3] += D;
00015c  9a51              LDR      r2,[sp,#0x144]
00015e  4411              ADD      r1,r1,r2
000160  60c1              STR      r1,[r0,#0xc]
;;;324        context->Intermediate_Hash[4] += E;
000162  9950              LDR      r1,[sp,#0x140]
000164  4429              ADD      r1,r1,r5
;;;325    
;;;326        context->Message_Block_Index = 0;
000166  6101              STR      r1,[r0,#0x10]
000168  2100              MOVS     r1,#0
00016a  8381              STRH     r1,[r0,#0x1c]
;;;327    }
00016c  b056              ADD      sp,sp,#0x158
00016e  e8bd8ff0          POP      {r4-r11,pc}
;;;328    
                          ENDP

000172  0000              DCW      0x0000
                  |L3.372|
                          DCD      ||.constdata||

                          AREA ||i.SHA1Reset||, CODE, READONLY, ALIGN=2

                  SHA1Reset PROC
;;;68     
;;;69     int SHA1Reset(SHA1Context *context)
000000  b198              CBZ      r0,|L4.42|
;;;70     {
;;;71         if (!context)
;;;72         {
;;;73             return shaNull;
;;;74         }
;;;75     
;;;76         context->Length_Low             = 0;
000002  2100              MOVS     r1,#0
;;;77         context->Length_High            = 0;
000004  6141              STR      r1,[r0,#0x14]
;;;78         context->Message_Block_Index    = 0;
000006  6181              STR      r1,[r0,#0x18]
000008  8381              STRH     r1,[r0,#0x1c]
;;;79     
;;;80         context->Intermediate_Hash[0]   = 0x67452301;
00000a  4a09              LDR      r2,|L4.48|
;;;81         context->Intermediate_Hash[1]   = 0xEFCDAB89;
00000c  6002              STR      r2,[r0,#0]
00000e  4a09              LDR      r2,|L4.52|
;;;82         context->Intermediate_Hash[2]   = 0x98BADCFE;
000010  6042              STR      r2,[r0,#4]
000012  4a07              LDR      r2,|L4.48|
000014  43d2              MVNS     r2,r2
;;;83         context->Intermediate_Hash[3]   = 0x10325476;
000016  6082              STR      r2,[r0,#8]
000018  4a06              LDR      r2,|L4.52|
00001a  43d2              MVNS     r2,r2
;;;84         context->Intermediate_Hash[4]   = 0xC3D2E1F0;
00001c  60c2              STR      r2,[r0,#0xc]
00001e  4a06              LDR      r2,|L4.56|
;;;85     
;;;86         context->Computed   = 0;
;;;87         context->Corrupted  = 0;
000020  6601              STR      r1,[r0,#0x60]
;;;88     
;;;89         return shaSuccess;
000022  6102              STR      r2,[r0,#0x10]
000024  6641              STR      r1,[r0,#0x64]
000026  4608              MOV      r0,r1
;;;90     }
000028  4770              BX       lr
                  |L4.42|
00002a  2001              MOVS     r0,#1                 ;73
00002c  4770              BX       lr
;;;91     
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      0x67452301
                  |L4.52|
                          DCD      0xefcdab89
                  |L4.56|
                          DCD      0xc3d2e1f0

                          AREA ||i.SHA1Result||, CODE, READONLY, ALIGN=1

                  SHA1Result PROC
;;;110     */
;;;111    int SHA1Result( SHA1Context *context,
000000  b530              PUSH     {r4,r5,lr}
;;;112                    uint8_t Message_Digest[SHA1HashSize])
;;;113    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d006              BEQ      |L5.22|
;;;114        int i;
;;;115    
;;;116        if (!context || !Message_Digest)
000008  b12d              CBZ      r5,|L5.22|
;;;117        {
;;;118            return shaNull;
;;;119        }
;;;120    
;;;121        if (context->Corrupted)
00000a  6e60              LDR      r0,[r4,#0x64]
00000c  2800              CMP      r0,#0
00000e  d103              BNE      |L5.24|
;;;122        {
;;;123            return context->Corrupted;
;;;124        }
;;;125    
;;;126        if (!context->Computed)
000010  6e20              LDR      r0,[r4,#0x60]
000012  b110              CBZ      r0,|L5.26|
000014  e00f              B        |L5.54|
                  |L5.22|
000016  2001              MOVS     r0,#1                 ;118
                  |L5.24|
;;;127        {
;;;128            SHA1PadMessage(context);
;;;129            for(i=0; i<64; ++i)
;;;130            {
;;;131                /* message may be sensitive, clear it out */
;;;132                context->Message_Block[i] = 0;
;;;133            }
;;;134            context->Length_Low = 0;    /* and clear length */
;;;135            context->Length_High = 0;
;;;136            context->Computed = 1;
;;;137    
;;;138        }
;;;139    
;;;140        for(i = 0; i < SHA1HashSize; ++i)
;;;141        {
;;;142            Message_Digest[i] = context->Intermediate_Hash[i>>2]
;;;143                                >> 8 * ( 3 - ( i & 0x03 ) );
;;;144        }
;;;145    
;;;146        return shaSuccess;
;;;147    }
000018  bd30              POP      {r4,r5,pc}
                  |L5.26|
00001a  4620              MOV      r0,r4                 ;128
00001c  f7fffffe          BL       SHA1PadMessage
000020  2000              MOVS     r0,#0                 ;129
000022  4601              MOV      r1,r0                 ;129
                  |L5.36|
000024  1822              ADDS     r2,r4,r0              ;132
000026  1c40              ADDS     r0,r0,#1              ;132
000028  7791              STRB     r1,[r2,#0x1e]         ;132
00002a  2840              CMP      r0,#0x40              ;129
00002c  dbfa              BLT      |L5.36|
00002e  6161              STR      r1,[r4,#0x14]         ;135
000030  2001              MOVS     r0,#1                 ;136
000032  61a1              STR      r1,[r4,#0x18]         ;136
000034  6620              STR      r0,[r4,#0x60]         ;136
                  |L5.54|
000036  2000              MOVS     r0,#0                 ;140
                  |L5.56|
000038  f0200103          BIC      r1,r0,#3              ;142
00003c  f0000203          AND      r2,r0,#3              ;142
000040  5861              LDR      r1,[r4,r1]            ;142
000042  f1c20203          RSB      r2,r2,#3              ;142
000046  00d2              LSLS     r2,r2,#3              ;142
000048  40d1              LSRS     r1,r1,r2              ;142
00004a  5429              STRB     r1,[r5,r0]            ;142
00004c  1c40              ADDS     r0,r0,#1              ;142
00004e  2814              CMP      r0,#0x14              ;140
000050  dbf2              BLT      |L5.56|
000052  2000              MOVS     r0,#0                 ;146
000054  bd30              POP      {r4,r5,pc}
;;;148    
                          ENDP


                          AREA ||i.kdp_gen_crc16||, CODE, READONLY, ALIGN=1

                  kdp_gen_crc16 PROC
;;;12     
;;;13     u16 kdp_gen_crc16(u8 *data, u32 size)
000000  b5f0              PUSH     {r4-r7,lr}
;;;14     {
;;;15         u16 out = 0;
000002  2200              MOVS     r2,#0
;;;16         int bits_read = 0, bit_flag, i;
000004  4613              MOV      r3,r2
;;;17     
;;;18         /* Sanity check: */
;;;19         if (data == NULL)
;;;20             return 0;
;;;21     
;;;22         while (size > 0)
;;;23         {
;;;24             bit_flag = out >> 15;
;;;25     
;;;26             /* Get next bit: */
;;;27             out <<= 1;
000006  f64f74ff          MOV      r4,#0xffff
;;;28             out |= (*data >> bits_read) & 1;
;;;29             bits_read++;
;;;30             if (bits_read > 7)
;;;31             {
;;;32                 bits_read = 0;
;;;33                 data++;
;;;34                 size--;
;;;35             }
;;;36     
;;;37             /* Cycle check: */
;;;38             if (bit_flag)
;;;39                 out ^= CRC16_CONSTANT;
00000a  f2480505          MOV      r5,#0x8005
00000e  2800              CMP      r0,#0                 ;14
000010  d027              BEQ      |L6.98|
000012  e00f              B        |L6.52|
                  |L6.20|
000014  0bd6              LSRS     r6,r2,#15             ;24
000016  ea040742          AND      r7,r4,r2,LSL #1       ;27
00001a  7802              LDRB     r2,[r0,#0]            ;28
00001c  40da              LSRS     r2,r2,r3              ;28
00001e  f0020201          AND      r2,r2,#1              ;28
000022  433a              ORRS     r2,r2,r7              ;28
000024  1c5b              ADDS     r3,r3,#1              ;28
000026  2b07              CMP      r3,#7                 ;30
000028  dd02              BLE      |L6.48|
00002a  2300              MOVS     r3,#0                 ;32
00002c  1c40              ADDS     r0,r0,#1              ;32
00002e  1e49              SUBS     r1,r1,#1              ;32
                  |L6.48|
000030  b106              CBZ      r6,|L6.52|
000032  406a              EORS     r2,r2,r5
                  |L6.52|
000034  2900              CMP      r1,#0                 ;22
000036  d1ed              BNE      |L6.20|
;;;40     
;;;41         }
;;;42     
;;;43         // push out the last 16 bits
;;;44         for (i = 0; i < 16; ++i) {
000038  2000              MOVS     r0,#0
                  |L6.58|
;;;45             bit_flag = out >> 15;
00003a  0bd1              LSRS     r1,r2,#15
;;;46             out <<= 1;
00003c  ea040242          AND      r2,r4,r2,LSL #1
;;;47             if (bit_flag)
000040  d000              BEQ      |L6.68|
;;;48                 out ^= CRC16_CONSTANT;
000042  406a              EORS     r2,r2,r5
                  |L6.68|
000044  1c40              ADDS     r0,r0,#1
000046  2810              CMP      r0,#0x10              ;44
000048  dbf7              BLT      |L6.58|
;;;49         }
;;;50     
;;;51         // reverse the bits
;;;52         u16 crc = 0;
00004a  2000              MOVS     r0,#0
;;;53         i = 0x8000;
00004c  f44f4100          MOV      r1,#0x8000
;;;54         int j = 0x0001;
000050  2301              MOVS     r3,#1
                  |L6.82|
;;;55         for (; i != 0; i >>= 1, j <<= 1) {
;;;56             if (i & out) crc |= j;
000052  4211              TST      r1,r2
000054  d001              BEQ      |L6.90|
000056  4318              ORRS     r0,r0,r3
000058  b280              UXTH     r0,r0
                  |L6.90|
00005a  1049              ASRS     r1,r1,#1              ;55
00005c  ea4f0343          LSL      r3,r3,#1              ;55
000060  d1f7              BNE      |L6.82|
                  |L6.98|
;;;57         }
;;;58     
;;;59         return crc;
;;;60     }
000062  bdf0              POP      {r4-r7,pc}
;;;61     
                          ENDP


                          AREA ||i.kdp_gen_sha32||, CODE, READONLY, ALIGN=2

                  kdp_gen_sha32 PROC
;;;402    
;;;403    u32 kdp_gen_sha32(u8 *data, u32 size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;404    {
;;;405        u32 *sram, *ddr, i, j;
;;;406        ddr = (u32*)data;
;;;407        sram = (u32*)(sha_core.Message_Block);
000004  4e1a              LDR      r6,|L7.112|
000006  4680              MOV      r8,r0                 ;404
000008  4605              MOV      r5,r0                 ;406
00000a  460f              MOV      r7,r1                 ;404
;;;408        SHA1Reset(&sha_core);
00000c  f1a6001e          SUB      r0,r6,#0x1e
000010  f7fffffe          BL       SHA1Reset
;;;409        for (i = 0; i < size; i += 64)
000014  2400              MOVS     r4,#0
000016  e00b              B        |L7.48|
                  |L7.24|
;;;410        {
;;;411    #if 0
;;;412            memcpy(sram, ddr, 64);
;;;413            ddr += 16;
;;;414    #else
;;;415            for (j = 0; j < 16; j++)  // copy one block over
000018  2000              MOVS     r0,#0
                  |L7.26|
;;;416                sram[j] = *ddr++;
00001a  cd04              LDM      r5!,{r2}
00001c  f8462020          STR      r2,[r6,r0,LSL #2]
000020  1c40              ADDS     r0,r0,#1
000022  2810              CMP      r0,#0x10              ;415
000024  d3f9              BCC      |L7.26|
;;;417    #endif
;;;418            SHA1ProcessMessageBlock(&sha_core);
000026  4812              LDR      r0,|L7.112|
000028  381e              SUBS     r0,r0,#0x1e
00002a  f7fffffe          BL       SHA1ProcessMessageBlock
00002e  3440              ADDS     r4,r4,#0x40
                  |L7.48|
000030  42bc              CMP      r4,r7                 ;409
000032  d3f1              BCC      |L7.24|
;;;419        }
;;;420        if (size & 0x03F)  // pad partial block with zero's
000034  06b8              LSLS     r0,r7,#26
000036  d00f              BEQ      |L7.88|
;;;421        {
;;;422            i -= 64; // point to the start of partial block
;;;423            memset(sha_core.Message_Block, 0, 64);
000038  2140              MOVS     r1,#0x40
00003a  4630              MOV      r0,r6
00003c  3c40              SUBS     r4,r4,#0x40
00003e  f7fffffe          BL       __aeabi_memclr
;;;424            memcpy(sha_core.Message_Block, &data[i], size & 0x03F);
000042  f007023f          AND      r2,r7,#0x3f
000046  eb080104          ADD      r1,r8,r4
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       __aeabi_memcpy
;;;425            SHA1ProcessMessageBlock(&sha_core);
000050  4807              LDR      r0,|L7.112|
000052  381e              SUBS     r0,r0,#0x1e
000054  f7fffffe          BL       SHA1ProcessMessageBlock
                  |L7.88|
;;;426        }
;;;427        j = 0;
000058  2000              MOVS     r0,#0
00005a  4a05              LDR      r2,|L7.112|
;;;428        for (i = 0; i < 5; i++)
00005c  4601              MOV      r1,r0
00005e  3a1e              SUBS     r2,r2,#0x1e           ;407
                  |L7.96|
;;;429            j ^= sha_core.Intermediate_Hash[i];
000060  f8523021          LDR      r3,[r2,r1,LSL #2]
000064  1c49              ADDS     r1,r1,#1
000066  4058              EORS     r0,r0,r3
000068  2905              CMP      r1,#5                 ;428
00006a  d3f9              BCC      |L7.96|
;;;430        return(j);
;;;431    }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;432    
                          ENDP

                  |L7.112|
                          DCD      ||.bss||+0x1e

                          AREA ||i.kdp_gen_sum32||, CODE, READONLY, ALIGN=1

                  kdp_gen_sum32 PROC
;;;436    */
;;;437    u32 kdp_gen_sum32(u8 *data, u32 size)
000000  b530              PUSH     {r4,r5,lr}
;;;438    {
;;;439        u32 sum, *ddr, i = (u32)data & 0x03;
000002  f0100303          ANDS     r3,r0,#3
;;;440        ddr = (u32*) ((u32)data & 0xFFFFFFFC);  // point to the first 32-bit aligned block
000006  f0200203          BIC      r2,r0,#3
00000a  d006              BEQ      |L8.26|
;;;441        if (i) { // starting address misaligned ?
;;;442    		size = size + i - 4;
;;;443            sum = *ddr;
00000c  ca01              LDM      r2!,{r0}
00000e  4419              ADD      r1,r1,r3              ;442
;;;444            sum >>= i*8;
000010  00db              LSLS     r3,r3,#3
000012  40d8              LSRS     r0,r0,r3
;;;445    		sum <<= i*8;
000014  4098              LSLS     r0,r0,r3
000016  1f09              SUBS     r1,r1,#4
;;;446            ddr++;
000018  e000              B        |L8.28|
                  |L8.26|
;;;447        }
;;;448        else
;;;449            sum = 0;
00001a  2000              MOVS     r0,#0
                  |L8.28|
;;;450        for (i = 0; i < (size & 0xFFFFFFFC); i += 4) {
00001c  2300              MOVS     r3,#0
00001e  f0210403          BIC      r4,r1,#3
000022  e002              B        |L8.42|
                  |L8.36|
;;;451            sum += *ddr;
000024  ca20              LDM      r2!,{r5}
000026  1d1b              ADDS     r3,r3,#4
000028  4428              ADD      r0,r0,r5
                  |L8.42|
00002a  429c              CMP      r4,r3                 ;450
00002c  d8fa              BHI      |L8.36|
;;;452            ddr++;
;;;453        }
;;;454        i = size & 3;
00002e  f0110103          ANDS     r1,r1,#3
;;;455        if (i)  // ending address misaligned ?
000032  d006              BEQ      |L8.66|
;;;456        {
;;;457            size = *ddr;
000034  6812              LDR      r2,[r2,#0]
;;;458            size <<= (4-i)*8;
000036  f1c10104          RSB      r1,r1,#4
00003a  00c9              LSLS     r1,r1,#3
00003c  408a              LSLS     r2,r2,r1
;;;459            size >>= (4-i)*8;
00003e  40ca              LSRS     r2,r2,r1
;;;460            sum += size;
000040  4410              ADD      r0,r0,r2
                  |L8.66|
;;;461        }
;;;462        return(sum);
;;;463    }
000042  bd30              POP      {r4,r5,pc}
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sha_core
                          %        104

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x5a827999
                          DCD      0x6ed9eba1
                          DCD      0x8f1bbcdc
                          DCD      0xca62c1d6
