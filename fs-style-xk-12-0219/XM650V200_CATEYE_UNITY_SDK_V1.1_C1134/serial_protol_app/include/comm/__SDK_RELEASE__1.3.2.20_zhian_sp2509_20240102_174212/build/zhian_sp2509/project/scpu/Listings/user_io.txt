; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\user_io.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\user_io.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\user_io.crf ..\..\user\user_io.c]
                          THUMB

                          AREA ||i._io_extender_init||, CODE, READONLY, ALIGN=1

                  _io_extender_init PROC
;;;47     
;;;48     void _io_extender_init(void)
000000  4770              BX       lr
;;;49     {
;;;50     //    u16 regAddr;
;;;51     
;;;52     //    _io_extender_set_i2c_port(0); //__i2c_port = 0;
;;;53     
;;;54     //#ifndef CUSTOMER_SETTING_REMOVE_LOG
;;;55     //    u8 data = 0;
;;;56     //    //get device id
;;;57     //    data = user_io_get_extra_device_id();
;;;58     //    dbg_msg_user("io extender init, ID = %x", data);
;;;59     //#endif
;;;60     //    
;;;61     //    //set io direction
;;;62     //    regAddr = IOEXT_REG_DIR_P0;
;;;63     //    _io_extender_set_io(regAddr, IOEXT_P0|IOEXT_P1|IOEXT_P2|IOEXT_P3|IOEXT_P4|IOEXT_P5|IOEXT_P6|IOEXT_P7, 0);
;;;64     //    regAddr = IOEXT_REG_DIR_P1;
;;;65     //    _io_extender_set_io(regAddr, IOEXT_P0|IOEXT_P1|IOEXT_P2|IOEXT_P3|IOEXT_P4|IOEXT_P5|IOEXT_P6|IOEXT_P7, 0);
;;;66     
;;;67     //    //set P0 value
;;;68     //    regAddr = IOEXT_REG_SET_IO_P0;
;;;69     //    _io_extender_set_io(regAddr, IOEXT_P0|IOEXT_P1|IOEXT_P2|IOEXT_P3|IOEXT_P4|IOEXT_P5|IOEXT_P6|IOEXT_P7, 0);
;;;70     //    delay_us(200);
;;;71     
;;;72     //#if 1
;;;73     //#else
;;;74     //    _io_extender_set_io(regAddr, IOEXT_P5|IOEXT_P3|IOEXT_P1, 1);
;;;75     //    _io_extender_set_io(regAddr, IOEXT_P2, 1);//0x6E;
;;;76     //#endif
;;;77     //    regAddr = IOEXT_REG_SET_SYS_CFG;
;;;78     //    _io_extender_set_io(regAddr, IOEXT_P0|IOEXT_P1|IOEXT_P2|IOEXT_P3|IOEXT_P4|IOEXT_P5|IOEXT_P6|IOEXT_P7, 0);
;;;79     //    _io_extender_set_io(regAddr, IOEXT_P4, 1);//0x10
;;;80     
;;;81     //    regAddr = IOEXT_REG_SET_LED_SW;
;;;82     //    _io_extender_set_io(regAddr, IOEXT_P0|IOEXT_P1|IOEXT_P2|IOEXT_P3|IOEXT_P4|IOEXT_P5|IOEXT_P6|IOEXT_P7, 1);//0xFF
;;;83     
;;;84     //    //set P1 value
;;;85     //    //regAddr = IOEXT_REG_SET_IO_P1;
;;;86     //    //_io_extender_set_io(regAddr, IOEXT_P0, 0);
;;;87     //    //dbg_msg_user("io extender init, done");
;;;88     }
;;;89     
                          ENDP


                          AREA ||i.backlight_init||, CODE, READONLY, ALIGN=1

                  backlight_init PROC
;;;552    
;;;553    void backlight_init(void)
000000  4770              BX       lr
;;;554    {
;;;555    
;;;556    #if (DISPLAY_DEVICE == DISPLAY_DEVICE_LCM)
;;;557        user_io_set_backlight(user_io_get_backlight());
;;;558    #endif
;;;559    }
;;;560    
                          ENDP


                          AREA ||i.lcd_power_off||, CODE, READONLY, ALIGN=2

                  lcd_power_off PROC
;;;465    }
;;;466    void lcd_power_off(void)
000000  4901              LDR      r1,|L3.8|
;;;467    {
;;;468        //dbg_msg_user("[%s]", __func__);
;;;469        _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P6, 0);
;;;470        _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P7, 1);
;;;471        lcd_power_is_opened = FALSE;
000002  2000              MOVS     r0,#0
000004  70c8              STRB     r0,[r1,#3]
;;;472        //_io_extender_set_io(IOEXT_REG_SET_LED_SW, 0xFF, 1);
;;;473    }
000006  4770              BX       lr
;;;474    
                          ENDP

                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.lcd_power_on||, CODE, READONLY, ALIGN=2

                  lcd_power_on PROC
;;;455    BOOL lcd_power_is_opened = FALSE;
;;;456    void lcd_power_on(void) 
000000  4803              LDR      r0,|L4.16|
;;;457    {
;;;458        if (!lcd_power_is_opened)
000002  78c1              LDRB     r1,[r0,#3]  ; lcd_power_is_opened
000004  2900              CMP      r1,#0                 ;457
000006  d101              BNE      |L4.12|
;;;459        {
;;;460            //dbg_msg_user("[%s]", __func__);
;;;461            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P6, 1);
;;;462            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P7, 0);
;;;463            lcd_power_is_opened = TRUE;
000008  2101              MOVS     r1,#1
00000a  70c1              STRB     r1,[r0,#3]
                  |L4.12|
;;;464        }
;;;465    }
00000c  4770              BX       lr
;;;466    void lcd_power_off(void)
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      ||.data||

                          AREA ||i.nir_camera_power_off||, CODE, READONLY, ALIGN=2

                  nir_camera_power_off PROC
;;;197    }
;;;198    void nir_camera_power_off(void)
000000  4803              LDR      r0,|L5.16|
;;;199    {
;;;200        //dbg_msg_user("[%s]", __func__);
;;;201        if (nir_camera_is_powered_on)
000002  7881              LDRB     r1,[r0,#2]  ; nir_camera_is_powered_on
000004  2900              CMP      r1,#0                 ;199
000006  d001              BEQ      |L5.12|
;;;202        {
;;;203            /*
;;;204            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P3, 0);//PWDN
;;;205            //if (!rgb_camera_is_powered_on)
;;;206            //    _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P4, 1);//PWR_EN1
;;;207            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P5, 0);//PWR_EN
;;;208            */
;;;209    //        PINMUX_LC_DATA11_SET(PINMUX_LC_DATA11_GPIO0);//NIR
;;;210    //        kdp520_gpio_setdir(  GPIO_0, GPIO_DIR_OUTPUT );
;;;211    //        kdp520_gpio_cleardata( 1<<GPIO_0);
;;;212            nir_camera_is_powered_on = FALSE;
000008  2100              MOVS     r1,#0
00000a  7081              STRB     r1,[r0,#2]
                  |L5.12|
;;;213        }
;;;214    }
00000c  4770              BX       lr
;;;215    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      ||.data||

                          AREA ||i.nir_camera_power_on||, CODE, READONLY, ALIGN=2

                  nir_camera_power_on PROC
;;;168    }
;;;169    void nir_camera_power_on(void)
000000  b510              PUSH     {r4,lr}
;;;170    {
;;;171        //dbg_msg_user("[%s]", __func__);
;;;172        if (!nir_camera_is_powered_on)
000002  4c04              LDR      r4,|L6.20|
000004  78a0              LDRB     r0,[r4,#2]  ; nir_camera_is_powered_on
000006  2800              CMP      r0,#0                 ;170
000008  d103              BNE      |L6.18|
;;;173        {
;;;174            rgb_camera_power_on();
00000a  f7fffffe          BL       rgb_camera_power_on
;;;175            /*
;;;176            tp_power_on();
;;;177            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P3, 1);//PWDN
;;;178            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P4, 0);//PWR_EN1
;;;179            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P5, 1);//PWR_EN
;;;180            */
;;;181    //        PINMUX_LC_DATA9_SET(PINMUX_LC_DATA9_GPIO20);//RGB reset
;;;182    //        kdp520_gpio_setdir(  GPIO_20, GPIO_DIR_OUTPUT );
;;;183    //        kdp520_gpio_setdata( 1<<GPIO_20);
;;;184            
;;;185    //        PINMUX_LC_DATA11_SET(PINMUX_LC_DATA11_GPIO0);//RGB reset
;;;186    //        kdp520_gpio_setdir(  GPIO_0, GPIO_DIR_OUTPUT );
;;;187    //        kdp520_gpio_setdata( 1<<GPIO_0);
;;;188    //        //kdp520_gpio_cleardata( 1<<GPIO_0);
;;;189            
;;;190    //        PINMUX_LC_DATA10_SET(PINMUX_LC_DATA10_GPIO21);//RGB reset
;;;191    //        kdp520_gpio_setdir(  GPIO_21, GPIO_DIR_OUTPUT );
;;;192    //        kdp520_gpio_setdata( 1<<GPIO_21);
;;;193    
;;;194            //delay_us(30000);
;;;195            nir_camera_is_powered_on = TRUE;
00000e  2001              MOVS     r0,#1
000010  70a0              STRB     r0,[r4,#2]
                  |L6.18|
;;;196        }
;;;197    }
000012  bd10              POP      {r4,pc}
;;;198    void nir_camera_power_off(void)
                          ENDP

                  |L6.20|
                          DCD      ||.data||

                          AREA ||i.nir_led_close||, CODE, READONLY, ALIGN=1

                  nir_led_close PROC
;;;402    
;;;403    void nir_led_close(void) 
000000  2002              MOVS     r0,#2
;;;404    {
;;;405    #if ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36515 )
;;;406        u8 nData;
;;;407    
;;;408        led_set_light_mode( LED_TORCH_MODE );
;;;409        kdp_drv_i2c_write( I2C_ADAP_0, LED_SLAVE_ID, 0x01, 1, g_LedLightMode );  //Set to torch mode and turn off LED
;;;410    #else
;;;411        kdp520_gpio_cleardata( 1<<GPIO_1);
000002  f7ffbffe          B.W      kdp520_gpio_cleardata
;;;412        
;;;413    //    if (nir_led_is_opened) {
;;;414    //        nir_led_init(0);
;;;415    //        nir_led_is_opened = FALSE;
;;;416    //    }
;;;417    #endif
;;;418    }
;;;419    
                          ENDP


                          AREA ||i.nir_led_init||, CODE, READONLY, ALIGN=2

                  nir_led_init PROC
;;;327    
;;;328    void nir_led_init(u16 duty)
000000  b570              PUSH     {r4-r6,lr}
;;;329    {
;;;330    #if ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36515 )
;;;331        aw36515_init( LED_STANDBY_MODE );
;;;332        if ( g_LedLightMode != LED_STANDBY_MODE )
;;;333        {
;;;334            nir_led_open( duty );
;;;335        }
;;;336    #else
;;;337    //    static u8 nir_pulse_cnt=255;
;;;338        
;;;339        PINMUX_LC_DATA14_SET(PINMUX_LC_DATA14_GPIO3);
000002  4c13              LDR      r4,|L8.80|
000004  4605              MOV      r5,r0                 ;329
000006  f8d40174          LDR      r0,[r4,#0x174]
00000a  f0200007          BIC      r0,r0,#7
00000e  1cc0              ADDS     r0,r0,#3
000010  f8c40174          STR      r0,[r4,#0x174]
;;;340        kdp520_gpio_setdir( GPIO_3, GPIO_DIR_OUTPUT);
000014  2101              MOVS     r1,#1
000016  2003              MOVS     r0,#3
000018  f50474b6          ADD      r4,r4,#0x16c
00001c  f7fffffe          BL       kdp520_gpio_setdir
;;;341        kdp520_gpio_setdata( 1<<GPIO_3);
000020  2008              MOVS     r0,#8
000022  f7fffffe          BL       kdp520_gpio_setdata
;;;342        
;;;343        PINMUX_LC_DATA12_SET(PINMUX_LC_DATA12_GPIO1);
000026  6820              LDR      r0,[r4,#0]
000028  f0200007          BIC      r0,r0,#7
00002c  1cc0              ADDS     r0,r0,#3
00002e  6020              STR      r0,[r4,#0]
;;;344        //aw36404_init(GPIO_2, &nir_pulse_cnt, duty);
;;;345    
;;;346        //PINMUX_LC_DATA10_SET(PINMUX_LC_DATA10_GPIO21);
;;;347        kdp520_gpio_setdir( GPIO_1, GPIO_DIR_OUTPUT);
000030  2101              MOVS     r1,#1
000032  4608              MOV      r0,r1
000034  f7fffffe          BL       kdp520_gpio_setdir
;;;348    
;;;349        if (duty > 0)
000038  b125              CBZ      r5,|L8.68|
;;;350        {
;;;351            nir_led_open(duty);
00003a  4628              MOV      r0,r5
00003c  e8bd4070          POP      {r4-r6,lr}
000040  f7ffbffe          B.W      nir_led_open
                  |L8.68|
000044  e8bd4070          POP      {r4-r6,lr}
000048  2002              MOVS     r0,#2
00004a  f7ffbffe          B.W      kdp520_gpio_cleardata
;;;352        }
;;;353        else
;;;354        {
;;;355            nir_led_close();
;;;356        }
;;;357    #endif
;;;358    }
;;;359    
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      0xc2380000

                          AREA ||i.nir_led_open||, CODE, READONLY, ALIGN=2

                  nir_led_open PROC
;;;359    
;;;360    void nir_led_open(u16 level)
000000  4803              LDR      r0,|L9.16|
;;;361    {
;;;362    #if CFG_ONE_SHOT_MODE == YES
;;;363        if( skip_all_led == TRUE ) return;
000002  7800              LDRB     r0,[r0,#0]  ; skip_all_led
000004  2801              CMP      r0,#1
000006  d002              BEQ      |L9.14|
;;;364    #endif
;;;365    
;;;366    #if ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36515 )
;;;367        u8 nLevel, nLedBriReg;
;;;368    
;;;369        if ( g_LedLightMode == LED_STANDBY_MODE )
;;;370        {
;;;371            led_set_light_mode(LED_TORCH_MODE);
;;;372        }
;;;373    
;;;374        if ( g_LedLightMode == LED_TORCH_MODE )
;;;375        {
;;;376            nLedBriReg = 0x05;
;;;377        }
;;;378        else if ( g_LedLightMode == LED_FLASH_MODE )
;;;379        {
;;;380            nLedBriReg = 0x03;
;;;381        }
;;;382    
;;;383        level = (level > 100)? (100):(level);
;;;384        nLevel = level * 255 / 100;  //mapping to 0~255
;;;385    
;;;386        //dbg_msg_console("[nir_led_open]  mode=0x%x, duty = %d ", g_LedLightMode, nLevel);
;;;387        kdp_drv_i2c_write( I2C_ADAP_0, LED_SLAVE_ID, 0x01, 1, (g_LedLightMode|IO_LED1) );  //set LED mode and turn on LED1 
;;;388        kdp_drv_i2c_write( I2C_ADAP_0, LED_SLAVE_ID, nLedBriReg, 1, nLevel );
;;;389    #else
;;;390    //#if CFG_AI_TYPE == AI_TYPE_R1N1   
;;;391    //       u16 duty = (level > 100) ? (100) : (level);
;;;392    //       nir_led_init(duty >> 1);
;;;393    //#elif (CFG_AI_TYPE == AI_TYPE_N1R1 || CFG_AI_TYPE == AI_TYPE_N1)
;;;394    //       u16 duty = (level > 90) ? (90) : (level);
;;;395    //       nir_led_init(duty);
;;;396    //#endif
;;;397        
;;;398        //kdp520_gpio_setdir( GPIO_2, GPIO_DIR_OUTPUT);
;;;399        kdp520_gpio_setdata( 1<<GPIO_1);
000008  2002              MOVS     r0,#2
00000a  f7ffbffe          B.W      kdp520_gpio_setdata
                  |L9.14|
;;;400    #endif
;;;401    }
00000e  4770              BX       lr
;;;402    
                          ENDP

                  |L9.16|
                          DCD      ||.data||

                          AREA ||i.rgb_camera_power_off||, CODE, READONLY, ALIGN=2

                  rgb_camera_power_off PROC
;;;152    }
;;;153    void rgb_camera_power_off(void)
000000  4803              LDR      r0,|L10.16|
;;;154    {
;;;155        //dbg_msg_user("[%s]", __func__);
;;;156        if (rgb_camera_is_powered_on) {
000002  7841              LDRB     r1,[r0,#1]  ; rgb_camera_is_powered_on
000004  2900              CMP      r1,#0                 ;154
000006  d001              BEQ      |L10.12|
;;;157    //        PINMUX_SD_DATA2_SET(PINMUX_SD_DATA2_GPIO26);//RGB reset
;;;158    //        kdp520_gpio_setdir(  GPIO_26, GPIO_DIR_OUTPUT );
;;;159    //        kdp520_gpio_cleardata( 1<<GPIO_26);
;;;160            /*
;;;161            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P0, 1);//PWDN
;;;162            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P2, 0);//PWR_EN2
;;;163            //if (!nir_camera_is_powered_on)
;;;164            //    _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P4, 1);//PWR_EN1
;;;165            */
;;;166            rgb_camera_is_powered_on = FALSE;
000008  2100              MOVS     r1,#0
00000a  7041              STRB     r1,[r0,#1]
                  |L10.12|
;;;167        }
;;;168    }
00000c  4770              BX       lr
;;;169    void nir_camera_power_on(void)
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      ||.data||

                          AREA ||i.rgb_camera_power_on||, CODE, READONLY, ALIGN=2

                  rgb_camera_power_on PROC
;;;112    
;;;113    void rgb_camera_power_on(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;114    {
;;;115        //dbg_msg_user("[%s]", __func__);
;;;116        if (!rgb_camera_is_powered_on) 
000004  4d2b              LDR      r5,|L11.180|
000006  7868              LDRB     r0,[r5,#1]  ; rgb_camera_is_powered_on
000008  2800              CMP      r0,#0                 ;114
00000a  d151              BNE      |L11.176|
;;;117        {
;;;118            PINMUX_LC_DATA10_SET(PINMUX_LC_DATA10_GPIO21);
00000c  4c2a              LDR      r4,|L11.184|
00000e  f8d40164          LDR      r0,[r4,#0x164]
000012  f0200007          BIC      r0,r0,#7
000016  1cc0              ADDS     r0,r0,#3
000018  f8c40164          STR      r0,[r4,#0x164]
;;;119            kdp520_gpio_setdir(  GPIO_21, GPIO_DIR_OUTPUT );
00001c  2101              MOVS     r1,#1
00001e  2015              MOVS     r0,#0x15
000020  f50474b0          ADD      r4,r4,#0x160
000024  f7fffffe          BL       kdp520_gpio_setdir
;;;120            kdp520_gpio_setdata( 1<<GPIO_21);
000028  f44f1600          MOV      r6,#0x200000
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       kdp520_gpio_setdata
;;;121    		
;;;122            PINMUX_LC_DATA11_SET(PINMUX_LC_DATA11_GPIO0);//RGB PWDN
000032  68a0              LDR      r0,[r4,#8]
000034  f0200007          BIC      r0,r0,#7
000038  1cc0              ADDS     r0,r0,#3
00003a  60a0              STR      r0,[r4,#8]
;;;123            kdp520_gpio_setdir(  GPIO_0, GPIO_DIR_OUTPUT );
00003c  2101              MOVS     r1,#1
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       kdp520_gpio_setdir
;;;124            kdp520_gpio_setdata( 1<<GPIO_0);
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       kdp520_gpio_setdata
;;;125            
;;;126            delay_us(1000);
00004a  f44f777a          MOV      r7,#0x3e8
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       delay_us
;;;127            /*
;;;128            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P0, 0);//PWDN
;;;129            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P1, 1);//RST
;;;130            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P2, 1);//PWR_EN2
;;;131            _io_extender_set_io(IOEXT_REG_SET_IO_P0, IOEXT_P4, 0);//PWR_EN1
;;;132            */
;;;133            PINMUX_LC_DATA9_SET(PINMUX_LC_DATA9_GPIO20);//RGB 1.8V
000054  6820              LDR      r0,[r4,#0]
000056  f0200007          BIC      r0,r0,#7
00005a  1cc0              ADDS     r0,r0,#3
00005c  6020              STR      r0,[r4,#0]
;;;134            kdp520_gpio_setdir(  GPIO_20, GPIO_DIR_OUTPUT );
00005e  2101              MOVS     r1,#1
000060  2014              MOVS     r0,#0x14
000062  f7fffffe          BL       kdp520_gpio_setdir
;;;135            kdp520_gpio_setdata( 1<<GPIO_20);
000066  1070              ASRS     r0,r6,#1
000068  f7fffffe          BL       kdp520_gpio_setdata
;;;136            
;;;137            delay_us(1000);
00006c  4638              MOV      r0,r7
00006e  f7fffffe          BL       delay_us
;;;138            
;;;139            PINMUX_LC_DATA10_SET(PINMUX_LC_DATA10_GPIO21);//NIR PWDN
000072  6860              LDR      r0,[r4,#4]
000074  f0200007          BIC      r0,r0,#7
000078  1cc0              ADDS     r0,r0,#3
00007a  6060              STR      r0,[r4,#4]
;;;140            kdp520_gpio_setdir(  GPIO_21, GPIO_DIR_OUTPUT );
00007c  2101              MOVS     r1,#1
00007e  2015              MOVS     r0,#0x15
000080  f7fffffe          BL       kdp520_gpio_setdir
;;;141            kdp520_gpio_cleardata( 1<<GPIO_21);
000084  4630              MOV      r0,r6
000086  f7fffffe          BL       kdp520_gpio_cleardata
;;;142    
;;;143            PINMUX_LC_DATA11_SET(PINMUX_LC_DATA11_GPIO0);//RGB PWDN
00008a  68a0              LDR      r0,[r4,#8]
00008c  f0200007          BIC      r0,r0,#7
000090  1cc0              ADDS     r0,r0,#3
000092  60a0              STR      r0,[r4,#8]
;;;144            kdp520_gpio_setdir(  GPIO_0, GPIO_DIR_OUTPUT );
000094  2101              MOVS     r1,#1
000096  2000              MOVS     r0,#0
000098  f7fffffe          BL       kdp520_gpio_setdir
;;;145            kdp520_gpio_cleardata( 1<<GPIO_0);
00009c  2001              MOVS     r0,#1
00009e  f7fffffe          BL       kdp520_gpio_cleardata
;;;146            
;;;147            rgb_camera_rst();
0000a2  f7fffffe          BL       rgb_camera_rst
;;;148            delay_us(1000);
0000a6  4638              MOV      r0,r7
0000a8  f7fffffe          BL       delay_us
;;;149            //delay_us(30000);
;;;150            rgb_camera_is_powered_on = TRUE;
0000ac  2001              MOVS     r0,#1
0000ae  7068              STRB     r0,[r5,#1]
                  |L11.176|
;;;151        }
;;;152    }
0000b0  e8bd81f0          POP      {r4-r8,pc}
;;;153    void rgb_camera_power_off(void)
                          ENDP

                  |L11.180|
                          DCD      ||.data||
                  |L11.184|
                          DCD      0xc2380000

                          AREA ||i.rgb_camera_rst||, CODE, READONLY, ALIGN=2

                  rgb_camera_rst PROC
;;;92     
;;;93     void rgb_camera_rst(void)
000000  b570              PUSH     {r4-r6,lr}
;;;94     {
;;;95         PINMUX_SD_DATA2_SET(PINMUX_SD_DATA2_GPIO26);//RGB reset
000002  4c1a              LDR      r4,|L12.108|
000004  f8d4018c          LDR      r0,[r4,#0x18c]
000008  f0200007          BIC      r0,r0,#7
00000c  1cc0              ADDS     r0,r0,#3
00000e  f8c4018c          STR      r0,[r4,#0x18c]
;;;96         kdp520_gpio_setdir(  GPIO_26, GPIO_DIR_OUTPUT );
000012  2101              MOVS     r1,#1
000014  201a              MOVS     r0,#0x1a
000016  f50474c6          ADD      r4,r4,#0x18c
00001a  f7fffffe          BL       kdp520_gpio_setdir
;;;97         kdp520_gpio_setdata( 1<<GPIO_26);
00001e  f04f6580          MOV      r5,#0x4000000
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       kdp520_gpio_setdata
;;;98         
;;;99         delay_us(1000);
000028  f44f767a          MOV      r6,#0x3e8
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       delay_us
;;;100        
;;;101        PINMUX_SD_DATA2_SET(PINMUX_SD_DATA2_GPIO26);//RGB reset
000032  6820              LDR      r0,[r4,#0]
000034  f0200007          BIC      r0,r0,#7
000038  1cc0              ADDS     r0,r0,#3
00003a  6020              STR      r0,[r4,#0]
;;;102        kdp520_gpio_setdir(  GPIO_26, GPIO_DIR_OUTPUT );
00003c  2101              MOVS     r1,#1
00003e  201a              MOVS     r0,#0x1a
000040  f7fffffe          BL       kdp520_gpio_setdir
;;;103        kdp520_gpio_cleardata( 1<<GPIO_26);
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       kdp520_gpio_cleardata
;;;104        
;;;105        delay_us(1000);
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       delay_us
;;;106    
;;;107        PINMUX_SD_DATA2_SET(PINMUX_SD_DATA2_GPIO26);//RGB reset
000050  6820              LDR      r0,[r4,#0]
000052  f0200007          BIC      r0,r0,#7
000056  1cc0              ADDS     r0,r0,#3
000058  6020              STR      r0,[r4,#0]
;;;108        kdp520_gpio_setdir(  GPIO_26, GPIO_DIR_OUTPUT );
00005a  2101              MOVS     r1,#1
00005c  201a              MOVS     r0,#0x1a
00005e  f7fffffe          BL       kdp520_gpio_setdir
;;;109        kdp520_gpio_setdata( 1<<GPIO_26);
000062  4628              MOV      r0,r5
000064  e8bd4070          POP      {r4-r6,lr}
000068  f7ffbffe          B.W      kdp520_gpio_setdata
;;;110        
;;;111    }
;;;112    
                          ENDP

                  |L12.108|
                          DCD      0xc2380000

                          AREA ||i.rgb_led_close||, CODE, READONLY, ALIGN=2

                  rgb_led_close PROC
;;;443    
;;;444    void rgb_led_close(void) 
000000  4803              LDR      r0,|L13.16|
;;;445    {
;;;446    #if ( CFG_LED_DRIVER_TYPE != LED_DRIVER_AW36515 )
;;;447        if (0 != _rgb_led_value)
000002  88c1              LDRH     r1,[r0,#6]  ; _rgb_led_value
000004  2900              CMP      r1,#0                 ;445
000006  d001              BEQ      |L13.12|
;;;448        {
;;;449            rgb_led_init(0);
;;;450            _rgb_led_value = 0;
000008  2100              MOVS     r1,#0
00000a  80c1              STRH     r1,[r0,#6]
                  |L13.12|
;;;451        }
;;;452    #endif
;;;453    }
00000c  4770              BX       lr
;;;454    
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      ||.data||

                          AREA ||i.rgb_led_init||, CODE, READONLY, ALIGN=1

                  rgb_led_init PROC
;;;420    //volatile u8 rgb_pulse_cnt=255;
;;;421    void rgb_led_init(u16 duty)
000000  4770              BX       lr
;;;422    {
;;;423    #if ( CFG_LED_DRIVER_TYPE != LED_DRIVER_AW36515 )
;;;424    //    static u8 rgb_pulse_cnt=255;
;;;425    //    PINMUX_PWM0_SET(PINMUX_PWM0_GPIO31);
;;;426    //    aw36404_init(GPIO_31, &rgb_pulse_cnt, duty);
;;;427    //    PINMUX_LC_DATA14_SET(PINMUX_LC_DATA14_GPIO3);
;;;428    //    aw36404_init(GPIO_3, &rgb_pulse_cnt, duty);
;;;429    #endif
;;;430    }
;;;431    
                          ENDP


                          AREA ||i.rgb_led_open||, CODE, READONLY, ALIGN=2

                  rgb_led_open PROC
;;;431    
;;;432    void rgb_led_open(u16 level)
000000  4904              LDR      r1,|L15.20|
;;;433    {
;;;434    #if CFG_ONE_SHOT_MODE == YES
;;;435        if( skip_all_led == TRUE ) return;
000002  780a              LDRB     r2,[r1,#0]  ; skip_all_led
000004  2a01              CMP      r2,#1
000006  d003              BEQ      |L15.16|
;;;436    #endif
;;;437    #if ( CFG_LED_DRIVER_TYPE != LED_DRIVER_AW36515 )
;;;438        u16 duty = (level > 100) ? (100) : (level);
000008  2864              CMP      r0,#0x64
00000a  d900              BLS      |L15.14|
00000c  2064              MOVS     r0,#0x64
                  |L15.14|
;;;439        rgb_led_init(duty);
;;;440        _rgb_led_value = duty;
00000e  80c8              STRH     r0,[r1,#6]
                  |L15.16|
;;;441    #endif
;;;442    }
000010  4770              BX       lr
;;;443    
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      ||.data||

                          AREA ||i.tp_power_off||, CODE, READONLY, ALIGN=2

                  tp_power_off PROC
;;;487    }
;;;488    void tp_power_off(void)
000000  4803              LDR      r0,|L16.16|
;;;489    {
;;;490        if (tp_is_powered_on)
000002  7901              LDRB     r1,[r0,#4]  ; tp_is_powered_on
000004  2900              CMP      r1,#0                 ;489
000006  d001              BEQ      |L16.12|
;;;491        {
;;;492            //dbg_msg_user("[%s]", __func__);
;;;493            _io_extender_set_io(IOEXT_REG_SET_IO_P1, IOEXT_P1, 1);
;;;494            tp_is_powered_on = FALSE;
000008  2100              MOVS     r1,#0
00000a  7101              STRB     r1,[r0,#4]
                  |L16.12|
;;;495        }
;;;496    }
00000c  4770              BX       lr
;;;497    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      ||.data||

                          AREA ||i.tp_power_on||, CODE, READONLY, ALIGN=2

                  tp_power_on PROC
;;;475    BOOL tp_is_powered_on = FALSE;
;;;476    void tp_power_on(void)
000000  b510              PUSH     {r4,lr}
;;;477    {
;;;478        if (!tp_is_powered_on)
000002  4c06              LDR      r4,|L17.28|
000004  7920              LDRB     r0,[r4,#4]  ; tp_is_powered_on
000006  2800              CMP      r0,#0                 ;477
000008  d107              BNE      |L17.26|
;;;479        {
;;;480            lcd_power_on();
00000a  f7fffffe          BL       lcd_power_on
;;;481            //dbg_msg_user("[%s]", __func__);
;;;482            _io_extender_set_io(IOEXT_REG_SET_IO_P1, IOEXT_P0, 1);//RST_N
;;;483            _io_extender_set_io(IOEXT_REG_SET_IO_P1, IOEXT_P1, 0);//EN_N
;;;484            delay_us(300);
00000e  f44f7096          MOV      r0,#0x12c
000012  f7fffffe          BL       delay_us
;;;485            tp_is_powered_on = TRUE;
000016  2001              MOVS     r0,#1
000018  7120              STRB     r0,[r4,#4]
                  |L17.26|
;;;486        }
;;;487    }
00001a  bd10              POP      {r4,pc}
;;;488    void tp_power_off(void)
                          ENDP

                  |L17.28|
                          DCD      ||.data||

                          AREA ||i.user_console_cmd01||, CODE, READONLY, ALIGN=1

                  user_console_cmd01 PROC
;;;631    
;;;632    void user_console_cmd01(void)
000000  4770              BX       lr
;;;633    {
;;;634    }
;;;635    
                          ENDP


                          AREA ||i.user_console_cmd02||, CODE, READONLY, ALIGN=1

                  user_console_cmd02 PROC
;;;635    
;;;636    void user_console_cmd02(void)
000000  4770              BX       lr
;;;637    {
;;;638    }
;;;639    
                          ENDP


                          AREA ||i.user_console_cmd03||, CODE, READONLY, ALIGN=1

                  user_console_cmd03 PROC
;;;639    
;;;640    void user_console_cmd03(void)
000000  4770              BX       lr
;;;641    {
;;;642    }
;;;643    
                          ENDP


                          AREA ||i.user_console_cmd04||, CODE, READONLY, ALIGN=1

                  user_console_cmd04 PROC
;;;643    
;;;644    void user_console_cmd04(void)
000000  4770              BX       lr
;;;645    {
;;;646    }
;;;647    
                          ENDP


                          AREA ||i.user_console_cmd05||, CODE, READONLY, ALIGN=1

                  user_console_cmd05 PROC
;;;647    
;;;648    void user_console_cmd05(void)
000000  4770              BX       lr
;;;649    {
;;;650    }
                          ENDP


                          AREA ||i.user_io_chk_backlight||, CODE, READONLY, ALIGN=2

                  user_io_chk_backlight PROC
;;;532    
;;;533    void user_io_chk_backlight(void)
000000  b570              PUSH     {r4-r6,lr}
;;;534    {
;;;535        if (!flag_display_backlight)
000002  4c12              LDR      r4,|L23.76|
000004  7960              LDRB     r0,[r4,#5]  ; flag_display_backlight
000006  2800              CMP      r0,#0                 ;534
000008  d11f              BNE      |L23.74|
;;;536        {
;;;537            kdp520_gpio_setedgemode(1 << GPIO_TE, 0);
00000a  f44f3580          MOV      r5,#0x10000
00000e  2100              MOVS     r1,#0
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       kdp520_gpio_setedgemode
;;;538            kdp520_gpio_enableint( GPIO_TE, GPIO_EDGE, GPIO_Rising);
000016  2200              MOVS     r2,#0
000018  4611              MOV      r1,r2
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       kdp520_gpio_enableint
;;;539            kdp520_wait_gpio_int(1<<GPIO_TE);
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       kdp520_wait_gpio_int
;;;540            osDelay(10);
000026  200a              MOVS     r0,#0xa
000028  f7fffffe          BL       osDelay
;;;541            kdp520_wait_gpio_int(1<<GPIO_TE);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       kdp520_wait_gpio_int
;;;542            kdp520_gpio_disableint(GPIO_TE);
000032  2010              MOVS     r0,#0x10
000034  f7fffffe          BL       kdp520_gpio_disableint
;;;543    
;;;544            flag_display_backlight = TRUE;
000038  2001              MOVS     r0,#1
00003a  7160              STRB     r0,[r4,#5]
;;;545    
;;;546            if(user_io_get_backlight())
00003c  68a0              LDR      r0,[r4,#8]  ; _glight
00003e  2800              CMP      r0,#0
000040  d003              BEQ      |L23.74|
;;;547            {
;;;548                user_io_set_backlight(user_io_get_backlight());
000042  e8bd4070          POP      {r4-r6,lr}
000046  f7ffbffe          B.W      user_io_set_backlight
                  |L23.74|
;;;549            }
;;;550        }
;;;551    }
00004a  bd70              POP      {r4-r6,pc}
;;;552    
                          ENDP

                  |L23.76|
                          DCD      ||.data||

                          AREA ||i.user_io_get_backlight||, CODE, READONLY, ALIGN=2

                  user_io_get_backlight PROC
;;;499    int _glight = 50;
;;;500    int user_io_get_backlight(void)
000000  4801              LDR      r0,|L24.8|
;;;501    {
;;;502    	return _glight;
000002  6880              LDR      r0,[r0,#8]  ; _glight
;;;503    }
000004  4770              BX       lr
;;;504    
                          ENDP

000006  0000              DCW      0x0000
                  |L24.8|
                          DCD      ||.data||

                          AREA ||i.user_io_get_extra_device_cnt||, CODE, READONLY, ALIGN=1

                  user_io_get_extra_device_cnt PROC
;;;599    
;;;600    u32 user_io_get_extra_device_cnt(void)
000000  2000              MOVS     r0,#0
;;;601    {
;;;602        return 0;
;;;603    }
000002  4770              BX       lr
;;;604    
                          ENDP


                          AREA ||i.user_io_get_extra_device_id||, CODE, READONLY, ALIGN=1

                  user_io_get_extra_device_id PROC
;;;604    
;;;605    u32 user_io_get_extra_device_id(u32 device_idx)
000000  2000              MOVS     r0,#0
;;;606    {
;;;607        u8 data = 0;
;;;608    //    if (device_idx < user_io_get_extra_device_cnt()) {
;;;609    //        switch (device_idx) {
;;;610    //        case 0: kdp_drv_i2c_read(__i2c_port, IOEXT_SLAVE_ADDR, IOEXT_REG_ID, 1, &data); if (IO_EXTENDER_ID != data) data = 0; break;
;;;611    //        default:;
;;;612    //        }
;;;613    //    }
;;;614        
;;;615        return (u32)data;
;;;616    }
000002  4770              BX       lr
;;;617    
                          ENDP


                          AREA ||i.user_io_get_extra_device_name||, CODE, READONLY, ALIGN=1

                  user_io_get_extra_device_name PROC
;;;617    
;;;618    void user_io_get_extra_device_name(u32 device_idx, char *out_name, u32 max_lenth)
000000  4770              BX       lr
;;;619    {
;;;620    //    if (device_idx < user_io_get_extra_device_cnt()) {
;;;621    //        switch (device_idx) {
;;;622    //        case 0: strncpy(out_name, "aw9523b", max_lenth); break;
;;;623    //        default:;
;;;624    //        }
;;;625    //    }
;;;626    }
;;;627    
                          ENDP


                          AREA ||i.user_io_init||, CODE, READONLY, ALIGN=2

                  user_io_init PROC
;;;567    
;;;568    void user_io_init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;569    {
;;;570        /*
;;;571        _io_extender_init();
;;;572        */
;;;573        rgb_led_close();
000002  f7fffffe          BL       rgb_led_close
;;;574        nir_led_init(0);
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       nir_led_init
;;;575    
;;;576        backlight_init();
;;;577    
;;;578        //rgb_camera_power_off();
;;;579        //nir_camera_power_off();
;;;580        /*
;;;581        lcd_power_off();
;;;582        tp_power_off();
;;;583        */
;;;584    #if ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36515 )
;;;585        kl520_api_led_register_hook( CAMERA_DEVICE_NIR_IDX, nir_led_open, nir_led_close, led_set_light_mode );
;;;586        kl520_api_led_register_hook( CAMERA_DEVICE_RGB_IDX, rgb_led_open, rgb_led_close, led_set_light_mode );
;;;587    #else
;;;588        kl520_api_led_register_hook(CAMERA_DEVICE_NIR_IDX, nir_led_open, nir_led_close);
00000c  4c0f              LDR      r4,|L28.76|
00000e  4a0d              LDR      r2,|L28.68|
000010  490d              LDR      r1,|L28.72|
000012  7820              LDRB     r0,[r4,#0]  ; nir_sensor_index
000014  f7fffffe          BL       kl520_api_led_register_hook
;;;589        kl520_api_led_register_hook(CAMERA_DEVICE_RGB_IDX, rgb_led_open, rgb_led_close);
000018  4d0f              LDR      r5,|L28.88|
00001a  4a0d              LDR      r2,|L28.80|
00001c  490d              LDR      r1,|L28.84|
00001e  7828              LDRB     r0,[r5,#0]  ; rgb_sensor_index
000020  f7fffffe          BL       kl520_api_led_register_hook
;;;590    #endif
;;;591        kl520_api_light_sensor_register_hook(user_io_light_sensor_get);
000024  480d              LDR      r0,|L28.92|
000026  f7fffffe          BL       kl520_api_light_sensor_register_hook
;;;592    
;;;593        kl520_api_camera_register_hook(CAMERA_DEVICE_NIR_IDX, nir_camera_power_on, nir_camera_power_off);
00002a  4a0d              LDR      r2,|L28.96|
00002c  490d              LDR      r1,|L28.100|
00002e  7820              LDRB     r0,[r4,#0]  ; nir_sensor_index
000030  f7fffffe          BL       kl520_api_camera_register_hook
;;;594        kl520_api_camera_register_hook(CAMERA_DEVICE_RGB_IDX, rgb_camera_power_on, rgb_camera_power_off);
000034  7828              LDRB     r0,[r5,#0]  ; rgb_sensor_index
000036  e8bd4070          POP      {r4-r6,lr}
00003a  4a0b              LDR      r2,|L28.104|
00003c  490b              LDR      r1,|L28.108|
00003e  f7ffbffe          B.W      kl520_api_camera_register_hook
;;;595        /*
;;;596        kl520_api_touch_register_hook(tp_power_on, tp_power_off);
;;;597        */
;;;598    }
;;;599    
                          ENDP

000042  0000              DCW      0x0000
                  |L28.68|
                          DCD      nir_led_close
                  |L28.72|
                          DCD      nir_led_open
                  |L28.76|
                          DCD      nir_sensor_index
                  |L28.80|
                          DCD      rgb_led_close
                  |L28.84|
                          DCD      rgb_led_open
                  |L28.88|
                          DCD      rgb_sensor_index
                  |L28.92|
                          DCD      user_io_light_sensor_get
                  |L28.96|
                          DCD      nir_camera_power_off
                  |L28.100|
                          DCD      nir_camera_power_on
                  |L28.104|
                          DCD      rgb_camera_power_off
                  |L28.108|
                          DCD      rgb_camera_power_on

                          AREA ||i.user_io_light_sensor_get||, CODE, READONLY, ALIGN=1

                  user_io_light_sensor_get PROC
;;;561    /* allowed quantized value : 0 ~ 1023 */
;;;562    int user_io_light_sensor_get(void)
000000  b510              PUSH     {r4,lr}
;;;563    {
;;;564        kdp520_adc_init();
000002  f7fffffe          BL       kdp520_adc_init
;;;565        return kdp520_adc_read(0);
000006  e8bd4010          POP      {r4,lr}
00000a  2000              MOVS     r0,#0
00000c  f7ffbffe          B.W      kdp520_adc_read
;;;566    }
;;;567    
                          ENDP


                          AREA ||i.user_io_poweroff||, CODE, READONLY, ALIGN=1

                  user_io_poweroff PROC
;;;627    
;;;628    void user_io_poweroff(void)
000000  4770              BX       lr
;;;629    {
;;;630    }
;;;631    
                          ENDP


                          AREA ||i.user_io_set_backlight||, CODE, READONLY, ALIGN=2

                  user_io_set_backlight PROC
;;;504    
;;;505    int user_io_set_backlight(int light)
000000  4901              LDR      r1,|L31.8|
;;;506    {   
;;;507    #if ( CFG_PANEL_TYPE != PANEL_NULL )
;;;508        u32 duty;
;;;509        if(flag_display_backlight)
;;;510        {
;;;511            duty = light;
;;;512        }
;;;513        else
;;;514        {
;;;515            duty = 0;
;;;516        }
;;;517        
;;;518        static u8 lcd_bl_pulse_cnt=255;
;;;519        PINMUX_LC_DATA12_SET(PINMUX_LC_DATA12_GPIO1);
;;;520        aw36404_init(GPIO_1, &lcd_bl_pulse_cnt, duty);
;;;521    
;;;522        if(light == 0)
;;;523        {
;;;524            flag_display_backlight = FALSE;
;;;525            return 0;
;;;526        }
;;;527    #endif
;;;528        _glight = light;
000002  6088              STR      r0,[r1,#8]  ; _glight
;;;529        
;;;530    	return _glight;
;;;531    }
000004  4770              BX       lr
;;;532    
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  skip_all_led
000000  00                DCB      0x00
                  rgb_camera_is_powered_on
000001  00                DCB      0x00
                  nir_camera_is_powered_on
000002  00                DCB      0x00
                  lcd_power_is_opened
000003  00                DCB      0x00
                  tp_is_powered_on
000004  00                DCB      0x00
                  flag_display_backlight
000005  00                DCB      0x00
                  _rgb_led_value
000006  ffff              DCW      0xffff
                  _glight
                          DCD      0x00000032

                          AREA ||area_number.35||, DATA, ALIGN=0

                          EXPORTAS ||area_number.35||, ||.data||
                  production_test_flag
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\user\\user_io.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_user_io_c_84608c3d____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___9_user_io_c_84608c3d____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_user_io_c_84608c3d____REVSH|
#line 223
|__asm___9_user_io_c_84608c3d____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_user_io_c_84608c3d____RRX|
#line 410
|__asm___9_user_io_c_84608c3d____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
