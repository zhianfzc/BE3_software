L 1 "..\..\user\main.c"
N/* --------------------------------------------------------------------------
N * Copyright (c) 2013-2016 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N *      Name:    main.c
N *      Purpose: RTX for Kneron
N *
N *---------------------------------------------------------------------------*/
N#include "board_kl520.h"
L 1 "..\..\..\..\board\board_kl520.h" 1
N#ifndef __BOARD_KL520_H__
N#define __BOARD_KL520_H__
N#include <stdio.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 4 "..\..\..\..\board\board_kl520.h" 2
N#include <string.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 5 "..\..\..\..\board\board_kl520.h" 2
N#include "string.h"
N#include <cmsis_os2.h>
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include\cmsis_os2.h" 1
N/*
N * Copyright (c) 2013-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * ----------------------------------------------------------------------
N *
N * $Date:        12. June 2020
N * $Revision:    V2.1.3
N *
N * Project:      CMSIS-RTOS2 API
N * Title:        cmsis_os2.h header file
N *
N * Version 2.1.3
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osThreadGetId
N * Version 2.1.2
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osKernelGetInfo, osKernelGetState
N * Version 2.1.1
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osKernelGetTickCount, osKernelGetTickFreq
N *    Changed Kernel Tick type to uint32_t:
N *    - updated: osKernelGetTickCount, osDelayUntil
N * Version 2.1.0
N *    Support for critical and uncritical sections (nesting safe):
N *    - updated: osKernelLock, osKernelUnlock
N *    - added: osKernelRestoreLock
N *    Updated Thread and Event Flags:
N *    - changed flags parameter and return type from int32_t to uint32_t
N * Version 2.0.0
N *    Initial Release
N *---------------------------------------------------------------------------*/
N 
N#ifndef CMSIS_OS2_H_
N#define CMSIS_OS2_H_
N 
N#ifndef __NO_RETURN
N#if   defined(__CC_ARM)
X#if   1L
N#define __NO_RETURN __declspec(noreturn)
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S#define __NO_RETURN __attribute__((__noreturn__))
S#elif defined(__GNUC__)
S#define __NO_RETURN __attribute__((__noreturn__))
S#elif defined(__ICCARM__)
S#define __NO_RETURN __noreturn
S#else
S#define __NO_RETURN
N#endif
N#endif
N 
N#include <stdint.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 65 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include\cmsis_os2.h" 2
N#include <stddef.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
X  #elif !0L
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 66 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include\cmsis_os2.h" 2
N 
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N 
N 
N//  ==== Enumerations, structures, defines ====
N 
N/// Version information.
Ntypedef struct {
N  uint32_t                       api;   ///< API version (major.minor.rev: mmnnnrrrr dec).
N  uint32_t                    kernel;   ///< Kernel version (major.minor.rev: mmnnnrrrr dec).
N} osVersion_t;
N 
N/// Kernel state.
Ntypedef enum {
N  osKernelInactive        =  0,         ///< Inactive.
N  osKernelReady           =  1,         ///< Ready.
N  osKernelRunning         =  2,         ///< Running.
N  osKernelLocked          =  3,         ///< Locked.
N  osKernelSuspended       =  4,         ///< Suspended.
N  osKernelError           = -1,         ///< Error.
N  osKernelReserved        = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osKernelState_t;
N 
N/// Thread state.
Ntypedef enum {
N  osThreadInactive        =  0,         ///< Inactive.
N  osThreadReady           =  1,         ///< Ready.
N  osThreadRunning         =  2,         ///< Running.
N  osThreadBlocked         =  3,         ///< Blocked.
N  osThreadTerminated      =  4,         ///< Terminated.
N  osThreadError           = -1,         ///< Error.
N  osThreadReserved        = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osThreadState_t;
N 
N/// Priority values.
Ntypedef enum {
N  osPriorityNone          =  0,         ///< No priority (not initialized).
N  osPriorityIdle          =  1,         ///< Reserved for Idle thread.
N  osPriorityLow           =  8,         ///< Priority: low
N  osPriorityLow1          =  8+1,       ///< Priority: low + 1
N  osPriorityLow2          =  8+2,       ///< Priority: low + 2
N  osPriorityLow3          =  8+3,       ///< Priority: low + 3
N  osPriorityLow4          =  8+4,       ///< Priority: low + 4
N  osPriorityLow5          =  8+5,       ///< Priority: low + 5
N  osPriorityLow6          =  8+6,       ///< Priority: low + 6
N  osPriorityLow7          =  8+7,       ///< Priority: low + 7
N  osPriorityBelowNormal   = 16,         ///< Priority: below normal
N  osPriorityBelowNormal1  = 16+1,       ///< Priority: below normal + 1
N  osPriorityBelowNormal2  = 16+2,       ///< Priority: below normal + 2
N  osPriorityBelowNormal3  = 16+3,       ///< Priority: below normal + 3
N  osPriorityBelowNormal4  = 16+4,       ///< Priority: below normal + 4
N  osPriorityBelowNormal5  = 16+5,       ///< Priority: below normal + 5
N  osPriorityBelowNormal6  = 16+6,       ///< Priority: below normal + 6
N  osPriorityBelowNormal7  = 16+7,       ///< Priority: below normal + 7
N  osPriorityNormal        = 24,         ///< Priority: normal
N  osPriorityNormal1       = 24+1,       ///< Priority: normal + 1
N  osPriorityNormal2       = 24+2,       ///< Priority: normal + 2
N  osPriorityNormal3       = 24+3,       ///< Priority: normal + 3
N  osPriorityNormal4       = 24+4,       ///< Priority: normal + 4
N  osPriorityNormal5       = 24+5,       ///< Priority: normal + 5
N  osPriorityNormal6       = 24+6,       ///< Priority: normal + 6
N  osPriorityNormal7       = 24+7,       ///< Priority: normal + 7
N  osPriorityAboveNormal   = 32,         ///< Priority: above normal
N  osPriorityAboveNormal1  = 32+1,       ///< Priority: above normal + 1
N  osPriorityAboveNormal2  = 32+2,       ///< Priority: above normal + 2
N  osPriorityAboveNormal3  = 32+3,       ///< Priority: above normal + 3
N  osPriorityAboveNormal4  = 32+4,       ///< Priority: above normal + 4
N  osPriorityAboveNormal5  = 32+5,       ///< Priority: above normal + 5
N  osPriorityAboveNormal6  = 32+6,       ///< Priority: above normal + 6
N  osPriorityAboveNormal7  = 32+7,       ///< Priority: above normal + 7
N  osPriorityHigh          = 40,         ///< Priority: high
N  osPriorityHigh1         = 40+1,       ///< Priority: high + 1
N  osPriorityHigh2         = 40+2,       ///< Priority: high + 2
N  osPriorityHigh3         = 40+3,       ///< Priority: high + 3
N  osPriorityHigh4         = 40+4,       ///< Priority: high + 4
N  osPriorityHigh5         = 40+5,       ///< Priority: high + 5
N  osPriorityHigh6         = 40+6,       ///< Priority: high + 6
N  osPriorityHigh7         = 40+7,       ///< Priority: high + 7
N  osPriorityRealtime      = 48,         ///< Priority: realtime
N  osPriorityRealtime1     = 48+1,       ///< Priority: realtime + 1
N  osPriorityRealtime2     = 48+2,       ///< Priority: realtime + 2
N  osPriorityRealtime3     = 48+3,       ///< Priority: realtime + 3
N  osPriorityRealtime4     = 48+4,       ///< Priority: realtime + 4
N  osPriorityRealtime5     = 48+5,       ///< Priority: realtime + 5
N  osPriorityRealtime6     = 48+6,       ///< Priority: realtime + 6
N  osPriorityRealtime7     = 48+7,       ///< Priority: realtime + 7
N  osPriorityISR           = 56,         ///< Reserved for ISR deferred thread.
N  osPriorityError         = -1,         ///< System cannot determine priority or illegal priority.
N  osPriorityReserved      = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osPriority_t;
N 
N/// Entry point of a thread.
Ntypedef void (*osThreadFunc_t) (void *argument);
N 
N/// Timer callback function.
Ntypedef void (*osTimerFunc_t) (void *argument);
N 
N/// Timer type.
Ntypedef enum {
N  osTimerOnce               = 0,          ///< One-shot timer.
N  osTimerPeriodic           = 1           ///< Repeating timer.
N} osTimerType_t;
N 
N// Timeout value.
N#define osWaitForever         0xFFFFFFFFU ///< Wait forever timeout value.
N 
N// Flags options (\ref osThreadFlagsWait and \ref osEventFlagsWait).
N#define osFlagsWaitAny        0x00000000U ///< Wait for any flag (default).
N#define osFlagsWaitAll        0x00000001U ///< Wait for all flags.
N#define osFlagsNoClear        0x00000002U ///< Do not clear flags which have been specified to wait for.
N 
N// Flags errors (returned by osThreadFlagsXxxx and osEventFlagsXxxx).
N#define osFlagsError          0x80000000U ///< Error indicator.
N#define osFlagsErrorUnknown   0xFFFFFFFFU ///< osError (-1).
N#define osFlagsErrorTimeout   0xFFFFFFFEU ///< osErrorTimeout (-2).
N#define osFlagsErrorResource  0xFFFFFFFDU ///< osErrorResource (-3).
N#define osFlagsErrorParameter 0xFFFFFFFCU ///< osErrorParameter (-4).
N#define osFlagsErrorISR       0xFFFFFFFAU ///< osErrorISR (-6).
N 
N// Thread attributes (attr_bits in \ref osThreadAttr_t).
N#define osThreadDetached      0x00000000U ///< Thread created in detached mode (default)
N#define osThreadJoinable      0x00000001U ///< Thread created in joinable mode
N 
N// Mutex attributes (attr_bits in \ref osMutexAttr_t).
N#define osMutexRecursive      0x00000001U ///< Recursive mutex.
N#define osMutexPrioInherit    0x00000002U ///< Priority inherit protocol.
N#define osMutexRobust         0x00000008U ///< Robust mutex.
N 
N/// Status code values returned by CMSIS-RTOS functions.
Ntypedef enum {
N  osOK                      =  0,         ///< Operation completed successfully.
N  osError                   = -1,         ///< Unspecified RTOS error: run-time error but no other error message fits.
N  osErrorTimeout            = -2,         ///< Operation not completed within the timeout period.
N  osErrorResource           = -3,         ///< Resource not available.
N  osErrorParameter          = -4,         ///< Parameter error.
N  osErrorNoMemory           = -5,         ///< System is out of memory: it was impossible to allocate or reserve memory for the operation.
N  osErrorISR                = -6,         ///< Not allowed in ISR context: the function cannot be called from interrupt service routines.
N  osStatusReserved          = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osStatus_t;
N 
N 
N/// \details Thread ID identifies the thread.
Ntypedef void *osThreadId_t;
N 
N/// \details Timer ID identifies the timer.
Ntypedef void *osTimerId_t;
N 
N/// \details Event Flags ID identifies the event flags.
Ntypedef void *osEventFlagsId_t;
N 
N/// \details Mutex ID identifies the mutex.
Ntypedef void *osMutexId_t;
N 
N/// \details Semaphore ID identifies the semaphore.
Ntypedef void *osSemaphoreId_t;
N 
N/// \details Memory Pool ID identifies the memory pool.
Ntypedef void *osMemoryPoolId_t;
N 
N/// \details Message Queue ID identifies the message queue.
Ntypedef void *osMessageQueueId_t;
N 
N 
N#ifndef TZ_MODULEID_T
N#define TZ_MODULEID_T
N/// \details Data type that identifies secure software modules called by a process.
Ntypedef uint32_t TZ_ModuleId_t;
N#endif
N 
N 
N/// Attributes structure for thread.
Ntypedef struct {
N  const char                   *name;   ///< name of the thread
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                   *stack_mem;    ///< memory for stack
N  uint32_t                stack_size;   ///< size of stack
N  osPriority_t              priority;   ///< initial thread priority (default: osPriorityNormal)
N  TZ_ModuleId_t            tz_module;   ///< TrustZone module identifier
N  uint32_t                  reserved;   ///< reserved (must be 0)
N} osThreadAttr_t;
N 
N/// Attributes structure for timer.
Ntypedef struct {
N  const char                   *name;   ///< name of the timer
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osTimerAttr_t;
N 
N/// Attributes structure for event flags.
Ntypedef struct {
N  const char                   *name;   ///< name of the event flags
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osEventFlagsAttr_t;
N 
N/// Attributes structure for mutex.
Ntypedef struct {
N  const char                   *name;   ///< name of the mutex
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osMutexAttr_t;
N 
N/// Attributes structure for semaphore.
Ntypedef struct {
N  const char                   *name;   ///< name of the semaphore
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osSemaphoreAttr_t;
N 
N/// Attributes structure for memory pool.
Ntypedef struct {
N  const char                   *name;   ///< name of the memory pool
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                      *mp_mem;    ///< memory for data storage
N  uint32_t                   mp_size;   ///< size of provided memory for data storage 
N} osMemoryPoolAttr_t;
N 
N/// Attributes structure for message queue.
Ntypedef struct {
N  const char                   *name;   ///< name of the message queue
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                      *mq_mem;    ///< memory for data storage
N  uint32_t                   mq_size;   ///< size of provided memory for data storage 
N} osMessageQueueAttr_t;
N 
N 
N//  ==== Kernel Management Functions ====
N 
N/// Initialize the RTOS Kernel.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelInitialize (void);
N 
N///  Get RTOS Kernel Information.
N/// \param[out]    version       pointer to buffer for retrieving version information.
N/// \param[out]    id_buf        pointer to buffer for retrieving kernel identification string.
N/// \param[in]     id_size       size of buffer for kernel identification string.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size);
N 
N/// Get the current RTOS Kernel state.
N/// \return current RTOS Kernel state.
NosKernelState_t osKernelGetState (void);
N 
N/// Start the RTOS Kernel scheduler.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelStart (void);
N 
N/// Lock the RTOS Kernel scheduler.
N/// \return previous lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelLock (void);
N 
N/// Unlock the RTOS Kernel scheduler.
N/// \return previous lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelUnlock (void);
N 
N/// Restore the RTOS Kernel scheduler lock state.
N/// \param[in]     lock          lock state obtained by \ref osKernelLock or \ref osKernelUnlock.
N/// \return new lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelRestoreLock (int32_t lock);
N 
N/// Suspend the RTOS Kernel scheduler.
N/// \return time in ticks, for how long the system can sleep or power-down.
Nuint32_t osKernelSuspend (void);
N 
N/// Resume the RTOS Kernel scheduler.
N/// \param[in]     sleep_ticks   time in ticks for how long the system was in sleep or power-down mode.
Nvoid osKernelResume (uint32_t sleep_ticks);
N 
N/// Get the RTOS kernel tick count.
N/// \return RTOS kernel current tick count.
Nuint32_t osKernelGetTickCount (void);
N 
N/// Get the RTOS kernel tick frequency.
N/// \return frequency of the kernel tick in hertz, i.e. kernel ticks per second.
Nuint32_t osKernelGetTickFreq (void);
N 
N/// Get the RTOS kernel system timer count.
N/// \return RTOS kernel current system timer count as 32-bit value.
Nuint32_t osKernelGetSysTimerCount (void);
N 
N/// Get the RTOS kernel system timer frequency.
N/// \return frequency of the system timer in hertz, i.e. timer ticks per second.
Nuint32_t osKernelGetSysTimerFreq (void);
N 
N 
N//  ==== Thread Management Functions ====
N 
N/// Create a thread and add it to Active Threads.
N/// \param[in]     func          thread function.
N/// \param[in]     argument      pointer that is passed to the thread function as start argument.
N/// \param[in]     attr          thread attributes; NULL: default values.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr);
N 
N/// Get name of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return name as null-terminated string.
Nconst char *osThreadGetName (osThreadId_t thread_id);
N 
N/// Return the thread ID of the current running thread.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId_t osThreadGetId (void);
N 
N/// Get current thread state of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return current thread state of the specified thread.
NosThreadState_t osThreadGetState (osThreadId_t thread_id);
N 
N/// Get stack size of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return stack size in bytes.
Nuint32_t osThreadGetStackSize (osThreadId_t thread_id);
N 
N/// Get available stack space of a thread based on stack watermark recording during execution.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return remaining stack space in bytes.
Nuint32_t osThreadGetStackSpace (osThreadId_t thread_id);
N 
N/// Change priority of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \param[in]     priority      new priority value for the thread function.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority);
N 
N/// Get current priority of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return current priority value of the specified thread.
NosPriority_t osThreadGetPriority (osThreadId_t thread_id);
N 
N/// Pass control to next thread that is in state \b READY.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadYield (void);
N 
N/// Suspend execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadSuspend (osThreadId_t thread_id);
N 
N/// Resume execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadResume (osThreadId_t thread_id);
N 
N/// Detach a thread (thread storage can be reclaimed when thread terminates).
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadDetach (osThreadId_t thread_id);
N 
N/// Wait for specified thread to terminate.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadJoin (osThreadId_t thread_id);
N 
N/// Terminate execution of current running thread.
N__NO_RETURN void osThreadExit (void);
X__declspec(noreturn) void osThreadExit (void);
N 
N/// Terminate execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadTerminate (osThreadId_t thread_id);
N 
N/// Get number of active threads.
N/// \return number of active threads.
Nuint32_t osThreadGetCount (void);
N 
N/// Enumerate active threads.
N/// \param[out]    thread_array  pointer to array for retrieving thread IDs.
N/// \param[in]     array_items   maximum number of items in array for retrieving thread IDs.
N/// \return number of enumerated threads.
Nuint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items);
N 
N 
N//  ==== Thread Flags Functions ====
N 
N/// Set the specified Thread Flags of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \param[in]     flags         specifies the flags of the thread that shall be set.
N/// \return thread flags after setting or error code if highest bit set.
Nuint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags);
N 
N/// Clear the specified Thread Flags of current running thread.
N/// \param[in]     flags         specifies the flags of the thread that shall be cleared.
N/// \return thread flags before clearing or error code if highest bit set.
Nuint32_t osThreadFlagsClear (uint32_t flags);
N 
N/// Get the current Thread Flags of current running thread.
N/// \return current thread flags.
Nuint32_t osThreadFlagsGet (void);
N 
N/// Wait for one or more Thread Flags of the current running thread to become signaled.
N/// \param[in]     flags         specifies the flags to wait for.
N/// \param[in]     options       specifies flags options (osFlagsXxxx).
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return thread flags before clearing or error code if highest bit set.
Nuint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout);
N 
N 
N//  ==== Generic Wait Functions ====
N 
N/// Wait for Timeout (Time Delay).
N/// \param[in]     ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value
N/// \return status code that indicates the execution status of the function.
NosStatus_t osDelay (uint32_t ticks);
N 
N/// Wait until specified time.
N/// \param[in]     ticks         absolute time in ticks
N/// \return status code that indicates the execution status of the function.
NosStatus_t osDelayUntil (uint32_t ticks);
N 
N 
N//  ==== Timer Management Functions ====
N 
N/// Create and Initialize a timer.
N/// \param[in]     func          function pointer to callback function.
N/// \param[in]     type          \ref osTimerOnce for one-shot or \ref osTimerPeriodic for periodic behavior.
N/// \param[in]     argument      argument to the timer callback function.
N/// \param[in]     attr          timer attributes; NULL: default values.
N/// \return timer ID for reference by other functions or NULL in case of error.
NosTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr);
N 
N/// Get name of a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return name as null-terminated string.
Nconst char *osTimerGetName (osTimerId_t timer_id);
N 
N/// Start or restart a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \param[in]     ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value of the timer.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks);
N 
N/// Stop a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerStop (osTimerId_t timer_id);
N 
N/// Check if a timer is running.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return 0 not running, 1 running.
Nuint32_t osTimerIsRunning (osTimerId_t timer_id);
N 
N/// Delete a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerDelete (osTimerId_t timer_id);
N 
N 
N//  ==== Event Flags Management Functions ====
N 
N/// Create and Initialize an Event Flags object.
N/// \param[in]     attr          event flags attributes; NULL: default values.
N/// \return event flags ID for reference by other functions or NULL in case of error.
NosEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr);
N 
N/// Get name of an Event Flags object.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return name as null-terminated string.
Nconst char *osEventFlagsGetName (osEventFlagsId_t ef_id);
N 
N/// Set the specified Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags that shall be set.
N/// \return event flags after setting or error code if highest bit set.
Nuint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags);
N 
N/// Clear the specified Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags that shall be cleared.
N/// \return event flags before clearing or error code if highest bit set.
Nuint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags);
N 
N/// Get the current Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return current event flags.
Nuint32_t osEventFlagsGet (osEventFlagsId_t ef_id);
N 
N/// Wait for one or more Event Flags to become signaled.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags to wait for.
N/// \param[in]     options       specifies flags options (osFlagsXxxx).
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return event flags before clearing or error code if highest bit set.
Nuint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout);
N 
N/// Delete an Event Flags object.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id);
N 
N 
N//  ==== Mutex Management Functions ====
N 
N/// Create and Initialize a Mutex object.
N/// \param[in]     attr          mutex attributes; NULL: default values.
N/// \return mutex ID for reference by other functions or NULL in case of error.
NosMutexId_t osMutexNew (const osMutexAttr_t *attr);
N 
N/// Get name of a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return name as null-terminated string.
Nconst char *osMutexGetName (osMutexId_t mutex_id);
N 
N/// Acquire a Mutex or timeout if it is locked.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout);
N 
N/// Release a Mutex that was acquired by \ref osMutexAcquire.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexRelease (osMutexId_t mutex_id);
N 
N/// Get Thread which owns a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return thread ID of owner thread or NULL when mutex was not acquired.
NosThreadId_t osMutexGetOwner (osMutexId_t mutex_id);
N 
N/// Delete a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexDelete (osMutexId_t mutex_id);
N 
N 
N//  ==== Semaphore Management Functions ====
N 
N/// Create and Initialize a Semaphore object.
N/// \param[in]     max_count     maximum number of available tokens.
N/// \param[in]     initial_count initial number of available tokens.
N/// \param[in]     attr          semaphore attributes; NULL: default values.
N/// \return semaphore ID for reference by other functions or NULL in case of error.
NosSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr);
N 
N/// Get name of a Semaphore object.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return name as null-terminated string.
Nconst char *osSemaphoreGetName (osSemaphoreId_t semaphore_id);
N 
N/// Acquire a Semaphore token or timeout if no tokens are available.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout);
N 
N/// Release a Semaphore token up to the initial maximum count.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id);
N 
N/// Get current Semaphore token count.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return number of tokens available.
Nuint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id);
N 
N/// Delete a Semaphore object.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id);
N 
N 
N//  ==== Memory Pool Management Functions ====
N 
N/// Create and Initialize a Memory Pool object.
N/// \param[in]     block_count   maximum number of memory blocks in memory pool.
N/// \param[in]     block_size    memory block size in bytes.
N/// \param[in]     attr          memory pool attributes; NULL: default values.
N/// \return memory pool ID for reference by other functions or NULL in case of error.
NosMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr);
N 
N/// Get name of a Memory Pool object.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return name as null-terminated string.
Nconst char *osMemoryPoolGetName (osMemoryPoolId_t mp_id);
N 
N/// Allocate a memory block from a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return address of the allocated memory block or NULL in case of no memory is available.
Nvoid *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout);
N 
N/// Return an allocated memory block back to a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \param[in]     block         address of the allocated memory block to be returned to the memory pool.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block);
N 
N/// Get maximum number of memory blocks in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return maximum number of memory blocks.
Nuint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id);
N 
N/// Get memory block size in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return memory block size in bytes.
Nuint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id);
N 
N/// Get number of memory blocks used in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return number of memory blocks used.
Nuint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id);
N 
N/// Get number of memory blocks available in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return number of memory blocks available.
Nuint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id);
N 
N/// Delete a Memory Pool object.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id);
N 
N 
N//  ==== Message Queue Management Functions ====
N 
N/// Create and Initialize a Message Queue object.
N/// \param[in]     msg_count     maximum number of messages in queue.
N/// \param[in]     msg_size      maximum message size in bytes.
N/// \param[in]     attr          message queue attributes; NULL: default values.
N/// \return message queue ID for reference by other functions or NULL in case of error.
NosMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr);
N 
N/// Get name of a Message Queue object.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return name as null-terminated string.
Nconst char *osMessageQueueGetName (osMessageQueueId_t mq_id);
N 
N/// Put a Message into a Queue or timeout if Queue is full.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \param[in]     msg_ptr       pointer to buffer with message to put into a queue.
N/// \param[in]     msg_prio      message priority.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout);
N 
N/// Get a Message from a Queue or timeout if Queue is empty.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \param[out]    msg_ptr       pointer to buffer for message to get from a queue.
N/// \param[out]    msg_prio      pointer to buffer for message priority or NULL.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout);
N 
N/// Get maximum number of messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return maximum number of messages.
Nuint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id);
N 
N/// Get maximum message size in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return maximum message size in bytes.
Nuint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id);
N 
N/// Get number of queued messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return number of queued messages.
Nuint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id);
N 
N/// Get number of available slots for messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return number of available slots for messages.
Nuint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id);
N 
N/// Reset a Message Queue to initial empty state.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueReset (osMessageQueueId_t mq_id);
N 
N/// Delete a Message Queue object.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id);
N 
N 
N#ifdef  __cplusplus
S}
N#endif
N 
N#endif  // CMSIS_OS2_H_
L 7 "..\..\..\..\board\board_kl520.h" 2
N#include "cmsis_os2.h"                    // ARM::CMSIS:RTOS2:Keil RTX5
N#include "types.h"
L 1 "..\..\..\..\common\include\types.h" 1
N#ifndef TYPES_H
N#define TYPES_H
N
N#include <stdint.h>
N#include <stdbool.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 6 "..\..\..\..\common\include\types.h" 2
N
N//#if TARGET_SCPU
N#define BS              0x08
N#define ESC				27
N
N#ifndef NULL
S#define NULL    0
N#endif
N
N#ifndef ENABLE
N#define ENABLE  1
N#endif
N
N#ifndef DISABLE
N#define DISABLE 0
N#endif
N
N#ifndef FALSE
N#define FALSE   0
N#endif
N
N#ifndef TRUE
N#define TRUE    1
N#endif
N#if 0
Stypedef int bool;
S#define true 1
S#define false 0
N#endif
N/* type define */
N	typedef unsigned long long 		UINT64;
N	typedef long long 				INT64;
N	typedef	unsigned int			UINT32;
N	typedef	int						INT32;
N	typedef	unsigned short			UINT16;
N	typedef	short					INT16;
N	typedef unsigned char			UINT8;
N	typedef char					INT8;
N	typedef unsigned char			BOOL;
N
N	typedef unsigned char           u8_t;
N	typedef unsigned short          u16_t;
N	typedef unsigned long           u32_t;
N	typedef unsigned long long		u64_t;
N
N	typedef unsigned char 			uchar;
N
N    typedef char                    s8;
N	typedef short                   s16;
N    typedef int                     s32;
N    typedef long long               s64;
N
N    typedef unsigned char           u8;
N	typedef unsigned short          u16;
N    typedef unsigned int            u32;
N    typedef unsigned long long      u64;
N
N#ifndef _SIZE_T
N#define _SIZE_T
Ntypedef unsigned int size_t;
N#endif
N
N#ifndef _SSIZE_T
N#define _SSIZE_T
Ntypedef long ssize_t;
N#endif
N
Ntypedef INT8          INT8S;
Ntypedef UINT8         INT8U;
Ntypedef INT16         INT16S;
Ntypedef UINT16        INT16U;
Ntypedef INT32         INT32S;
Ntypedef UINT32        INT32U;
N
N
Ntypedef unsigned char                   byte;
Ntypedef unsigned short                  word;
Ntypedef unsigned long int               dword;
N
N//#endif
N
N#endif //TYPES_H
L 9 "..\..\..\..\board\board_kl520.h" 2
N#include "delay.h"
L 1 "..\..\..\..\common\include\delay.h" 1
N/*
N * Kneron Delay driver
N *
N * Copyright (C) 2019 Kneron, Inc. All rights reserved.
N *
N */
N
N#ifndef __DELAY_H__
N#define __DELAY_H__
N
N/**
N * @brief microseconds delay for any cpu
N *
N * @param [in] usec number of microseconds
N * @return No
N */
Nvoid delay_us(unsigned int usec);
N
Nvoid delay_ms_enable(void);
Nvoid delay_ms_disable(void);
Nvoid delay_ms(unsigned int msec);
N
N#endif
L 10 "..\..\..\..\board\board_kl520.h" 2
N#include "base.h"
L 1 "..\..\..\..\common\include\base.h" 1
N/**
N * @file      base.h
N * @brief     Basic utils & struct
N * @copyright (c) 2018 Kneron Inc. All right reserved.
N */
N
N#ifndef __BASE_H__
N#define __BASE_H__
N
N
N#define BIT0                            0x00000001
N#define BIT1                            0x00000002
N#define BIT2                            0x00000004
N#define BIT3                            0x00000008
N#define BIT4                            0x00000010
N#define BIT5                            0x00000020
N#define BIT6                            0x00000040
N#define BIT7                            0x00000080
N#define BIT8                            0x00000100
N#define BIT9                            0x00000200
N#define BIT10                           0x00000400
N#define BIT11                           0x00000800
N#define BIT12                           0x00001000
N#define BIT13                           0x00002000
N#define BIT14                           0x00004000
N#define BIT15                           0x00008000
N#define BIT16                           0x00010000
N#define BIT17                           0x00020000
N#define BIT18                           0x00040000
N#define BIT19                           0x00080000
N#define BIT20                           0x00100000
N#define BIT21                           0x00200000
N#define BIT22                           0x00400000
N#define BIT23                           0x00800000
N#define BIT24                           0x01000000
N#define BIT25                           0x02000000
N#define BIT26                           0x04000000
N#define BIT27                           0x08000000
N#define BIT28                           0x10000000
N#define BIT29                           0x20000000
N#define BIT30                           0x40000000
N#define BIT31                           0x80000000
N
N#ifndef BIT
N#define BIT(x)      (0x01U << (x))
N#endif
N
N#define divRoundDown(n,s)   ((n) / (s))
N#define divRoundUp(n,s)     ((n+s-1)/(s))
N
N#define ARRAY_SIZE(x) 		(sizeof(x) / sizeof((x)[0]))
N
N#define RoundUp(val, units) \
N		((((unsigned long)(val) + ((units) - 1)) / (units)) * (units))
X#define RoundUp(val, units) 		((((unsigned long)(val) + ((units) - 1)) / (units)) * (units))
N#define RoundDown(val, units) \
N		(((unsigned long)(val)/(units))*(units))
X#define RoundDown(val, units) 		(((unsigned long)(val)/(units))*(units))
N    
N#include "io.h"
L 1 "..\..\..\..\scpu\drivers\include\io.h" 1
N#ifndef IO_H
N#define IO_H
N
N
N#define readl(addr)             (*(volatile unsigned int *)(addr))
N#define writel(val, addr)       (*(volatile unsigned int *)(addr) = (val))
N
N#define readw(addr)             (*(volatile unsigned short *)(addr))
N#define writew(val, addr)       (*(volatile unsigned short *)(addr) = (val))
N
N#define readb(addr)             (*(volatile unsigned char *)(addr))
N#define writeb(val, addr)       (*(volatile unsigned char *)(addr) = (val))
N
N#define inl(p)                  readl(p)
N#define outl(v, p)              writel(v, p)
N
N#define inw(port)               readl(port)
N#define outw(port, val)         writel(val, port)
N
N#define inb(port)               readb(port)
N#define outb(port, val)         writeb(val, port)
N
N//#define inhw(port)            readw(port)
N//#define outhw(port, val)      writew(val, port)
N#define inhw(port)              readl(port)
N#define outhw(port, val)        writel(val, port)
N
N#define u32Lib_LeRead32(x)      *((volatile INT32U *)((INT8U * )x)) //bessel:add  (INT8U * )
N#define vLib_LeWrite32(x,y)     *(volatile INT32U *)((INT8U * )x)=(y)  //bessel:add  (INT8U * )
N
N#define masked_outw(port, val, mask)    outw(port, (inw(port) & ~mask) | (val & mask))
N
N#define GET_BIT(port, __bit) \
N    ((inw(port) & BIT##__bit) >> __bit)
X#define GET_BIT(port, __bit)     ((inw(port) & BIT##__bit) >> __bit)
N
N#define GET_BITS(port, __s_bit, __e_bit) \
N    ((inw(port) & (BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) >> __s_bit)
X#define GET_BITS(port, __s_bit, __e_bit)     ((inw(port) & (BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) >> __s_bit)
N
N#define SET_BIT(port, __bit) \
N    outw(port, BIT##__bit)
X#define SET_BIT(port, __bit)     outw(port, BIT##__bit)
N
N#define SET_MASKED_BIT(port, val, __bit) \
N    outw(port, (inw(port) & ~BIT##__bit) | ((val << __bit) & BIT##__bit))
X#define SET_MASKED_BIT(port, val, __bit)     outw(port, (inw(port) & ~BIT##__bit) | ((val << __bit) & BIT##__bit))
N
N#define SET_MASKED_BITS(port, val, __s_bit, __e_bit) \
N    outw(port, ((inw(port) & ~(BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) | (val << __s_bit))); 
X#define SET_MASKED_BITS(port, val, __s_bit, __e_bit)     outw(port, ((inw(port) & ~(BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) | (val << __s_bit))); 
N
N
N#endif // IO_H
L 59 "..\..\..\..\common\include\base.h" 2
N        
N#endif
N
N
L 11 "..\..\..\..\board\board_kl520.h" 2
N#include "dbg.h"
L 1 "..\..\..\..\common\include\dbg.h" 1
N/**
N * @file      dbg.h
N * @brief     debug macro 
N * @copyright (c) 2018 Kneron Inc. All right reserved.
N */
N
N#ifndef __DBG_H__
N#define __DBG_H__
N
N#include <stdio.h>
N#include "ipc.h"
L 1 "..\..\..\..\common\include\ipc.h" 1
N/*
N * Kneron IPC Header for KL520
N *
N * Copyright (C) 2018-2019 Kneron, Inc. All rights reserved.
N *
N */
N
N#ifndef KNERON_IPC_H
N#define KNERON_IPC_H
N
N#include <stdint.h>
N#include "model_type.h"
L 1 "..\..\..\..\common\include\model_type.h" 1
N#ifndef __MODEL_TYPE_H
N#define __MODEL_TYPE_H
N
N
Nenum model_type {
N#if 0
S    INVALID_ID,
S    KNERON_FDSMALLBOX                   = 1,
S    KNERON_FDANCHOR                     = 2,
S    KNERON_FDSSD                        = 32,
S    AVERAGE_POOLING                     = 4,
S    KNERON_LM_5PTS                      = 5,
S    KNERON_LM_68PTS                     = 6,
S    KNERON_LM_150PTS                    = 7,
S    //KNERON_FR_RES50                     = 8,
S    KNERON_FR_RES34                     = 9,
S    KNERON_FR_VGG10                     = 8,
S    KNERON_TINY_YOLO_PERSON             = 11,
S    KNERON_3D_LIVENESS                  = 12,
S    KNERON_GESTURE_RETINANET            = 13,
S    TINY_YOLO_VOC                       = 14,
S    IMAGENET_CLASSIFICATION_RES50       = 15,
S    IMAGENET_CLASSIFICATION_RES34       = 16,
S    IMAGENET_CLASSIFICATION_INCEPTION_V3= 17,
S    IMAGENET_CLASSIFICATION_MOBILENET_V2= 18,
S    TINY_YOLO_V3                        = 19,
S	KNERON_2D_LIVENESS                  = 20,
S    KNERON_FD_RETINANET                 = 21,
S    KNERON_SSD_PERSON                   = 22,
S    KNERON_AGE_GENDER                   = 23,
S	KNERON_NIR_LIVENESS                 = 30,
S    KNERON_FUSE_LIVENESS                = 41,
S	KNERON_CV_LIVENESS                  = 26,
S    KNERON_OD_MBSSD                     = 27,
S    KNERON_AGE_GROUP                    = 28,
S    KNERON_LM_S_5PTS                    = 55,
S    //KNERON_NIR_HSN_LIVENESS             = 32,
S    KNERON_LM_EYE_LID                   = 42,
S    KNERON_FACE_QUALITY                 = 40,
S    KNERON_RGB_LIVENESS                 = 57,
S    KNERON_NIR_OCCLUDE                  = 51,
S    UPHOTON_LIVENESS                    = 1001,
S		KNERON_FACESEG_DLA34_128_128_3      = 58
N#endif
N    UPHOTON_LIVENESS                    = 1001,
N	INVALID_TYPE = 0,
N	KNERON_FD_SMALLBOX_200_200_3 = 1,
N	KNERON_FD_ANCHOR_200_200_3 = 2,
N	KNERON_FD_MBSSD_200_200_3= 3,
N	AVERAGE_POOLING = 4, //use with FD smallbox and don't use anymore
N	KNERON_LM_5PTS_ONET_56_56_3 = 5,
N	KNERON_LM_68PTS_dlib_112_112_3 = 6,
N	KNERON_LM_150PTS = 7,
N	KNERON_FR_RES50_112_112_3 = 8,
N    //KNERON_FR_RES50_COMPACT=39,
N	KNERON_FR_RES34 = 9,
N	KNERON_FR_VGG10 = 10,
N	KNERON_TINY_YOLO_PERSON_416_416_3 = 11,
N	KNERON_3D_LIVENESS = 12, //has two inputs: depth and RGB
N	KNERON_GESTURE_RETINANET_320_320_3 = 13,
N	TINY_YOLO_VOC_224_224_3 = 14,
N	IMAGENET_CLASSIFICATION_RES50_224_224_3 = 15,
N	IMAGENET_CLASSIFICATION_RES34_224_224_3 = 16,
N	IMAGENET_CLASSIFICATION_INCEPTION_V3_224_224_3 = 17,
N	IMAGENET_CLASSIFICATION_MOBILENET_V2_224_224_3 = 18,
N	TINY_YOLO_V3_224_224_3 = 19,
N	KNERON_2D_LIVENESS_224_224_3 = 20, //oldest rgb liveness model and don't use anymore
N	KNERON_FD_RETINANET_256_256_3 = 21,
N	KNERON_PERSON_MOBILENETSSD_224_224_3 = 22,
N	KNERON_AGE_GENDER = 23, //oldest age gender model and don't use anymore 
N	KNERON_LM_5PTS_BLUR_ONET_48_48_3 = 24,
N	KNERON_2D_LIVENESS_V3_FACEBAGNET_224_224_3 = 25,
N    KNERON_AGE_GENDER_V2_RES18_128_128_3 = 26,
N	KNERON_OD_MBSSD = 27, //HW model and don't know input size
N	KNERON_PD_MBSSD = 28, //HW model and don't know which version and input size
N	KNERON_FR_MASK_RES50_112_112_3 = 29, 
N	KNERON_NIR_LIVENESS_RES18_112_112_3 = 30,
N	KNERON_FR_MASK_RES101_112_112_3 = 31,
N    KNERON_FD_MASK_MBSSD_200_200_3 = 32,	
N    TINY_YOLO_V3_416_416_3 = 33,
N    TINY_YOLO_V3_608_608_3 = 34,
N
N	//Category Face related 40~200
N	KNERON_CAT_FACE = 40,
N	KNERON_FACE_QAULITY_ONET_56_56_1 = KNERON_CAT_FACE,
N	KNERON_FUSE_LIVENESS = KNERON_CAT_FACE +1, // don't know the model backbone and input size of fuse liveness model
N	KNERON_EYELID_DETECTION_ONET_48_48_3 = KNERON_CAT_FACE +2,
N	KNERON_YAWN_DETECTION_PFLD_112_112_3 = KNERON_CAT_FACE +3,
N	KNERON_DBFACE_MBNET_V2_480_864_3 = KNERON_CAT_FACE +4,
N	KNERON_FILTER = KNERON_CAT_FACE +5, //No model inference, just pre and post-process
N	KNERON_ALIGNMENT = KNERON_CAT_FACE +6, //No model inference, just preprocess
N	KNERON_FACE_EXPRESSION_112_112_3 = KNERON_CAT_FACE +7,
N	KNERON_RBG_OCCLUSION_RES18_112_112_3 = KNERON_CAT_FACE +8,
N	KNERON_LM2BBOX = KNERON_CAT_FACE + 9, //No model inference, just post-process
N	KNERON_PUPIL_ONET_48_48_3 = KNERON_CAT_FACE +10,
N    KNERON_NIR_OCCLUSION_RES18_112_112_3 = KNERON_CAT_FACE +11,
N    KNERON_HEAD_SHOULDER_MBNET_V2_112_112_3 = KNERON_CAT_FACE + 12,
N    KNERON_RGB_LIVENESS_RES18_112_112_3 = KNERON_CAT_FACE +13, 
N	KNERON_MOUTH_LM_v1_56_56_1 = KNERON_CAT_FACE +14,    //nose, upper lip middle, chin, two sides of faces
N	KNERON_MOUTH_LM_v2_56_56_1 = KNERON_CAT_FACE +15,    //nose, upper/lower lip middle, two sides of faces
N	KNERON_PUPIL_ONET_48_48_1 = KNERON_CAT_FACE +16,
N    KNERON_RGB_LIVENESS_MBV2_112_112_3 = KNERON_CAT_FACE +17,
N    KNERON_FACESEG_DLA34_128_128_3 = KNERON_CAT_FACE +18,
N    KNERON_OCC_CLS = KNERON_CAT_FACE +19, //no model inference, just post-process
N    KNERON_LMSEG_FUSE = KNERON_CAT_FACE+20, //no model inference, just post-process
N    KNERON_FUSE_LIVENESS_850 = 65,
N    KNERON_FUSE_SC035        = 98,
N    KNERON_FUSE_DUAL_1054    = 103,
N    KNERON_FUSE_LIVENESS_850_940 = 77,
N    KNERON_FACE_POSE = 68,
N    KNERON_FUSE_NIR_LV = 76,
N
N    KNERON_FD_ROTATE=63,
N    KNERON_LM_ROTATE=64,
N    KNERON_FACE_POSE_ROTATE=71,
N    KNERON_NIR_LV_ROTATE=72,
N    KNERON_HSN_LV_ROTATE=81,
N    KNERON_LM_S_ROTATE=87,
N    KNERON_LM_PLUS_ROTATE=93,
N    KNERON_FD_FCOS_ROTATE=94,
N    KNERON_NIR_LV_ROTATE_1054=104,
N    KNERON_FD_FCOS_ROTATE_1054=106,
N    KNERON_HSN_LV_ROTATE_1054=109,
N    KNERON_NIR_COMBO_ROTATE_1054=111,
N    KNERON_FR_RES50_1054=39,
N
N    KNERON_FACE_PUPIL_CLS2_48_48_3 = KNERON_CAT_FACE +52,
N    
N    KNERON_FACE_PUPIL_ROTATE_CLS2_48_48_3 = KNERON_CAT_FACE +56,
N    KNERON_FACESEG_DLA34_rotate_128_128_3 = KNERON_CAT_FACE +60,
N    KNERON_FACESEG_ROTATE = 119,
N    KNERON_TOF_FR50M_112_112_3 = 120,
N
N	//Category Object Detection related 200~300
N	KNERON_OB_DETECT = 200,
N	KNERON_OBJECTDETECTION_CENTERNET_512_512_3 = KNERON_OB_DETECT,
N	KNERON_OBJECTDETECTION_FCOS_416_416_3 = KNERON_OB_DETECT +1,
N	KNERON_PD_MBNET_V2_480_864_3 = KNERON_OB_DETECT +2, //16:9 aspect ratio
N	KNERON_CAR_DETECTION_MBSSD_224_416_3 = KNERON_OB_DETECT +3,
N	KNERON_PD_CROP_MBSSD_304_304_3 = KNERON_OB_DETECT +4,
N	YOLO_V3_416_416_3 = KNERON_OB_DETECT +5,
N	YOLO_V4_416_416_3 = KNERON_OB_DETECT +6,
N	KNERON_CAR_DETECTION_YOLO_V5_352_640_3 = KNERON_OB_DETECT +7,
N	KNERON_LICENSE_DETECT_WPOD_208_416_3 = KNERON_OB_DETECT +8,
N	KNERON_2D_UPPERBODY_KEYPOINT_RES18_384_288_3 = KNERON_OB_DETECT +9,
N	YOLO_V3_608_608_3 = KNERON_OB_DETECT +10,
N    KNERON_YOLOV5S_640_640_3 = KNERON_OB_DETECT +11,
N    KNERON_YOLOV5S_480_256_3 = KNERON_OB_DETECT + 12,
N    KNERON_SITTINGPOSTURE_RESNET34_288_384_3 = KNERON_OB_DETECT + 13,
N    KNERON_PERSONDETECTION_FCOS_416_416_3 = KNERON_OB_DETECT +14,
N    KNERON_YOLOV5m_640_640_3 = KNERON_OB_DETECT +15,
N    KNERON_YOLOV5S6_480_256_3 = KNERON_OB_DETECT + 16,
N    KNERON_PERSONDETECTION_FCOS_384_288_3 = KNERON_OB_DETECT +17,
N    KNERON_PERSONDETECTION_FCOS_720_416_3 = KNERON_OB_DETECT +18,
N    KNERON_PERSONDETECTION_dbface_864_480_3 = KNERON_OB_DETECT +19,
N        
N
N	//Category OCR related 300~400
N	KNERON_OCR = 300,
N	KNERON_LICENSE_OCR_MBNET_64_160_3 = KNERON_OCR,
N	KNERON_WATERMETER_OCR_MBNET = KNERON_OCR +1, //unknown
N
N
N	//Category SDK test related
N	KNERON_CAT_SDK_TEST = 1000,
N	KNERON_SDK_FD = KNERON_CAT_SDK_TEST,
N	KNERON_SDK_LM = KNERON_CAT_SDK_TEST +1,
N	KNERON_SDK_FR = KNERON_CAT_SDK_TEST +2,
N	
N	// Category Function Runner related 2000
N    KNERON_FUNCTION = 2000,
N    KNERON_FUNCTION_NIRLIVENESS_CLS = KNERON_FUNCTION,
N    KNERON_FUNCTION_OCC_CLS = KNERON_FUNCTION +1,
N    KNERON_FUNCTION_LMSEG_FUSE = KNERON_FUNCTION +2, 
N    KNERON_FUNCTION_FILTER_SCORE = KNERON_FUNCTION +3,
N
N	//Category Customer models
N	//0x8000 = 32768
N	CUSTOMER = 32768,
N
N	Count
N
N};
N#endif
L 13 "..\..\..\..\common\include\ipc.h" 2
N#include "model_res.h"
L 1 "..\..\..\..\common\include\model_res.h" 1
N#ifndef __MODEL_RES_H__
N#define __MODEL_RES_H__
N
N/* These header defines structures shared by scpu/ncpu/host_lib */
N
N#define LAND_MARK_POINTS       5
N#define EYE_LID_LM_POINTS      7
N#define FR_FEATURE_MAP_SIZE    512
N#define LV_R_SIZE              1
N#define LV_SCORE_SIZE          2
N#define DUAL_LAND_MARK_POINTS  10
N#define DME_OBJECT_MAX         80
N#define IMAGENET_TOP_MAX       5
N#define HAND_KEY_POINTS        7
N
N/* Yolo Result */
Nstruct bounding_box_s {
N    float x1;      // top-left corner: x
N    float y1;      // top-left corner: y
N    float x2;      // bottom-right corner: x
N    float y2;      // bottom-right corner: y
N    float score;   // probability score
N    int32_t class_num; // class # (of many) with highest probability
N};
N
Nstruct yolo_result_s {
N    uint32_t class_count;            // total class count
N    uint32_t box_count;              // boxes of all classes
N    struct bounding_box_s boxes[1];  // box_count
N};
N
Nstruct age_gender_result_s {
N    uint32_t age;
N    uint8_t ismale;
N};
N
Nstruct imagenet_result_s {
N    int32_t   index; // index of the class
N    float score; // probability score of the class
N};
N
Nstruct facedet_result_s {
N    int32_t len;
N    int32_t xywh[4]; // 4 values for X, Y, W, H
N    float xywh_fl[4]; // 4 values for X, Y, W, H
N    float score;     //prob score
N    int32_t class_num; //class
N};
N
Nstruct landmark_result_s {
N    struct {
N        uint32_t x;
N        uint32_t y;
N        float    x_f;
N        float    y_f;
N    } marks[LAND_MARK_POINTS];
X    } marks[5];
N    float score;
N    float blur;
N};
N
Nstruct hand_kp_result_s {
N    struct {
N        float    x_f;
N        float    y_f;
N    } marks[HAND_KEY_POINTS];
X    } marks[7];
N    float score;
N};
N
Nstruct eye_lid_lm_result_s {
N    struct {
N        uint32_t x;
N        uint32_t y;
N    } marks[EYE_LID_LM_POINTS];
X    } marks[7];
N    float score;
N};
N
Nstruct face_occlude_result_s {
N    float yaw;
N    float pitch;
N    float roll;
N    float occ;
N    float seg_res[7];
N};
N
Nstruct age_group_result_s {
N    int32_t age;
N};
N
Nstruct face_quality_result_s {
N    float face_score;
N};
N
Nstruct fr_result_s {
N    float feature_map[FR_FEATURE_MAP_SIZE];
X    float feature_map[512];
N};
N
N/* by larry lai */
N
Nstruct lv_result_s{
N    int32_t  real[LV_R_SIZE];
X    int32_t  real[1];
N    float    score[LV_SCORE_SIZE];
X    float    score[2];
N    _Bool    wb_result;
N    float    nir_luma_ratio;
N    uint8_t  rgb_quality;
N    uint8_t  rgb_corner_y;
N    float    effect_2d;
N    uint8_t  cal_nir_led_on_tile;
N    uint8_t  cal_distance;
N    float    id_ref_c;   
N};
N
Nstruct dual_landmarks_s {
N    struct {
N        uint32_t x;
N        uint32_t y;
N    } marks[DUAL_LAND_MARK_POINTS];
X    } marks[10];
N};
N
Ntypedef struct {
N    struct bounding_box_s fd_res;
N    struct age_gender_result_s ag_res;
N} fd_age_gender_res;
N
Ntypedef struct {
N    uint32_t class_count; // total class count
N    uint32_t box_count;   // boxes of all classes
N    struct bounding_box_s boxes[DME_OBJECT_MAX]; // box information
X    struct bounding_box_s boxes[80]; 
N} dme_res;
N
N#endif
L 14 "..\..\..\..\common\include\ipc.h" 2
N
N/* IPC memory */
N//----------------------------
N/* N i/d RAM */
N#ifdef TARGET_NCPU
S#define S_D_RAM_ADDR                0x20200000
S#define N_D_RAM_ADDR                0x0FFF0000
N#endif
N#ifdef TARGET_SCPU
N#define S_D_RAM_ADDR                0x10200000
N#define N_D_RAM_ADDR                0x2FFF0000
N#endif
N
N#define S_D_RAM_SIZE                0x18000          /* 96 KB */
N#define N_D_RAM_SIZE                0x10000          /* 64 KB */
N
N#define IPC_RAM_SIZE                0x2000           /* 8K Bytes : split 7 : 1 */
N#define IPC_MEM_OFFSET              (S_D_RAM_SIZE - IPC_RAM_SIZE)
N#define IPC_MEM_OFFSET2             (S_D_RAM_SIZE - IPC_RAM_SIZE / 8)
N#define IPC_MEM_ADDR                (S_D_RAM_ADDR + IPC_MEM_OFFSET)
N#define IPC_MEM_ADDR2               (S_D_RAM_ADDR + IPC_MEM_OFFSET2)
N//----------------------------
N
N#define SCPU2NCPU_ID		('s'<<24 | 'c'<<16 | 'p'<<8 | 'u')
N#define NCPU2SCPU_ID		('n'<<24 | 'c'<<16 | 'p'<<8 | 'u')
N
N#define MULTI_MODEL_MAX         16      /* Max active models in memory */
N#define IPC_IMAGE_ACTIVE_MAX    2       /* Max active images for NCPU/NPU */
N#define IPC_COM_PAX             IPC_IMAGE_ACTIVE_MAX
N#define IPC_IMAGE_MAX           5       /* Max cycled buffer for images */
N
N/* Image process cmd_flags set by scpu */
N#define IMAGE_STATE_INACTIVE                0
N#define IMAGE_STATE_ACTIVE                  1
N#define IMAGE_STATE_RECEIVING               2
N
N/* Image process status set by ncpu */
N#define IMAGE_STATE_IDLE                    0
N#define IMAGE_STATE_NPU_BUSY                1
N#define IMAGE_STATE_NPU_DONE                2
N#define IMAGE_STATE_POST_PROCESSING         IMAGE_STATE_NPU_DONE
N#define IMAGE_STATE_POST_PROCESSING_DONE    3
N#define IMAGE_STATE_DONE                    IMAGE_STATE_POST_PROCESSING_DONE
N
N#define IMAGE_STATE_PREPROC_ERROR           (-1)
N#define IMAGE_STATE_NPU_ERROR               (-2)
N
N/* Image format flags */
N#define IMAGE_FORMAT_SUB128                 BIT31
N#define IMAGE_FORMAT_ROT_MASK               (BIT30 | BIT29)
N#define IMAGE_FORMAT_ROT_SHIFT              29
N#define IMAGE_FORMAT_ROT_CLOCKWISE          0x01
N#define IMAGE_FORMAT_ROT_COUNTER_CLOCKWISE  0x02
N
N#define IMAGE_FORMAT_RAW_OUTPUT             BIT28
N#define IMAGE_FORMAT_PARALLEL_PROC          BIT27
N
N#define IMAGE_FORMAT_MODEL_AGE_GENDER       BIT24
N
N#define IMAGE_FORMAT_SYMMETRIC_PADDING      BIT21
N#define IMAGE_FORMAT_PAD_MODE               (BIT21 | BIT20)
N#define IMAGE_FORMAT_PAD_SHIFT              20
N
N
N#define IMAGE_FORMAT_CHANGE_ASPECT_RATIO    BIT20
N
N#define IMAGE_FORMAT_BYPASS_PRE             BIT19
N#define IMAGE_FORMAT_BYPASS_NPU_OP          BIT18
N#define IMAGE_FORMAT_BYPASS_CPU_OP          BIT17
N#define IMAGE_FORMAT_BYPASS_POST            BIT16
N
N/* Padding mode */
N#define NPU_PAD_RIGHT_BOTTOM 0
N#define NPU_PAD_NONE         1
N#define NPU_PAD_SYMMETRIC    2
N#define NPU_PAD_PREDEFINED   3
N
N
N#define IMAGE_FORMAT_NPU            0x00FF
N#define NPU_FORMAT_RGBA8888         0x00
N#define NPU_FORMAT_NIR              0x20
N/* Support YCBCR (YUV) */
N#define NPU_FORMAT_YCBCR422         0x30
N#define NPU_FORMAT_YCBCR444         0x50
N#define NPU_FORMAT_RGB565           0x60
N
N/* Determine the exact format with the data byte sequence in DDR memory: [lowest byte]...[highest byte] */
N#define NPU_FORMAT_YCBCR422_CRY1CBY0 0x30
N#define NPU_FORMAT_YCBCR422_CBY1CRY0 0x31
N#define NPU_FORMAT_YCBCR422_Y1CRY0CB 0x32
N#define NPU_FORMAT_YCBCR422_Y1CBY0CR 0x33
N#define NPU_FORMAT_YCBCR422_CRY0CBY1 0x34
N#define NPU_FORMAT_YCBCR422_CBY0CRY1 0x35
N#define NPU_FORMAT_YCBCR422_Y0CRY1CB 0x36
N#define NPU_FORMAT_YCBCR422_Y0CBY1CR 0x37  // Y0CbY1CrY2CbY3Cr...
N
N/* Model structure */
Nstruct kdp_model_s {
N    /* Model type */
N    uint32_t    model_type; //defined in model_type.h
N
N    /* Model version */
N    uint32_t    model_version;
N
N    /* Input in memory */
N    uint32_t    input_mem_addr;
N    int32_t     input_mem_len;
N	
N    /* Output in memory */
N    uint32_t    output_mem_addr;
N    int32_t     output_mem_len;
N
N    /* Working buffer */
N    uint32_t    buf_addr;
N    int32_t     buf_len;
N
N    /* command.bin in memory */
N    uint32_t    cmd_mem_addr;
N    int32_t     cmd_mem_len;
N
N    /* weight.bin in memory */
N    uint32_t    weight_mem_addr;
N    int32_t     weight_mem_len;
N
N    /* setup.bin in memory */
N    uint32_t    setup_mem_addr;
N    int32_t     setup_mem_len;
N};
Ntypedef struct kdp_model_s kdp_model_info_t;
N
N/* Result structure of a model */
Nstruct result_buf_s {
N    int32_t     model_id;
N    uint32_t    result_mem_addr;
N    int32_t     result_mem_len;
N    int32_t     result_ret_len;
N};
N
N#define MAX_PARAMS_LEN          40 /* uint32_t */
N
Nstruct kdp_img_cfg {
N    uint32_t image_mem_addr;
N    int32_t image_mem_len;
N    int32_t image_col;
N    int32_t image_row;
N    int32_t image_ch;
N    uint32_t image_format;
N    uint32_t image_buf_active_index; // scpu_to_ncpu->active_img_index
N};
N
Nstruct kdp_crop_box_s {
N    int32_t top;
N    int32_t bottom;
N    int32_t left;
N    int32_t right;
N};
N
Nstruct kdp_pad_value_s {
N    int32_t pad_top;
N    int32_t pad_bottom;
N    int32_t pad_left;
N    int32_t pad_right;
N};
N
N/* Parameter structure of a raw image */
Nstruct parameter_s {
N    /* Crop parameters or other purposes */
N    int         crop_top;
N    int         crop_bottom;
N    int         crop_left;
N    int         crop_right;
N
N    /* Pad parameters or other purposes */
N    int         pad_top;
N    int         pad_bottom;
N    int         pad_left;
N    int         pad_right;
N    int         flip_face;  // for fr, 0 to not, 1 to flip
N
N    /* Shared parameters */
N    uint32_t    params[MAX_PARAMS_LEN];
X    uint32_t    params[40];
N
N    uint32_t    dual_landmarks[20];
N    uint32_t    dual_landmarks_3d[20];
N    uint8_t     init_tile;
N    uint8_t     nir_mode;
N    float       init_nir_gain;
N    float       nir_gain;
N    uint32_t    nir_cur_exp_time;
N    uint32_t    calibration_count;
N    float       registered_offsetX;
N    float       registered_offsetY;
N    uint8_t     rgb_led_flag;
N    uint8_t     rgb_avg_luma;
N    float       x_scaling;
N    uint8_t     d_offset;
N    uint8_t     pass_type;
N    _Bool       ignore_rgb_led;
N    _Bool       bctc;
N    uint8_t     input_nir_led_on_tile;
N    uint8_t     nir_led_flag;
N    uint8_t     input_distance;
N    uint32_t    rgb_cur_exp_time;
N    uint32_t    rgb_init_exp_time;
N    uint8_t     pre_gain;
N    uint8_t     post_gain;
N    uint8_t     global_gain;
N    uint8_t     y_average;
N    float       rgb_lm_score;
N    float       nir_lv_cnn_face_real_score;
N    float       fuse_lv_cnn_real_score;
N};
N
N/* Raw image structure */
Nstruct kdp_img_raw_s {
N    /* Image state: 1 = active, 0 = inactive */
N    int         state;
N
N    /* Image sequence number */
N    int         seq_num;
N
N    /* Image ref index */
N    int         ref_idx;
N
N    /* raw image dimensions */
N    uint32_t    input_row;
N    uint32_t    input_col;
N    uint32_t    input_channel;
N
N    /* Raw image format and pre-process flags
N     * bit-31: = 1 : subtract 128
N     * bit 30:29 00: no rotation; 01: rotate clockwise; 10: rotate counter clockwise; 11: reserved
N     * bit 7:0: format
N     */
N    uint32_t    format;
N
N    /* Parameter structure */
N    struct parameter_s  params_s;
N
N    /* input image in memory */
N    uint32_t    image_mem_addr;
N    int32_t     image_mem_len;
N
N    struct result_buf_s results[MULTI_MODEL_MAX];
X    struct result_buf_s results[16];
N
N    /* Test: SCPU total */
N    uint32_t    tick_start;
N    uint32_t    tick_end;
N
N    /* Test: NCPU processes */
N    uint32_t    tick_start_pre;
N    uint32_t    tick_end_pre;
N    uint32_t    tick_start_npu;
N    uint32_t    tick_end_npu;
N    uint32_t    tick_start_post;
N    uint32_t    tick_end_post;
N};
N
N/* Image result structure */
Nstruct kdp_img_result_s {
N    /* Processing status: 2 = done, 1 = running, 0 = unused */
N    int         status;
N
N    /* Image sequence number */
N    int         seq_num;
N	
N    /* result memory addr */
N    //dummy information
N    uint32_t    result_mem_addr;
N};
N
N/* Structure of sCPU->nCPU Message */
Nstruct scpu_to_ncpu_s {
N    uint32_t    id;        /* = 'scpu' */
N    uint32_t    version;
N    uint32_t    cmd;            // Run / Stop
N    uint32_t    input_count;    // # of input image
N
N    /*
N     * debug control flags (dbg.h):
N     *   bits 19-16: scpu debug level
N     *   bits 03-00: ncpu debug level
N     */
N    uint32_t    debug_flags;
N
N    /* Active images (& model) being processed by npu/ncpu */
N    uint32_t            cmd_flags[IPC_IMAGE_ACTIVE_MAX]; // discussion, IPC_COM_PAX
X    uint32_t            cmd_flags[2]; 
N    int32_t             active_img_index[IPC_IMAGE_ACTIVE_MAX]; // discussion, raw_imgs_idx[IPC_COM_PAX]
X    int32_t             active_img_index[2]; 
N    int32_t             model_slot_index[IPC_IMAGE_ACTIVE_MAX]; // discussion, models_slot_idx[IPC_COM_PAX]
X    int32_t             model_slot_index[2]; 
N
N    int32_t             active_img_index_rgb_liveness;
N
N    /* Models in memory */
N    int32_t             num_models;  //usually, num_models=1 (only one active model)
N    struct kdp_model_s  models[MULTI_MODEL_MAX];            //to save active modelInfo
X    struct kdp_model_s  models[16];            
N    uint32_t            models_type[MULTI_MODEL_MAX];       //to save model type
X    uint32_t            models_type[16];       
N
N    /* Raw image information */
N    struct kdp_img_raw_s raw_images[IPC_IMAGE_MAX];
X    struct kdp_img_raw_s raw_images[5];
N
N    /* Input/Output working buffers for NPU */
N    uint32_t    input_mem_addr2;
N    int32_t     input_mem_len2;
N
N    /* Memory for parallel processing */
N    uint32_t    output_mem_addr2;
N    int32_t     output_mem_len2;
N
N    /* Memory for pre processing command */
N    uint32_t    inproc_mem_addr;
N    
N    /* Memory for post processing parameters */
N    uint32_t    output_mem_addr3;
N};
N
N/* Structure of nCPU->sCPU Message */
Nstruct ncpu_to_scpu_s {
N    uint32_t    id;        /* = 'ncpu' */
N    uint32_t    version;
N    int32_t     status;
N
N    /* Active pipeline */
N    int32_t     cmd_status[IPC_IMAGE_ACTIVE_MAX];
X    int32_t     cmd_status[2];
N    int32_t     img_index_done[IPC_IMAGE_ACTIVE_MAX]; // for debug only
X    int32_t     img_index_done[2]; 
N
N    /* Images result info corresponding to raw_images[] */
N    struct kdp_img_result_s img_results[IPC_IMAGE_MAX];
X    struct kdp_img_result_s img_results[5];
N};
N
N/* scpu_to_ncpu: cmd */
Nenum {
N    CMD_NO,
N    CMD_STOP_NPU,
N    CMD_RUN_NPU,
N    CMD_RUN_NPU_1,
N    CMD_RUN_NCPU,
N    CMD_RUN_NCPU_1,
N};
N
N/* ncpu_to_scpu: status */
Nenum {
N    STATUS_ERR = -1,
N    STATUS_INIT = 0,
N    STATUS_OK,
N    STATUS_OK_1,
N    STATUS_DDR_FAULT = -101,
N};
N
Nstruct nir_camera_tune_s{
N    uint8_t     init_tile;
N    uint8_t     nir_mode;
N    float       init_nir_gain;
N    float       nir_gain;
N    uint32_t    nir_cur_exp_time;
N    uint32_t    calibration_count;
N    float       registered_offsetX;
N    float       registered_offsetY;
N    uint8_t     rgb_led_flag;
N    uint8_t     rgb_avg_luma;
N    float       x_scaling;
N    uint8_t     d_offset;
N    uint8_t     pass_type;
N    _Bool       ignore_rgb_led;
N    _Bool       bctc;
N    uint8_t     input_nir_led_on_tile;
N    uint8_t     nir_led_flag;
N    uint8_t     input_distance;
N    uint32_t    rgb_cur_exp_time;
N    uint32_t    rgb_init_exp_time; 
N    uint8_t     pre_gain;
N    uint8_t     post_gain;
N    uint8_t     global_gain;
N    uint8_t     y_average;
N    float       rgb_lm_score;
N    float       nir_lv_cnn_face_real_score;
N    float       fuse_lv_cnn_real_score;
N    
N};
N
Nstruct lv_params_s {
N    uint32_t dual_landmarks[DUAL_LAND_MARK_POINTS * 2];
X    uint32_t dual_landmarks[10 * 2];
N    uint32_t dual_landmarks_3d[DUAL_LAND_MARK_POINTS * 2];
X    uint32_t dual_landmarks_3d[10 * 2];
N    struct nir_camera_tune_s nir_tune;
N};
N
N#endif
L 12 "..\..\..\..\common\include\dbg.h" 2
N
N//#define DEV_TEST_VERSION
N//#define DEV_PKT_LOG_DETAIL
N
N#define LOG_NONE        0
N#define LOG_USER        1
N#define LOG_CRITICAL    1
N#define LOG_ERROR       2
N
N#define LOG_INFO        4
N#define LOG_TRACE       5
N#define LOG_DBG         6
N#define LOG_PROFILE     9
N
N#define DEBUG_CONSOLE                  DRVUART_PORT0
N
N#ifdef DEV_TEST_VERSION
S#undef CUSTOMER_SETTING_REMOVE_LOG
N#else
N#define CUSTOMER_SETTING_REMOVE_LOG
N#endif
N
N#ifdef  LOG_ENABLE
N
N#ifdef TARGET_NCPU
S
Sextern void fLib_printf(const char *f, ...);
S
Sextern struct scpu_to_ncpu_s *in_comm_p;
Sextern int ncpu_debug_level;
S#define log_get_level_ncpu()    (in_comm_p->debug_flags & 0x0000000F)
S    
S#ifdef CUSTOMER_SETTING_REMOVE_LOG
S    #define dbg_msg(fmt, ...) 
S    #define trace_msg(fmt, ...) 
S    #define info_msg(fmt, ...) 
S    #define err_msg(fmt, ...) fLib_printf(fmt, ##__VA_ARGS__)
S    #define critical_msg(fmt, ...) 
S    #define profile_msg(fmt, ...) 
S    #define dbg_msg_algo(fmt, ...) //MSG(LOG_CRITICAL, fmt, ##__VA_ARGS__) 
S    #define dbg_msg_algo2(fmt, ...) //MSG(LOG_CRITICAL, fmt, ##__VA_ARGS__) 
S#else
S    #define dbg_msg(fmt, ...) //MSG(LOG_DBG, fmt, ##__VA_ARGS__)
S    #define trace_msg(fmt, ...) //MSG(LOG_TRACE, fmt, ##__VA_ARGS__)
S    #define info_msg(fmt, ...) //MSG(LOG_INFO, fmt, ##__VA_ARGS__)
S    #define err_msg(fmt, ...) fLib_printf(fmt, ##__VA_ARGS__)
S    #define critical_msg(fmt, ...) fLib_printf(fmt, ##__VA_ARGS__)
S    #define profile_msg(fmt, ...) fLib_printf(fmt, ##__VA_ARGS__)
S    #define dbg_msg_algo(fmt, ...) fLib_printf(fmt, ##__VA_ARGS__)
S    #define dbg_msg_algo2(fmt, ...) //MSG(LOG_CRITICAL, fmt, ##__VA_ARGS__) 
S#endif   
S    
S    
N#else // TARGET_SCPU
N
Nextern struct scpu_to_ncpu_s *s_out_comm;
Nextern int scpu_debug_level;
N
N#define MSG(level, format, ...) \
N    do {                                                   \
N        if (level <= scpu_debug_level)                     \
N            kdp_printf(format, ##__VA_ARGS__);            \
N    } while (0)
X#define MSG(level, format, ...)     do {                                                           if (level <= scpu_debug_level)                                 kdp_printf(format, ##__VA_ARGS__);                } while (0)
N
N
Nvoid kdp_printf(const char *f, ...);
Nvoid kdp_level_printf(int level, const char *fmt, ...);
Nvoid kdp_user_level_printf(int level, const char *fmt, ...);
Nvoid kdp_printf_nocrlf(const char *f, ...);
N    
N#define dbg_msg(fmt, ...) //MSG(LOG_DBG, fmt, ##__VA_ARGS__)
N#define trace_msg(fmt, ...) MSG(LOG_TRACE, fmt, ##__VA_ARGS__)
N#define info_msg(fmt, ...) //MSG(LOG_INFO, fmt, ##__VA_ARGS__)
N#define err_msg(fmt, ...) kdp_level_printf(LOG_ERROR, fmt, ##__VA_ARGS__)
N#define critical_msg(fmt, ...) MSG(LOG_CRITICAL, fmt, ##__VA_ARGS__)
N#define profile_msg(fmt, ...) MSG(LOG_PROFILE, fmt, ##__VA_ARGS__)
N
N
N#ifdef CUSTOMER_SETTING_REMOVE_LOG
N    #define dbg_msg_console(__format__, ...) kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_err(__format__, ...) kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_flash(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_camera(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_display(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_touch(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_com(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_gui(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_app(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_e2e(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_api(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_usb(__format__, ...) //{ kdp_printf(__format__"\r\n", ##__VA_ARGS__); }
N    #define dbg_msg_algo(__format__, ...) //kdp_level_printf(LOG_CRITICAL, __format__"\r\n", ##__VA_ARGS__)
N    #define dlog(__format__, ...) //kdp_level_printf(LOG_DBG, "[%s][%s] " __format__ "\r\n", DEF_LOG_CATEG, __func__, ##__VA_ARGS__)
N    #define dbg_msg_model(__format__, ...) kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_ncpu(__format__, ...) //kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_engineering(__format__, ...) //kdp_user_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_tile(__format__, ...) //kdp_level_printf(LOG_USER, __format__, ##__VA_ARGS__)
N#else
S    #define dbg_msg_console(__format__, ...) kdp_printf(__format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_err(__format__, ...) kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_flash(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_camera(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_display(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_touch(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_com(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_gui(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_app(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_e2e(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_api(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_usb(__format__, ...) { kdp_printf(__format__"\r\n", ##__VA_ARGS__); }
S    #define dbg_msg_algo(__format__, ...) kdp_level_printf(LOG_CRITICAL, __format__"\r\n", ##__VA_ARGS__)
S    #define dlog(__format__, ...) kdp_level_printf(LOG_DBG, "[%s][%s] " __format__ "\r\n", DEF_LOG_CATEG, __func__, ##__VA_ARGS__)
S    #define dbg_msg_model(__format__, ...) kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)    
S    #define dbg_msg_ncpu(__format__, ...) //kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_engineering(__format__, ...) //kdp_user_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_tile(__format__, ...) kdp_level_printf(LOG_USER, __format__, ##__VA_ARGS__)
N#endif 
N
N#define dbg_msg_user(__format__, ...) kdp_user_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N#define dbg_msg_nocrlf(__format__, ...) { kdp_printf_nocrlf(__format__, ##__VA_ARGS__); }
N#define dbg_msg_console_zhian(__format__, ...) kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N
N
N#endif
N
N#else
S
N#endif // LOG_ENABLE
N
Nuint32_t log_get_level_scpu(void);
Nuint32_t log_get_user_level_scpu(void);
Nvoid log_set_level_scpu(uint32_t level);
Nvoid log_set_level_ncpu(uint32_t level);
Nvoid log_set_user_level_scpu(uint32_t level);
Nvoid log_set_user_level_ncpu(uint32_t level);
N
N#define kmdw_console_set_log_level_scpu log_set_level_scpu
N#define kmdw_console_set_log_level_ncpu log_set_level_ncpu
N
N#define ASSERT(x)   do { \
N                        if (!(x)) 	\
N                            for (;;)	\
N                                ; 		\
N                    } while (0)
X#define ASSERT(x)   do {                         if (!(x)) 	                            for (;;)	                                ; 		                    } while (0)
N
N#endif // __DBG_H__
L 12 "..\..\..\..\board\board_kl520.h" 2
N
N#include "v2k_image.h"
L 1 "..\..\..\..\scpu\framework\include\framework\v2k_image.h" 1
N/*
N * Standard image size definitions
N */
N#ifndef __V2K_IMAGE_H__
N#define __V2K_IMAGE_H__
N
N#include "v2k.h"
L 1 "..\..\..\..\scpu\framework\include\framework\v2k.h" 1
N#ifndef __V2K_H__
N#define __V2K_H__
N
N
N#define V2K_CAP_VIDEO_CAPTURE   0x00000001  /* Is a video capture device */
N#define V2K_CAP_STREAMING       0x00000002  /* can stream on/off */
N#define V2K_CAP_DEVICE_CAPS     0x00000004  /* can query capabilities */
N
Nenum v2k_field {
N    V2K_FIELD_ANY               = 0, 
N    V2K_FIELD_NONE              = 1, /* this device has no fields ... */
N    V2K_FIELD_INTERLACED        = 4, /* both fields interlaced */
N    V2K_FIELD_INTERLACED_DEPTH  = 0x10, 
N};
N
Nenum v2k_colorspace {
N    V2K_COLORSPACE_RGB          = 0,
N    V2K_COLORSPACE_YUV          = 1,
N    V2K_COLORSPACE_RAW          = 2,
N};
N
Nstruct v2k_rect {
N    int left;
N    int top;
N    unsigned int width;
N    unsigned int height;
N};
N
Nstruct v2k_fract {
N    unsigned int numerator;
N    unsigned int denominator;
N};
N
Nstruct v2k_capability {
N    char driver[16];
N    char desc[16];
N    unsigned int version;
N    unsigned int capabilities;
N    int device_id;
N};
N
Nstruct v2k_format {
N    unsigned int width;
N    unsigned int height;
N    unsigned int pixelformat;    /* fourcc */
N    unsigned int field;          /* enum v2k_field */
N    unsigned int bytesperline;   /* for padding, zero if unused */
N    unsigned int sizeimage;
N    unsigned int colorspace;     /* enum v2k_colorspace */
N};
N
Nstruct v2k_buffer {
N    unsigned int type;
N    unsigned int index;
N    unsigned int flags;
N    unsigned int field;
N    unsigned int length;
N    unsigned int offset;
N    unsigned long timestamp;    
N};
N
Nstruct v2k_requestbuffers {
N    unsigned int count;
N};
N
Nstruct v2k_dev_operations;
Nstruct v2k_dev_handle {
N    int i_rdev;
N    void *private_data;
N    const struct v2k_dev_operations *dev_ops;
N};
N
Nstruct v2k_dev_operations {
N    int (*open)(struct v2k_dev_handle *);
N    int (*close)(struct v2k_dev_handle *);
N    //int (*release)(struct v2k_dev_handle *);
N    long (*ioctl)(struct v2k_dev_handle *, unsigned int, void * );    
N};
N
N#define v2k_fourcc(a, b, c, d) \
N    ((unsigned int)(a) | ((unsigned int)(b) << 8) | ((unsigned int)(c) << 16) | ((unsigned int)(d) << 24))
X#define v2k_fourcc(a, b, c, d)     ((unsigned int)(a) | ((unsigned int)(b) << 8) | ((unsigned int)(c) << 16) | ((unsigned int)(d) << 24))
N
N#define V2K_PIX_FMT_YCBCR   v2k_fourcc('Y', 'B', 'Y', 'R')
N#define V2K_PIX_FMT_RGB565  v2k_fourcc('R', 'G', 'B', 'P')
N#define V2K_PIX_FMT_RAW10   v2k_fourcc('R', 'A', '1', '0')
N#define V2K_PIX_FMT_RAW8    v2k_fourcc('R', 'A', 'W', '8')
N
N#define V2K_TYPE_STATIC   	0
N#define V2K_TYPE_DYNAMIC    1
N
N#endif 
L 8 "..\..\..\..\scpu\framework\include\framework\v2k_image.h" 2
N
N#define QVGA_LANDSCAPE_WIDTH    320
N#define QVGA_LANDSCAPE_HEIGHT   240
N#define QVGA_PORTRAIT_WIDTH     240
N#define QVGA_PORTRAIT_HEIGHT    320
N
N#define TFT43_WIDTH             480
N#define TFT43_HEIGHT            272
N
N#define VGA_LANDSCAPE_WIDTH     640
N#define VGA_LANDSCAPE_HEIGHT    480
N#define VGA_PORTRAIT_WIDTH      480
N#define VGA_PORTRAIT_HEIGHT     640
N
N#define HD_WIDTH                1280
N#define HD_HEIGHT               720
N
N#define FHD_WIDTH               1920
N#define FHD_HEIGHT              1080
N
N#define HMX_RICA_WIDTH          864
N#define HMX_RICA_HEIGHT         491
N
N#define QVGA_WIDTH              1280
N#define QVGA_HEIGHT             960
N
N#define UGA_WIDTH               1600
N#define UGA_HEIGHT              1200
N
N#define SC132_FULL_RES_WIDTH    1080
N#define SC132_FULL_RES_HEIGHT   1280
N
N
Nenum image_input_format {
N    image_input_format_rgb565 = 0,
N    image_input_format_rgb555,
N    image_input_format_rgb444,
N    image_input_format_rgb24,
N    image_input_format_ycbcr422,
N    image_input_format_ycbcr420,
N    image_input_format_palette_8,
N    image_input_format_palette_4,
N    image_input_format_palette_2,
N    image_input_format_palette_1,
N};
N
Nstruct sensor_datafmt_info {
N    unsigned int fourcc;
N    enum v2k_colorspace colorspace;
N};
N
Nstruct sensor_win_size {
N    unsigned int width;
N    unsigned int height;
N};
N
N// move this to a better place
Nstruct sensor_init_seq {
N    unsigned short addr;
N    unsigned char value;
N}__attribute__((packed));
N
N
Nstruct video_input_params {
N
N    unsigned int    src_fmt;
N    unsigned int    src_type;
N    unsigned short  src_cam_idx;    //input
N    unsigned short  src_width;      //input
N    unsigned short  src_height;     //input
N    
N    unsigned short  dp_area_x;      //display area x relative to src_width
N    unsigned short  dp_area_y;      //display area y relative to src_height
N    unsigned short  dp_area_w;      //display area width relative to src_width 
N    unsigned short  dp_area_h;      //display area height relative to src_height
N    unsigned short  dp_out_w;       //display width
N    unsigned short  dp_out_h;       //display height
N
N    unsigned short  panel_in_w;    //screen in
N    unsigned short  panel_in_h;    //screen in
N    unsigned short  panel_out_w;   //screen out
N    unsigned short  panel_out_h;   //screen out
N};
N
Nstruct kdp_rect {
N    unsigned short start_x;
N    unsigned short start_y;
N    unsigned short end_x;
N    unsigned short end_y;
N};
N
Nint calc_framesize(
N        unsigned short frame_width, 
N        unsigned short frame_height, 
N        unsigned int input_fmt);
N
N#endif
L 14 "..\..\..\..\board\board_kl520.h" 2
N#include "board_cfg.h"
L 1 "..\..\config\board_cfg.h" 1
N#ifndef __BOARD_CFG_H__
N#define __BOARD_CFG_H__
N
N
N// PRE-definition for board configuration
N#define SENSOR_TYPE_NULL                                                                -1
N#define SENSOR_TYPE_HMX2056                                                              0
N#define SENSOR_TYPE_OV9286                                                               1
N#define SENSOR_TYPE_HMXRICA                                                              2
N#define SENSOR_TYPE_GC2145                                                               3
N#define SENSOR_TYPE_SC132GS                                                              4
N#define SENSOR_TYPE_SC035HGS                                                             5
N#define SENSOR_TYPE_GC1054_R                                                             6
N#define SENSOR_TYPE_GC1054_L                                                             7
N#define SENSOR_TYPE_SP2509_R                                                             8
N#define SENSOR_TYPE_SP2509_L                                                             9
N#define SENSOR_TYPE_MIXO3238                                                            10
N#define SENSOR_TYPE_BF20A1_R                                                            11
N#define SENSOR_TYPE_BF20A1_L                                                            12
N#define SENSOR_TYPE_OV02B1B_R                                                           13
N#define SENSOR_TYPE_OV02B1B_L                                                           14
N#define SENSOR_TYPE_MAX                                                                 15
N#define SENSOR_TYPE_HMX2056_OV9286                                                      16
N#define SENSOR_TYPE_GC2145_SC132GS                                                      17
N#define SENSOR_TYPE_SC132GS_GC2145                                                      18
N#define SENSOR_TYPE_GC2145_SC035HGS                                                      19
N#define SENSOR_TYPE_GC1054_GC1054                                                       20
N#define SENSOR_TYPE_SP2509_SP2509                                                       21
N#define SENSOR_TYPE_BF20A1_BF20A1                                                       22
N#define SENSOR_TYPE_OV02B1B_OV02B1B                                                      23
N#define SENSOR_TYPE_USER_DEFINE                                                       0xff
N#define LED_DRIVER_AW36404                                                               0
N#define LED_DRIVER_AW36515                                                               1
N#define LED_DRIVER_GPIO                                                                  2
N#define RES_640_480                                                                      0
N#define RES_480_640                                                                      1
N#define RES_480_272                                                                      2
N#define RES_272_480                                                                      3
N#define RES_864_491                                                                      4
N#define RES_1600_1200                                                                    5
N#define RES_1080_1280                                                                    6
N#define RES_1280_720                                                                     7
N#define RES_1920_1080                                                                    8
N#define RES_800_600                                                                      9
N#define RES_USER_DEFINE                                                                 10
N#define IMAGE_FORMAT_RGB565                                                              0
N#define IMAGE_FORMAT_RAW10                                                               1
N#define IMAGE_FORMAT_RAW8                                                                2
N#define IMAGE_FORMAT_YCBCR                                                               3
N#define IMAGE_MIPILANE_NUM_1                                                             1
N#define IMAGE_MIPILANE_NUM_2                                                             2
N#define DISPLAY_DEVICE_UNKNOWN                                                           0
N#define DISPLAY_DEVICE_LCDC                                                              1
N#define DISPLAY_DEVICE_LCM                                                               2
N#define DISPLAY_DEVICE_SPI_LCD                                                           3
N#define DISPLAY_DEVICE_LCM_AND_SPI_LCD                                                       4
N#define PANEL_NULL                                                                       0
N#define PANEL_MZT_480X272                                                                1
N#define PANEL_ST7789_240X320                                                             2
N#define PANEL_ST7789_320X240                                                             3
N#define PANEL_MZT                                                                        4
N#define PANEL_ST7789_240X320_SPI                                                         5
N#define PANEL_ST7789_240X320_8080_AND_SPI                                                       6
N#define CFG_SENSOR_TYPE                                          SENSOR_TYPE_SP2509_SP2509
N#define CFG_SENSOR_MIPI0_RX_EN                                                           1
N#define CFG_SENSOR_MIPI1_RX_EN                                                           1
N#define CFG_SENSOR_0_TYPE                                             SENSOR_TYPE_SP2509_R
N#define CFR_SENSOR_0_FORMAT                                              IMAGE_FORMAT_RAW8
N#define CFR_SENSOR_0_MIPILANE_NUM                                     IMAGE_MIPILANE_NUM_1
N#define CFR_SENSOR_0_RES                                                       RES_800_600
N#define CFG_SENSOR_0_WIDTH                                                             800
N#define CFG_SENSOR_0_HEIGHT                                                            600
N#define CFG_SENSOR_0_FMT_MIRROR                                                          0
N#define CFG_SENSOR_0_FMT_FLIP                                                            1
N#define CFG_SENSOR_0_I2C_ADDR                                                         0x3d
N#define CFG_SENSOR_1_TYPE                                             SENSOR_TYPE_SP2509_L
N#define CFR_SENSOR_1_FORMAT                                              IMAGE_FORMAT_RAW8
N#define CFR_SENSOR_1_MIPILANE_NUM                                     IMAGE_MIPILANE_NUM_1
N#define CFR_SENSOR_1_RES                                                       RES_800_600
N#define CFG_SENSOR_1_WIDTH                                                             800
N#define CFG_SENSOR_1_HEIGHT                                                            600
N#define CFG_SENSOR_1_FMT_MIRROR                                                          0
N#define CFG_SENSOR_1_FMT_FLIP                                                            1
N#define CFG_SENSOR_1_I2C_ADDR                                                         0x3d
N#define CFR_SENSOR_NUM                                                                   2
N#define CFR_CAM_RGB                                                                      0
N#define CFR_CAM_NIR                                                                      1
N#define CFG_SENSOR_0_FULL_RESOLUTION                                                       1
N#define CFG_SENSOR_1_FULL_RESOLUTION                                                       1
N#define CFG_PANEL_TYPE                                                          PANEL_NULL
N#define CFG_TOUCH_X_RANGE_MAX                                                          240
N#define CFG_TOUCH_Y_RANGE_MAX                                                          320
N#define CFG_TOUCH_X_AXIS_INVERSE                                                         0
N#define CFG_TOUCH_Y_AXIS_INVERSE                                                         1
N#define CFG_DISPLAY_DMA_ENABLE                                                           1
N#define CFG_PREFER_DISPLAY                                                               1
N#define CFG_I2C_0_ENABLE                                                                 1
N#define CFG_I2C_1_ENABLE                                                                 1
N#define CFG_I2C_2_ENABLE                                                                 0
N#define CFG_I2C_3_ENABLE                                                                 0
N#define CFG_UART0_ENABLE                                                                 1
N#define CFG_UART1_ENABLE                                                                 0
N#define CFG_UART1_TX_DMA_ENABLE                                                          0
N#define CFG_UART1_RX_DMA_ENABLE                                                          0
N#define CFG_UART2_ENABLE                                                                 1
N#define CFG_UART2_TX_DMA_ENABLE                                                          0
N#define CFG_UART2_RX_DMA_ENABLE                                                          0
N#define CFG_UART3_ENABLE                                                                 0
N#define CFG_UART3_TX_DMA_ENABLE                                                          0
N#define CFG_UART3_RX_DMA_ENABLE                                                          0
N#define CFG_UART4_ENABLE                                                                 1
N#define CFG_UART4_TX_DMA_ENABLE                                                          0
N#define CFG_UART4_RX_DMA_ENABLE                                                          0
N#define CFG_ADC0_ENABLE                                                                  0
N#define CFG_ADC0_DMA_ENABLE                                                              0
N#define CFG_ADC1_ENABLE                                                                  0
N#define CFG_ADC1_DMA_ENABLE                                                              0
N#define CFG_ADC2_ENABLE                                                                  0
N#define CFG_ADC2_DMA_ENABLE                                                              0
N#define CFG_ADC3_ENABLE                                                                  0
N#define CFG_ADC3_DMA_ENABLE                                                              0
N#define CFG_PWM1_DMA_ENABLE                                                              0
N#define CFG_PWM2_DMA_ENABLE                                                              0
N#define CFG_PWM3_DMA_ENABLE                                                              0
N#define CFG_PWM4_DMA_ENABLE                                                              0
N#define CFG_PWM5_DMA_ENABLE                                                              0
N#define CFG_PWM6_DMA_ENABLE                                                              0
N#define CFG_SSP0_ENABLE                                                                  0
N#define CFG_SSP0_TX_DMA_ENABLE                                                           0
N#define CFG_SSP0_RX_DMA_ENABLE                                                           0
N#define CFG_SSP1_ENABLE                                                                  1
N#define CFG_SSP1_TX_DMA_ENABLE                                                           0
N#define CFG_SSP1_RX_DMA_ENABLE                                                           0
N#define CFG_SPI_ENABLE                                                                   1
N#define CFG_SPI_DMA_ENABLE                                                               0
N#define CFG_SD_ENABLE                                                                    1
N#define CFG_SD_DMA_ENABLE                                                                0
N#define CFG_USBD_ENABLE                                                                  1
N#define CFG_USBH_ENABLE                                                                  0
N#define CFG_USB_OTG_ENABLE                                                               0
N#define CFG_UI_USR_IMG                                                                   1
N#define CFG_OTA_EN                                                                       0
N#define CFG_LED_DRIVER_TYPE                                                LED_DRIVER_GPIO
N// =======================================================================================
N#define AI_TYPE_R1                                                                       0
N#define AI_TYPE_R1N1                                                                     1
N#define AI_TYPE_N1                                                                       2
N#define AI_TYPE_N1R1                                                                     3
N#define AI_TYPE_PR1                                                                      4
N#define AI_TYPE_UPDATE_FMAP                                                              5
N#define CFG_AI_TYPE                                                           AI_TYPE_N1R1
N#define CFG_AI_3D_ENABLE                                                                 1
N#define CFG_AI_3D_LIVENESS_IN                                                            2
N#define CFG_AI_USE_FIXED_IMG                                                             0
N#define USE_N1_FACE_POSE                                                                 1
N#define USE_FUSE_LV__MODEL                                                               1
N#define CFG_RGB_CV_LIVENESS                                                              0
N#define USE_LIVENESS_CV                                                                  0
N#define USE_FACE_QUALITY                                                                 1
N#define KL520_FACE_ADD_BMP                                                               1
N#define CFG_LW3D_NORMAL                                                                  0
N#define CFG_LW3D_850                                                                     1
N#define CFG_LW3D_940                                                                     2
N#define CFG_LW3D_TYPE                                                         CFG_LW3D_850
N#define CFG_FLASH_DB_NIR_ONLY                                                            1
N#define CFG_REUSE_PREPROC                                                                1
N#define CFG_CAMERA_ROTATE                                                                1
N#define CFG_CAMERA_DUAL_1054                                                             1
N#define CFG_NIR_MODE2_SPLIT                                                              1
N#define CFG_FCOS_FD_ROTATE                                                               1
N#define CFG_ZHIAN                                                                        1
N#define CFG_LM_ONET_PLUS                                                                 1
N#define CFG_REC_ERR_NOT_RET                                                              1
N#define CFG_LED_CTRL_ENHANCE                                                             0
N#define CFG_MODELS_LOAD_BY_ORDER                                                         1
N#define CFG_MAX_USER                                                                   100
N#define CFG_ONE_SHOT_MODE                                                                1
N#define CFG_ONE_SHOT_ENHANCE                                                             1
N#define CFG_ONESHOT_PARALLEL                                                             0
N#define CFG_USB_EXPORT_LIVENESS_RET                                                       1
N#define CUSTOMIZE_DB_OFFSET                                                 0x01 //zcymod 
N#define CFG_DEL_CALIBRATION_SETTING_WHEN_DEL_ALL                                                       1
N// CFG_E2E_SETTING========================================================================
N#define CFG_E2E_STRUCT_LIGHT                                                             0
N#define CFG_E2E_NIR_TWO_STAGE_LIGHT                                                       0
N#define CFG_E2E_CHECK_POSITION                                                           1
N#define CFG_E2E_REC_NOTE                                                                 1
N#define CFG_E2E_RGB_LED_STRENGTH                                                       100
N#define CFG_E2E_NIR_LED_STRENGTH                                                        60
N#define CFG_E2E_RGB_LED_DEFAULT_DIM_ENV_STRENGTH                                                       2
N#define CFG_E2E_RGB_LED_WEAK_ENHANCE_COUNT                                                     200
N#define CFG_E2E_RGB_LED_WEAK_ENHANCE_STEP                                                       2
N#define CFG_E2E_RGB_LED_WEAK_ENHANCE_MAX                                                      20
N#define CFG_E2E_RGB_LED_WEAK_ENHANCE_MIN                                                       4
N#define CFG_E2E_RGB_LED_DEFAULT_DARK_ENV_STRENGTH                                                      15
N#define CFG_E2E_RGB_LED_STRONG_ENHANCE_COUNT                                                    1000
N#define CFG_E2E_RGB_LED_STRONG_ENHANCE_STRONG_STEP                                                       3
N#define CFG_E2E_RGB_LED_STRONG_ENHANCE_STRONG_MAX                                                      80
N#define CFG_E2E_RGB_LED_STRONG_ENHANCE_STRONG_MIN                                                      20
N// =======================================================================================
N//  1.Different rgb led on different hardware 2.bctc liveness version 
N//  Recognition and liveness in dark room is affected by these variable.
N// =======================================================================================
N#define CFG_IGNORE_RGB_LED                                                               1
N#define CFG_LV_HARD                                                                      0
N// =======================================================================================
N#define CFG_TOUCH_ENABLE                                                                 0
N#define TOUCH_INT_PIN                                                                   27
N#define TOUCH_TYPE_CT130                                                                 0
N#define TOUCH_TYPE_FT5X06                                                                1
N#define CFG_TOUCH_TYPE                                                    TOUCH_TYPE_CT130
N#define CFG_SNAPSHOT_ENABLE                                                              0
N#define CFG_USB_SIMTOOL                                                                  0
N#define CFG_SNAPSHOT_INFO                                                                1
N#define CFG_SNAPSHOT_NUMS                                                               10
N#define CFG_SNAPSHOT_ADVANCED                                                            0
N#define CFG_OTA_FLASH_BUF_ENABLE                                                         1
N#define CFG_OTA_IMAGE_BUF_ENABLE                                                         1
N#define CFG_KDP_SETTINGS_ENABLE                                                          1
N#define CFG_KDP_SETTINGS_SIZE                                                        20480
N#define CFG_USR_SETTINGS_ENABLE                                                          1
N#define CFG_USR_SETTINGS_SIZE                                                         4096
N#define CFG_GUI_ENABLE                                                                   0
N#define CFG_FMAP_EXTRA_ENABLE                                                            0
N#define DISPLAY_REGISTER_WITH_CUSTOM_IMG                                                       1
N// =======================================================================================
N// EXPORT_INFORMATION like stream, db, fm, etc...
N// =======================================================================================
N#define EX_FM_DISABLE                                                                    0
N#define EX_FM_USB_AP_CTRL_ALL                                                            1
N#define EX_FM_USB_AP_CTRL_MAIN_DB                                                        2
N#define EX_FM_UART_AP_CTRL_MAIN_DB                                                       3
N#define CFG_FMAP_AP_CTRL_TYPE                                   EX_FM_UART_AP_CTRL_MAIN_DB
N#define CFG_FMAP_EX_FIG_ENABLE                                                           0
N#define CFG_USB_PROGRAME_FW_ENABLE                                                       0
N#define CFG_USB_EXPORT_STREAM_IMG                                                        0
N#define CFG_USB_CLOUD_DB_UPDATE                                                          0
N// =======================================================================================
N// Display Setting
N// =======================================================================================
N#define DISPLAY_ENABLE                                                                   0
N#define DISPLAY_DOWNSCALE                                                                0
N#define DISPLAY_WIDTH                                                                  320
N#define DISPLAY_HEIGHT                                                                 240
N#define DISPLAY_RGB_WIDTH                                                             1280
N#define DISPLAY_RGB_HEIGHT                                                             720
N#define DISPLAY_RGB_X_OFFSET                                                             0
N#define DISPLAY_RGB_Y_OFFSET                                                             0
N#define DISPLAY_RGB_OUT_WIDTH                                                          320
N#define DISPLAY_RGB_OUT_HEIGHT                                                         240
N#define DISPLAY_NIR_WIDTH                                                             1280
N#define DISPLAY_NIR_HEIGHT                                                             720
N#define DISPLAY_NIR_X_OFFSET                                                             0
N#define DISPLAY_NIR_Y_OFFSET                                                             0
N#define DISPLAY_NIR_OUT_WIDTH                                                          320
N#define DISPLAY_NIR_OUT_HEIGHT                                                         240
N#define PANEL_IN_WIDTH                                                                 320
N#define PANEL_IN_HEIGHT                                                                240
N#define PANEL_RGB_X_OFFSET                                                               0
N#define PANEL_RGB_Y_OFFSET                                                               0
N#define PANEL_NIR_X_OFFSET                                                               0
N#define PANEL_NIR_Y_OFFSET                                                               0
N// CFG_ST7789_X_Y_INVERSE=1
N// =======================================================================================
N// In this section there are some macros used to selection communication interface which you want
N// If you want to use snapshot or OTA, you need select the correct bus type
N// If you select COM_BUS_TYPE_UART4, and then you need filled it to CFG_COM_BUS_TYPE
N// For example: "#define CFG_COM_BUS_TYPE  COM_BUS_TYPE_UART4"
N// =======================================================================================
N#define COM_BUS_UART_MASK                                                       0x0000007F
N#define COM_BUS_USB_MASK                                                        0x00000080
N#define COM_BUS_SPI_MASK                                                        0x00000F00
N#define COM_BUS_I2C_MASK                                                        0x0000F000
N#define COM_BUS_SDIO_MASK                                                       0x000F0000
N#define COM_BUS_OTG_MASK                                                        0x00100000
N#define COM_BUS_UART0                                                                 0x01
N#define COM_BUS_UART1                                                                 0x02
N#define COM_BUS_UART2                                                                 0x04
N#define COM_BUS_UART3                                                                 0x08
N#define COM_BUS_UART4                                                                 0x10
N#define COM_BUS_USB                                                                   0x80
N#define COM_BUS_SSP0                                                                 0x100
N#define COM_BUS_SSP1                                                                 0x200
N#define COM_BUS_SPI_MS_EN                                                            0x800
N#define COM_BUS_I2C0                                                                0x1000
N#define COM_BUS_I2C1                                                                0x2000
N#define COM_BUS_I2C2                                                                0x4000
N#define COM_BUS_I2C3                                                                0x8000
N#define COM_BUS_SDIO                                                               0x10000
N#define COM_BUS_OTG                                                               0x100000
N#define CFG_COM_BUS_TYPE                                                   (COM_BUS_UART2)
N// =======================================================================================
N#define COM_PROTOCOL_TYPE_LWCOM                                                          0
N#define COM_PROTOCOL_TYPE_KCOMM                                                          1
N#define CFG_COM_PROTOCOL_TYPE                                      COM_PROTOCOL_TYPE_LWCOM
N#define COM_USB_PROT_DEF                                                                 0
N#define COM_USB_PROT_KDP                                                                 1
N#define COM_USB_PROT_DEF_USR                                                             2
N#define COM_USB_PROT_KDP_USR                                                             3
N#define CFG_COM_USB_PROT_TYPE                                             COM_USB_PROT_DEF
N#define COM_UART_PROT_DEF                                                                0
N#define COM_UART_PROT_KDP                                                                1
N#define COM_UART_PROT_DEF_USR                                                            2
N#define COM_UART_PROT_KDP_USR                                                            3
N#define CFG_COM_URT_PROT_TYPE                                            COM_UART_PROT_KDP
N#define NO_ENCRYPTION                                                                    0
N#define AES_ENCRYPTION                                                                0x01
N#define XOR_ENCRYPTION                                                                0x02
N#define ENCRYPTION_MODE                                    (AES_ENCRYPTION|XOR_ENCRYPTION)
N#define COM_UART_MSG_KDP                                                                 0
N#define COM_UART_MSG_USER                                                                1
N#define CFG_COM_UART_MSG                                                 COM_UART_MSG_USER
N// =======================================================================================
N#define CFG_USB_MANUFACTURER                         {'K',0,'n',0,'e',0,'r',0,'o',0,'n',0}
N#define CFG_USB_PRODUCT                              {'K',0,'n',0,'e',0,'r',0,'o',0,'n',0}
N#define CFG_USB_SERIAL                   {'5',0,'5',0,'6',0,'6',0,'7',0,'7',0,'8',0,'8',0}
N#define BOARD_VERSION                                                                    0
N#define FAT_FS                                                                           0
N#define PETIT_FS                                                                         1
N#define CFG_OTG_FSTYPE                                                            PETIT_FS
N#define KL520A                                                                           0
N#define KL520B                                                                           1
N#define CFG_KL520_VERSION                                                           KL520B
N// =======================================================================================
N//  CFG_BOARD_PARAMS_0_ID = X. Means the Xth parameter group of CFG_BOARD_PARAMS_0.
N//  The board uses the same camera sensor, but the module components are different, such as lens.
N//  developer please refer to /doc/developer_only/board_cfg_desc.txt for more details.
N// =======================================================================================
N#define CFG_BOARD_PARAMS_0_ID                                                            2
N#define CFG_BOARD_PARAMS_0_0      {65.0f,130.0f,0.75f,1.33f,1.33f,-120.0f,40.0f,1.385f,0.8f,0.8f,1.00f,1.0f}
N#define CFG_BOARD_PARAMS_0_1      {65.0f,130.0f,0.7825f,0.98f,0.942f,-160.0f,6.0f,1.0f,1.14f,1.00f,1.385f,150.0f}
N#define CFG_BOARD_PARAMS_0_2      {130.0f,65.0f,-0.35f,1.0f,1.0f,-160.0f,6.0f,1.0f,1.14f,1.00f,1.385f,150.0f}
N#define CFG_BOARD_PARAMS_1_ID                                                            0
N#define CFG_BOARD_PARAMS_1_0                                                 {2.77f,94.0f}
N// =======================================================================================
N//  Memory selection for different flash vendor
N// =======================================================================================
N#define IMAGE_16MB                                                                      16
N#define IMAGE_32MB                                                                      32
N#define IMAGE_64MB                                                                      64
N#define IMAGE_SIZE                                                              IMAGE_16MB
N#define FLASH_16MB                                                                      16
N#define FLASH_32MB                                                                      32
N#define FLASH_64MB                                                                      64
N#define FLASH_SIZE                                                              FLASH_32MB
N#define GD25Q256D                                                                        0
N#define GD25S512MD                                                                       1
N#define W25Q256JV                                                                        2
N#define FLASH_VENDOR_SELECT                                                      W25Q256JV
N#define CFG_OTA_FLASH_SLAVE_ENABLE                                                       0
N#define CFG_USB_EXPORT_LIVENESS_RET                                                       1
N// =======================================================================================
N//  mipi pll setting
N//  for more different setting please refer to /doc/developer_only/csirx_pll_setting_table.xslx for more details.
N// =======================================================================================
N#define CFG_PLL_MS                                                                       2
N#define CFG_PLL_NS                                                                     200
N#define CFG_PLL_PS                                                                       2
N#define CFG_CSIRX0_TXESCCLK                                                              3
N#define CFG_CSIRX0_CSI                                                                  16
N#define CFG_CSIRX0_VC0                                                                   7
N#define CFG_CSIRX1_TXESCCLK_PLL3                                                         3
N#define CFG_CSIRX1_CSI                                                                  16
N#define CFG_CSIRX1_VC0                                                                   7
N#define MIPI_PRE_DEF1                                             {2,268,2,5,27,13,5,15,4}
N#define MIPI_PRE_DEF2                                              {1,210,3,5,15,3,2,31,7}
N#define MIPI_PRE_DEF3                                               {2,242,2,4,11,5,4,7,1}
N#define MIPI_PRE_DEF4                                               {2,242,2,4,7,1,4,11,5}
N#define MIPI_PRE_DEF5                                               {2,200,2,3,9,4,3,13,3}
N#define MIPI_PRE_DEF6                                              {2,200,2,3,16,7,3,16,7}
N#define MIPI_PRE_DEF7                                              {2,200,2,3,12,2,3,16,7}
N#define MIPI_PRE_DEF8                                              {2,200,2,3,16,7,3,12,2}
N#define MIPI_PRE_DEF9                                              {2,300,2,2,3,5,5,27,10}
N#define MIPI_PRE_DEF10                                           {2,200,2,3,24,24,3,24,24}
N// ====1600x1200====
N#define MIPI_PRE_DEF11                                             {2,268,2,4,10,4,4,10,4}
N// ================
N// =====800x600=====
N#define MIPI_PRE_DEF12                                             {2,268,2,4,28,9,4,28,9}
N// ================
N#define MIPI_PRE_DEF13                                             {2,400,2,3,26,7,3,26,7}
N#define MIPI_CUSTOM               {CFG_PLL_MS,CFG_PLL_NS,CFG_PLL_PS,CFG_CSIRX0_TXESCCLK,CFG_CSIRX0_CSI,CFG_CSIRX0_VC0,CFG_CSIRX1_TXESCCLK_PLL3,CFG_CSIRX1_CSI,CFG_CSIRX1_VC0}
N#define CFG_MIPI_PLL_SETTING                                                MIPI_PRE_DEF13
N// =======================================================================================
N// =======================================================================================
N
N#endif
L 15 "..\..\..\..\board\board_kl520.h" 2
N
Nextern u8 rgb_sensor_index;
Nextern u8 nir_sensor_index;
Nextern u8 sensor_0_mirror;
Nextern u8 sensor_0_flip;
Nextern u8 sensor_1_mirror;
Nextern u8 sensor_1_flip;
N
N#define YES                         1
N#define NO                          0
N
N#define CFG_AI_3D_LIVENESS_IN_NONE  0
N#define CFG_AI_3D_LIVENESS_IN_SCPU  1
N#define CFG_AI_3D_LIVENESS_IN_NCPU  2
N
N/* Tile average setting */
N#if (CFG_SENSOR_1_TYPE == SENSOR_TYPE_SC035HGS && CFG_CAMERA_ROTATE == 1)
X#if (9 == 5 && 1 == 1)
S#define ALL_TILE_VALUE              (NO)
N#else
N#define ALL_TILE_VALUE              (YES)
N#endif
N
N#define TILE_AVG_32                 (32)
N#define TILE_AVG_64                 (64)
N#define TILE_AVG_128                (128)
N#define TILE_AVG_CAL_SIZE           (TILE_AVG_128)
N
N#if (ALL_TILE_VALUE == NO)  //only for SC035
X#if ((1) == 0)  
S#define TILE_AVG_BLOCK_X            (4)
S#define TILE_AVG_BLOCK_Y            (5)
N#else
N#define TILE_AVG_BLOCK_X            (10)  //cannot modify
N#define TILE_AVG_BLOCK_Y            (6)   //cannot modify
N#endif
N#define TILE_AVG_BLOCK_NUMBER       (TILE_AVG_BLOCK_X * TILE_AVG_BLOCK_Y)
N
N#define TILE_AVG_VALID_X            ( ( (NIR_IMG_SOURCE_W / TILE_AVG_CAL_SIZE) < TILE_AVG_BLOCK_X ) ? (NIR_IMG_SOURCE_W / TILE_AVG_CAL_SIZE) : TILE_AVG_BLOCK_X )
N#define TILE_AVG_VALID_Y            ( ( (NIR_IMG_SOURCE_H / TILE_AVG_CAL_SIZE) < TILE_AVG_BLOCK_Y ) ? (NIR_IMG_SOURCE_H / TILE_AVG_CAL_SIZE) : TILE_AVG_BLOCK_Y )
N
N#if ( CFG_PALM_PRINT_MODE == YES )
X#if ( CFG_PALM_PRINT_MODE == 1 )
S#define BRIGHTNESS_STATS_X_BLOCK_NUM  ( 4 )
S#define BRIGHTNESS_STATS_Y_BLOCK_NUM  ( 15 )
S#define BRIGHTNESS_STATS_BLOCK_MAX    ( BRIGHTNESS_STATS_X_BLOCK_NUM * BRIGHTNESS_STATS_Y_BLOCK_NUM )  //less than "TILE_AVG_BLOCK_NUMBER"
S#define BRIGHTNESS_STATS_X_BLOCK_SIZE ( 100 )   //fixed
S#define BRIGHTNESS_STATS_Y_BLOCK_SIZE ( 26 )    //fixed
S#define BRIGHTNESS_STATS_X_START      ( 100 )
S#define BRIGHTNESS_STATS_Y_START      ( 100 )
S#define BRIGHTNESS_STATS_STEP         ( 4 )     //fixed
N#endif
N
N/* The other definitions which are based on customer board configuration */
N#ifdef CFG_SENSOR_TYPE
N#define CFG_MIPIRX_ENABLE           YES
N#endif
N
N#define MIPI_0_RX_ENABLE            CFG_SENSOR_MIPI0_RX_EN
N#define MIPI_1_RX_ENABLE            CFG_SENSOR_MIPI1_RX_EN
N#define IMGSRC_0_TYPE               CFG_SENSOR_0_TYPE
N#define IMGSRC_1_TYPE               CFG_SENSOR_1_TYPE
N#define IMGSRC_0_RES                CFR_SENSOR_0_RES
N#define IMGSRC_1_RES                CFR_SENSOR_1_RES
N#define IMGSRC_0_FORMAT             CFR_SENSOR_0_FORMAT
N#define IMGSRC_1_FORMAT             CFR_SENSOR_1_FORMAT
N#define IMGSRC_0_MIPILANE_NUM       CFR_SENSOR_0_MIPILANE_NUM
N#define IMGSRC_1_MIPILANE_NUM       CFR_SENSOR_1_MIPILANE_NUM
N#define IMGSRC_NUM                  CFR_SENSOR_NUM
N
N#if (CFG_SENSOR_TYPE == SENSOR_TYPE_GC2145_SC132GS)
X#if (21 == 17)
S#define MIPI_CAM_RGB                0
S#define MIPI_CAM_NIR                1
S#if CFG_SENSOR_0_FULL_RESOLUTION == YES
S#define GC2145_FULL_RES             (YES)
S#else
S#define GC2145_FULL_RES             (NO)
S#endif
S
S#define RGB_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
S#define RGB_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
S
S#if CFG_SENSOR_1_FULL_RESOLUTION == YES
S#define SC132GS_FULL_RES            (YES)
S#else
S#define SC132GS_FULL_RES            (NO)
S#endif
S
S#define NIR_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
S#define NIR_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
S
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_SC132GS_GC2145)
X#elif (21 == 18)
S#define MIPI_CAM_RGB                1
S#define MIPI_CAM_NIR                0
S#if CFG_SENSOR_0_FULL_RESOLUTION == YES
S#define SC132GS_FULL_RES            (YES)
S#else
S#define SC132GS_FULL_RES            (NO)
S#endif
S#define RGB_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
S#define RGB_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
S
S#if CFG_SENSOR_1_FULL_RESOLUTION == YES
S#define GC2145_FULL_RES             (YES)
S#else
S#define GC2145_FULL_RES             (NO)
S#endif
S#define NIR_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
S#define NIR_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
S
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_HMX2056_OV9286)
X#elif (21 == 16)
S#define MIPI_CAM_RGB                0
S#define MIPI_CAM_NIR                1
S#define RGB_IMG_SOURCE_W            640
S#define RGB_IMG_SOURCE_H            480
S#define NIR_IMG_SOURCE_W            480
S#define NIR_IMG_SOURCE_H            640
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_HMXRICA)
X#elif (21 == 2)
S#define MIPI_CAM_NIR                0
S#define RGB_IMG_SOURCE_W            640
S#define RGB_IMG_SOURCE_H            480
S#define NIR_IMG_SOURCE_W            491
S#define NIR_IMG_SOURCE_H            864
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_GC2145_SC035HGS)
X#elif (21 == 19)
S#define MIPI_CAM_RGB                0
S#define MIPI_CAM_NIR                1
S#if CFG_SENSOR_0_FULL_RESOLUTION == YES
S#define RGB_IMG_SOURCE_W            UGA_WIDTH
S#define RGB_IMG_SOURCE_H            UGA_HEIGHT
S#define GC2145_FULL_RES             (YES)
S#else
S#define RGB_IMG_SOURCE_W            640
S#define RGB_IMG_SOURCE_H            480
S#define GC2145_FULL_RES             (NO)
S#endif
S#define NIR_IMG_SOURCE_W            640
S#define NIR_IMG_SOURCE_H            480
S#define SC035HGS_FULL_RES            (NO)
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_GC1054_GC1054)
X#elif (21 == 20)
S#define MIPI_CAM_RGB                rgb_sensor_index
S#define MIPI_CAM_NIR                nir_sensor_index
S
S 
S#define RGB_IMG_SOURCE_W            1280
S#define RGB_IMG_SOURCE_H            720
S#define NIR_IMG_SOURCE_W            1280
S#define NIR_IMG_SOURCE_H            720
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_GC02M1_GC1054)
X#elif (21 == SENSOR_TYPE_GC02M1_GC1054)
S#define MIPI_CAM_RGB                rgb_sensor_index
S#define MIPI_CAM_NIR                nir_sensor_index
S 
S#define RGB_IMG_SOURCE_W            1280
S#define RGB_IMG_SOURCE_H            720
S#define NIR_IMG_SOURCE_W            1280
S#define NIR_IMG_SOURCE_H            720
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_GC2145_GC1054)
X#elif (21 == SENSOR_TYPE_GC2145_GC1054)
S#define MIPI_CAM_RGB                rgb_sensor_index
S#define MIPI_CAM_NIR                nir_sensor_index
S 
S#define RGB_IMG_SOURCE_W            640
S#define RGB_IMG_SOURCE_H            480
S#define NIR_IMG_SOURCE_W            1280
S#define NIR_IMG_SOURCE_H            720
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_BF20A1_BF20A1)
X#elif (21 == 22)
S 
S#define MIPI_CAM_RGB                rgb_sensor_index
S#define MIPI_CAM_NIR                nir_sensor_index
S
S#define RGB_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
S#define RGB_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
S
S#define NIR_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
S#define NIR_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
S
N#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_OV02B1B_OV02B1B) || (CFG_SENSOR_TYPE == SENSOR_TYPE_SP2509_SP2509)
X#elif (21 == 23) || (21 == 21)
N#define MIPI_CAM_RGB                rgb_sensor_index
N#define MIPI_CAM_NIR                nir_sensor_index
N 
N#define RGB_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
N#define RGB_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
N#define NIR_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
N#define NIR_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
N
N#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_USER_DEFINE)
X#elif (21 == 0xff)
S#if (IMGSRC_0_FORMAT==IMAGE_FORMAT_RGB565) || (IMGSRC_0_FORMAT==IMAGE_FORMAT_YCBCR)
S#define MIPI_CAM_RGB                0
S#define RGB_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
S#define RGB_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
S#elif (IMGSRC_1_FORMAT==IMAGE_FORMAT_RGB565) || (IMGSRC_1_FORMAT==IMAGE_FORMAT_YCBCR)
S#define MIPI_CAM_RGB                1
S#define RGB_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
S#define RGB_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
S#endif
S#if (IMGSRC_0_FORMAT==IMAGE_FORMAT_RAW8) || (IMGSRC_0_FORMAT==IMAGE_FORMAT_RAW10)
S#define MIPI_CAM_NIR                0
S#define NIR_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
S#define NIR_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
S#elif (IMGSRC_1_FORMAT==IMAGE_FORMAT_RAW8) || (IMGSRC_1_FORMAT==IMAGE_FORMAT_RAW10)
S#define MIPI_CAM_NIR                1
S#define NIR_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
S#define NIR_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
S#endif
S#if ((IMGSRC_0_TYPE==SENSOR_TYPE_GC2145) && (IMGSRC_0_RES==RES_1600_1200)) \
S    || ((IMGSRC_1_TYPE==SENSOR_TYPE_GC2145) && (IMGSRC_1_RES==RES_1600_1200))
X#if ((IMGSRC_0_TYPE==SENSOR_TYPE_GC2145) && (IMGSRC_0_RES==RES_1600_1200))     || ((IMGSRC_1_TYPE==SENSOR_TYPE_GC2145) && (IMGSRC_1_RES==RES_1600_1200))
S#define GC2145_FULL_RES             (YES)
S#else
S#define GC2145_FULL_RES             (NO)
S#endif
S#if ((IMGSRC_0_TYPE==SENSOR_TYPE_SC132GS) && (IMGSRC_0_RES==RES_1080_1280)) \
S    || ((IMGSRC_1_TYPE==SENSOR_TYPE_SC132GS) && (IMGSRC_1_RES==RES_1080_1280))
X#if ((IMGSRC_0_TYPE==SENSOR_TYPE_SC132GS) && (IMGSRC_0_RES==RES_1080_1280))     || ((IMGSRC_1_TYPE==SENSOR_TYPE_SC132GS) && (IMGSRC_1_RES==RES_1080_1280))
S#define SC132GS_FULL_RES             (YES)
S#else
S#define SC132GS_FULL_RES             (NO)
S#endif
S
S#else
S#define MIPI_0_RX_ENABLE            YES
S#define MIPI_1_RX_ENABLE            NO
S#define IMGSRC_NUM                  1
N#endif
N
N#if CFG_PANEL_TYPE == PANEL_NULL || CFG_PANEL_TYPE == PANEL_MZT_480X272
X#if 0 == 0 || 0 == 1
N#define PANEL_WIDTH     (TFT43_WIDTH)
N#define PANEL_HEIGHT    (TFT43_HEIGHT)
N#elif (CFG_PANEL_TYPE == PANEL_ST7789_240X320 || CFG_PANEL_TYPE == PANEL_ST7789_240X320_SPI || (CFG_PANEL_TYPE==PANEL_ST7789_240X320_8080_AND_SPI) )
X#elif (0 == 2 || 0 == 5 || (0==6) )
S#define PANEL_WIDTH     (QVGA_PORTRAIT_WIDTH)
S#define PANEL_HEIGHT    (QVGA_PORTRAIT_HEIGHT)
S#elif (CFG_PANEL_TYPE == PANEL_ST7789_320X240)
S#define PANEL_WIDTH     (QVGA_LANDSCAPE_WIDTH)
S#define PANEL_HEIGHT    (QVGA_LANDSCAPE_HEIGHT)
S#elif (CFG_PANEL_TYPE == PANEL_MZT)
S#define PANEL_WIDTH     (VGA_LANDSCAPE_WIDTH)
S#define PANEL_HEIGHT    (VGA_LANDSCAPE_HEIGHT)
N#endif
N
N#if CFG_PANEL_TYPE == PANEL_NULL
X#if 0 == 0
N#   define DISPLAY_DEVICE           DISPLAY_DEVICE_UNKNOWN
N#elif CFG_PANEL_TYPE == PANEL_MZT_480X272
X#elif 0 == 1
S#   define DISPLAY_DEVICE           DISPLAY_DEVICE_LCDC
S#   if CFG_DISPLAY_DMA_ENABLE == YES
S#       define CFG_LCM_DMA_ENABLE YES
S#   endif
S#elif (CFG_PANEL_TYPE == PANEL_ST7789_240X320) || (CFG_PANEL_TYPE == PANEL_ST7789_320X240) || (CFG_PANEL_TYPE==PANEL_ST7789_240X320_8080_AND_SPI)
S#   define DISPLAY_DEVICE           DISPLAY_DEVICE_LCM
S#   if CFG_DISPLAY_DMA_ENABLE == YES
S#       define CFG_LCM_DMA_ENABLE YES
S#   endif
S#elif (CFG_PANEL_TYPE == PANEL_ST7789_240X320_SPI)
S#   define DISPLAY_DEVICE           DISPLAY_DEVICE_SPI_LCD
S#   if CFG_DISPLAY_DMA_ENABLE == YES
S#       define CFG_LCM_DMA_ENABLE YES
S#   endif
S#else
S#   define DISPLAY_DEVICE           DISPLAY_DEVICE_UNKNOWN
N#endif
N
N#define KDP_BIT_CTRL_MODE                   ( NO )
N//#define KDP_REMOTE_CTRL_BY_TYPE				( NO )
N
N#ifdef CFG_CATEYE_COMMON_MIPI
S#define CATEYE_COMMON_MIPI                  ( YES )
N#else
N#define CATEYE_COMMON_MIPI                  ( NO )
N#endif
N#endif
L 23 "..\..\user\main.c" 2
N#include "kdp520_dma.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp520_dma.h" 1
N
N#ifndef __KDP520_DMA_H__
N#define __KDP520_DMA_H__
N
N#include "types.h"
N#include "kdp_ddr_table.h"
L 1 "..\..\config\kdp_ddr_table.h" 1
N#ifndef __KDP_DDR_TABLE_H__
N#define __KDP_DDR_TABLE_H__
N
N
N#include "board_kl520.h"
N
N#define KDP_DDR_MEM_START                   0x60000000
N#define KDP_DDR_MEM_END                     0x63FFFFFF
N//////////////////////////
N/* ddr - models section */
N//////////////////////////
N#define KDP_DDR_MODEL_START_ADDR            KDP_DDR_MEM_START
N#define KDP_DDR_MODEL_RESERVED_END          0x61DFFFFF //reserved 30 MB for models
N#define KDP_DDR_BASE_SYSTEM_RESERVED        0x61E00000 //reserved 191 KB
N#define KDP_DDR_MODEL_INFO_TEMP             0x61E2C000 //reserved 16 KB for model info
N#define KDP_DDR_MODEL_END_ADDR              0x61E2FFFF
N///////////////////////////
N/* ddr - drivers section */
N///////////////////////////
N#define KDP_DDR_DRV_START_ADDR              (KDP_DDR_MODEL_END_ADDR + 1)
N///////////////////////////
N/* ddr - testing section */
N///////////////////////////
N#define KDP_DDR_TEST_RGB_IMG_SIZE           0x00075300 // RGB565
N#define KDP_DDR_TEST_NIR_IMG_SIZE           0x00075300 // RAW8
N#define KDP_DDR_TEST_INF_IMG_SIZE           0x00002000 // img info
N#define KDP_DDR_TEST_IMG_NAME_SIZE          0x00001000 // img info
N#define KDP_DDR_TEST_START_ADDR             0x61E30000
N#define KDP_DDR_TEST_RGB_IMG_ADDR           KDP_DDR_TEST_START_ADDR // 0x61E30000
N#define KDP_DDR_TEST_NIR_IMG_ADDR           (KDP_DDR_TEST_RGB_IMG_ADDR + KDP_DDR_TEST_RGB_IMG_SIZE) // 0x61EA5300
N#define KDP_DDR_TEST_INF_IMG_ADDR           (KDP_DDR_TEST_NIR_IMG_ADDR + KDP_DDR_TEST_NIR_IMG_SIZE) // 0x61F1A600
N#define KDP_DDR_TEST_IMG_NAME_ADDR          (KDP_DDR_TEST_INF_IMG_ADDR + KDP_DDR_TEST_INF_IMG_SIZE) // 0x61F1A600
N#define KDP_DDR_TEST_ENDP1_ADDR             (KDP_DDR_TEST_IMG_NAME_ADDR + KDP_DDR_TEST_IMG_NAME_SIZE) // 0x61F1D600
N#if CFG_AI_USE_FIXED_IMG == YES
X#if 0 == 1
S#define KDP_DDR_AI_RGB_SRC_ADDR             KDP_DDR_TEST_RGB_IMG_ADDR // 0x61E30000
S#define KDP_DDR_AI_NIR_SRC_ADDR             KDP_DDR_TEST_NIR_IMG_ADDR // 0x61EA5300
N#endif
N
N
N/* @snapshot driver section */
N#if CFG_SNAPSHOT_ENABLE == 2
X#if 0 == 2
S#define KDP_DDR_DRV_SNAPSHOT_RESERVED       0x00026000
S#define KDP_DDR_DRV_SNAPSHOT_START_ADDR     0x61F1D600
S#define KDP_DDR_DRV_SNAPSHOT_ENDP1_ADDR     (KDP_DDR_DRV_SNAPSHOT_START_ADDR + KDP_DDR_DRV_SNAPSHOT_RESERVED) // 0x61F43600
N#endif
N
N/* @Flash controller use : FLASH */
N#if CFG_OTA_FLASH_BUF_ENABLE == YES
X#if 1 == 1
N#define KDP_DDR_OTA_FLASH_BUF_RESERVED      0x00002000
N#define KDP_DDR_OTA_FLASH_BUF_START_ADDR    0x61F43600
N#define KDP_DDR_OTA_FLASH_BUF_ENDP1_ADDR    (KDP_DDR_OTA_FLASH_BUF_START_ADDR + KDP_DDR_OTA_FLASH_BUF_RESERVED) // 0x61F45600
N#endif
N
N/* @IMAGE DDR : FLASH */
N#if CFG_OTA_IMAGE_BUF_ENABLE == YES
X#if 1 == 1
N#define KDP_DDR_OTA_IMAGE_BUF_RESERVED      0x00032000
N#define KDP_DDR_OTA_IMAGE_BUF_START_ADDR    0x61F45600
N#define KDP_DDR_OTA_IMAGE_BUF_ENDP1_ADDR    (KDP_DDR_OTA_IMAGE_BUF_START_ADDR + KDP_DDR_OTA_IMAGE_BUF_RESERVED) // 0x61F77600
N#endif
N
N/* @kdp settings section */
N#if CFG_KDP_SETTINGS_ENABLE == YES
X#if 1 == 1
N#define KDP_DDR_SETTINGS_RESERVED           0x00005000
N#define KDP_DDR_SETTINGS_START_ADDR         0x61F77600
N#define KDP_DDR_SETTINGS_ENDP1_ADDR         (KDP_DDR_SETTINGS_START_ADDR + KDP_DDR_SETTINGS_RESERVED) // 0x61F7C600
N#endif
N
N/* @extraction driver section */
N#define KDP_DDR_TEST_RGB_FR_SIZE            0x00000400 // RGB
N#define KDP_DDR_TEST_NIR_FR_SIZE            0x00000400 // NIR
N#define KDP_DDR_TEST_USER_DB_SIZE           0x00004000 // USER_DB
N#define KDP_DDR_TEST_EXTRA_START_ADDR       0x61F7C600
N#define KDP_DDR_TEST_EXTRA_RGB_ADDR         KDP_DDR_TEST_EXTRA_START_ADDR // 0x61F7CA00
N#define KDP_DDR_TEST_EXTRA_NIR_ADDR         (KDP_DDR_TEST_EXTRA_RGB_ADDR + KDP_DDR_TEST_RGB_FR_SIZE) // 0x61F7CE00
N#define KDP_DDR_TEST_EXTRA_DB_ADDR          (KDP_DDR_TEST_EXTRA_NIR_ADDR + KDP_DDR_TEST_NIR_FR_SIZE) // 0x61F80E00
N
N
N/* @Communication bus buffer : COM_BUS_xx */
N#if CFG_COM_BUS_TYPE >= 0
X#if (0x04) >= 0
N#define KDP_DDR_DRV_COM_BUS_RESERVED        0x00001400
N#define KDP_DDR_DRV_COM_BUS_TX_START_ADDR    0x61F80E00
N#define KDP_DDR_DRV_COM_BUS_TX_ENDP1_ADDR    (KDP_DDR_DRV_COM_BUS_TX_START_ADDR + KDP_DDR_DRV_COM_BUS_RESERVED) // 0x61F82200
N#define KDP_DDR_DRV_COM_BUS_RX0_START_ADDR    0x61F82200
N#define KDP_DDR_DRV_COM_BUS_RX0_ENDP1_ADDR    (KDP_DDR_DRV_COM_BUS_RX0_START_ADDR + KDP_DDR_DRV_COM_BUS_RESERVED) // 0x61F83600
N#define KDP_DDR_DRV_COM_BUS_RX1_START_ADDR    0x61F83600
N#define KDP_DDR_DRV_COM_BUS_RX1_ENDP1_ADDR    (KDP_DDR_DRV_COM_BUS_RX1_START_ADDR + KDP_DDR_DRV_COM_BUS_RESERVED) // 0x61F84A00
N#endif
N
N#define KDP_DDR_LAST_ADDR                   0x61F84A00
N
N#endif
L 7 "..\..\..\..\scpu\drivers\include\kdp520_dma.h" 2
N
N/* registers */
N#define DMA_INT						0x0
N#define DMA_INT_TC					0x4
N#define DMA_INT_TC_CLR				0x8
N#define DMA_INT_ERRABT				0xC
N#define DMA_INT_ERRABT_CLR			0x10
N#define DMA_TC						0x14
N#define DMA_ERRABT					0x18
N#define DMA_CH_EN					0x1C
N#define DMA_CH_BUSY					0x20
N#define DMA_CSR						0x24
N#define DMA_SYNC					0x28
N
N#define DMA_FEATURE					0x34
N
N#define DMA_C0_DevDtBase			0x40
N#define DMA_C0_DevRegBase			0x80
N
N
N#define DMA_CHANNEL_OFFSET			0x20
N#define DMA_CHANNEL0_BASE			0x100
N#define DMA_CHANNEL1_BASE			0x120
N#define DMA_CHANNEL2_BASE			0x140
N#define DMA_CHANNEL3_BASE			0x160
N#define DMA_CHANNEL4_BASE			0x180
N#define DMA_CHANNEL5_BASE			0x1a0
N#define DMA_CHANNEL6_BASE			0x1c0
N#define DMA_CHANNEL7_BASE			0x1e0
N
N#define DMA_CHANNEL_CSR_OFFSET		0x0
N#define DMA_CHANNEL_CFG_OFFSET		0x4
N#define DMA_CHANNEL_SRCADDR_OFFSET	0x8
N#define DMA_CHANNEL_DSTADDR_OFFSET	0xc
N#define DMA_CHANNEL_LLP_OFFSET		0x10
N#define DMA_CHANNEL_SIZE_OFFSET		0x14
N
N
N/* bit mapping of main configuration status register(CSR) */
N#define DMA_CSR_M1ENDIAN			0x00000004
N#define DMA_CSR_M0ENDIAN			0x00000002
N#define DMA_CSR_DMACEN				0x00000001
N
N/* bit mapping of channel control register */
N#define DMA_CSR_TC_MSK				0x80000000
N#define DMA_CSR_CHPRJ_HIGHEST		0x00C00000
N#define DMA_CSR_CHPRJ_2ND			0x00800000
N#define DMA_CSR_CHPRJ_3RD			0x00400000
N#define DMA_CSR_PRTO3				0x00200000
N#define DMA_CSR_PRTO2				0x00100000
N#define DMA_CSR_PRTO1				0x00080000
N#define DMA_CSR_SRC_BURST_SIZE_1	0x00000000
N#define DMA_CSR_SRC_BURST_SIZE_4	0x00010000
N#define DMA_CSR_SRC_BURST_SIZE_8	0x00020000
N#define DMA_CSR_SRC_BURST_SIZE_16	0x00030000
N#define DMA_CSR_SRC_BURST_SIZE_32	0x00040000
N#define DMA_CSR_SRC_BURST_SIZE_64	0x00050000
N#define DMA_CSR_SRC_BURST_SIZE_128	0x00060000
N#define DMA_CSR_SRC_BURST_SIZE_256	0x00070000
N
N#define DMA_CSR_ABT					0x00008000
N#define DMA_CSR_SRC_WIDTH_8			0x00000000
N#define DMA_CSR_SRC_WIDTH_16		0x00000800
N#define DMA_CSR_SRC_WIDTH_32		0x00001000
N
N#define DMA_CSR_DST_WIDTH_8			0x00000000
N#define DMA_CSR_DST_WIDTH_16		0x00000100
N#define DMA_CSR_DST_WIDTH_32		0x00000200
N
N#define DMA_CSR_MODE_NORMAL			0x00000000
N#define DMA_CSR_MODE_HANDSHAKE		0x00000080
N
N#define DMA_CSR_SRC_INCREMENT		0x00000000
N#define DMA_CSR_SRC_DECREMENT		0x00000020
N#define DMA_CSR_SRC_FIX				0x00000040
N
N#define DMA_CSR_DST_INCREMENT		0x00000000
N#define DMA_CSR_DST_DECREMENT		0x00000008
N#define DMA_CSR_DST_FIX				0x00000010
N
N#define DMA_CSR_SRC_SEL				0x00000004
N#define DMA_CSR_DST_SEL				0x00000002
N#define DMA_CSR_CH_ENABLE			0x00000001
N
N#define DMA_CSR_CHPR1				0x00C00000
N#define DMA_CSR_SRC_SIZE			0x00070000
N#define DMA_CSR_SRC_WIDTH			0x00003800
N#define DMA_CSR_DST_WIDTH			0x00000700
N#define DMA_CSR_SRCAD_CTL			0x00000060
N#define DMA_CSR_DSTAD_CTL			0x00000018
N
N
N#define DMA_MAX_SIZE				0x10000
N#define DAM_CHANNEL_NUMBER			8
N
N/* bit mapping of channel configuration register */
N#define DMA_CFG_INT_ERR_MSK_Disable	0x00000000
N#define DMA_CFG_INT_TC_MSK_Disable	0x00000000
N
N/* bit mapping of Linked List Control Descriptor */
N#define DMA_LLP_TC_MSK				0x10000000
N
N#define DMA_LLP_SRC_WIDTH_8			0x00000000
N#define DMA_LLP_SRC_WIDTH_16		0x02000000
N#define DMA_LLP_SRC_WIDTH_32		0x04000000
N
N#define DMA_LLP_DST_WIDTH_8			0x00000000
N#define DMA_LLP_DST_WIDTH_16		0x00400000
N#define DMA_LLP_DST_WIDTH_32		0x00800000
N
N#define DMA_LLP_SRC_INCREMENT		0x00000000
N#define DMA_LLP_SRC_DECREMENT		0x00100000
N#define DMA_LLP_SRC_FIX				0x00200000
N
N#define DMA_LLP_DST_INCREMENT		0x00000000
N#define DMA_LLP_DST_DECREMENT		0x00040000
N#define DMA_LLP_DST_FIX				0x00080000
N
N#define DMA_LLP_SRC_SEL				0x00020000
N#define DMA_LLP_DST_SEL				0x00010000
N
N/////////////////////////// AHB DMA Define //////////////////////////////////
N#define AHBDMA_Channel0					0
N#define AHBDMA_Channel1					1
N#define AHBDMA_Channel2					2
N#define AHBDMA_Channel3					3
N#define AHBDMA_Channel4					4
N#define AHBDMA_Channel5					5
N#define AHBDMA_Channel6					6
N#define AHBDMA_Channel7					7
N
N
N#define AHBDMA_CH_SD					0
N#define AHBDMA_CH_I2S_TX				1
N#define AHBDMA_CH_I2S_RX				2
N#define AHBDMA_CH_ADC					3
N#define AHBDMA_CH_IDE_TX				4
N#define AHBDMA_CH_IDE_RX				5
N#define AHBDMA_CH_SPI2_TX				6
N#define AHBDMA_CH_SPI2_RX				7
N
N
N
N#define AHBDMA_SrcWidth_Byte				0
N#define AHBDMA_SrcWidth_Word				1
N#define AHBDMA_SrcWidth_DWord				2
N
N#define AHBDMA_DstWidth_Byte				0
N#define AHBDMA_DstWidth_Word				1
N#define AHBDMA_DstWidth_DWord				2
N
N#define AHBDMA_Burst1						0
N#define AHBDMA_Burst4						1
N#define AHBDMA_Burst8						2
N#define AHBDMA_Burst16						3
N#define AHBDMA_Burst32						4
N#define AHBDMA_Burst64						5
N#define AHBDMA_Burst128					6
N#define AHBDMA_Burst256					7
N
N#define AHBDMA_NormalMode					0
N#define AHBDMA_HwHandShakeMode			1
N
N#define AHBDMA_SrcInc						0
N#define AHBDMA_SrcDec						1
N#define AHBDMA_SrcFix						2
N
N#define AHBDMA_DstInc						0
N#define AHBDMA_DstDec						1
N#define AHBDMA_DstFix						2
N
N#define AHBDMA_PriorityLow					0
N#define AHBDMA_Priority3rd					1
N#define AHBDMA_Priority2nd					2
N#define AHBDMA_PriorityHigh					3
N
N
N// --------------------------------------------------------------------
N//	3.21.1 Channel Control Register (Cn_CSR) (0x100, 0x120, ....)
N// --------------------------------------------------------------------
Ntypedef struct
N{
N	UINT32 enable:1;
N	UINT32 dst_sel:1;
N	UINT32 src_sel:1;
N	UINT32 dst_ctrl:2;
N	UINT32 src_ctrl:2;
N	UINT32 mode:1;
N	UINT32 dst_width:3;
N	UINT32 src_width:3;
N	UINT32 reserved1:1;
N	UINT32 abt:1;
N	UINT32 src_size:3;
N	UINT32 prot:3;
N	UINT32 priority:2;
N	UINT32 ff_th:3;			//FIE7021
N	UINT32 reserved0:4;		//FIE7021
N	UINT32 tc_msk:1;
N} dma_ch_csr;
N
Ntypedef struct
N{
N	UINT32 int_tc_msk:1;
N	UINT32 int_err_msk:1;
N	UINT32 int_abt_msk:1;
N//FIE7020	UINT32 reserved0:5;
N	UINT32 src_rs:4;		//FIE7021
N	UINT32 src_he:1;		//FIE7021
N	UINT32 busy:1;
N//FIE7020	UINT32 reserved1:7;
N	UINT32 dst_rs:4;		//FIE7021
N	UINT32 dst_he:1;		//FIE7021
N	UINT32 reserved1:2;		//FIE7021
N	UINT32 llp_cnt:4;
N	UINT32 reserved2:12;
N} dma_ch_cfg;
N
Ntypedef struct
N{
N	UINT32 master_id:1;
N	UINT32 reserved:1;
N	UINT32 link_list_addr:30;
N} dma_ch_llp;
N
N
N// --------------------------------------------------------------------
N// Table 3-2. Control Field Definition in Linked List Descriptor
N// --------------------------------------------------------------------
Ntypedef struct
N{
N	UINT32 reserved:16;		//FIE7021
N
N	UINT32 dst_sel:1;
N	UINT32 src_sel:1;
N	UINT32 dst_ctrl:2;
N	UINT32 src_ctrl:2;
N	UINT32 dst_width:3;
N	UINT32 src_width:3;
N	UINT32 tc_msk:1;
N	UINT32 ff_th:3;			//FIE7021
N} dma_llp_ctrl;
N
N
N// channel n registers (0x100 ~ ...)
Ntypedef struct
N{
N	dma_ch_csr csr;			// 0x0
N	dma_ch_cfg cfg;			// 0x4
N	UINT32 src_addr;				// 0x8
N	UINT32 dst_addr;				// 0xc
N	dma_ch_llp llp;			// 0x10
N	UINT32 size;					// 0x14
N	UINT32 dummy[2];
N} dma_ch;
N
N
N// --------------------------------------------------------------------
N//	Table 3-1. Address Map for Linked List Descriptor (Base Address: Cn_LLP[31:2])
N// --------------------------------------------------------------------
Ntypedef struct
N{
N	UINT32 src_addr;
N	UINT32 dst_addr;
N	dma_ch_llp llp;
N	dma_llp_ctrl llp_ctrl;
N	UINT32 size;			//FIE7021
N} dma_lld;
N
N
Ntypedef struct
N{
N	UINT32 dma_int;							// 0x00
N	UINT32 dma_int_tc;						// 0x04
N	UINT32 dma_int_tc_clr;					// 0x08
N	UINT32 dma_int_err;						// 0x0c
N	UINT32 dma_int_err_clr;					// 0x10
N	UINT32 dma_tc;							// 0x14
N	UINT32 dma_err;							// 0x18
N	UINT32 dma_ch_enable;					// 0x1c
N	UINT32 dma_ch_busy;						// 0x20
N	UINT32 dma_csr;							// 0x24
N	UINT32 dma_sync;						// 0x28
N	UINT32 dummy0[5];
N	UINT32 dma_ch_dev_dt_base[8];			// 0x40
N
N	UINT32 dummy1[8];						// 0x60
N
N	UINT32 dma_ch_dev_reg_base[8];			// 0x80
N
N	UINT32 dummy2[24];
N
N	dma_ch dma_ch[8];				// 0x100 ~ ...
N} kdp520_dma_reg;
N
Ntypedef struct
N{
N    u32 addr;
N    u16 start_x;
N    u16 start_y;
N    u16 w;
N    u8 data_type;
N} dma_2d_crop_info_t;
N
Ntypedef struct
N{
N    dma_2d_crop_info_t src;
N    dma_2d_crop_info_t dst;
N    u16 data_w;
N    u16 data_h;
N} dma_2d_memcpy_t;
N
N/*  -------------------------------------------------------------------------------
N *   API
N *  -------------------------------------------------------------------------------
N */
N
Nextern int    kdp_dma_is_ch_busy(INT32 Channel);
Nextern int    kdp_dma_is_ch_enable(INT32 Channel);
Nextern UINT32 kdp_dma_get_int_status(void);
Nextern UINT32 kdp_dma_get_ch_int_status(INT32 Channel);
Nextern int    kdp_dma_get_busy_status(void);
Nextern int    kdp_dma_get_enable_status(void);
N
Nextern void   kdp_dma_init(UINT32 M0_BigEndian, UINT32 M1_BigEndian, UINT32 Sync);
Nextern void   kdp_dma_enable_ch(INT32 Channel);
N
Nextern void   kdp_dma_disable_ch(INT32 Channel);  // add by jerry
N
Nextern void   kdp_dma_clear_ch_int_status(INT32 Channel);
N
Nextern void   kdp_dma_set_ch_cfg(INT32 Channel, dma_ch_csr Csr);
Nextern void   kdp_dma_set_ch_cn_cfg(INT32 Channel, dma_ch_cfg CnCfg);
Nextern dma_ch_csr kdp_dma_get_ch_cfg(INT32 Channel);
Nextern void   kdp_dma_ch_int_mask(INT32 Channel, dma_ch_cfg Mask);
Nextern void   kdp_dma_ch_linklist(INT32 Channel, dma_ch_llp LLP);
Nextern void   kdp_dma_ch_data_ctrl(INT32 Channel, UINT32 SrcAddr, UINT32 DstAddr, UINT32 Size);
Nextern void kdp_flash_to_ddr_dma_copy(UINT32 *src_addr, UINT32 *dst_addr, UINT32 size);
Nextern void kdp_dma_normal_mode(
NUINT32 Channel,   // use which channel for AHB DMA, 0..7
NUINT32 SrcAddr,   // source begin address
NUINT32 DstAddr,   // dest begin address
NUINT32 Size,      // total bytes
NUINT32 SrcWidth,  // source width 8/16/32 bits -> 0/1/2
NUINT32 DstWidth,  // dest width 8/16/32 bits -> 0/1/2
NUINT32 SrcSize,   // source burst size, How many "SrcWidth" will be transmmited at one times ?
NUINT32 SrcCtrl,   // source address change : Inc/dec/fixed --> 0/1/2
NUINT32 DstCtrl,   // dest address change : Inc/dec/fixed --> 0/1/2
NUINT32 Priority,  // priority for this chaanel 0(low)/1/2/3(high)
NUINT32 Mode,      // Normal/Hardwire,   0/1
Nint    req	  	  // DMA request select (ps. ???????? ram vs device, ?????? req)
N				  // ?? device vs device, ?????? api
N);
N
Nextern void kdp_dma_linkmode(
NUINT32 Channel,   // use which channel for AHB DMA, 0..7
NUINT32 LinkAddr,  // Link-List address
NUINT32 LLPCount,  // total link-list node
NUINT32 SrcAddr,   // source begin address
NUINT32 DstAddr,   // dest begin address
NUINT32 Size,      // total bytes
NUINT32 SrcWidth,  // source width 8/16/32 bits -> 0/1/2
NUINT32 DstWidth,  // dest width 8/16/32 bits -> 0/1/2
NUINT32 SrcSize,   // source burst size, How many "SrcWidth" will be transmmited at one times ?
NUINT32 SrcCtrl,   // source address change : Inc/dec/fixed --> 0/1/2
NUINT32 DstCtrl,   // dest address change : Inc/dec/fixed --> 0/1/2
NUINT32 Priority,  // priority for this chaanel 0(low)/1/2/3(high)
NUINT32 Mode,      // Normal/Hardwire,   0/1
Nint    req	  	  // DMA request select (ps. ???????? ram vs device, ?????? req)
N				  // ?? device vs device, ?????? api
N);
N
Nextern void kdp_dma_wait_int_status(UINT32 Channel);
Nextern void kdp_dma_set_interrupt(UINT32 channel, UINT32 tcintr, UINT32 errintr, UINT32 abtintr);
Nextern void kdp_dma_reset_ch(UINT8 channel);
Nextern void kdp_dma_clear_interrupt(UINT8 channel);
Nextern void kdp_dma_clear_all_interrupt(void);
Nextern void kdp_dma_enable_dma_int(void);
Nextern void kdp_dma_disable_dma_int(void);
Nextern void kdp_dma_enable_dma_tc_int(void);
Nextern void kdp_dma_disable_dma_tc_int(void);
Nextern u8 kdp_dma_wait_dma_int(UINT32 channel);
Nextern void kdp_dma_wait_dma_tc_int(UINT32 channel);
Nextern void kdp_ddr_to_slcd_dma_copy(UINT32 *src_addr, UINT32 *dst_addr, UINT32 size);
Nint kdp_dma_get_ch_num(void);		// DMA maximum channel number
Nextern void kdp_dma_link_transfer(
NUINT32 Channel,   // use which channel for AHB DMA, 0..7
NUINT32 LinkAddr,  // Link-List address
NUINT32 LLPCount,  // total link-list node
NUINT32 SrcAddr,   // source begin address
NUINT32 DstAddr,   // dest begin address
NUINT32 Size,      // total bytes
NUINT32 SrcWidth,  // source width 8/16/32 bits -> 0/1/2
NUINT32 DstWidth,  // dest width 8/16/32 bits -> 0/1/2
NUINT32 SrcSize,   // source burst size, How many "SrcWidth" will be transmmited at one times ?
NUINT32 SrcCtrl,   // source address change : Inc/dec/fixed --> 0/1/2
NUINT32 DstCtrl,   // dest address change : Inc/dec/fixed --> 0/1/2
NUINT32 Priority,  // priority for this chaanel 0(low)/1/2/3(high)
NUINT32 Mode,      // Normal/Hardwire,   0/1
Nint req);
Nextern u8 kdp_api_2D_memcpy( dma_2d_memcpy_t info );
N
N#if (CFG_E2E_NIR_TWO_STAGE_LIGHT == YES)
X#if (0 == 1)
Svoid kl520_api_img_reserv_dma(u32 writeAddr, u32 readAddr, u32 len);
N#endif
N
N#endif  //__KDP520_DMA_H__
L 24 "..\..\user\main.c" 2
N#include "kneron_mozart.h"                // Device header
L 1 "..\..\..\..\scpu\device\include\Kneron\kneron_mozart.h" 1
N/**************************************************************************//**
N * @file     kneron_mozart.h
N * @brief    CMSIS Core Peripheral Access Layer Header File for
N *           ARMCM4 Device (configured for CM4 without FPU)
N * @version  V5.3.1
N * @date     09. July 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef Kneron_Mozart
N#define Kneron_Mozart
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N// base on Kneron_0221_v014.resmap_int_n_dma.xml
Ntypedef enum {
N/* -------------------  Cortex-M4 Processor Exceptions Numbers  ------------------- */
N    Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N    NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
N    HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N    MemoryManagement_IRQn         = -12,              /*!<   4  Memory Management, MPU mismatch, including Access Violation
N                                                                and No Match                                                     */
N    BusFault_IRQn                 = -11,              /*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
N                                                                related Fault                                                    */
N    UsageFault_IRQn               = -10,              /*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition    */
N    SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
N    DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
N    PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
N    SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
N/* -------------------  Kneron_Mozart Specific Interrupt Numbers  ------------------- */
N    PINMUX_FUNCTION_IRQ           =  0,               /*!<  0   PINMUX             */
N    DDR_FTDDR3030_IRQ             =  1,               /*!<  1   DDR                */
N    ADC_FTADCC010_IRQ             =  2,               /*!<  2   ADC                */
N    DMA_FTDMAC020_0_IRQ           =  3,               /*!<  3   DMA0               */
N    DMA_FTDMAC020_0_TC_IRQ        =  4,               /*!<  4   DMA0_TC            */
N    DMA_FTDMAC020_0_ERR_IRQ       =  5,               /*!<  5   DMA0_ERR           */
N    DMA_FTDMAC020_1_IRQ           =  6,               /*!<  6   DMA1_TC            */
N    DMA_FTDMAC020_1_TC_IRQ        =  7,               /*!<  7   DMA1               */
N    DMA_FTDMAC020_1_ERR_IRQ       =  8,               /*!<  8   DMA1_ERR           */
N    D2A_FTDPI2AHB_IRQ             =  9,               /*!<  9   DPI2AHB            */
N    GPIO_FTGPIO010_IRQ            =  10,              /*!<  10  GPIO               */
N    PWM_FTPWMTMR010_GLOBAL_IRQ    =  11,              /*!<  11  PWMTMR_GLOBAL    	 */
N    PWM_FTPWMTMR010_1_IRQ         =  12,              /*!<  12  PWMTMR_1           */
N    PWM_FTPWMTMR010_2_IRQ         =  13,              /*!<  13  PWMTMR_2           */
N    PWM_FTPWMTMR010_3_IRQ         =  14,              /*!<  14  PWMTMR_3           */
N    PWM_FTPWMTMR010_4_IRQ         =  15,              /*!<  15  PWMTMR_4           */
N    PWM_FTPWMTMR010_5_IRQ         =  16,              /*!<  16  PWMTMR_5           */
N    PWM_FTPWMTMR010_6_IRQ         =  17,              /*!<  17  PWMTMR_6           */
N    SDC_FTSDC021_IRQ              =  18,              /*!<  18  SDC                */
N    SPI_FTSPI020_IRQ              =  19,              /*!<  19  SPI                */
N    SPI_FTSPI2AHB_RD_IRQ          =  20,              /*!<  20  SPI2AHB_RD         */
N    SPI_FTSPI2AHB_WR_IRQ          =  21,              /*!<  21  SPI2AHB_WR         */
N    SPI_FTSPI2AHB_IRQ             =  22,              /*!<  22  SPI2AHB            */
N    SSP_FTSSP010_0_IRQ            =  23,              /*!<  23  SSP                */
N    SSP_FTSSP010_1_IRQ            =  24,              /*!<  24  SSP                */
N    TMR_FTTMR010_0_1_IRQ          =  25,              /*!<  25  TMR_1              */
N    TMR_FTTMR010_0_2_IRQ          =  26,              /*!<  26  TMR_2              */
N    TMR_FTTMR010_0_3_IRQ          =  27,              /*!<  27  TMR_3              */
N    TMR_FTTMR010_0_GLOBAL_IRQ     =  25,              /*!<  28  TMR_GLOBAL         */
N    UART_FTUART010_IRDA_IRQ       =  29,              /*!<  29  UART0_IRDA         */
N    UART_FTUART010_0_IRQ          =  30,              /*!<  30  UART0              */
N    UART_FTUART010_1_IRQ          =  31,              /*!<  31  UART1              */
N    WDT_FTWDT010_IRQ              =  32,              /*!<  32  WDT                */
N    NPU_NPU_IRQ                   =  33,              /*!<  33  NPU                */
N    CSI_FTCSIRX100_IRQ            =  34,              /*!<  34  CSIRX              */
N    OTG_SBS_3_IRQ                 =  35,              /*!<  35  OTG_SBS            */
N    #if 0
S    TMR_FTTMR010_1_1_IRQ          =  36,              /*!<  36  TMR010_1           */
S    TMR_FTTMR010_1_2_IRQ          =  37,              /*!<  37  TMR010_2           */
S    TMR_FTTMR010_1_3_IRQ          =  38,              /*!<  38  TMR010_3           */
S    TMR_FTTMR010_1_IRQ            =  39,              /*!<  39  TMR010             */
N    #endif
N    TMR_FTTMR010_1_GLOBAL_IRQ     =  36,              /*!<  36  TMR010_1           */
N    TMR_FTTMR010_1_1_IRQ          =  37,              /*!<  37  TMR010_2           */
N    TMR_FTTMR010_1_2_IRQ          =  38,              /*!<  38  TMR010_3           */
N    TMR_FTTMR010_1_3_IRQ          =  39,              /*!<  39  TMR010             */
N    SYS_SYSTEM_IRQ                =  40,              /*!<  40  SYSC               */
N    MIPI_TX_IRQ                   =  41,              /*!<  41  MIPI_TX            */
N    IIC_FTIIC010_0_IRQ            =  42,              /*!<  42  I2C0               */
N    IIC_FTIIC010_1_IRQ            =  43,              /*!<  43  I2C1               */
N    IIC_FTIIC010_2_IRQ            =  44,              /*!<  44  I2C2               */
N    IIC_FTIIC010_3_IRQ            =  45,              /*!<  45  I2C3               */
N    SSP_FTSSP010_0_1_IRQ          =  46,              /*!<  46  SSP_u0_1           */
N    SSP_FTSSP010_1_1_IRQ          =  47,              /*!<  47  SSP_u1_1           */
N    UART_FTUART010_1_1_IRQ        =  48,              /*!<  48  UART2              */
N    UART_FTUART010_1_2_IRQ        =  49,              /*!<  49  UART3              */
N    UART_FTUART010_1_3_IRQ        =  50,              /*!<  50  UART4              */
N    SYSC_SGI_S_STATUS_IRQ         =  51,              /*!<  51  SYSC_SGI_S         */
N    SBS_CSI_RX_IRQ                =  52,              /*!<  52  CSI_RX             */
N    LCDC_FTLCDC210_VSTATUS_IRQ    =  53,              /*!<  53  LCDC_VSTATUS       */
N    LCDC_FTLCDC210_BAUPD_IRQ      =  54,              /*!<  54  LCDC_BAUPD         */
N    LCDC_FTLCDC210_FUR_IRQ        =  55,              /*!<  55  LCDC_FUR           */
N    LCDC_FTLCDC210_MERR_IRQ       =  56,              /*!<  56  LCDC_MERR          */
N    LCDC_FTLCDC210_IRQ            =  57,              /*!<  57  LCDC               */
N    D2A_FTDPI2AHB_1_IRQ           =  58,              /*!<  9  DPI2AHB_1          */    
N} IRQn_Type;
N
N
N/* -------------------------  AHB DMA Request Number  ------------------------ */
N/* -------------------------      FTDMAC020_u0        ------------------------ */
N/* -----[Request Name]                  [Num]           [Instance] ----------- */
N#define IRDA_u1_2_NTX_RDY_REQ           0               /*FTUART010_u1_2*/
N#define IRDA_u1_2_TX_ACK                0               /*FTUART010_u1_2*/
N#define IRDA_u1_2_NRX_RDY_REQ           1               /*FTUART010_u1_2*/
N#define IRDA_u1_2_RX_ACK                1               /*FTUART010_u1_2*/
N#define IRDA_u1_3_NTX_RDY_REQ           2               /*FTUART010_u1_3*/
N#define IRDA_u1_3_TX_ACK                2               /*FTUART010_u1_3*/
N#define IRDA_u1_3_NRX_RDY_REQ           3               /*FTUART010_u1_3*/
N#define IRDA_u1_3_RX_ACK                3               /*FTUART010_u1_3*/
N#define TMR1_DMA_REQ                    4               /*FTPWM010_1*/
N#define TMR1_DMA_ACK                    4               /*FTPWM010_1*/
N#define TMR2_DMA_REQ                    5               /*FTPWM010_2*/
N#define TMR2_DMA_ACK                    5               /*FTPWM010_2*/
N#define TMR3_DMA_REQ                    6               /*FTPWM010_3*/
N#define TMR3_DMA_ACK                    6               /*FTPWM010_3*/
N#define TMR4_DMA_REQ                    7               /*FTPWM010_4*/
N#define TMR4_DMA_ACK                    7               /*FTPWM010_4*/
N#define TMR5_DMA_REQ                    8               /*FTPWM010_5*/
N#define TMR5_DMA_ACK                    8               /*FTPWM010_5*/
N#define TMR6_DMA_REQ                    9               /*FTPWM010_6*/
N#define TMR6_DMA_ACK                    9               /*FTPWM010_6*/
N#define SD_DMA_REQ                      10              /*FTSDC021*/
N#define SD_DMA_ACK                      10              /*FTSDC021*/
N#define SPI_DMA_REQ                     11              /*FTSPI020*/
N#define SPI_DMA_ACK                     11              /*FTSPI020*/
N#define SSP_u0_TX_DMA_REQ               12              /*FTSSP010_u0*/
N#define SSP_u0_TX_DMA_GNT               12              /*FTSSP010_u0*/
N#define SSP_u0_RX_DMA_REQ               13              /*FTSSP010_u0*/
N#define SSP_u0_RX_DMA_GNT               13              /*FTSSP010_u0*/
N#define SSP_u0_1_TX_DMA_REQ             14              /*FTSSP010_u0_1*/
N#define SSP_u0_1_TX_DMA_GNT             14              /*FTSSP010_u0_1*/
N#define SSP_u0_1_RX_DMA_REQ             15              /*FTSSP010_u0_1*/
N#define SSP_u0_1_RX_DMA_GNT             15              /*FTSSP010_u0_1*/
N/* -------------------------      FTDMAC020_u1        ------------------------ */
N/* -----[Request Name]                  [Num]           [Instance] ----------- */
N#define SSP_u1_TX_DMA_REQ               0               /*FTSSP010_u1*/
N#define SSP_u1_TX_DMA_GNT               0               /*FTSSP010_u1*/
N#define SSP_u1_RX_DMA_REQ               1               /*FTSSP010_u1*/
N#define SSP_u1_RX_DMA_RGNT              1               /*FTSSP010_u1*/
N#define SSP_u1_1_TX_DMA_REQ             2               /*FTSSP010_u1_1*/
N#define SSP_u1_1_TX_DMA_GNT             2               /*FTSSP010_u1_1*/
N#define SSP_u1_1_RX_DMA_REQ             3               /*FTSSP010_u1_1*/
N#define SSP_u1_1_RX_DMA_GNT             3               /*FTSSP010_u1_1*/
N#define IRDA_u0_DMA_REQ                 4               /*FTUART010_u0*/
N#define IRDA_u0_DMA_ACK                 4               /*FTUART010_u0*/
N#define IRDA_u0_NTX_RDY                 5               /*FTUART010_u0*/
N#define IRDA_u0_TX_ACK                  5               /*FTUART010_u0*/
N#define IRDA_u0_NRX_RDY                 6               /*FTUART010_u0*/
N#define IRDA_u0_RX_ACK                  6               /*FTUART010_u0*/
N#define IRDA_u1_NTX_RDY                 7               /*FTUART010_u1*/
N#define IRDA_u1_TX_ACK                  7               /*FTUART010_u1*/
N#define IRDA_u1_NRX_RDY                 8               /*FTUART010_u1*/
N#define IRDA_u1_RX_ACK                  8               /*FTUART010_u1*/
N#define IRDA_u1_1_NTX_RDY               9               /*FTUART010_u1_1*/
N#define IRDA_u1_1_TX_ACK                9               /*FTUART010_u1_1*/
N#define IRDA_u1_1_NRX_RDY               10              /*FTUART010_u1_1*/
N#define IRDA_u1_1_RX_ACK                10              /*FTUART010_u1_1*/
N#define ADC_DMA_REQ_0                   11              /*FTADCC010*/
N#define ADC_DMA_ACK_0                   11              /*FTADCC010*/
N#define ADC_DMA_REQ_1                   12              /*FTADCC010*/
N#define ADC_DMA_ACK_1                   12              /*FTADCC010*/
N#define ADC_DMA_REQ_2                   13              /*FTADCC010*/
N#define ADC_DMA_ACK_2                   13              /*FTADCC010*/
N#define ADC_DMA_REQ_3                   14              /*FTADCC010*/
N#define ADC_DMA_REQ_3                   14              /*FTADCC010*/
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* -------  Start of section using anonymous unions and disabling warnings  ------- */
N#if   defined (__CC_ARM)
X#if   1L
N    #pragma push
N    #pragma anon_unions
N#elif defined (__ICCARM__)
X#elif 0L
S    #pragma language=extended
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S    #pragma clang diagnostic push
S    #pragma clang diagnostic ignored "-Wc11-extensions"
S    #pragma clang diagnostic ignored "-Wreserved-id-macro"
S#elif defined (__GNUC__)
S    /* anonymous unions are enabled by default */
S#elif defined (__TMS470__)
S    /* anonymous unions are enabled by default */
S#elif defined (__TASKING__)
S    #pragma warning 586
S#elif defined (__CSMC__)
S    /* anonymous unions are enabled by default */
S#else
S    #warning Not supported compiler type
N#endif
N
N/* --------  Configuration of Core Peripherals  ----------------------------------- */
N#define __CM4_REV                 0x0001U   /* Core revision r0p1 */
N#define __MPU_PRESENT             1U        /* MPU present */
N#define __VTOR_PRESENT            1U        /* VTOR present */
N#define __NVIC_PRIO_BITS          3U        /* Number of Bits used for Priority Levels */
N#define __Vendor_SysTickConfig    0U        /* Set to 1 if different SysTick Config is used */
N#define __FPU_PRESENT             1U        /* with FPU present */
N
N#include "core_cm4.h"                       /* Processor and core peripherals */
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V5.1.2
N * @date     04. June 2021
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M4
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.5
N * @date     02. February 2022
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2022 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 6U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 2
N
N/* CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM4_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM4_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) |                                     __CM4_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (4U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
X    #if 1L && (1U == 1U)
N      #define __FPU_USED       1U
N    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
N    #endif
N  #else
S    #define __FPU_USED         0U
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #if defined __ARM_FP
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.1.0
N * @date     09. October 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.3.2
N * @date     27. May 2021
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2021 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060750 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (0L && (__TARGET_ARCH_6S_M  == 1))   )
S  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (1L && (1 == 1))
N  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N  /* __ARM_ARCH_8_1M_MAIN__  not applicable */
N
N/* CMSIS compiler control DSP macros */
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1 == 1))     )
N  #define __ARM_FEATURE_DSP         1
N#endif
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif
N#ifndef   __NO_RETURN
S  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N#ifndef   __COMPILER_BARRIER
N  #define __COMPILER_BARRIER()                   __memory_changed()
N#endif
N
N/* #########################  Startup and Lowlevel Init  ######################## */
N
N#ifndef __PROGRAM_START
N#define __PROGRAM_START           __main
N#endif
N
N#ifndef __INITIAL_SP
N#define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit
N#endif
N
N#ifndef __STACK_LIMIT
N#define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base
N#endif
N
N#ifndef __VECTOR_TABLE
N#define __VECTOR_TABLE            __Vectors
N#endif
N
N#ifndef __VECTOR_TABLE_ATTRIBUTE
N#define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section("RESET")))
N#endif
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (1L && (1 == 1))     )
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value != 0U; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return result;
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (1L && (1 == 1))     )
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
S{
S  if ((sat >= 1U) && (sat <= 32U))
S  {
S    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
S    const int32_t min = -1 - max ;
S    if (val > max)
S    {
S      return max;
S    }
S    else if (val < min)
S    {
S      return min;
S    }
S  }
S  return val;
S}
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
S{
S  if (sat <= 31U)
S  {
S    const uint32_t max = ((1U << sat) - 1U);
S    if (val > (int32_t)max)
S    {
S      return max;
S    }
S    else if (val < 0)
S    {
S      return 0U;
S    }
S  }
S  return (uint32_t)val;
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing special-purpose register PRIMASK.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N  __ISB();
X  __isb(0xF);
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (1L && (1 == 1))     )
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing special-purpose register FAULTMASK.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting special-purpose register FAULTMASK.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1U);
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((1L && (1U == 1U)) &&      (1L && (1U    == 1U))     )
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((1L && (1U == 1U)) &&      (1L && (1U    == 1U))     )
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#else
S  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1 == 1))     )
N
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
N
N#define __SXTB16_RORn(ARG1, ARG2)        __SXTB16(__ROR(ARG1, ARG2))
N
N#define __SXTAB16_RORn(ARG1, ARG2, ARG3) __SXTAB16(ARG1, __ROR(ARG2, ARG3))
N
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6.6 LTM (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)
X#elif 1L && (5060750 >= 6010050) && (5060750 < 6100100)
S  #include "cmsis_armclang_ltm.h"
S
S  /*
S * Arm Compiler above 6.10.1 (armclang)
S */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #define __RESTRICT                             __restrict
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 163 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000U
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT             1U
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
N    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
N    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
N#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
N#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RESERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_MMARVALID_Pos             (SCB_CFSR_MEMFAULTSR_Pos + 7U)                 /*!< SCB CFSR (MMFSR): MMARVALID Position */
N#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
N
N#define SCB_CFSR_MLSPERR_Pos               (SCB_CFSR_MEMFAULTSR_Pos + 5U)                 /*!< SCB CFSR (MMFSR): MLSPERR Position */
N#define SCB_CFSR_MLSPERR_Msk               (1UL << SCB_CFSR_MLSPERR_Pos)                  /*!< SCB CFSR (MMFSR): MLSPERR Mask */
N
N#define SCB_CFSR_MSTKERR_Pos               (SCB_CFSR_MEMFAULTSR_Pos + 4U)                 /*!< SCB CFSR (MMFSR): MSTKERR Position */
N#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
N
N#define SCB_CFSR_MUNSTKERR_Pos             (SCB_CFSR_MEMFAULTSR_Pos + 3U)                 /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
N#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
N
N#define SCB_CFSR_DACCVIOL_Pos              (SCB_CFSR_MEMFAULTSR_Pos + 1U)                 /*!< SCB CFSR (MMFSR): DACCVIOL Position */
N#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
N
N#define SCB_CFSR_IACCVIOL_Pos              (SCB_CFSR_MEMFAULTSR_Pos + 0U)                 /*!< SCB CFSR (MMFSR): IACCVIOL Position */
N#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
N
N/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
N#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
N
N#define SCB_CFSR_LSPERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 5U)                  /*!< SCB CFSR (BFSR): LSPERR Position */
N#define SCB_CFSR_LSPERR_Msk               (1UL << SCB_CFSR_LSPERR_Pos)                    /*!< SCB CFSR (BFSR): LSPERR Mask */
N
N#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
N#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
N
N#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
N#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
N
N#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
N#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
N
N#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
N#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
N
N#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
N#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
N
N/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
N#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
N
N#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
N#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
N
N#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
N#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
N
N#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
N#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
N
N#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
N#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
N
N#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
N#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[32U];
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFFFFFFFFUL /*<< ITM_TPR_PRIVMASK_Pos*/)     /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IM  uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile const  uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER Register */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x1UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x1UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY2_Pos          0U                                         /*!< TPI ITATBCTR2: ATREADY2 Position */
N#define TPI_ITATBCTR2_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY2_Pos*/)   /*!< TPI ITATBCTR2: ATREADY2 Mask */
N
N#define TPI_ITATBCTR2_ATREADY1_Pos          0U                                         /*!< TPI ITATBCTR2: ATREADY1 Position */
N#define TPI_ITATBCTR2_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY1_Pos*/)   /*!< TPI ITATBCTR2: ATREADY1 Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x1UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x1UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY2_Pos          0U                                         /*!< TPI ITATBCTR0: ATREADY2 Position */
N#define TPI_ITATBCTR0_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY2_Pos*/)   /*!< TPI ITATBCTR0: ATREADY2 Mask */
N
N#define TPI_ITATBCTR0_ATREADY1_Pos          0U                                         /*!< TPI ITATBCTR0: ATREADY1 Position */
N#define TPI_ITATBCTR0_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY1_Pos*/)   /*!< TPI ITATBCTR0: ATREADY1 Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x3UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_SubType_Pos             4U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N#define TPI_DEVTYPE_MajorType_Pos           0U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N#define MPU_TYPE_RALIASES                  4U
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif /* defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U) */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N  \brief    Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
X  volatile uint32_t FPCCR;                   
N  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
X  volatile uint32_t FPCAR;                   
N  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
X  volatile uint32_t FPDSCR;                  
N  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
X  volatile const  uint32_t MVFR0;                   
N  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
X  volatile const  uint32_t MVFR1;                   
N  __IM  uint32_t MVFR2;                  /*!< Offset: 0x018 (R/ )  Media and FP Feature Register 2 */
X  volatile const  uint32_t MVFR2;                   
N} FPU_Type;
N
N/* Floating-Point Context Control Register Definitions */
N#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register Definitions */
N#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register Definitions */
N#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 Definitions */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 Definitions */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/* Media and FP Feature Register 2 Definitions */
N
N#define FPU_MVFR2_VFP_Misc_Pos              4U                                            /*!< MVFR2: VFP Misc bits Position */
N#define FPU_MVFR2_VFP_Misc_Msk             (0xFUL << FPU_MVFR2_VFP_Misc_Pos)              /*!< MVFR2: VFP Misc bits Mask */
N
N/*@} end of group CMSIS_FPU */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N#define FPU_BASE            (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
N#define FPU                 ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N  #define NVIC_GetActive              __NVIC_GetActive
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* The following EXC_RETURN values are saved the LR on exception entry */
N#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
N#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
N#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
N#define EXC_RETURN_HANDLER_FPU     (0xFFFFFFE1UL)     /* return to Handler mode, uses MSP after return, restore floating-point state */
N#define EXC_RETURN_THREAD_MSP_FPU  (0xFFFFFFE9UL)     /* return to Thread mode, uses MSP after return, restore floating-point state  */
N#define EXC_RETURN_THREAD_PSP_FPU  (0xFFFFFFEDUL)     /* return to Thread mode, uses PSP after return, restore floating-point state  */
N
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
X                (PriorityGroupTmp << 8U)  );               
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t __NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    __COMPILER_BARRIER();
X    __memory_changed();
N    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __COMPILER_BARRIER();
X    __memory_changed();
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __DSB();
X    __dsb(0xF);
N    __ISB();
X    __isb(0xF);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetActive(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - 3U)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3U)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)IRQn)]               >> (8U - 3U)));
N  }
N  else
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3U)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3U)) ? (uint32_t)(3U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3U));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3U)) ? (uint32_t)(3U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3U));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N  /* ARM Application Note 321 states that the M4 does not require the architectural barrier */
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
X__declspec(noreturn) static __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  __dsb(0xF);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  MPU functions  #################################### */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N
N#include "mpu_armv7.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\mpu_armv7.h" 1
N/******************************************************************************
N * @file     mpu_armv7.h
N * @brief    CMSIS MPU API for Armv7-M MPU
N * @version  V5.1.2
N * @date     25. May 2020
N ******************************************************************************/
N/*
N * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N 
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header    /* treat file as system include file */
N#endif
N 
N#ifndef ARM_MPU_ARMV7_H
N#define ARM_MPU_ARMV7_H
N
N#define ARM_MPU_REGION_SIZE_32B      ((uint8_t)0x04U) ///!< MPU Region Size 32 Bytes
N#define ARM_MPU_REGION_SIZE_64B      ((uint8_t)0x05U) ///!< MPU Region Size 64 Bytes
N#define ARM_MPU_REGION_SIZE_128B     ((uint8_t)0x06U) ///!< MPU Region Size 128 Bytes
N#define ARM_MPU_REGION_SIZE_256B     ((uint8_t)0x07U) ///!< MPU Region Size 256 Bytes
N#define ARM_MPU_REGION_SIZE_512B     ((uint8_t)0x08U) ///!< MPU Region Size 512 Bytes
N#define ARM_MPU_REGION_SIZE_1KB      ((uint8_t)0x09U) ///!< MPU Region Size 1 KByte
N#define ARM_MPU_REGION_SIZE_2KB      ((uint8_t)0x0AU) ///!< MPU Region Size 2 KBytes
N#define ARM_MPU_REGION_SIZE_4KB      ((uint8_t)0x0BU) ///!< MPU Region Size 4 KBytes
N#define ARM_MPU_REGION_SIZE_8KB      ((uint8_t)0x0CU) ///!< MPU Region Size 8 KBytes
N#define ARM_MPU_REGION_SIZE_16KB     ((uint8_t)0x0DU) ///!< MPU Region Size 16 KBytes
N#define ARM_MPU_REGION_SIZE_32KB     ((uint8_t)0x0EU) ///!< MPU Region Size 32 KBytes
N#define ARM_MPU_REGION_SIZE_64KB     ((uint8_t)0x0FU) ///!< MPU Region Size 64 KBytes
N#define ARM_MPU_REGION_SIZE_128KB    ((uint8_t)0x10U) ///!< MPU Region Size 128 KBytes
N#define ARM_MPU_REGION_SIZE_256KB    ((uint8_t)0x11U) ///!< MPU Region Size 256 KBytes
N#define ARM_MPU_REGION_SIZE_512KB    ((uint8_t)0x12U) ///!< MPU Region Size 512 KBytes
N#define ARM_MPU_REGION_SIZE_1MB      ((uint8_t)0x13U) ///!< MPU Region Size 1 MByte
N#define ARM_MPU_REGION_SIZE_2MB      ((uint8_t)0x14U) ///!< MPU Region Size 2 MBytes
N#define ARM_MPU_REGION_SIZE_4MB      ((uint8_t)0x15U) ///!< MPU Region Size 4 MBytes
N#define ARM_MPU_REGION_SIZE_8MB      ((uint8_t)0x16U) ///!< MPU Region Size 8 MBytes
N#define ARM_MPU_REGION_SIZE_16MB     ((uint8_t)0x17U) ///!< MPU Region Size 16 MBytes
N#define ARM_MPU_REGION_SIZE_32MB     ((uint8_t)0x18U) ///!< MPU Region Size 32 MBytes
N#define ARM_MPU_REGION_SIZE_64MB     ((uint8_t)0x19U) ///!< MPU Region Size 64 MBytes
N#define ARM_MPU_REGION_SIZE_128MB    ((uint8_t)0x1AU) ///!< MPU Region Size 128 MBytes
N#define ARM_MPU_REGION_SIZE_256MB    ((uint8_t)0x1BU) ///!< MPU Region Size 256 MBytes
N#define ARM_MPU_REGION_SIZE_512MB    ((uint8_t)0x1CU) ///!< MPU Region Size 512 MBytes
N#define ARM_MPU_REGION_SIZE_1GB      ((uint8_t)0x1DU) ///!< MPU Region Size 1 GByte
N#define ARM_MPU_REGION_SIZE_2GB      ((uint8_t)0x1EU) ///!< MPU Region Size 2 GBytes
N#define ARM_MPU_REGION_SIZE_4GB      ((uint8_t)0x1FU) ///!< MPU Region Size 4 GBytes
N
N#define ARM_MPU_AP_NONE 0U ///!< MPU Access Permission no access
N#define ARM_MPU_AP_PRIV 1U ///!< MPU Access Permission privileged access only
N#define ARM_MPU_AP_URO  2U ///!< MPU Access Permission unprivileged access read-only
N#define ARM_MPU_AP_FULL 3U ///!< MPU Access Permission full access
N#define ARM_MPU_AP_PRO  5U ///!< MPU Access Permission privileged access read-only
N#define ARM_MPU_AP_RO   6U ///!< MPU Access Permission read-only access
N
N/** MPU Region Base Address Register Value
N*
N* \param Region The region to be configured, number 0 to 15.
N* \param BaseAddress The base address for the region.
N*/
N#define ARM_MPU_RBAR(Region, BaseAddress) \
N  (((BaseAddress) & MPU_RBAR_ADDR_Msk) |  \
N   ((Region) & MPU_RBAR_REGION_Msk)    |  \
N   (MPU_RBAR_VALID_Msk))
X#define ARM_MPU_RBAR(Region, BaseAddress)   (((BaseAddress) & MPU_RBAR_ADDR_Msk) |     ((Region) & MPU_RBAR_REGION_Msk)    |     (MPU_RBAR_VALID_Msk))
N
N/**
N* MPU Memory Access Attributes
N* 
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N*/  
N#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)   \
N  ((((TypeExtField) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                  | \
N   (((IsShareable)  << MPU_RASR_S_Pos)   & MPU_RASR_S_Msk)                    | \
N   (((IsCacheable)  << MPU_RASR_C_Pos)   & MPU_RASR_C_Msk)                    | \
N   (((IsBufferable) << MPU_RASR_B_Pos)   & MPU_RASR_B_Msk))
X#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)     ((((TypeExtField) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                  |    (((IsShareable)  << MPU_RASR_S_Pos)   & MPU_RASR_S_Msk)                    |    (((IsCacheable)  << MPU_RASR_C_Pos)   & MPU_RASR_C_Msk)                    |    (((IsBufferable) << MPU_RASR_B_Pos)   & MPU_RASR_B_Msk))
N
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param AccessAttributes  Memory access attribution, see \ref ARM_MPU_ACCESS_.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/
N#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)    \
N  ((((DisableExec)      << MPU_RASR_XN_Pos)   & MPU_RASR_XN_Msk)                                  | \
N   (((AccessPermission) << MPU_RASR_AP_Pos)   & MPU_RASR_AP_Msk)                                  | \
N   (((AccessAttributes) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk))) | \
N   (((SubRegionDisable) << MPU_RASR_SRD_Pos)  & MPU_RASR_SRD_Msk)                                 | \
N   (((Size)             << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk)                                | \
N   (((MPU_RASR_ENABLE_Msk))))
X#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)      ((((DisableExec)      << MPU_RASR_XN_Pos)   & MPU_RASR_XN_Msk)                                  |    (((AccessPermission) << MPU_RASR_AP_Pos)   & MPU_RASR_AP_Msk)                                  |    (((AccessAttributes) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk))) |    (((SubRegionDisable) << MPU_RASR_SRD_Pos)  & MPU_RASR_SRD_Msk)                                 |    (((Size)             << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk)                                |    (((MPU_RASR_ENABLE_Msk))))
N
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/                         
N#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size) \
N  ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
X#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size)   ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
N
N/**
N* MPU Memory Access Attribute for strongly ordered memory.
N*  - TEX: 000b
N*  - Shareable
N*  - Non-cacheable
N*  - Non-bufferable
N*/ 
N#define ARM_MPU_ACCESS_ORDERED ARM_MPU_ACCESS_(0U, 1U, 0U, 0U)
N
N/**
N* MPU Memory Access Attribute for device memory.
N*  - TEX: 000b (if shareable) or 010b (if non-shareable)
N*  - Shareable or non-shareable
N*  - Non-cacheable
N*  - Bufferable (if shareable) or non-bufferable (if non-shareable)
N*
N* \param IsShareable Configures the device memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_DEVICE(IsShareable) ((IsShareable) ? ARM_MPU_ACCESS_(0U, 1U, 0U, 1U) : ARM_MPU_ACCESS_(2U, 0U, 0U, 0U))
N
N/**
N* MPU Memory Access Attribute for normal memory.
N*  - TEX: 1BBb (reflecting outer cacheability rules)
N*  - Shareable or non-shareable
N*  - Cacheable or non-cacheable (reflecting inner cacheability rules)
N*  - Bufferable or non-bufferable (reflecting inner cacheability rules)
N*
N* \param OuterCp Configures the outer cache policy.
N* \param InnerCp Configures the inner cache policy.
N* \param IsShareable Configures the memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_NORMAL(OuterCp, InnerCp, IsShareable) ARM_MPU_ACCESS_((4U | (OuterCp)), IsShareable, ((InnerCp) >> 1U), ((InnerCp) & 1U))
N
N/**
N* MPU Memory Access Attribute non-cacheable policy.
N*/
N#define ARM_MPU_CACHEP_NOCACHE 0U
N
N/**
N* MPU Memory Access Attribute write-back, write and read allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_WRA 1U
N
N/**
N* MPU Memory Access Attribute write-through, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WT_NWA 2U
N
N/**
N* MPU Memory Access Attribute write-back, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_NWA 3U
N
N
N/**
N* Struct for a single MPU Region
N*/
Ntypedef struct {
N  uint32_t RBAR; //!< The region base address register value (RBAR)
N  uint32_t RASR; //!< The region attribute and size register value (RASR) \ref MPU_RASR
N} ARM_MPU_Region_t;
N    
N/** Enable the MPU.
N* \param MPU_Control Default access permissions for unconfigured regions.
N*/
N__STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control)
Xstatic __inline void ARM_MPU_Enable(uint32_t MPU_Control)
N{
N  __DMB();
X  __dmb(0xF);
N  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL = MPU_Control | (1UL );
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
N  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR |= (1UL << 16U);
N#endif
N  __DSB();
X  __dsb(0xF);
N  __ISB();
X  __isb(0xF);
N}
N
N/** Disable the MPU.
N*/
N__STATIC_INLINE void ARM_MPU_Disable(void)
Xstatic __inline void ARM_MPU_Disable(void)
N{
N  __DMB();
X  __dmb(0xF);
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
N  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR &= ~(1UL << 16U);
N#endif
N  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL  &= ~(1UL );
N  __DSB();
X  __dsb(0xF);
N  __ISB();
X  __isb(0xF);
N}
N
N/** Clear and disable the given MPU region.
N* \param rnr Region number to be cleared.
N*/
N__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
Xstatic __inline void ARM_MPU_ClrRegion(uint32_t rnr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RASR = 0U;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = 0U;
N}
N
N/** Configure an MPU region.
N* \param rbar Value for RBAR register.
N* \param rasr Value for RASR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
N{
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Configure the given MPU region.
N* \param rnr Region number to be configured.
N* \param rbar Value for RBAR register.
N* \param rasr Value for RASR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Memcpy with strictly ordered memory access, e.g. used by code in ARM_MPU_Load().
N* \param dst Destination data is copied to.
N* \param src Source data is copied from.
N* \param len Amount of data words to be copied.
N*/
N__STATIC_INLINE void ARM_MPU_OrderedMemcpy(volatile uint32_t* dst, const uint32_t* __RESTRICT src, uint32_t len)
Xstatic __inline void ARM_MPU_OrderedMemcpy(volatile uint32_t* dst, const uint32_t* __restrict src, uint32_t len)
N{
N  uint32_t i;
N  for (i = 0U; i < len; ++i) 
N  {
N    dst[i] = src[i];
N  }
N}
N
N/** Load the given number of MPU regions from a table.
N* \param table Pointer to the MPU configuration table.
N* \param cnt Amount of regions to be configured.
N*/
N__STATIC_INLINE void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
Xstatic __inline void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
N{
N  const uint32_t rowWordSize = sizeof(ARM_MPU_Region_t)/4U;
N  while (cnt > MPU_TYPE_RALIASES) {
X  while (cnt > 4U) {
N    ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), MPU_TYPE_RALIASES*rowWordSize);
X    ARM_MPU_OrderedMemcpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), 4U*rowWordSize);
N    table += MPU_TYPE_RALIASES;
X    table += 4U;
N    cnt -= MPU_TYPE_RALIASES;
X    cnt -= 4U;
N  }
N  ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), cnt*rowWordSize);
X  ARM_MPU_OrderedMemcpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), cnt*rowWordSize);
N}
N
N#endif
L 1961 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 2
N
N#endif
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N  uint32_t mvfr0;
N
N  mvfr0 = FPU->MVFR0;
X  mvfr0 = ((FPU_Type *) ((0xE000E000UL) + 0x0F30UL) )->MVFR0;
N  if      ((mvfr0 & (FPU_MVFR0_Single_precision_Msk | FPU_MVFR0_Double_precision_Msk)) == 0x020U)
X  if      ((mvfr0 & ((0xFUL << 4U) | (0xFUL << 8U))) == 0x020U)
N  {
N    return 1U;           /* Single precision FPU */
N  }
N  else
N  {
N    return 0U;           /* No FPU */
N  }
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0U == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 3U) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != ((int32_t)0x5AA55AA5U))
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = ((int32_t)0x5AA55AA5U);        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == ((int32_t)0x5AA55AA5U))
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 221 "..\..\..\..\scpu\device\include\Kneron\kneron_mozart.h" 2
N#include "system_ARMCM4.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include\system_ARMCM4.h" 1
N/**************************************************************************//**
N * @file     system_ARMCM4.h
N * @brief    CMSIS Device System Header File for
N *           ARMCM4 Device
N * @version  V5.3.2
N * @date     15. November 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef SYSTEM_ARMCM4_H
N#define SYSTEM_ARMCM4_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N  \brief Exception / Interrupt Handler Function Prototype
N*/
Ntypedef void(*VECTOR_TABLE_Type)(void);
N
N/**
N  \brief System Clock Frequency (Core Clock)
N*/
Nextern uint32_t SystemCoreClock;
N
N/**
N  \brief Setup the microcontroller system.
N
N   Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N
N/**
N  \brief  Update SystemCoreClock variable.
N
N   Updates the SystemCoreClock with current core Clock retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_ARMCM4_H */
L 222 "..\..\..\..\scpu\device\include\Kneron\kneron_mozart.h" 2
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma pop
N#elif defined(__ICCARM__)
X#elif 0L
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#else
S  #warning Not supported compiler type
N#endif
N
N
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N// base on Kneron_bus_v013.xlsx
N/*  ----------------------------   SAHB Peripheral Device    --------------------------------*/
N#define SiRAM_MEM_BASE                              0x10100000
N#define SiRAM_MEM_SIZE                              0x18000/*new*/
N#define SdRAM_MEM_BASE                              0x10200000
N#define SdRAM_MEM_SIZE                              0x18000/*new*/
N#define SPIF_XIP_BASE                               0x18000000
N#define DDR_MEM_BASE                                0x60000000
N#define DDR_MEM_SIZE                                0x40000000/*new*/
N#define SPI_FTSPI020_PA_BASE                        0xA0000000
N#define DMAC_FTDMAC020_PA_BASE                      0xA0100000
N
N/*  ----------------------------   NAHB Peripheral Device    --------------------------------*/
N#define NiRAM_MEM_BASE                              0x28000000/*new*/
N#define NiRAM_MEM_SIZE                              0x10000/*new*/
N#define NdRAM_MEM_BASE                              0x0FFF0000/*new*/
N#define NdRAM_MEM_SIZE                              0x10000/*new*/
N#define NPU_PA_BASE                                 0x30000000
N#define DMAC_FTDMAC020_1_PA_BASE                    0xB0200000
N
N/*  ----------------------------   PAHB Peripheral Device    --------------------------------*/
N#define SDC_FTSDC021_PA_BASE                        0xC0000000
N#define USB_FOTG210_PA_BASE                         0xC0100000
N        
N/*  ----------------------------   APB0 Peripheral Device    --------------------------------*/
N/* IIC */
N#define IIC_FTIIC010_0_PA_BASE                      0xC1000000
N#define IIC_FTIIC010_1_PA_BASE                      0xC1100000
N#define IIC_FTIIC010_2_PA_BASE                      0xC1200000
N#define IIC_FTIIC010_3_PA_BASE                      0xC1300000
N/* UART */
N#define UART_FTUART010_0_PA_BASE                    0xC1400000
N#define UART_FTUART010_1_PA_BASE                    0xC1500000
N#define UART_FTUART010_1_1_PA_BASE                  0xC1600000
N#define UART_FTUART010_1_2_PA_BASE                  0xC1700000
N#define UART_FTUART010_1_3_PA_BASE                  0xC1800000
N/* SSP */
N#define I2S_FTSSP010_0_PA_BASE                      0xC1900000
N#define I2S_FTSSP010_1_PA_BASE                      0xC1A00000
N#define SPI_FTSSP010_0_PA_BASE                      0xC1B00000
N#define SPI_FTSSP010_1_PA_BASE                      0xC1C00000
N/* GPIO */
N#define GPIO_FTGPIO010_PA_BASE                      0xC1D00000
N/* WDT */
N#define WDT_FTWDT010_PA_BASE                        0xC1E00000
N/* PWM/TMR */
N#define PWM_FTPWMTMR010_PA_BASE                     0xC1F00000
N#define TMR_FTPWMTMR010_0_PA_BASE                   0xC2000000
N#define TMR_FTPWMTMR010_1_PA_BASE                   0xC2100000
N/* eFuse */
N#define EFUSE_PA_BASE                               0xC2200000
N/* SCU */
N#define SCU_FTSCU100_PA_BASE                        0xC2300000
N#define RTC_PA_BASE									0xC2300200
N#define SCU_EXTREG_PA_BASE                          0xC2380000
N
N/*  ----------------------------   APB1 Peripheral Device    --------------------------------*/
N/* ADC */
N#define ADC_FTTSC010_0_PA_BASE                      0xC3000000
N/* OTG-PHY */
N#define OTGPHY_FOTG210_0_PA_BASE                    0xC3100000
N/* DDRC */
N#define DDRC_FTDDR3030_PA_BASE                      0xC3200000
N/* LCDC */
N#define LCD_FTLCDC210_PA_BASE                       0xC3300000
N#define SLCD_FTLCDC210_PA_BASE                      0xC3400000
N/* MIPI */
N#define CSIRX_FTCSIRX100_PA_BASE                    0xC3500000
N#define CSIRX_FTCSIRX100_1_PA_BASE                  0xC3600000
N#define MIPIRX_PHY_CSR_PA_BASE                      0xC3700000
N#define MIPIRX_PHY_CSR_1_PA_BASE                    0xC3800000
N#define DPI2AHB_CSR_PA_BASE                         0xC3900000
N#define DPI2AHB_CSR_1_PA_BASE                       0xC3A00000
N#define CSITX_CSR_PA_BASE                           0xC3B00000
N#define DSITX_CSR_PA_BASE                           0xC3C00000
N#define MIPI_TX_PHY_PA_BASE                         0xC3D00000
N
N/*  ----------------------------   APB1 Peripheral Device    --------------------------------*/
N
N//clock
N
N#define APB_CLOCK 100000000     //FPGA:50000000
N//#define LCD_PATGEN
N// total record how much size, then play it
N#define I2S_TOTAL_SIZE          0x2000          
N#define UART_CLOCK              (30000000UL) //kneron
N#define UART_CLOCK_2            (30000000UL) //kneron
N
N//#define MIXING_MODE_OPEN_RENDERER
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif  /* Kneron_Mozart */
N
L 25 "..\..\user\main.c" 2
N#include "kneron_mozart_ext.h"
L 1 "..\..\..\..\scpu\device\include\Kneron\kneron_mozart_ext.h" 1
N/**************************************************************************//**
N * @file     kneron_mozart_ext.h
N * @brief    CMSIS Core Peripheral Extension Access Layer Header File for
N *           ARMCM4 Device (configured for CM4 without FPU)
N * @version  V5.3.1
N * @date     09. July 2018
N ******************************************************************************/
N#ifndef Kneron_Mozart_EXT
N#define Kneron_Mozart_EXT
N
N
N/* NCPU/SCPU ID status */
N#define CPU_ID_STS_ADDR                 0xE00FF01C 
N#define CPU_ID_SCPU                     0x53430000
N#define CPU_ID_NCPU                     0x4e430000
N
N
N
N#endif  /* Kneron_Mozart */
N
L 26 "..\..\user\main.c" 2
N#include "Driver_Common.h"
L 1 "..\..\..\..\scpu\device\include\CMSIS\Driver_Common.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        2. Jan 2014
N * $Revision:    V2.00
N *
N * Project:      Common Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.00
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Added General return codes definitions
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_COMMON_H
N#define __DRIVER_COMMON_H
N
N#include <stddef.h>
N#include <stdint.h>
N#include <stdbool.h>
N
N#define ARM_DRIVER_VERSION_MAJOR_MINOR(major,minor) (((major) << 8) | (minor))
N
N/**
N\brief Driver Version
N*/
Ntypedef struct _ARM_DRIVER_VERSION {
N  uint16_t api;                         ///< API version
N  uint16_t drv;                         ///< Driver version
N} ARM_DRIVER_VERSION;
N
N/* General return codes */
N#define ARM_DRIVER_OK                 0 ///< Operation succeeded 
N#define ARM_DRIVER_ERROR             -1 ///< Unspecified error
N#define ARM_DRIVER_ERROR_BUSY        -2 ///< Driver is busy
N#define ARM_DRIVER_ERROR_TIMEOUT     -3 ///< Timeout occurred
N#define ARM_DRIVER_ERROR_UNSUPPORTED -4 ///< Operation not supported
N#define ARM_DRIVER_ERROR_PARAMETER   -5 ///< Parameter error
N#define ARM_DRIVER_ERROR_SPECIFIC    -6 ///< Start of driver specific errors 
N
N/**
N\brief General power states
N*/ 
Ntypedef enum _ARM_POWER_STATE {
N  ARM_POWER_OFF,                        ///< Power off: no operation possible
N  ARM_POWER_LOW,                        ///< Low Power mode: retain state, detect and signal wake-up events
N  ARM_POWER_FULL                        ///< Power on: full operation at maximum performance
N} ARM_POWER_STATE;
N
N#endif /* __DRIVER_COMMON_H */
L 27 "..\..\user\main.c" 2
N#include "io.h"
N#include "ddr.h"
L 1 "..\..\..\..\scpu\drivers\include\ddr.h" 1
N#ifndef __DDR_H__
N#define __DDR_H__
N
N
Nenum ddr_init_mode {
N    DDR_INIT_WAKEUP_ONLY = 0,
N    DDR_INIT_ALL,
N    DDR_INIT_ALL_EXIT_SELF_REFRESH,
N};
N
N#ifdef KL520
Nvoid ddr_wakeup(void);
Nvoid ddr_init(enum ddr_init_mode mode);
Nvoid ddr_init_chip_0429(void);
Nvoid ddr_self_refresh_enter(void);
Nvoid ddr_self_refresh_exit(void);
N#endif
N
Nvoid ddr_init_v35_mipi(unsigned char ncpu_wakeup);
N
N
N#endif
L 29 "..\..\user\main.c" 2
N#include "kdp_uart.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp_uart.h" 1
N#ifndef __KDP_UART_H__
N#define __KDP_UART_H__
N
N
N#include "types.h"
N#include "base.h"
N#include "cmsis_os2.h"
N#include "Driver_USART.h" //cmsis driver
L 1 "..\..\..\..\scpu\device\include\CMSIS\Driver_USART.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        9. Apr 2014
N * $Revision:    V2.01
N *
N * Project:      USART (Universal Synchronous Asynchronous Receiver Transmitter)
N *               Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.01
N *    Removed optional argument parameter from Signal Event
N *  Version 2.00
N *    New simplified driver:
N *      complexity moved to upper layer (especially data handling)
N *      more unified API for different communication interfaces
N *      renamed driver UART -> USART (Asynchronous & Synchronous)
N *    Added modes:
N *      Synchronous
N *      Single-wire
N *      IrDA
N *      Smart Card  
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.01
N *    Added events:
N *      ARM_UART_EVENT_TX_EMPTY,     ARM_UART_EVENT_RX_TIMEOUT
N *      ARM_UART_EVENT_TX_THRESHOLD, ARM_UART_EVENT_RX_THRESHOLD
N *    Added functions: SetTxThreshold, SetRxThreshold
N *    Added "rx_timeout_event" to capabilities
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_USART_H
N#define __DRIVER_USART_H
N
N#include "Driver_Common.h"
N
N#define ARM_USART_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,01)  /* API version */
N
N
N/****** USART Control Codes *****/
N
N#define ARM_USART_CONTROL_Pos                0
N#define ARM_USART_CONTROL_Msk               (0xFFUL << ARM_USART_CONTROL_Pos)
N
N/*----- USART Control Codes: Mode -----*/
N#define ARM_USART_MODE_ASYNCHRONOUS         (0x01UL << ARM_USART_CONTROL_Pos)   ///< UART (Asynchronous); arg = Baudrate
N#define ARM_USART_MODE_SYNCHRONOUS_MASTER   (0x02UL << ARM_USART_CONTROL_Pos)   ///< Synchronous Master (generates clock signal); arg = Baudrate
N#define ARM_USART_MODE_SYNCHRONOUS_SLAVE    (0x03UL << ARM_USART_CONTROL_Pos)   ///< Synchronous Slave (external clock signal)
N#define ARM_USART_MODE_SINGLE_WIRE          (0x04UL << ARM_USART_CONTROL_Pos)   ///< UART Single-wire (half-duplex); arg = Baudrate
N#define ARM_USART_MODE_IRDA                 (0x05UL << ARM_USART_CONTROL_Pos)   ///< UART IrDA; arg = Baudrate
N#define ARM_USART_MODE_SMART_CARD           (0x06UL << ARM_USART_CONTROL_Pos)   ///< UART Smart Card; arg = Baudrate
N
N/*----- USART Control Codes: Mode Parameters: Data Bits -----*/
N#define ARM_USART_DATA_BITS_Pos              8
N#define ARM_USART_DATA_BITS_Msk             (7UL << ARM_USART_DATA_BITS_Pos)
N#define ARM_USART_DATA_BITS_5               (5UL << ARM_USART_DATA_BITS_Pos)    ///< 5 Data bits
N#define ARM_USART_DATA_BITS_6               (6UL << ARM_USART_DATA_BITS_Pos)    ///< 6 Data bit
N#define ARM_USART_DATA_BITS_7               (7UL << ARM_USART_DATA_BITS_Pos)    ///< 7 Data bits
N#define ARM_USART_DATA_BITS_8               (0UL << ARM_USART_DATA_BITS_Pos)    ///< 8 Data bits (default)
N#define ARM_USART_DATA_BITS_9               (1UL << ARM_USART_DATA_BITS_Pos)    ///< 9 Data bits
N
N/*----- USART Control Codes: Mode Parameters: Parity -----*/
N#define ARM_USART_PARITY_Pos                 12
N#define ARM_USART_PARITY_Msk                (3UL << ARM_USART_PARITY_Pos)
N#define ARM_USART_PARITY_NONE               (0UL << ARM_USART_PARITY_Pos)       ///< No Parity (default)
N#define ARM_USART_PARITY_EVEN               (1UL << ARM_USART_PARITY_Pos)       ///< Even Parity
N#define ARM_USART_PARITY_ODD                (2UL << ARM_USART_PARITY_Pos)       ///< Odd Parity
N
N/*----- USART Control Codes: Mode Parameters: Stop Bits -----*/
N#define ARM_USART_STOP_BITS_Pos              14
N#define ARM_USART_STOP_BITS_Msk             (3UL << ARM_USART_STOP_BITS_Pos)
N#define ARM_USART_STOP_BITS_1               (0UL << ARM_USART_STOP_BITS_Pos)    ///< 1 Stop bit (default)
N#define ARM_USART_STOP_BITS_2               (1UL << ARM_USART_STOP_BITS_Pos)    ///< 2 Stop bits
N#define ARM_USART_STOP_BITS_1_5             (2UL << ARM_USART_STOP_BITS_Pos)    ///< 1.5 Stop bits
N#define ARM_USART_STOP_BITS_0_5             (3UL << ARM_USART_STOP_BITS_Pos)    ///< 0.5 Stop bits
N
N/*----- USART Control Codes: Mode Parameters: Flow Control -----*/
N#define ARM_USART_FLOW_CONTROL_Pos           16
N#define ARM_USART_FLOW_CONTROL_Msk          (3UL << ARM_USART_FLOW_CONTROL_Pos)
N#define ARM_USART_FLOW_CONTROL_NONE         (0UL << ARM_USART_FLOW_CONTROL_Pos) ///< No Flow Control (default)
N#define ARM_USART_FLOW_CONTROL_RTS          (1UL << ARM_USART_FLOW_CONTROL_Pos) ///< RTS Flow Control
N#define ARM_USART_FLOW_CONTROL_CTS          (2UL << ARM_USART_FLOW_CONTROL_Pos) ///< CTS Flow Control
N#define ARM_USART_FLOW_CONTROL_RTS_CTS      (3UL << ARM_USART_FLOW_CONTROL_Pos) ///< RTS/CTS Flow Control
N
N/*----- USART Control Codes: Mode Parameters: Clock Polarity (Synchronous mode) -----*/
N#define ARM_USART_CPOL_Pos                   17
N#define ARM_USART_CPOL_Msk                  (1UL << ARM_USART_CPOL_Pos)
N#define ARM_USART_CPOL0                     (0UL << ARM_USART_CPOL_Pos)         ///< CPOL = 0 (default)
N#define ARM_USART_CPOL1                     (1UL << ARM_USART_CPOL_Pos)         ///< CPOL = 1
N
N/*----- USART Control Codes: Mode Parameters: Clock Phase (Synchronous mode) -----*/
N#define ARM_USART_CPHA_Pos                   18
N#define ARM_USART_CPHA_Msk                  (1UL << ARM_USART_CPHA_Pos)
N#define ARM_USART_CPHA0                     (0UL << ARM_USART_CPHA_Pos)         ///< CPHA = 0 (default)
N#define ARM_USART_CPHA1                     (1UL << ARM_USART_CPHA_Pos)         ///< CPHA = 1
N
N
N/*----- USART Control Codes: Miscellaneous Controls  -----*/
N#define ARM_USART_SET_DEFAULT_TX_VALUE      (0x10UL << ARM_USART_CONTROL_Pos)   ///< Set default Transmit value (Synchronous Receive only); arg = value
N#define ARM_USART_SET_IRDA_PULSE            (0x11UL << ARM_USART_CONTROL_Pos)   ///< Set IrDA Pulse in ns; arg: 0=3/16 of bit period  
N#define ARM_USART_SET_SMART_CARD_GUARD_TIME (0x12UL << ARM_USART_CONTROL_Pos)   ///< Set Smart Card Guard Time; arg = number of bit periods
N#define ARM_USART_SET_SMART_CARD_CLOCK      (0x13UL << ARM_USART_CONTROL_Pos)   ///< Set Smart Card Clock in Hz; arg: 0=Clock not generated
N#define ARM_USART_CONTROL_SMART_CARD_NACK   (0x14UL << ARM_USART_CONTROL_Pos)   ///< Smart Card NACK generation; arg: 0=disabled, 1=enabled
N#define ARM_USART_CONTROL_TX                (0x15UL << ARM_USART_CONTROL_Pos)   ///< Transmitter; arg: 0=disabled, 1=enabled
N#define ARM_USART_CONTROL_RX                (0x16UL << ARM_USART_CONTROL_Pos)   ///< Receiver; arg: 0=disabled, 1=enabled
N#define ARM_USART_CONTROL_BREAK             (0x17UL << ARM_USART_CONTROL_Pos)   ///< Continuous Break transmission; arg: 0=disabled, 1=enabled
N#define ARM_USART_ABORT_SEND                (0x18UL << ARM_USART_CONTROL_Pos)   ///< Abort \ref ARM_USART_Send
N#define ARM_USART_ABORT_RECEIVE             (0x19UL << ARM_USART_CONTROL_Pos)   ///< Abort \ref ARM_USART_Receive
N#define ARM_USART_ABORT_TRANSFER            (0x1AUL << ARM_USART_CONTROL_Pos)   ///< Abort \ref ARM_USART_Transfer
N
N
N
N/****** USART specific error codes *****/
N#define ARM_USART_ERROR_MODE                (ARM_DRIVER_ERROR_SPECIFIC - 1)     ///< Specified Mode not supported
N#define ARM_USART_ERROR_BAUDRATE            (ARM_DRIVER_ERROR_SPECIFIC - 2)     ///< Specified baudrate not supported
N#define ARM_USART_ERROR_DATA_BITS           (ARM_DRIVER_ERROR_SPECIFIC - 3)     ///< Specified number of Data bits not supported
N#define ARM_USART_ERROR_PARITY              (ARM_DRIVER_ERROR_SPECIFIC - 4)     ///< Specified Parity not supported
N#define ARM_USART_ERROR_STOP_BITS           (ARM_DRIVER_ERROR_SPECIFIC - 5)     ///< Specified number of Stop bits not supported
N#define ARM_USART_ERROR_FLOW_CONTROL        (ARM_DRIVER_ERROR_SPECIFIC - 6)     ///< Specified Flow Control not supported
N#define ARM_USART_ERROR_CPOL                (ARM_DRIVER_ERROR_SPECIFIC - 7)     ///< Specified Clock Polarity not supported
N#define ARM_USART_ERROR_CPHA                (ARM_DRIVER_ERROR_SPECIFIC - 8)     ///< Specified Clock Phase not supported
N
N
N/**
N\brief USART Status
N*/
Ntypedef struct _ARM_USART_STATUS {
N  uint32_t tx_busy          : 1;        ///< Transmitter busy flag
N  uint32_t rx_busy          : 1;        ///< Receiver busy flag
N  uint32_t tx_underflow     : 1;        ///< Transmit data underflow detected (cleared on start of next send operation)
N  uint32_t rx_overflow      : 1;        ///< Receive data overflow detected (cleared on start of next receive operation)
N  uint32_t rx_break         : 1;        ///< Break detected on receive (cleared on start of next receive operation)
N  uint32_t rx_framing_error : 1;        ///< Framing error detected on receive (cleared on start of next receive operation)
N  uint32_t rx_parity_error  : 1;        ///< Parity error detected on receive (cleared on start of next receive operation)
N} ARM_USART_STATUS;
N
N/**
N\brief USART Modem Control
N*/
Ntypedef enum _ARM_USART_MODEM_CONTROL {
N  ARM_USART_RTS_CLEAR,                  ///< Deactivate RTS
N  ARM_USART_RTS_SET,                    ///< Activate RTS
N  ARM_USART_DTR_CLEAR,                  ///< Deactivate DTR
N  ARM_USART_DTR_SET                     ///< Activate DTR
N} ARM_USART_MODEM_CONTROL;
N
N/**
N\brief USART Modem Status
N*/
Ntypedef struct _ARM_USART_MODEM_STATUS {
N  uint32_t cts : 1;                     ///< CTS state: 1=Active, 0=Inactive
N  uint32_t dsr : 1;                     ///< DSR state: 1=Active, 0=Inactive
N  uint32_t dcd : 1;                     ///< DCD state: 1=Active, 0=Inactive
N  uint32_t ri  : 1;                     ///< RI  state: 1=Active, 0=Inactive
N} ARM_USART_MODEM_STATUS;
N
N
N/****** USART Event *****/
N#define ARM_USART_EVENT_SEND_COMPLETE       (1UL << 0)  ///< Send completed; however USART may still transmit data
N#define ARM_USART_EVENT_RECEIVE_COMPLETE    (1UL << 1)  ///< Receive completed
N#define ARM_USART_EVENT_TRANSFER_COMPLETE   (1UL << 2)  ///< Transfer completed
N#define ARM_USART_EVENT_TX_COMPLETE         (1UL << 3)  ///< Transmit completed (optional)
N#define ARM_USART_EVENT_TX_UNDERFLOW        (1UL << 4)  ///< Transmit data not available (Synchronous Slave)
N#define ARM_USART_EVENT_RX_OVERFLOW         (1UL << 5)  ///< Receive data overflow
N#define ARM_USART_EVENT_RX_TIMEOUT          (1UL << 6)  ///< Receive character timeout (optional)
N#define ARM_USART_EVENT_RX_BREAK            (1UL << 7)  ///< Break detected on receive
N#define ARM_USART_EVENT_RX_FRAMING_ERROR    (1UL << 8)  ///< Framing error detected on receive
N#define ARM_USART_EVENT_RX_PARITY_ERROR     (1UL << 9)  ///< Parity error detected on receive
N#define ARM_USART_EVENT_CTS                 (1UL << 10) ///< CTS state changed (optional)
N#define ARM_USART_EVENT_DSR                 (1UL << 11) ///< DSR state changed (optional)
N#define ARM_USART_EVENT_DCD                 (1UL << 12) ///< DCD state changed (optional)
N#define ARM_USART_EVENT_RI                  (1UL << 13) ///< RI  state changed (optional)
N
N
N// Function documentation
N/**
N  \fn          ARM_DRIVER_VERSION ARM_USART_GetVersion (void)
N  \brief       Get driver version.
N  \return      \ref ARM_DRIVER_VERSION
N
N  \fn          ARM_USART_CAPABILITIES ARM_USART_GetCapabilities (void)
N  \brief       Get driver capabilities
N  \return      \ref ARM_USART_CAPABILITIES
N
N  \fn          int32_t ARM_USART_Initialize (ARM_USART_SignalEvent_t cb_event)
N  \brief       Initialize USART Interface.
N  \param[in]   cb_event  Pointer to \ref ARM_USART_SignalEvent
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Uninitialize (void)
N  \brief       De-initialize USART Interface.
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_PowerControl (ARM_POWER_STATE state)
N  \brief       Control USART Interface Power.
N  \param[in]   state  Power state
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Send (const void *data, uint32_t num)
N  \brief       Start sending data to USART transmitter.
N  \param[in]   data  Pointer to buffer with data to send to USART transmitter
N  \param[in]   num   Number of data items to send
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Receive (void *data, uint32_t num)
N  \brief       Start receiving data from USART receiver.
N  \param[out]  data  Pointer to buffer for data to receive from USART receiver
N  \param[in]   num   Number of data items to receive
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Transfer (const void *data_out,
N                                                 void *data_in,
N                                           uint32_t    num)
N  \brief       Start sending/receiving data to/from USART transmitter/receiver.
N  \param[in]   data_out  Pointer to buffer with data to send to USART transmitter
N  \param[out]  data_in   Pointer to buffer for data to receive from USART receiver
N  \param[in]   num       Number of data items to transfer
N  \return      \ref execution_status
N
N  \fn          uint32_t ARM_USART_GetTxCount (void)
N  \brief       Get transmitted data count.
N  \return      number of data items transmitted
N
N  \fn          uint32_t ARM_USART_GetRxCount (void)
N  \brief       Get received data count.
N  \return      number of data items received
N
N  \fn          int32_t ARM_USART_Control (uint32_t control, uint32_t arg)
N  \brief       Control USART Interface.
N  \param[in]   control  Operation
N  \param[in]   arg      Argument of operation (optional)
N  \return      common \ref execution_status and driver specific \ref usart_execution_status
N
N  \fn          ARM_USART_STATUS ARM_USART_GetStatus (void)
N  \brief       Get USART status.
N  \return      USART status \ref ARM_USART_STATUS
N
N  \fn          int32_t ARM_USART_SetModemControl (ARM_USART_MODEM_CONTROL control)
N  \brief       Set USART Modem Control line state.
N  \param[in]   control  \ref ARM_USART_MODEM_CONTROL
N  \return      \ref execution_status 
N
N  \fn          ARM_USART_MODEM_STATUS ARM_USART_GetModemStatus (void)
N  \brief       Get USART Modem Status lines state.
N  \return      modem status \ref ARM_USART_MODEM_STATUS
N
N  \fn          void ARM_USART_SignalEvent (uint32_t event)
N  \brief       Signal USART Events.
N  \param[in]   event  \ref USART_events notification mask
N  \return      none
N*/
N
Ntypedef void (*ARM_USART_SignalEvent_t) (uint32_t event);  ///< Pointer to \ref ARM_USART_SignalEvent : Signal USART Event.
N
N
N/**
N\brief USART Device Driver Capabilities.
N*/
Ntypedef struct _ARM_USART_CAPABILITIES {
N  uint32_t asynchronous       : 1;      ///< supports UART (Asynchronous) mode 
N  uint32_t synchronous_master : 1;      ///< supports Synchronous Master mode
N  uint32_t synchronous_slave  : 1;      ///< supports Synchronous Slave mode
N  uint32_t single_wire        : 1;      ///< supports UART Single-wire mode
N  uint32_t irda               : 1;      ///< supports UART IrDA mode
N  uint32_t smart_card         : 1;      ///< supports UART Smart Card mode
N  uint32_t smart_card_clock   : 1;      ///< Smart Card Clock generator available
N  uint32_t flow_control_rts   : 1;      ///< RTS Flow Control available
N  uint32_t flow_control_cts   : 1;      ///< CTS Flow Control available
N  uint32_t event_tx_complete  : 1;      ///< Transmit completed event: \ref ARM_USART_EVENT_TX_COMPLETE
N  uint32_t event_rx_timeout   : 1;      ///< Signal receive character timeout event: \ref ARM_USART_EVENT_RX_TIMEOUT
N  uint32_t rts                : 1;      ///< RTS Line: 0=not available, 1=available
N  uint32_t cts                : 1;      ///< CTS Line: 0=not available, 1=available
N  uint32_t dtr                : 1;      ///< DTR Line: 0=not available, 1=available
N  uint32_t dsr                : 1;      ///< DSR Line: 0=not available, 1=available
N  uint32_t dcd                : 1;      ///< DCD Line: 0=not available, 1=available
N  uint32_t ri                 : 1;      ///< RI Line: 0=not available, 1=available
N  uint32_t event_cts          : 1;      ///< Signal CTS change event: \ref ARM_USART_EVENT_CTS
N  uint32_t event_dsr          : 1;      ///< Signal DSR change event: \ref ARM_USART_EVENT_DSR
N  uint32_t event_dcd          : 1;      ///< Signal DCD change event: \ref ARM_USART_EVENT_DCD
N  uint32_t event_ri           : 1;      ///< Signal RI change event: \ref ARM_USART_EVENT_RI
N} ARM_USART_CAPABILITIES;
N
N
N/**
N\brief Access structure of the USART Driver.
N*/
Ntypedef struct _ARM_DRIVER_USART {
N  ARM_DRIVER_VERSION     (*GetVersion)      (void);                              ///< Pointer to \ref ARM_USART_GetVersion : Get driver version.
N  ARM_USART_CAPABILITIES (*GetCapabilities) (void);                              ///< Pointer to \ref ARM_USART_GetCapabilities : Get driver capabilities.
N  int32_t                (*Initialize)      (ARM_USART_SignalEvent_t cb_event);  ///< Pointer to \ref ARM_USART_Initialize : Initialize USART Interface.
N  int32_t                (*Uninitialize)    (void);                              ///< Pointer to \ref ARM_USART_Uninitialize : De-initialize USART Interface.
N  int32_t                (*PowerControl)    (ARM_POWER_STATE state);             ///< Pointer to \ref ARM_USART_PowerControl : Control USART Interface Power.
N  int32_t                (*Send)            (const void *data, uint32_t num);    ///< Pointer to \ref ARM_USART_Send : Start sending data to USART transmitter.
N  int32_t                (*Receive)         (      void *data, uint32_t num);    ///< Pointer to \ref ARM_USART_Receive : Start receiving data from USART receiver.
N  int32_t                (*Transfer)        (const void *data_out,
N                                                   void *data_in,
N                                             uint32_t    num);                   ///< Pointer to \ref ARM_USART_Transfer : Start sending/receiving data to/from USART.
N  uint32_t               (*GetTxCount)      (void);                              ///< Pointer to \ref ARM_USART_GetTxCount : Get transmitted data count.
N  uint32_t               (*GetRxCount)      (void);                              ///< Pointer to \ref ARM_USART_GetRxCount : Get received data count.
N  int32_t                (*Control)         (uint32_t control, uint32_t arg);    ///< Pointer to \ref ARM_USART_Control : Control USART Interface.
N  ARM_USART_STATUS       (*GetStatus)       (void);                              ///< Pointer to \ref ARM_USART_GetStatus : Get USART status.
N  int32_t                (*SetModemControl) (ARM_USART_MODEM_CONTROL control);   ///< Pointer to \ref ARM_USART_SetModemControl : Set USART Modem Control line state.
N  ARM_USART_MODEM_STATUS (*GetModemStatus)  (void);                              ///< Pointer to \ref ARM_USART_GetModemStatus : Get USART Modem Status lines state.
N} const ARM_DRIVER_USART;
N
N#endif /* __DRIVER_USART_H */
L 9 "..\..\..\..\scpu\drivers\include\kdp_uart.h" 2
N
N
N#define UART_CLOCK                     (30000000UL) //kneron
N#define BAUD_1500000                   (UART_CLOCK / 24000000)  //Verification
N#define BAUD_921600                    (UART_CLOCK / 14745600)
N#define BAUD_460800                    (UART_CLOCK / 7372800)
N#define BAUD_230400                    (UART_CLOCK / 3686400)
N#define BAUD_115200                    (UART_CLOCK / 1843200)
N#define BAUD_57600                     (UART_CLOCK / 921600)
N#define BAUD_38400                     (UART_CLOCK / 614400)
N#define BAUD_19200                     (UART_CLOCK / 307200)
N#define BAUD_14400                     (UART_CLOCK / 230400)
N#define BAUD_9600                      (UART_CLOCK / 153600)
N#define BAUD_4800                      (UART_CLOCK / 76800)
N#define BAUD_2400                      (UART_CLOCK / 38400)
N#define BAUD_1200                      (UART_CLOCK / 19200)
N
Ntypedef enum {
N    DRVUART_PORT0=0,
N    DRVUART_PORT1=1,
N    DRVUART_PORT2=2,
N    DRVUART_PORT3=3,
N    DRVUART_PORT4=4,
N} DRVUART_PORT;
N
N#define SERIAL_THR                     0x00             /*  Transmitter Holding Register(Write).*/
N#define SERIAL_RBR                     0x00             /*  Receive Buffer register (Read).*/
N#define SERIAL_IER                     0x04             /*  Interrupt Enable register.*/
N#define SERIAL_IIR                     0x08             /*  Interrupt Identification register(Read).*/
N#define SERIAL_FCR                     0x08             /*  FIFO control register(Write).*/
N#define SERIAL_LCR                     0x0C             /*  Line Control register.*/
N#define SERIAL_MCR                     0x10             /*  Modem Control Register.*/
N#define SERIAL_LSR                     0x14             /*  Line status register(Read) .*/
N#define SERIAL_MSR                     0x18             /*  Modem Status register (Read).*/
N#define SERIAL_SPR                     0x1C         /*  Scratch pad register */
N#define SERIAL_DLL                     0x0          /*  Divisor Register LSB */
N#define SERIAL_DLM                     0x4          /*  Divisor Register MSB */
N#define SERIAL_PSR                     0x8             /* Prescale Divison Factor */
N
N#define SERIAL_MDR                     0x20
N#define SERIAL_ACR                     0x24
N#define SERIAL_TXLENL                  0x28
N#define SERIAL_TXLENH                  0x2C
N#define SERIAL_MRXLENL                 0x30
N#define SERIAL_MRXLENH                 0x34
N#define SERIAL_PLR                     0x38
N#define SERIAL_FMIIR_PIO               0x3C
N#define SERIAL_FEATURE                 0x68
N
N/* IER Register */
N#define SERIAL_IER_DR                  0x1          /* Data ready Enable */
N#define SERIAL_IER_TE                  0x2          /* THR Empty Enable */
N#define SERIAL_IER_RLS                 0x4          /* Receive Line Status Enable */
N#define SERIAL_IER_MS                  0x8          /* Modem Staus Enable */
N
N/* IIR Register */
N#define SERIAL_IIR_NONE                0x1            /* No interrupt pending */
N#define SERIAL_IIR_RLS                 0x6            /* Receive Line Status */
N#define SERIAL_IIR_DR                  0x4            /* Receive Data Ready */
N#define SERIAL_IIR_TIMEOUT             0xc            /* Receive Time Out */
N#define SERIAL_IIR_TE                  0x2            /* THR Empty */
N#define SERIAL_IIR_MODEM               0x0            /* Modem Status */
N
N/* FCR Register */
N#define SERIAL_FCR_FE                  0x1              /* FIFO Enable */
N#define SERIAL_FCR_RXFR                0x2              /* Rx FIFO Reset */
N#define SERIAL_FCR_TXFR                0x4              /* Tx FIFO Reset */
N
N/* LCR Register */
N#define SERIAL_LCR_LEN5                0x0
N#define SERIAL_LCR_LEN6                0x1
N#define SERIAL_LCR_LEN7                0x2
N#define SERIAL_LCR_LEN8                0x3
N
N#define SERIAL_LCR_STOP                0x4
N#define SERIAL_LCR_EVEN                0x18          /* Even Parity */
N#define SERIAL_LCR_ODD                 0x8          /* Odd Parity */
N#define SERIAL_LCR_PE                  0x8            /* Parity Enable */
N#define SERIAL_LCR_SETBREAK            0x40             /* Set Break condition */
N#define SERIAL_LCR_STICKPARITY         0x20             /* Stick Parity Enable */
N#define SERIAL_LCR_DLAB                0x80         /* Divisor Latch Access Bit */
N
N/* LSR Register */
N#define SERIAL_LSR_DR                  0x1          /* Data Ready */
N#define SERIAL_LSR_OE                  0x2          /* Overrun Error */
N#define SERIAL_LSR_PE                  0x4          /* Parity Error */
N#define SERIAL_LSR_FE                  0x8          /* Framing Error */
N#define SERIAL_LSR_BI                  0x10         /* Break Interrupt */
N#define SERIAL_LSR_THRE                0x20         /* THR Empty */
N#define SERIAL_LSR_TE                  0x40         /* Transmitte Empty */
N#define SERIAL_LSR_DE                  0x80         /* FIFO Data Error */
N
N/* MCR Register */
N#define SERIAL_MCR_DTR                 0x1        /* Data Terminal Ready */
N#define SERIAL_MCR_RTS                 0x2        /* Request to Send */
N#define SERIAL_MCR_OUT1                0x4        /* output    1 */
N#define SERIAL_MCR_OUT2                0x8        /* output2 or global interrupt enable */
N#define SERIAL_MCR_LPBK                0x10         /* loopback mode */
N
N
N/* MSR Register */
N#define SERIAL_MSR_DELTACTS            0x1        /* Delta CTS */
N#define SERIAL_MSR_DELTADSR            0x2        /* Delta DSR */
N#define SERIAL_MSR_TERI                0x4        /* Trailing Edge RI */
N#define SERIAL_MSR_DELTACD             0x8        /* Delta CD */
N#define SERIAL_MSR_CTS                 0x10         /* Clear To Send */
N#define SERIAL_MSR_DSR                 0x20         /* Data Set Ready */
N#define SERIAL_MSR_RI                  0x40         /* Ring Indicator */
N#define SERIAL_MSR_DCD                 0x80         /* Data Carrier Detect */
N
N
N/* MDR register */
N#define SERIAL_MDR_MODE_SEL            0x03
N#define SERIAL_MDR_UART                0x0
N#define SERIAL_MDR_SIR                 0x1
N#define SERIAL_MDR_FIR                 0x2
N
N/* ACR register */
N#define SERIAL_ACR_TXENABLE            0x1
N#define SERIAL_ACR_RXENABLE            0x2
N#define SERIAL_ACR_SET_EOT             0x4
N
N#ifndef PARITY_NONE
N#define PARITY_NONE             0
N#endif
N
N#ifndef PARITY_ODD
N#define PARITY_ODD              1
N#endif
N
N#ifndef PARITY_EVEN
N#define PARITY_EVEN             2
N#endif
N
N#ifndef PARITY_MARK
N#define PARITY_MARK             3
N#endif
N
N#ifndef PARITY_SPACE
N#define PARITY_SPACE            4
N#endif
N
N#define BACKSP_KEY 0x08
N#define RETURN_KEY 0x0D
N#define DELETE_KEY 0x7F
N#define BELL       0x07
N
N
N#define MAX_UART_INST  5  //max uart instance
N#define MAX_BUF_LEN   512 //max buffer len for every individual UART port
N#define NO_FIFO 0
N
N#define UART_SUCCESS  0
N#define UART_FAIL     -1
N
N#define SERIAL_RX_FIFO_COUNT      0x5C 
N
N#define SERIAL_FIFO_DEPTH_REG     0x68
N
N#define SERIAL_FIFO_DEPTH_16B     0x1
N#define SERIAL_FIFO_DEPTH_32B     0x2
N#define SERIAL_FIFO_DEPTH_64B     0x4
N#define SERIAL_FIFO_DEPTH_128B    0x8
N
N#define SERIAL_FIFO_TRIG_LVEL_1   0x0
N#define SERIAL_FIFO_TRIG_LVEL_4   0x1
N#define SERIAL_FIFO_TRIG_LVEL_8   0x2
N#define SERIAL_FIFO_TRIG_LVEL_14  0x3
N
N#define DEFAULT_SYNC_TIMEOUT_CHARS_TIME  512     //for UART_SYNC_MODE: correspond to 512 chars transmission time 
N
Ntypedef int kdp_uart_hdl_t;
Ntypedef void(*uart_isr_t)(void);
Ntypedef void(*kdp_uart_callback_t)(uint32_t event);
N
N/**
N * UART driver status
N */
Ntypedef enum
N{
N    KDP_UART_STATUS_OK,     /**< UART driver status : OK*/
N    KDP_UART_STATUS_ERROR,  /**< UART driver status : ERROR */
N    KDP_UART_STATUS_BUSY    /**< UART driver status : BUSY */
N} KDP_UART_DRV_STATUS_t;
N
N/**
N * UART initialization structure
N*/
Ntypedef struct KDP_UART_CONFIG
N{
N    uint32_t baudrate;
N    uint8_t  data_bits;
N    uint8_t  frame_length;
N    uint8_t  stop_bits;
N    uint8_t  parity_mode;
N    uint8_t  fifo_en;
N} KDP_UART_CONFIG_t;
N
N/**
N\brief KDP UART Device Driver Capabilities. This capability covers ARM_USART_CAPABILITIES
N*/
Ntypedef struct _KDP_USART_CAPABILITIES {
N    uint32_t asynchronous : 1;      ///< supports UART (Asynchronous) mode 
N    uint32_t synchronous_master : 1;///< supports Synchronous Master mode
N    uint32_t synchronous_slave : 1; ///< supports Synchronous Slave mode
N    uint32_t serial_irda : 1;       ///< supports SIR (Serial IrDA mode)
N    uint32_t fast_irda : 1;         ///< supports FIR (Fast IrDA mode)
N    uint32_t flow_control_rts : 1;  ///< RTS Flow Control available
N    uint32_t flow_control_cts : 1;  ///< CTS Flow Control available
N    uint32_t event_tx_complete : 1; ///< Transmit completed event: \ref ARM_USART_EVENT_TX_COMPLETE
N    uint32_t event_rx_timeout : 1;  ///< Signal receive character timeout event: \ref ARM_USART_EVENT_RX_TIMEOUT
N    uint32_t rts : 1;               ///< RTS Line: 0=not available, 1=available
N    uint32_t cts : 1;               ///< CTS Line: 0=not available, 1=available
N    uint32_t dtr : 1;               ///< DTR Line: 0=not available, 1=available
N    uint32_t dsr : 1;               ///< DSR Line: 0=not available, 1=available
N    uint32_t dcd : 1;               ///< DCD Line: 0=not available, 1=available
N    uint32_t ri : 1;                ///< RI Line: 0=not available, 1=available
N    uint32_t event_cts : 1;         ///< Signal CTS change event: \ref ARM_USART_EVENT_CTS
N    uint32_t event_dsr : 1;         ///< Signal DSR change event: \ref ARM_USART_EVENT_DSR
N    uint32_t event_dcd : 1;         ///< Signal DCD change event: \ref ARM_USART_EVENT_DCD
N    uint32_t event_ri : 1;          ///< Signal RI change event: \ref ARM_USART_EVENT_RI
N} KDP_USART_CAPABILITIES;
N
N// UART flags
N
N#define     UART_INITIALIZED          (1 << 0)
N#define     UART_POWERED              (1 << 1)
N#define     UART_BASIC_CONFIGURED     (1 << 2)
N#define     UART_FIFO_RX_CONFIGURED   (1 << 3)
N#define     UART_FIFO_TX_CONFIGURED   (1 << 4)
N#define     UART_TX_ENABLED           (1 << 5)
N#define     UART_RX_ENABLED           (1 << 6)
N#define     UART_LOOPBACK_ENABLED     (1 << 7)
N
N#define     UART_MODE_ASYN_RX  (1 << 0)
N#define     UART_MODE_ASYN_TX  (1 << 1)
N#define     UART_MODE_SYNC_RX  (1 << 2)
N#define     UART_MODE_SYNC_TX  (1 << 3)
N#define     SIR_MODE_ASYN      (1 << 4)
N#define     FIR_MODE_ASYN      (1 << 5)
N
N
N// UART Transfer Information (Run-Time)
Ntypedef struct UART_TRANSFER_INFO
N{
N    volatile uint32_t                rx_num;        // Total number of data to be received
N    volatile uint32_t                tx_num;        // Total number of data to be send
N    volatile uint8_t                 *rx_buf;       // Pointer to in data buffer
N    volatile uint8_t                 *tx_buf;       // Pointer to out data buffer
N    volatile uint32_t                rx_cnt;        // Number of data received
N    volatile uint32_t                tx_cnt;        // Number of data sent
N    volatile uint32_t                write_idx;     // Write index
N    volatile uint32_t                read_idx;      // Read index
N} UART_TRANSFER_INFO_t;
N
Ntypedef struct
N{
N    volatile uint8_t tx_busy;             // Transmitter busy flag
N    volatile uint8_t rx_busy;             // Receiver busy flag
N    uint8_t tx_underflow;                 // Transmit data underflow detected (cleared on start of next send operation)
N    uint8_t rx_overflow;                  // Receive data overflow detected (cleared on start of next receive operation)
N    uint8_t rx_break;                     // Break detected on receive (cleared on start of next receive operation)
N    uint8_t rx_framing_error;             // Framing error detected on receive (cleared on start of next receive operation)
N    uint8_t rx_parity_error;              // Parity error detected on receive (cleared on start of next receive operation)
N} UART_STATUS_t;
N
N// UART Information (Run-Time)
Ntypedef struct
N{
N    ARM_USART_SignalEvent_t cb_event;           // Event callback
N    UART_STATUS_t           status;             // Status flags
N    UART_TRANSFER_INFO_t    xfer;               // Transfer information
N    uint32_t                flags;              // UART driver flags: UART_FLAG_T
N    uint32_t                mode;               // UART mode
N} UART_INFO_T;
N
N
N// UART Resources definitions
Ntypedef struct
N{
N    uint32_t               irq_num;                    // UART TX IRQ Number
N    uart_isr_t             isr;                        // ISR route
N    uint32_t               fifo_depth;                 //16/32/64/128 depth, set by UART_CTRL_CONFIG
N    uint32_t               tx_fifo_threshold;          // FIFO tx trigger threshold
N    uint32_t               rx_fifo_threshold;          // FIFO rx trigger threshold
N    uint32_t               fifo_len;                   // FIFO tx buffer len
N    uint32_t               clock;                      //clock
N    uint32_t               hw_base;                    // hardware base address
N} UART_RESOURCES_T;
N
Ntypedef enum {
N    UART_UNINIT,
N    UART_INIT_DONE,
N    UART_WORKING,
N    UART_CLOSED
N}kdp_uart_drv_state_t;
N
Ntypedef enum {
N    UART0_DEV,
N    UART1_DEV,
N    UART2_DEV,
N    UART3_DEV,
N    UART4_DEV,
N    TOTAL_UART_DEV
N} kdp_uart_dev_id;
N
Ntypedef struct {
N    bool     bEnFifo;
X    _Bool     bEnFifo;
N    uint8_t  fifo_trig_level;
N} kdp_uart_fifo_cfg_t;
N
Ntypedef enum {
N    UART_CTRL_CONFIG,      //param: KDP_UART_CONFIG_t
N    UART_CTRL_FIFO_RX,     //param: kdp_uart_fifo_cfg_t
N    UART_CTRL_FIFO_TX,     //param: kdp_uart_fifo_cfg_t
N    UART_CTRL_LOOPBACK,
N    UART_CTRL_TX_EN,
N    UART_CTRL_RX_EN,
N    UART_CTRL_RTS_EN,
N    UART_CTRL_DTR_EN,
N    UART_CTRL_ABORT_TX,
N    UART_CTRL_ABORT_RX,
N    UART_CTRL_TIMEOUT_RX,
N    UART_CTRL_TIMEOUT_TX
N}kdp_uart_ctrl_t;
N
N/* driver instance handle */
Ntypedef struct {
N    uint32_t                 uart_port;
N    kdp_uart_drv_state_t     state;
N    KDP_USART_CAPABILITIES   *pCap;
N    KDP_UART_CONFIG_t        config;
N    UART_INFO_T              info;
N    UART_RESOURCES_T         res;
N    int32_t                  nTimeOutTx;       //Tx timeout (ms) for UART_SYNC_MODE
N    int32_t                  nTimeOutRx;       //Rx timeout (ms) for UART_SYNC_MODE
N    uint32_t                 iir;              //store IIR register value (IIR register will be reset once it is 
N                                               //read once, need to store for further process)
N} kdp_driver_hdl_t;
N
Ntypedef struct {
N    int8_t             total_open_uarts;
N    bool               active_dev[TOTAL_UART_DEV];
X    _Bool               active_dev[TOTAL_UART_DEV];
N    kdp_driver_hdl_t   *uart_dev[MAX_UART_INST];
X    kdp_driver_hdl_t   *uart_dev[5];
N
N} kdp_uart_drv_ctx_t;
N
N/******** kdp_uart_api_sts_t *********/
Ntypedef uint32_t kdp_uart_api_sts_t;
N
N#define UART_API_RETURN_SUCCESS     0
N#define UART_API_NOT_POWRERED       (1<<0)
N#define UART_API_TX_BUSY            (1<<1)
N#define UART_API_RX_BUSY            (1<<2)
N#define UART_API_INVALID_PARAM      (1<<3)
N#define UART_API_ERROR              (1<<4)
N#define UART_API_TIMEOUT            (1<<5)
N
N/*************************************/
N
N/* Init the UART device driver, it shall be called once in lifecycle
N*/
Nvoid kdp_uart_init(void);
N
N/*
N  Open one UART port
NInput:
N  com_port: UART port id
N  cb: callback function
N
NOutput:
N  return device handle: >=0 means success; -1 means open fail
N*/
Nkdp_uart_hdl_t kdp_uart_open(uint8_t com_port, uint32_t mode, kdp_uart_callback_t cb);
N
N/*
N Query capability
NInput:
N handle: driver handle
N
NOutput:
N capability of the UART port
N*/
N
NKDP_USART_CAPABILITIES* kdp_uart_get_capability(kdp_uart_hdl_t hanle);
N
N/*
NSet control for the device
NInput:
N    handle: device handle
N    prop: control enumeration
N    val: pointer to control value/structure
Nreturn:
N    error code
N*/
Nint32_t kdp_uart_control(kdp_uart_hdl_t handle, kdp_uart_ctrl_t prop, uint8_t * val);
N
N/*
NQuery driver status
NInput:
N    handle: driver handle
N
NOutput:
N    driver status
N*/
NUART_STATUS_t* kdp_uart_get_status(kdp_uart_hdl_t hanle);
N
N/*
NWrite data to Mozart device, such as command, parameters, but not suitable for chunk data
NInput:
N    hdl: device handle
N    buf: data buffer
N    len: data buffer length
Nreturn:
N    driver status
N*/
Nkdp_uart_api_sts_t kdp_uart_write(kdp_uart_hdl_t hdl, uint8_t *buf, uint32_t len);
N
N/*
NRead data from Mozart device
NInput:
N    handle: device handle
N    buf: data buffer
N    len: data buffer length
Nreturn:
N    driver status
N*/
Nkdp_uart_api_sts_t kdp_uart_read(kdp_uart_hdl_t handle, uint8_t *buf, uint32_t len);
N
N/*
NPower control
NInput:
N    handle: driver handle
N    pwr_set: power status expected to be set
N
NOutput:
N    success or fail
N*/
Nint32_t kdp_uart_power_control(kdp_uart_hdl_t handle, ARM_POWER_STATE pwr_st);
N
N
N/* close the device
NInput:
N    handle: device handle
Nreturn:
N    0 - success; -1 - failure
N*/
Nint32_t kdp_uart_close(kdp_uart_hdl_t handle);
N
N/* get char number in Rx buffer 
NInput:
N    handle: device handle
NReturn:
N    Received bytes 
N*/
Nuint32_t kdp_uart_GetRxCount(kdp_uart_hdl_t handle);
N
N/* get char number in Tx buffer 
NInput:
N    handle: device handle
NReturn:
N    Sent bytes
N*/
Nuint32_t kdp_uart_GetTxCount(kdp_uart_hdl_t handle);
N
Nuint32_t kdp_uart_GetRxBufSize(kdp_uart_hdl_t handle);
Nuint32_t kdp_uart_GetWriteIndex(kdp_uart_hdl_t handle);
Nuint32_t kdp_uart_GetReadIndex(kdp_uart_hdl_t handle);
Nuint32_t kdp_uart_SetWriteIndex(kdp_uart_hdl_t handle, uint32_t index);
Nuint32_t kdp_uart_SetReadIndex(kdp_uart_hdl_t handle, uint32_t index);
N
Nchar kdp_getchar(DRVUART_PORT port_no);
Nint kdp_gets(DRVUART_PORT port_no, char *buf);
Nvoid kdp_uart_rx_busy_clear(kdp_uart_hdl_t handle);
Nextern void kdp_uart_print_register(uint8_t port_no);
N
N#endif  //__KDP_UART_H__
L 30 "..\..\user\main.c" 2
N#include "kl520_include.h"
L 1 "..\..\..\..\scpu\include\kl520_include.h" 1
N#ifndef __KL520_INCLUDE_H__
N#define __KL520_INCLUDE_H__
N
N
N#include "types.h"
N#include "board_kl520.h"
N#include "kl520_sys.h"
L 1 "..\..\..\..\scpu\include\kl520_sys.h" 1
N#ifndef __KL520_SYS_H__
N#define __KL520_SYS_H__
N
N#include "types.h"
N#include "board_kl520.h"
N
N#define MAX(x,y)            ((x)<(y)?(y):(x))
N#define MIN(x,y)            ((x)>(y)?(y):(x))
N#define ABS(a)              (((a)>=0)?(a):(-(a)))
N
N/*Engineering Settings*/
N#define CALC_CAMERA_FPS     (NO)
N#define CALC_FDFR_MS_ONCE   (NO)
N#define CALC_FDFR_FPS       (NO)
N#define CALC_DISPLAY_FPS    (NO)
N
N#define MEASURE_RECOGNITION (NO)
N#define MEASURE_WITH_TOUCH  (NO)
N
N#define UART_INIT_AFTER_OTA (NO)
N
N#define CALIBRA_REG_OFFSET  (YES)
N
N//////////////////////////
N/* Engineering mode API */
N//////////////////////////
N
N#endif
L 8 "..\..\..\..\scpu\include\kl520_include.h" 2
N#include "framework/event.h"
L 1 "..\..\..\..\scpu\framework\include\framework/event.h" 1
N#ifndef __EVENT_H__
N#define __EVENT_H__
N
N
N#include <cmsis_os2.h>
N#include "types.h"
N
N#define FLAGS_VB_DONE           0xf1dd
N#define FLAGS_VB_DONE_0         0xf1d0
N#define FLAGS_VB_DONE_1         0xf1d1
N#define FLAGS_SOURCE_READY_EVT  0x91ad
N
N
Nextern osEventFlagsId_t evt_source_data_ready_id;
Nextern osEventFlagsId_t evt_mipi0_ready_id;
Nextern osEventFlagsId_t evt_vb_done_id_0;
Nextern osEventFlagsId_t evt_vb_done_id_1;
N
NosEventFlagsId_t create_event(void);
Nvoid set_event(osEventFlagsId_t id, unsigned int flags);
Nunsigned int wait_event(osEventFlagsId_t id, unsigned int flags);
Nunsigned int clear_event(osEventFlagsId_t id, unsigned int flags);
Nvoid delete_event(osEventFlagsId_t id);
Nvoid set_thread_event(osThreadId_t id, unsigned int flags);
Nvoid wait_thread_event(unsigned int flags);
NBOOL check_thread_alive(osEventFlagsId_t id);
N
N#endif
L 9 "..\..\..\..\scpu\include\kl520_include.h" 2
N#include "framework/v2k_color.h"
L 1 "..\..\..\..\scpu\framework\include\framework/v2k_color.h" 1
N#ifndef __V2K_COLOR_H__
N#define __V2K_COLOR_H__
N
N/* rgb 565 */
N#define WHITE                       0xFFFF
N#define BLACK                       0x0000
N#define BLUE                        0x001F
N#define BRED                        0xF81F
N#define GRED                        0xFFE0
N#define GBLUE                       0x07FF
N#define RED                         0xF800
N#define MAGENTA                     0xF81F
N#define GREEN                       0x07E0
N#define CYAN                        0x7FFF
N#define YELLOW                      0xFFE0
N#define BROWN                       0xBC40
N#define BRRED                       0xFC07
N#define GRAY                        0x8430
N
N
N#endif 
L 10 "..\..\..\..\scpu\include\kl520_include.h" 2
N#include "framework/framework_driver.h"
L 1 "..\..\..\..\scpu\framework\include\framework/framework_driver.h" 1
N#ifndef __DRIVER_H__
N#define __DRIVER_H__
N
N
N#include <stddef.h>
N#include "types.h"
N#include "framework/init.h"
L 1 "..\..\..\..\scpu\framework\include\framework/init.h" 1
N#ifndef __INIT_H__
N#define __INIT_H__
N
N
Ntypedef int  (*pf_entr)(void);
Ntypedef void (*pf_exit)(void);
N
N
N#include "board_kl520.h"
N#ifdef CFG_SENSOR_TYPE
N    #define ARRANGE_ENTR_RO_SECTION(fn, id) \
N        static pf_entr __entr_##fn __attribute__((used, section("entr_section"#id))) = fn;
X    #define ARRANGE_ENTR_RO_SECTION(fn, id)         static pf_entr __entr_##fn __attribute__((used, section("entr_section"#id))) = fn;
N    #define ARRANGE_EXIT_RO_SECTION(fn) \
N        static pf_exit __exit_##fn __attribute__((used, section("exit_section"))) = fn;
X    #define ARRANGE_EXIT_RO_SECTION(fn)         static pf_exit __exit_##fn __attribute__((used, section("exit_section"))) = fn;
N#else
S    #define ARRANGE_ENTR_RO_SECTION(fn, id) 
S    #define ARRANGE_EXIT_RO_SECTION(fn) 
N#endif
N
N
N#define INITTEXT __attribute__((section("init_text")))
N#define FINITEXT __attribute__((section("fini_Text"))) 
N#define INITDATA __attribute__((section("init_data")))
N
N#endif
L 8 "..\..\..\..\scpu\framework\include\framework/framework_driver.h" 2
N#include "framework/kdp_list.h"
L 1 "..\..\..\..\scpu\framework\include\framework/kdp_list.h" 1
N#ifndef __KDP_LIST_H__
N#define __KDP_LIST_H__
N
N
N#include "types.h"
N//#include "framework/framework_types.h"
N
Nstruct kdp_list {
N    struct kdp_list *next, *prev;
N};
N
Nstruct kdp_list_node {
N    struct kdp_list list;
N};
N
Nstruct kdp_list_iter {
N    struct kdp_list *i_list;
N    struct kdp_list_node *i_cur;
N};
N
N#define kdp_list_first_entry(ptr, type, member) \
N    container_of((ptr)->next, type, member)
X#define kdp_list_first_entry(ptr, type, member)     container_of((ptr)->next, type, member)
N
N#define kdp_list_next_entry(pos, member) \
N    container_of((pos)->member.next, typeof(*(pos)), member)
X#define kdp_list_next_entry(pos, member)     container_of((pos)->member.next, typeof(*(pos)), member)
N
N
Nvoid kdp_list_init(struct kdp_list *list);
Nvoid kdp_list_add_tail(struct kdp_list *head, struct kdp_list *new_list);
Nvoid kdp_list_add_node_tail(struct kdp_list *list, struct kdp_list_node *node);
Nvoid kdp_list_del(struct kdp_list *list);
Nvoid kdp_list_del_init(struct kdp_list *list);
Nint  kdp_list_empty(const struct kdp_list *list);
N
Nvoid kdp_list_iter_init_node(struct kdp_list *list, struct kdp_list_iter *iter);
Nvoid kdp_list_iter_exit(struct kdp_list_iter *iter);
Nstruct kdp_list_node *kdp_list_next(struct kdp_list_iter *iter);
N
N
N#endif
L 9 "..\..\..\..\scpu\framework\include\framework/framework_driver.h" 2
N#include "framework/v2k_image.h"
N
N
Ntypedef void (*fn_power_hook)(void);
N
Nstruct pin_context {
N    void *platform_data;
N    void *driver_data;
N    void *driver_this;
N};
Nstruct pin_context2 {
N    void *platform_data;
N};
N
Nstruct driver_context {
N    char name[20];
N
N    int (*add) (struct driver_context *, struct pin_context *);
N    int (*del) (struct driver_context *, struct pin_context *);
N
N    struct kdp_list_node knode_to_buslist;
N};
N
Nstruct driver_context2 {
N    int (*probe)(struct driver_context2 *, struct pin_context *);
N    int (*reset)(struct driver_context2 *, struct pin_context *);
N};
N
Nstruct kdp520_csi2rx_context_lite {
N    u32 ai_mem_addr;
N    u32 ai_mem_addr_tmp;
N    u32 vw_mem_addr;
N    u32 ov_mem_addr;	
N    u32 dp_mem_addr;	//for dsiplay
N    u32 dpi2ahb_base;
N};
Nstruct core_device {
N    const char *name;
N    struct ioport_setting *ioport;
N    int uuid; // universal unique id
N    struct pin_context pin_ctx;
N};
N#define to_core_device(x) container_of((x), struct core_device, pin_ctx)
N
N/* for core driver extension */
Nstruct power_mgr_api { 
N    int (*power)(struct core_device *, BOOL );/* power on or off the device */
N    int (*suspend)(struct core_device *);   /* power management - suspend */
N    int (*resume)(struct core_device *);    /* power management - resume */    
N};
N
Nstruct panel_driver {
N    int (*init)(struct core_device **);
N    int (*clear)(struct core_device **, u32 color);
N    u16 (*read_did)(struct core_device **);
N    void (*start)(struct core_device **);
N    void (*stop)(struct core_device **);
N    void (*preproc_rgb)(struct core_device **, u32 addr, u32 dest_addr);
N    void (*posproc_rgb)(struct core_device **, u32 addr, u32 dest_addr);
N    void (*preproc_nir)(struct core_device **, u32 addr, u32 dest_addr);   
N    void (*posproc_nir)(struct core_device **, u32 addr, u32 dest_addr);
N    void (*update)(struct core_device **, u32 addr);	
N};
N
Nstruct core_driver {
N    int (*probe)(struct core_device *);     /* used to set up device-specific structures or resource */
N    int (*remove)(struct core_device *);    /* used to release device-specfic structures or resource */
N    struct core_device *core_dev;
N    struct driver_context driver;
N    //struct power_mgr_api power_mgr;
N    void *cfg_func;
N};
N#define to_core_driver(drv)	(container_of((drv), struct core_driver, driver))
N
Nstruct kdp520_i2c_params {
N    unsigned long bus_speed;
N};
Nstruct core_i2c_driver {
N    int (*probe)(struct core_device *);     /* used to set up device-specific structures or resource */
N    int (*remove)(struct core_device *);    /* used to release device-specfic structures or resource */
N    struct core_device *core_dev;
N    struct driver_context driver;
N    struct power_mgr_api power_mgr;
N    void *cfg_func;
N
N    int (*set_params)(struct core_device *, struct kdp520_i2c_params *);
N    int (*init)(struct core_device *);
N    int (*reset)(struct core_device *);
N    int (*write)(struct core_device *, u8 , u16 , u16 , u8 );
N    int (*read)(struct core_device *, u8 , u16 , u16 , u8 *);
N    int (*readbytes)(struct core_device *, u8 , u16 , u16 , u8 *, u8);
N    
N    BOOL inited;
N    struct kdp520_i2c_params params;
N};
N
Ntypedef struct _lcm_custom_pinmux {
N    u32 pin_cs;
N    u32 pin_te;
N    u32 pin_rs;
N    u32 pin_rst;
N} lcm_custom_pinmux;
N
Nstruct display_driver {
N    // same as core_driver
N    int (*probe)(struct core_device **);     /* used to set up device-specific struct ures or resource */
N    int (*remove)(struct core_device **);    /* used to release device-specfic structures or resource */
N    struct core_device *core_dev;
N    struct driver_context driver;
N    struct power_mgr_api power_mgr;
N    void *cfg_func;
N
N    void *ctrller_ops;
N    lcm_custom_pinmux* custom_pinmux;
N
N    struct video_input_params vi_params;
N    u32 fb_size;
N	u32 type;
N    u32 base;
N    u16 display_id;
N    struct panel_driver *panel;
N    int (*attach_panel)(struct core_device **, struct panel_driver *panel);
N    int (*set_params)(struct core_device **, struct video_input_params *);
N    int (*get_params)(struct core_device **, struct video_input_params *);
N    int (*set_camera)(struct core_device **);
N//    int (*buffer_init)(struct core_device *, struct video_input_params *);
N    u32 (*get_buffer)(struct core_device **);
N    int (*init)(struct core_device **);
N    int (*start)(struct core_device **);
N    int (*stop)(struct core_device **);
N    int (*set_source)(struct core_device **, u32, int);
N    int (*set_pen)(struct core_device **, u16 , u32 );	
N    int (*draw_rect)(struct core_device **, int, int, u32, u32);
N    int (*draw_line)(struct core_device **, u32, u32, u32, u32);
N    int (*fill_rect)(struct core_device **, u32, u32, u32, u32);
N    int (*draw_bitmap)(struct core_device **, u32, u32, u32, u32, void *);
N    int (*fresh)(struct core_device **);
N};
N
Nstruct touch_panel_driver {
N    int (*init)(struct core_device *);
N    u16 (*read_did)(struct core_device *);
N    void (*start)(struct core_device *);
N    void (*stop)(struct core_device *);
N
N    void (*get_raw_data)(struct core_device *, u8);
N    void (*state_handler)(struct core_device *, void*);
N    void (*set_inactive)(void);
N    int (*get_active)(void);
N};
N
Nstruct touch_driver {
N    int (*probe)(struct core_device *);
N    int (*remove)(struct core_device *);
N    struct core_device *core_dev;
N    struct driver_context driver;
N    struct power_mgr_api power_mgr;
N    void *cfg_func;
N    void *ctrller_ops;
N
N    u16 device_id;
N    struct touch_panel_driver *panel;
N    int (*attach_panel)(struct core_device *, struct touch_panel_driver *panel);
N    int (*init)(struct core_device *);
N    int (*start)(struct core_device *);
N    int (*stop)(struct core_device *);
N    BOOL (*is_started)(struct core_device *);
N    void (*set_hook)(struct core_device *, fn_power_hook , fn_power_hook );
N    
N    u16 count;
N    u16 x[10];
N    u16 y[10];
N
N    u16 x_range_max;
N    u16 y_range_max;
N    u8 inverse_x_axis;
N    u8 inverse_y_axis;
N    fn_power_hook cb_power_on;
N    fn_power_hook cb_power_off;
N};
N
N////////////////////////////
N/* specific platform data */
N////////////////////////////
N/* i2c platform data */
Nstruct i2c_platform_data {
N    unsigned long bus_speed;
N};
N
N
Nextern struct driver_context* find_driver(char *);
Nextern struct ioport_setting *driver_get_ioport_setting(struct core_device *, unsigned int);
N
Nextern int drivers_init(void);
Nextern int driver_register(struct driver_context *, struct pin_context *);
Nextern void driver_unregister(struct driver_context *);
N//extern int driver_core_register(struct core_driver *);
N//extern void driver_core_unregister(struct core_driver *);
Nextern int driver_core_register(void *);
Nextern void driver_core_unregister(void *);
N
Nvoid* framework_drv_get_drvdata(const struct pin_context *);
Nvoid  framework_drv_set_drvdata(struct pin_context *, void *data);
Nvoid* framework_drv_get_drv(const struct pin_context *pin_ctx);
Nvoid  framework_drv_set_drv(struct pin_context *pin_ctx, void *this);
N
N#define DRIVER_SETUP(__driver, __setup_level, __register, __unregister, ...) \
Nstatic int INITTEXT __driver##_entr(void) { \
N    return __register(&(__driver) , ##__VA_ARGS__); \
N} \
NARRANGE_ENTR_RO_SECTION(__driver##_entr, __setup_level); \
Nstatic void FINITEXT __driver##_exit(void) { \
N    __unregister(&(__driver) , ##__VA_ARGS__); \
N} \
NARRANGE_EXIT_RO_SECTION(__driver##_exit);
X#define DRIVER_SETUP(__driver, __setup_level, __register, __unregister, ...) static int INITTEXT __driver##_entr(void) {     return __register(&(__driver) , ##__VA_ARGS__); } ARRANGE_ENTR_RO_SECTION(__driver##_entr, __setup_level); static void FINITEXT __driver##_exit(void) {     __unregister(&(__driver) , ##__VA_ARGS__); } ARRANGE_EXIT_RO_SECTION(__driver##_exit);
N
N#define DRIVER_SETUP_2(__driver, __setup_level, __register, __unregister, ...) \
Nstatic int INITTEXT __driver##_entr(void) { \
N    return __register((struct core_driver*)(&(__driver)), ##__VA_ARGS__); \
N} \
NARRANGE_ENTR_RO_SECTION(__driver##_entr, __setup_level); \
Nstatic void FINITEXT __driver##_exit(void) { \
N    __unregister((struct core_driver*)(&(__driver)), ##__VA_ARGS__); \
N} \
N
X#define DRIVER_SETUP_2(__driver, __setup_level, __register, __unregister, ...) static int INITTEXT __driver##_entr(void) {     return __register((struct core_driver*)(&(__driver)), ##__VA_ARGS__); } ARRANGE_ENTR_RO_SECTION(__driver##_entr, __setup_level); static void FINITEXT __driver##_exit(void) {     __unregister((struct core_driver*)(&(__driver)), ##__VA_ARGS__); } 
N#define KDP_CORE_DRIVER_SETUP(__core_driver, __setup_level) \
N    DRIVER_SETUP(__core_driver, __setup_level, driver_core_register, driver_core_unregister)
X#define KDP_CORE_DRIVER_SETUP(__core_driver, __setup_level)     DRIVER_SETUP(__core_driver, __setup_level, driver_core_register, driver_core_unregister)
N#define KDP_CORE_DRIVER_SETUP_2(__core_driver, __setup_level) \
N    DRIVER_SETUP_2(__core_driver, __setup_level, driver_core_register, driver_core_unregister)
X#define KDP_CORE_DRIVER_SETUP_2(__core_driver, __setup_level)     DRIVER_SETUP_2(__core_driver, __setup_level, driver_core_register, driver_core_unregister)
N
Nint framework_drv_init(void);
N
N#endif /* __DEVICE_H__ */
L 11 "..\..\..\..\scpu\include\kl520_include.h" 2
N#include "kdp_flash_table.h"
L 1 "..\..\config\kdp_flash_table.h" 1
N#ifndef __KDP_FLASH_TABLE_H__
N#define __KDP_FLASH_TABLE_H__
N
N
N#define KDP_FLASH_BOOT_SPL_ADDR             0x00000000 // file=./flash_bin/boot_spl.bin
N#define KDP_FLASH_BOOT_SPL_SIZE             0x00002000
N#define KDP_FLASH_FW_SCPU_ADDR              0x00002000 // file=./flash_bin/fw_scpu.bin
N#define KDP_FLASH_FW_SCPU_SIZE              0x00028000
N#define KDP_FLASH_FW_NCPU_ADDR              0x0002A000 // file=./flash_bin/fw_ncpu.bin
N#define KDP_FLASH_FW_NCPU_SIZE              0x00010000
N#define KDP_FLASH_BOOT_CFG0_ADDR            0x0003A000 // file=./flash_bin/boot_cfg0.bin
N#define KDP_FLASH_BOOT_CFG0_SIZE            0x00001000
N#define KDP_FLASH_FW_RESERVED1_ADDR         0x0003B000 // file=./flash_bin/fw_reserved.bin
N#define KDP_FLASH_FW_RESERVED1_SIZE         0x00006000
N#define KDP_FLASH_FW_SCPU1_ADDR             0x00041000 // file=./flash_bin/fw_scpu1.bin
N#define KDP_FLASH_FW_SCPU1_SIZE             0x00028000
N#define KDP_FLASH_FW_NCPU1_ADDR             0x00069000 // file=./flash_bin/fw_ncpu1.bin
N#define KDP_FLASH_FW_NCPU1_SIZE             0x00010000
N#define KDP_FLASH_BOOT_CFG1_ADDR            0x00079000 // file=./flash_bin/boot_cfg1.bin
N#define KDP_FLASH_BOOT_CFG1_SIZE            0x00001000
N#define KDP_FLASH_FID_MAP_ADDR              0x0007A000 // file=./flash_bin/fid_map.bin
N#define KDP_FLASH_FID_MAP_SIZE              0x000C8000
N#define KDP_FLASH_SETTINGS_ADDR             0x00142000 // file=./flash_bin/setting.bin
N#define KDP_FLASH_SETTINGS_SIZE             0x00001000
N#define KDP_FLASH_FW_INFO_ADDR              0x00143000 // file=./flash_bin/fw_info.bin
N#define KDP_FLASH_FW_INFO_SIZE              0x000001F4
N#define KDP_FLASH_ALL_MODELS_ADDR           0x00144000 // file=./flash_bin/all_models.bin
N#define KDP_FLASH_ALL_MODELS_SIZE           0x00E8C540
N#define KDP_FLASH_INF_ADDR                  0x00FD1000
N#define KDP_FLASH_INF_SIZE                  0x00002000
N
N#define KDP_FLASH_LAST_ADDR                 0x00FD3000
N
N#endif
L 12 "..\..\..\..\scpu\include\kl520_include.h" 2
N#include "kdp520_pwm_timer.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp520_pwm_timer.h" 1
N#ifndef __KDP520_PWM_TIMER_H
N#define __KDP520_PWM_TIMER_H
N
N
N#include <stdint.h>
N#include "types.h"
N#include "kneron_mozart.h"
N
N
N#define HZ			                (100)				/// how many tick each sec
N
N#define MAX_PWM_TIMER		        (6)
N
N#define TIMER_INTSTAT				(0x0)
N//#define TIMER_CR				    (0x0)
N#define TIMER_LOAD					(0x4)
N#define TIMER_COMPARE				(0x8)
N#define TIMER_CNTO					(0xc)
N
N
Ntypedef enum {
N    PWMTIMER1=1,
N    PWMTIMER2=2,
N    PWMTIMER3=3, 
N    PWMTIMER4=4,
N    PWMTIMER5=5,
N    PWMTIMER6=6,
N} pwmtimer;
N
N
Ntypedef struct 
N{	
N	UINT32 TmSrc:1;	/* bit 0 */
N	UINT32 TmStart:1;
N	UINT32 TmUpdate:1;
N	UINT32 TmOutInv:1;
N	UINT32 TmAutoLoad:1;
N	UINT32 TmIntEn:1;
N	UINT32 TmIntMode:1;
N	UINT32 TmDmaEn:1;	
N	UINT32 TmPwmEn:1;	/* bit 8 */
N	UINT32 Reserved:15;	/* bit 9~23 */
N	UINT32 TmDeadZone:8;	/* bit 24~31 */
N}kdp_timer_control ;
Ntypedef struct
N{	
N			UINT32 Counter;
N}kdp_pwm_CNTB;
N
Ntypedef struct
N{
N	UINT32 CompareBuffer;
N}kdp_pwm_CMPB; //CMPB
N
Ntypedef struct 
N{
N    UINT32 IntNum;			/* interrupt number */   
N    UINT32 Tick;				/* Tick Per Second */   
N    UINT32 Running;			/* Is timer running */       
N}kdp_timer_struct;
N
N
N#define APB_CLK APB_CLOCK
N//--------------------------------------------------
N// Timer tick
N//--------------------------------------------------
N#define PWMTMR_5000MSEC_PERIOD      (UINT32)(APB_CLK*5)
N#define PWMTMR_1000MSEC_PERIOD		(UINT32)(APB_CLK)
N#define PWMTMR_100MSEC_PERIOD			(UINT32)(APB_CLK/10)
N#define PWMTMR_20MSEC_PERIOD			(UINT32)(APB_CLK/50)
N#define PWMTMR_15MSEC_PERIOD			(UINT32)(((APB_CLK/100)*3)/2)
N#define PWMTMR_10MSEC_PERIOD			(UINT32)(APB_CLK/100)
N#define PWMTMR_1MSEC_PERIOD				(UINT32)(APB_CLK/1000)
N#define PWMTMR_01MSEC_PERIOD			(UINT32)(APB_CLK/10000)
N
Ntypedef enum Timer_IoType
N{
N	IO_TIMER_RESETALL,
N	IO_TIMER_GETTICK,
N	IO_TIMER_SETTICK,
N	IO_TIMER_SETCLKSRC
N}timeriotype;
N
N
N/*PWM function*/ 
N/**
N * enum pwm_polarity - polarity of a PWM signal
N * @PWM_POLARITY_NORMAL: a high signal for the duration of the duty-
N * cycle, followed by a low signal for the remainder of the pulse
N * period
N * @PWM_POLARITY_INVERSED: a low signal for the duration of the duty-
N * cycle, followed by a high signal for the remainder of the pulse
N * period
N */
Ntypedef enum {
N	PWM_POLARITY_NORMAL = 0,
N	PWM_POLARITY_INVERSED,
N}pwmpolarity;
N
Nextern BOOL kdp_pwm_config(pwmtimer timer, pwmpolarity polarity, int duty_ms, int period_ms);
Nextern BOOL kdp_pwm_enable(pwmtimer timer);
Nextern BOOL kdp_pwm_disable(pwmtimer timer);
Nextern BOOL kdp_pwm_start(pwmtimer timer);
Nextern BOOL kdp_pwm_stop(pwmtimer timer);
N
Nextern BOOL kdp_timer_init(pwmtimer timer, UINT32 tick);
Nextern INT32 kdp_timer_ioctrl(timeriotype IoType,pwmtimer timer,UINT32 tick);
Nextern INT32 kdp_timer_counter(pwmtimer timer);
Nextern INT32 kdp_timer_autoreloadenable(pwmtimer timer);
Nextern void kdp_timer_autoreloadvalue(pwmtimer timer, UINT32 value);
Nextern void kdp_timer_cmpvalue(pwmtimer timer, UINT32 value);
Nextern INT32 kdp_timer_enable(pwmtimer timer);
Nextern INT32 kdp_timer_disable(pwmtimer timer);
Nextern INT32 kdp_timer_close(pwmtimer timer);
Nextern void kdp_timer_resetall(void);
N
Nextern INT32 kdp_timer_int_enable(pwmtimer timer);
Nextern INT32 kdp_timer_int_disable(UINT32 timer);
Nextern INT32 kdp_timer_int_clear(pwmtimer timer);
Nextern INT32 kdp_timer_intmode_enable(UINT32 timer,UINT32 mode);
Nextern void kdp_timer_tick_reset(pwmtimer timer);
N
N
Nextern UINT32 kdp_current_t1_tick(void);
Nextern UINT32 kdp_current_t2_tick(void);
Nextern UINT32 kdp_current_t3_tick(void);
Nextern UINT32 kdp_current_t4_tick(void);
Nextern UINT32 kdp_current_t5_tick(void);
Nextern UINT32 kdp_current_t6_tick(void);
N
Nextern void PWMTMR1_IRQHandler(void);
Nextern void PWMTMR2_IRQHandler(void);
Nextern void PWMTMR3_IRQHandler(void);
Nextern void PWMTMR4_IRQHandler(void);
Nextern void PWMTMR5_IRQHandler(void);
Nextern void PWMTMR6_IRQHandler(void);
N
N
N#endif //__KDP520_PWM_TIMER_H
L 13 "..\..\..\..\scpu\include\kl520_include.h" 2
N#include "kdp_e2e_util.h"
L 1 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_util.h" 1
N#ifndef __KDP_E2E_UTIL_H__
N#define __KDP_E2E_UTIL_H__
N
N#include "kdp_app_fid.h"
L 1 "..\..\..\..\scpu\lib\kdp_application\include\kdp_app_fid.h" 1
N/*
N * Kneron Application FD/FR APIs
N *
N * Copyright (C) 2019 Kneron, Inc. All rights reserved.
N *
N */
N
N#ifndef __KDP_APP_FID_H_
N#define __KDP_APP_FID_H_
N
N#include <stdint.h>
N#include "types.h"
N#include "ipc.h"
N#include "kdp_app.h"
L 1 "..\..\..\..\scpu\lib\kdp_application\include\kdp_app.h" 1
N/*
N * Kneron Application Shared Data
N *
N * Copyright (C) 2019 Kneron, Inc. All rights reserved.
N *
N */
N
N/**
N * @file kdp_app.h
N * @brief Public API header of kdp_application generic functions
N */
N
N#ifndef __KDP_APP_H_
N#define __KDP_APP_H_
N
N
N#include "types.h"
N#include "model_type.h"
N#include "ipc.h"
N
N
Nenum kapp_status_code_e {
N    KAPP_OK = 0,
N    KAPP_UNKNOWN_ERR = 1,
N};
N
N/* no need to align with cam source index */
N#define KAPP_IMG_SRC_RGB  0
N#define KAPP_IMG_SRC_NIR  1
N#define KAPP_IMG_SRC_LV   2
N#define KAPP_IMG_SRC_MAX  3
N
N/**
N * @brief to get channel size by image format
N *
N * @param [in] image format
N * @return channel size
N */
N//uint32_t kdp_app_get_chnl_size(uint32_t format);
N
N/**
N * @brief to get pixel size by image format
N *
N * @param [in] image format
N * @return pixel size
N */
Nuint32_t kdp_app_get_pixel_size(uint32_t image_format);
N
N#endif
L 15 "..\..\..\..\scpu\lib\kdp_application\include\kdp_app_fid.h" 2
N
N// To use new FDR. If using old FDR (FDSmallbox+Onet+VGG10), comment this Macro
N#define FDSSD_ONETBLUR_VGG
N
N/* ==================
N *  FID application
N *      kdpAppFID.c
N * ================== */
N//enum kapp_fid_status_code_e {
N//    KAPP_FDR_WRONG_USAGE = 0x100,    ///== KDP_APP_FID_CODES
N//    KAPP_FDR_NO_FACE,                /// error: no face
N//    KAPP_FDR_BAD_POSE,               /// error: base face pose
N//    KAPP_FDR_NO_ALIVE,               /// error: not alive
N//    KAPP_FDR_FR_FAIL,                /// error: FR failed
N//    KAPP_LM_LOW_CONFIDENT,           /// error: LM low confident
N//    KAPP_LM_BLUR,                    /// error: LM blur
N//    KAPP_SMALL_FACE,                 /// error: face too small
N//    KAPP_RGB_Y_DARK
N//};
N
N//enum kapp_fid_op_e{
N//    KAPP_FID_OP_EXTRACT,             /// extract feature map only
N//    KAPP_FID_OP_INFERENCE,           /// do inference (do DB comparison)
N//    KAPP_FID_OP_REGISTER             /// do register (insert DB temp data)
N//};
N
N// data structure
N//---------------------------------
N//typedef struct kdp_app_fid_inout_s {
N//    enum kapp_fid_op_e op;               ///operation mode
N//    uint16_t face_id;                       //1-5: faceId (1-5)
N//    uint16_t user_id;                       ///as input: user id got from Host
N//                                            ///as output: user id returned by KL520
N//    float thresh_fid[KAPP_IMG_SRC_MAX];  ///threshold value for face recognition
N//} kdp_app_fid_inout_t;
N
N/** @brief face detectin result
N *
N * facedet_result_s is defined in ipc.h
N * */
N//typedef struct facedet_result_s kdp_app_face_det_res_t;
N
N/** @brief landmark result
N *
N * landmark_result_s is defined in ipc.h
N * */
N//typedef struct landmark_result_s kdp_app_face_lm_res_t;
N
N/** @brief face recognition result
N *
N * fr_result_s defined in ipc.h
N * */
N//typedef struct fr_result_s kdp_app_face_fmap_t;
N
N//typedef struct kdp_app_image_buffer_desc_s {
N//   uint32_t buf_count;                  ///image buffer count
N//   uint32_t alignment_in_bit;           ///alignment size in bit
N//   uint32_t rgb_buf_base_addr;          ///rgb image buffer address
N//   uint32_t rgb_img_size;               ///rgb image size
N//   uint32_t nir_buf_base_addr;          ///nir image buffer address
N//   uint32_t nir_img_size;               ///nir image size
N//} kdp_app_image_buffer_desc_t;
N
N/**
N * @brief do face detection
N * @param [out] p_out_p: detected face bounding box
N * @param [in] img_cfg img config
N * @return OK or Err code
N */
N//int32_t kdp_app_fd(struct facedet_result_s *p_out_p/*out*/,
N//                   struct kdp_img_cfg *img_cfg);
N
N
N/**
N * @brief do face landmark
N * @param [out] p_out_p detected face landmarks
N * @param [in] p_fd_out_p detected face bounding box
N * @param [in] img_cfg img config
N * @return OK or Err code
N */
N//int32_t kdp_app_lm(struct landmark_result_s *p_out_p/*out*/,
N//                   struct facedet_result_s *p_fd_out_p,
N//                   struct kdp_img_cfg *img_cfg);
N
N/**
N * @brief do nir liveness
N * @param [out] p_out_p detected nir liveness
N * @param [in] p_lm_out_p detected face landmarks
N * @param [in] img_cfg img config
N * @return OK or Err code
N */
Nint32_t kdp_app_nir_lv(struct lv_result_s *p_out_p/*out*/,
N                   //struct facedet_result_s  *p_fd_out_p,
N                   struct landmark_result_s   *p_lm_out_p,
N                   struct kdp_img_cfg *p_nir_img_setting_p);
N                   //int img_src);
N
Nint32_t kdp_app_nir_eye_lv(struct lv_result_s *p_out_p/*out*/,
N                   //struct facedet_result_s  *p_fd_out_p,
N                   struct landmark_result_s   *p_lm_out_p,
N                   struct kdp_img_cfg *p_nir_img_setting_p);
N
Nint32_t kdp_app_fuse_nir_lv(struct lv_result_s *p_out_p/*out*/,
N                   //struct facedet_result_s  *p_fd_out_p,
N                   struct landmark_result_s   *p_lm_out_p,
N                   struct kdp_img_cfg *p_nir_img_setting_p);
N                   //int img_src);
N/**
N * @brief do nir liveness by head shoulder and neck
N * @param [out] p_out_p detected nir liveness
N * @param [in] p_lm_out_p detected face landmarks
N * @param [in] img_cfg img config
N * @return OK or Err code
N */
Nint32_t kdp_app_nir_hsn_lv(struct lv_result_s *p_out_p/*out*/,
N                   //struct facedet_result_s  *p_fd_out_p,
N                   struct landmark_result_s   *p_lm_out_p,
N                   struct kdp_img_cfg *p_nir_img_setting_p);
N                   //int img_src);
N                   
N/**
N * @brief do nir structure light liveness
N * @param [out] p_out_p detected nir liveness
N * @param [in] p_lm_out_p detected face landmarks
N * @param [in] img_cfg img config
N * @return OK or Err code
N */
N//int32_t kdp_app_nir_sl_lv(struct lv_result_s *p_out_p/*out*/,
N//                   struct facedet_result_s  *p_nir_fd,
N//                   struct landmark_result_s   *p_lm_out_p,
N//                   struct kdp_img_cfg *p_nir_img_setting_p);              
N                   
N/**
N * @brief do rgb liveness
N * @param [out] p_out_p detected rgb liveness
N * @param [in] p_lm_out_p detected face landmarks
N * @param [in] img_cfg img config
N * @return OK or Err code
N */
N//int32_t kdp_app_rgb_lv(struct lv_result_s *p_out_p/*out*/,
N//                   //struct facedet_result_s  *p_fd_out_p,
N//                   struct landmark_result_s   *p_lm_out_p,
N//                   struct kdp_img_cfg *p_rgb_img_setting_p);
N//                   //int img_src);
N
N/**
N * @brief extract face embedding
N * @param [out] p_out_p extracted face embedding
N * @param [in] p_fd_out_p detected face bounding box
N * @param [in] p_lm_out_p detected face landmarks
N * @param [in] img_cfg img config
N * @return OK or Err code
N */
N//int32_t kdp_app_fr(struct fr_result_s *p_out_p/*out*/,
N//                   struct facedet_result_s  *p_fd_out_p,
N//                   struct landmark_result_s   *p_lm_out_p,
N//                   struct kdp_img_cfg *img_cfg);
N
N
N//int32_t kdp_model_age_group(struct age_group_result_s *age, /*output*/
N//                     struct kdp_img_cfg *img_cfg,
N//                     struct facedet_result_s *fd_bbox);
N
N/**
N * @brief init necessary data, face data base
N * @param[in]  reserve_db_num : reserve more user_db unit in ddr
N * @return OK
N */
N//int32_t kdp_app_init( uint16_t reserve_db_num );
N
N
N/**
N * @brief (Beta) get 5 pose score for a landmark set
N * @param[out] pose : 5 pose score
N * @param[in]  landmark : 5 points landmark, 10 int value
N */
N//void kdp_app_get_pose_value(uint32_t* landmarks, float *poses);
N
N
N/**
N * @brief (Beta) check if it is a bad pose for a landmark set
N * @param[in]  landmark : 5 points landmark, 10 int value
N * @return True for bad pose, False otherwise
N */
N//bool kdp_app_check_bad_pose(uint32_t *landmarks);
N
N//int kdp_app_check_head_pose(struct landmark_result_s* landmarks,
N//                            uint8_t reg_idx, uint8_t force_flag,
N//                            uint8_t* face_reg_thresh);
N
N//int kdp_app_rgb_occlusion_lv(struct kdp_img_cfg *img_cfg,
N//                     struct facedet_result_s *fd_bbox,
N//                     struct landmark_result_s   *p_lm,
N//                     struct face_occlude_result_s *out, int model_type);  // output)
N
Nint kdp_app_nir_face_seg_mask(struct kdp_img_cfg *img_cfg,
N                     struct facedet_result_s *fd_bbox,
N                     struct landmark_result_s   *p_lm,
N                     struct face_occlude_result_s *out, int model_type);  // output)
N										 
Nint32_t kdp_model_eye_lid_2(struct landmark_result_s *lm, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     struct lv_result_s *eye_lid,
N                     int e_id);										 
N/**
N * @brief (Beta) check if it is a good normal face for a landmark set
N * @param[in]  landmark : 5 points landmark, 10 int value
N * @param[in]  thresh : angle ratio threshold
N * @return True for good normal face
N */
N//bool kdp_app_check_angle_ratio(uint32_t *landmarks, float thresh);
N//int32_t kapp_face_seg(float output_seg_map[144],float landmark[10], float score[5], struct kdp_img_cfg *img_cfg);
N//#define kapp_fid_inout_t kdp_app_fid_inout_t
N//#define kapp_init kdp_app_init
N//#define kapp_image_buffer_desc_t kdp_app_image_buffer_desc_t
N//#define kapp_fdr kdp_app_fdr
N//#define kapp_lw3d kdp_app_lw3d
N
N#endif
L 5 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_util.h" 2
N#include "kdp_e2e_db.h"
L 1 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_db.h" 1
N#ifndef __KDP_E2E_DB_H__
N#define __KDP_E2E_DB_H__
N
N
N#include "types.h"
N#include "kdp_app_db.h"
L 1 "..\..\..\..\scpu\lib\kdp_application\include\kdp_app_db.h" 1
N/*
N * Kneron Application Database APIs
N *
N * Copyright (C) 2019 Kneron, Inc. All rights reserved.
N *
N */
N
N/**
N * @file kdp_app_db.h
N * @brief Kneron Application DB APIs
N */
N
N#ifndef __KAPP_DB_H_
N#define __KAPP_DB_H_
N
N#include <stdint.h>
N#include "kdp_app.h"
N#include "common.h"
L 1 "..\..\..\..\common\include\common.h" 1
N#ifndef COMMON_H
N#define COMMON_H
N
N#include "board_cfg.h"
N
N//#define DEVICE_ID           0x520       // Kneron device id for KL520
N//#define FW_VERSION          0x00090505  // 0, 9, 5, 5 major, minor, patch, edit
N
N//#define FID_THRESHOLD       (0.425f)
N
N#ifdef CFG_MAX_USER
N#define MAX_USER            (CFG_MAX_USER)  // MAX user count in DB
N#else
S#define MAX_USER            (100)  // MAX user count in DB
N#endif
N#define MAX_FID             (5)   // MAX face count for one user
N
N#define MAX_LEN_USERNAME    (32)
N
N//#define ALL_USER_UID        (0)
N
N#endif
L 19 "..\..\..\..\scpu\lib\kdp_application\include\kdp_app_db.h" 2
N#include "types.h"
N#include "board_cfg.h"
N#include "kdp_flash_table.h"
N
N#if (CFG_FLASH_DB_NIR_ONLY != 1)
X#if (1 != 1)
S#define FR_TO_DB_IDX_0      0
S#define FR_TO_DB_IDX_1      1
S#define DB_NUM              2  //@brief DB count. 1 or 2
N#else
N#define FR_TO_DB_IDX_0      1 //rgb sensor
N#define FR_TO_DB_IDX_1      0 //nir sendor
N#define DB_NUM              1 //nir only
N#endif
N
N#define FM_SIZE             256
N#define FM_SIZE_BYTE        (FM_SIZE * 4)
N#define KDP_DB_DEFAULT_OFFSET  (0x01) //zcy mod 0x80 to 0x01
N
N#define PALM_FM_SIZE        512
N
N/** @brief flash address of DB */
N#define KAPP_DB_FLASH_ADDR   KDP_FLASH_FID_MAP_ADDR
N#define KAPP_PALM_DB_FLASH_ADDR    (KDP_FLASH_FID_MAP_ADDR + 16*1024*1024) //yg todo:
N
Nenum kdp_app_db_type_valid_flag_e{
N    TYPE_INVALID = 0,
N    TYPE_VALID,
N    TYPE_REGISTER,
N    TYPE_RESERVER,
N};
N
Nenum kapp_db_status_code_e{
N    KAPP_DB_NO_SPACE = 0x200,   //kdpApp.h
N    KAPP_DB_ALREADY_SAVED,
N    KAPP_DB_DEL_NOT_VALID,
N    KAPP_DB_NO_MATCH,
N    KAPP_DB_REG_FIRST,
N    KAPP_DB_USER_NOT_REG,
N    KAPP_DB_DEL_FAIL,
N    KAPP_DB_FAIL_FLIP0,
N    KAPP_DB_FAIL_FLIP1,
N    KAPP_DB_FAIL_ABORT,
N    KAPP_DB_POSE_ERR,
N};
N
Ntypedef struct kapp_db_user_data_s {
N    uint16_t user_id_in;
N    uint16_t user_id_out;
N    uint16_t user_idx;
N    uint16_t fm_idx;
N    uint16_t del_all;
N    uint16_t flash_off;
N    uint16_t reserve_db_num;
N} kapp_db_user_data_t;
N
Ntypedef struct kdp_app_db_extra_data_struct {
N    char user_name[MAX_LEN_USERNAME];
X    char user_name[(32)];
N    u8 pre_add;            //Fixed 1bytes
N    u8 admin;
N    u8  rgb_age_group;
N    u8 rgb_face_quality;
N    u8 nir_face_quality;
N//    u8 rgb_corner_y;
N//    u16 rec_cnt;
N//    u16 rec_fm_hist[MAX_FID];
N    u8 nir_mode;
N//    float fs_feature[17];
N//    float darkness;
N//    float effect_2d;
N    float nir_gain;
N    u32 nir_cur_exp_time;
N    u16  n1_fd_x;
N    u16  n1_fd_y;
N    u16  n1_fd_w;
N    u16  n1_fd_h;
N    float lm_length_ratio[5];
N} kdp_app_db_extra_data;
N
Nextern float g_nFaceL2;
N
Nint32_t kdp_app_db_extra_data_read(u8 user_idx, kdp_app_db_extra_data* data_addr);
Nint32_t kdp_app_db_extra_data_write(u8 user_idx, kdp_app_db_extra_data* data_addr);
Nint32_t kdp_reload_db(void);
N
N/**
N * @brief register user fm data
N * @param [in] fdr_addr address of fd/fr feature map data
N * @param [in] user_id use id
N * @param [in] fm_idx face index
N * @param [in] reserve_db_num reserve more user_db uint in ddr memory
N * @return status
N */
N//int32_t kdp_app_db_register(uint32_t fdr_addr, uint16_t user_id, uint16_t fm_idx, int reserve_db_num);
N
N/**
N * @brief register user both fm data
N * @param [in] rgb_fdr_addr address of rgb fd/fr feature map data
N * @param [in] nir_fdr_addr address of nir fd/fr feature map data
N * @param [in] user_id use id
N * @param [in] fm_idx face index
N * @param [in] reserve_db_num reserve more user_db uint in ddr memory
N * @return status
N */
Nint32_t kdp_app_db_both_register(uint32_t rgb_fdr_addr, uint32_t nir_fdr_addr,  uint16_t user_id, uint16_t fm_idx, int reserve_db_num );
N
N/**
N * @brief Initialize database
N * @param [in] flash_db_addr_p flash address of the database
N * @param [in] reserve_db_num reserve more user_db uint in ddr memory
N * @return registered user count
N */
N//int32_t kdp_app_db_both_update( uint32_t rgb_fdr_addr, uint32_t nir_fdr_addr, uint16_t user_id, uint16_t fm_idx, int reserve_db_num, float coef);
Nint32_t kdp_app_db_fmap_update( uint32_t fdr_addr, uint16_t u_idx, uint16_t fm_idx, int db_idx);
Nvoid    kdp_app_db_save_fmap_to_flash(uint16_t update_idx, uint16_t fm_idx, int db_idx);
N
Nint32_t kdp_app_db_init(uint16_t reserve_db_num, BOOL flash_load );
Nint32_t kdp_app_db_init_flash_load(void);
N
N/**
N * @brief switch between two DB if use two DB setting
N * @param [in] db_index indicate which DB is activated
N */
N//void    kdp_app_db_switch(uint32_t db_index);
N
N/**
N * @brief use two DB to store 2 kinds of FM data
N */
N//void    kdp_app_db_split_mode(void);
N
N/**
N * @brief register user data to database
N * @param [in] *p_inout_p p_inout_p->user_id user id
N * @return user index in database
N */
Nint32_t kdp_app_db_add(kapp_db_user_data_t *p_inout_p);
N
N/**
N * @brief delete user data in ddr and flash
N * @param [in] *p_inout_p p_inout_p->user_id user id, "0" means all
N * @return none
N */
Nint32_t kdp_app_db_delete(kapp_db_user_data_t *p_inout_p);
N
N/**
N * @brief output user number and all user id data
N */
N//int32_t kdp_app_db_list(void);
N
N/**
N * @brief output one feature map data of one user
N * @param [in] *p_inout_p p_inout_p->user_id
N *                        p_inout_p->image_idx
N */
N//int32_t kdp_app_db_upload(kapp_db_user_data_t *p_inout_p);
N
N/**
N * @brief clear all user data not yet valid
N * @return OK or error code
N */
Nint32_t kdp_app_db_abort_reg(void);
N
N/**
N * @brief check if a db slot is used
N * @param [in] i slot index
N * @return 1: yes  0:no
N */
Nint32_t kdp_app_db_slot_is_used(uint16_t i);
N
N/**
N * @brief get feature map 0 count for a user index
N * @param [in] user_idx user index
N * @return count for feature map 0
N */
N//int kdp_app_db_get_fm0_cnt(int user_idx);
N
N/**
N * @brief get feature map 1 count for a user index
N * @param [in] user_idx user index
N * @return count for feature map 1
N */
N//int kdp_app_db_get_fm1_cnt(int user_idx);
N
N/**
N * @brief get slot type for a user index
N * @param [in] user_idx user index
N * @return type, 0:invalid, 1:valid, 2:register
N */
N//int kdp_app_db_get_user_id_slot_type(int user_idx);
N
N/**
N * @brief get user ID for a user index
N * @param [in] user_idx user index
N * @return user ID (could be different from user index)
N */
Nint kdp_app_db_get_user_id(int user_idx);
Nu8  kdp_app_db_get_db_idx(u8 user_id);
Nu8  _kl520_app_calc_db_uid(u8 db_idx);
N
N/**
N * @brief Add a single FM to DB,  init the user slot if slot is not valid
N * @param [in] user indx (slot #)
N * @param [in] user id
N * @param [in] u8 pointer to FM data (only works for fm0)
N * @return 0 - success, else error
N */
N//int kdp_app_db_add_FM(int user_idx, int user_id, unsigned char *pfm_data);
N
N/**
N * @brief Delete a single FM from DB, delete the user slot if no more FM is left
N * @param [in] user indx (slot #)
N * @param [in] FM indx (only works for fm0)
N * @return 0 - success, else error
N */
N //int kdp_app_db_delete_FM(int user_idx, int fm_idx);
N
N/**
N * @brief Calculate similarity of two feature points
N * @param [out] **db_ddr_p output ddr address of DB temp
N * @param [out] **db_flash_p flash address of DB
N * @return similarity score (smaller means more like)
N */
Nint32_t kdp_app_db_query(uint32_t **db_ddr_p, uint32_t **db_flash_p);
N
N/**
N * @brief compare user fd/fr result to user data in ddr (only normal face)
N * @param fdr_addr address of fd/fr feature map data
N * @param [in] user id
N * @param [in] database idx
N * @param thresh_fid threshold value for similarity
N * @return compare result and user id where find match feature map data
N */
N//int32_t kdp_app_db_compare_normal(uint32_t fdr_addr, uint16_t *user_id, int db_idx, float thresh_fid);
N
N/**
N * @brief compare user fd/fr result to itself
N * @param fdr_addr address of fd/fr feature map data
N * @param [in] user id
N * @param [in] database idx
N * @param [in] database idx
N * @param thresh_fid threshold value for comparing self
N * @param [in] reserve_db_num reserve more user_db uint in ddr memory
N * @return compare result
N */
Nint32_t kdp_app_db_compare_self(uint32_t fdr_addr, uint16_t user_id, int db_idx, float thresh_fid, int reserve_db_num);
N
N/**
N * @brief compare user fd/fr result to user data in ddr
N * @param fdr_addr_1 address of feature map data
N * @param weight_1 fdr_addr_1 accounts for all the calculation weights
N * @param db_idx_1 index of databases related to fdr_addr_1
N * @param fdr_addr_2 address of feature map data
N * @param weight_2 fdr_addr_2 accounts for all the calculation weights
N * @param db_idx_2 index of databases related to fdr_addr_2
N * @param thresh_fid threshold value for comparison
N * @return compare result, min dist and user id where find match feature map data
N */
N#if 0
Sint32_t kdp_app_db_compare_five_faces_both(
S        uint32_t fdr_addr_1, float weight_1, int db_idx_1,
S        uint32_t fdr_addr_2, float weight_2, int db_idx_2,
S        float thresh_fid, uint16_t *user_id, float* min_dist/*output*/);
N#endif
N
Nint32_t kdp_app_db_compare_five_faces_both_test(
N        uint32_t fdr_addr_1, float weight_1, int db_idx_1,
N        uint32_t fdr_addr_2, float weight_2, int db_idx_2,
N        u16   nir_mode,    
N        float thresh_fid, uint16_t *user_id/*output*/, float *min_dist, u8 var_pre_add);
Nint32_t kdp_app_db_compare_five_faces_one_user(
N        uint32_t fdr_addr_1, float weight_1, int db_idx_1,
N        uint32_t fdr_addr_2, float weight_2, int db_idx_2,
N        u16  user_id, float thresh_fid);
N
Nuint16_t kdp_app_db_find_exist_id(uint16_t user_id);
Nvoid kdp_app_db_flash_to_ddr(u8 user_id);
N
Nint32_t kdp_app_db_get_user_info_by_idx(
N        uint16_t idx,
N        uint16_t *lp_valid_fm0,
N        uint16_t *lp_valid_fm1,
N        uint16_t *lp_type);
N
Nuint32_t kdp_app_db_get_user_addr( int user_id );
Nuint32_t kdp_app_db_get_user_size( void );
Nuint32_t kdp_app_db_get_user_setting_addr( u16 user_idx );
N
Nuint32_t kdp_app_db_get_all_info_user_addr( u16 idx );
Nuint32_t kdp_app_db_get_all_info_user_size(void);
N
Nvoid kdp_app_db_set_last_register_id_preprocess(uint16_t user_idx, uint8_t fm_active );
Nvoid kdp_app_db_set_last_register_id_postprocess( uint16_t user_idx );
Nint32_t kdp_app_db_2users_compare(uint8_t* pOutR1, uint32_t fdr_addr_r1_1, uint32_t fdr_addr_r1_2, float weight_r1, \
N                                  uint8_t* pOutN1, uint32_t fdr_addr_n1_1, uint32_t fdr_addr_n1_2, float weight_n1 );
Xint32_t kdp_app_db_2users_compare(uint8_t* pOutR1, uint32_t fdr_addr_r1_1, uint32_t fdr_addr_r1_2, float weight_r1,                                   uint8_t* pOutN1, uint32_t fdr_addr_n1_1, uint32_t fdr_addr_n1_2, float weight_n1 );
N
NBOOL kdp_app_imp_db_chk(void);
NBOOL kdp_app_imp_fm_chk(BOOL nAfterChk);
NBOOL kdp_app_imp_fm_chk_int8(u32 addr);
N
N//void kdp_app_all_db_move_to_flash( uint32_t nSize );
N//void kdp_app_update_all_user_id(void);
N
N//import DB data
N//if specified slot is not empty, return error if force_mode is 0. 
N//return the new user id and DB data
Nint32_t kdp_app_db_import(uint16_t user_id, uint8_t* data, uint16_t data_size);
Nint32_t kdp_app_db_import_request(uint16_t *p_user_id, uint32_t size, uint8_t mode);
N
Nbool kdp_app_db_check_user_id(uint16_t user_id);
X_Bool kdp_app_db_check_user_id(uint16_t user_id);
Nbool kdp_app_db_check_usr_idx(u8 usr_idx);
X_Bool kdp_app_db_check_usr_idx(u8 usr_idx);
N
N#endif /* __KAPP_DB_H_ */
L 7 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_db.h" 2
N#include "kdp_e2e_face.h"
L 1 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_face.h" 1
N#ifndef __KDP_E2E_FACE_H__
N#define __KDP_E2E_FACE_H__
N
N
N#include "board_kl520.h"
N#include "types.h"
N#include "ipc.h"
N#include "kdp_fb_mgr.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp_fb_mgr.h" 1
N/*
N * KDP Frame Buffer driver header
N *
N * Copyright (C) 2019 Kneron, Inc. All rights reserved.
N *
N */
N
N#ifndef __KDP_FB_MGR_H__
N#define __KDP_FB_MGR_H__
N#include <stdint.h>
N#include "board_kl520.h"
N#include "board_cfg.h"
N
N#define MAX_FRAME_BUFFER        7
N#define USE_GUARDBAND           64   // 1/n on both sides
N#define SKIP_FRAME_NUM          0
N
N#define INF_WAIT_MAX_TIME_MS    1000
N#define INF_WAIT_OS_DELAY_MS    10
N#define INF_WAIT_OS_DELAY_TICKS (OS_TICK_FREQ * INF_WAIT_OS_DELAY_MS / 1000)
N
N#define FB_CTX_ENABLE               (NO)
N#define FB_WAIT_TILE_VAL            (YES)
N#define FB_TILE_RECODE              (NO)
N
N//#if (CFG_SENSOR_0_FULL_RESOLUTION == YES || CFG_SENSOR_1_FULL_RESOLUTION == YES)
N//    #define TILE_VAL_LEN    (60)
N//#else
N//    #define TILE_VAL_LEN    (60)
N//#endif
Nstruct frame_info
N{
N    uint8_t tile_val[TILE_AVG_BLOCK_NUMBER];
X    uint8_t tile_val[((10) * (6))];
N#if (FB_WAIT_TILE_VAL == YES)
X#if ((1) == 1)
N    uint8_t _inited;
N#endif
N};
N#if (FB_TILE_RECODE == YES)
X#if ((0) == 1)
Sstruct frame_record_info
S{
S
S    struct      frame_info  tile; //frame buffer tile val
S    int         fb_idx;
S    uint32_t    _tick_isr_cam;                    //tile cam tick
S    uint32_t    _tick_isr_tile;                   //tile isr tick
S    int         _tick_isr_time_diff;              //time differential
S    uint32_t    _tick_fdr_str;                   //fdfr str tick
S    uint8_t     _tile_value_mean;
S    uint32_t    _tick_value_mean;                //
S
S};
N#endif
Ntypedef int (*fb_write_done_notify)(int cam_idx, int write_idx);
N
Nint kdp_fb_mgr_init(int cam_idx, uint32_t buf_size, int buf_num);
N
Nuint32_t kdp_fb_mgr_next_write(int cam_idx, int *write_idx);
N
Nint kdp_fb_mgr_write_done(int cam_idx, int write_idx, unsigned char *tile_val);
N
Nuint32_t kdp_fb_mgr_buffer_write_next(int cam_idx, int* write_idx, unsigned char *tile_val);
N
Nvoid kdp_fb_mgr_free_write_buf(int cam_idx);
N
Nuint32_t kdp_fb_mgr_get_buf(int cam_idx, int idx);
N
Nuint32_t kdp_fb_mgr_get_buf_seq_num(int cam_idx, int idx);
N
Nuint32_t kdp_fb_mgr_get_current_buf_seq_num(int cam_idx);
N
Nvoid kdp_fb_mgr_get_latest_frame_info(int cam_idx, struct frame_info *info);
N
Nvoid kdp_fb_mgr_set_frame_info(int cam_idx, struct frame_info *info);
N
N#if (FB_TILE_RECODE == YES)
X#if ((0) == 1)
S
Svoid kdp_fb_mgr_set_frame_record_rst(int cam_idx);
S
Svoid kdp_fb_mgr_set_frame_record_cam_isr_tick(int cam_idx, int idx, uint32_t tick);
S
Svoid kdp_fb_mgr_set_tile_value_mean_tick(int cam_idx, u8 tile_value);
S
Sbool kdp_fb_mgr_tile_delay(int cam_idx, int idx);
S
Svoid kdp_fb_mgr_set_frame_record_cam_isr_tile(int cam_idx, uint32_t tick, struct frame_info *info);
S
Svoid kdp_fb_mgr_get_frame_record_info(int cam_idx, int idx, struct frame_record_info *info);
S
N#endif
N
Nuint32_t kdp_fb_mgr_next_read(int cam_idx, int *read_idx);
N
Nvoid kdp_fb_mgr_free_read_buf(int cam_idx);
N
Nuint32_t kdp_fb_mgr_next_aec(int cam_idx, int *aec_idx);    //for aec
N
Nvoid kdp_fb_mgr_free_aec_buf(int cam_idx);                  //for aec
N
Nuint32_t kdp_fb_mgr_next_inf(int cam_idx, int *inf_idx);
N
Nint kdp_fb_mgr_inf_done(int cam_idx, int inf_idx);
N
Nvoid kdp_fb_mgr_free_inf_buf(int cam_idx);
N
Nint kdp_fb_mgr_notifier_register(int cam_idx, fb_write_done_notify callback);
N
N#endif // __KDP_FB_MGR_H__
L 9 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_face.h" 2
N#include "kdp_app_db.h"
N#include "kdp_e2e_camera.h"
L 1 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_camera.h" 1
N#ifndef __KDP_E2E_CAMERA_H__
N#define __KDP_E2E_CAMERA_H__
N
N
N#include "board_kl520.h"
N#include "types.h"
N#include "ipc.h"
N#include "kdp_fb_mgr.h"
N#include "kdp_e2e_n1_only.h"
L 1 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_n1_only.h" 1
N#ifndef __KDP_E2E_N1_ONLY_H__
N#define __KDP_E2E_N1_ONLY_H__
N
N#include "kdp_app_fid.h"
N
N#define E2E_N1_ONLY_STRUCTURE_ENABLE        (CFG_E2E_STRUCT_LIGHT)
N#define E2E_N1_TWO_STAGE_LED_MODE           (CFG_E2E_NIR_TWO_STAGE_LIGHT)
N#define E2E_N1_REC_STR_LED_CLOSE_EARLY      (YES)
N#if (CFG_SENSOR_TYPE == SENSOR_TYPE_GC1054_GC1054) || \
N    (CFG_SENSOR_TYPE == SENSOR_TYPE_GC02M1_GC1054) || \
N    (CFG_SENSOR_TYPE == SENSOR_TYPE_OV02B1B_OV02B1B) || \
N    (CFG_SENSOR_TYPE == SENSOR_TYPE_SP2509_SP2509)
X#if (21 == 20) ||     (21 == SENSOR_TYPE_GC02M1_GC1054) ||     (21 == 23) ||     (21 == 21)
N#define E2E_RGB_USE_RAW8                    (YES)
N#else
S#define E2E_RGB_USE_RAW8                    (NO)
N#endif
N
Ns32 kdp_e2e_face_n1_only(void);
Ns32 kdp_e2e_face_n1_only_preproc(void);
Ns32 kdp_e2e_face_n1_only_environmental_adaptation(void);
Ns32 kdp_e2e_face_n1_only_stucture_light_live(void);
Ns32 kdp_e2e_face_n1_only_liveness(void);
Ns32 kdp_e2e_face_n1_only_invalid_score(int *lp_updated_e2e_ret);
N#if (E2E_N1_ONLY_STRUCTURE_ENABLE == YES)
X#if ((0) == 1)
Ss32 kdp_e2e_n1_only_ir_st_diff_same_id_compare(void);
N#endif
N
N#endif
L 10 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_camera.h" 2
N
N#define AEC_MULTI_THREAD            (NO)  //       Multithreading
N
N#if (IMGSRC_0_TYPE == SENSOR_TYPE_SC132GS) || (IMGSRC_1_TYPE == SENSOR_TYPE_SC132GS)
X#if (8 == 4) || (9 == 4)
S#define MAX_DEFAULT_NIR_EXP_TIME    (26864)
S#define NIR_DEFAULT_GAIN            (3.0f)
S#define NIR_DEFAULT_FPS             (40)
S#define MIN_DEFAULT_NIR_EXP_TIME    (256)
S#define MAX_GAIN                    (15.0f)
S#define MIN_GAIN                    (1.0f)
S#define NIR_LED_WAIT_FRAME          (4)
S#define RGB_LED_WAIT_FRAME          (4)
S#elif (IMGSRC_0_TYPE == SENSOR_TYPE_SC035HGS) || (IMGSRC_1_TYPE == SENSOR_TYPE_SC035HGS)
X#elif (8 == 5) || (9 == 5)
S#define MAX_DEFAULT_NIR_EXP_TIME    (34500)
S#define NIR_DEFAULT_GAIN            (4.0f)
S#define NIR_DEFAULT_FPS             (20)
S#define MIN_DEFAULT_NIR_EXP_TIME    (256)
S#define MAX_GAIN                    (15.0f)
S#define MIN_GAIN                    (1.0f)
S#define NIR_LED_WAIT_FRAME          (4)
S#define RGB_LED_WAIT_FRAME          (4)
S#elif (IMGSRC_1_TYPE == SENSOR_TYPE_GC1054_R) || (IMGSRC_1_TYPE == SENSOR_TYPE_GC1054_L) || (IMGSRC_0_TYPE == SENSOR_TYPE_GC1054_R) || (IMGSRC_0_TYPE == SENSOR_TYPE_GC1054_L)
X#elif (9 == 6) || (9 == 7) || (8 == 6) || (8 == 7)
S#define MAX_DEFAULT_NIR_EXP_TIME    (678)
S#define MIN_DEFAULT_NIR_EXP_TIME    (30)
S#define NIR_DEFAULT_GAIN            (500.0f)
S#define NIR_DEFAULT_FPS             (30)
S#define MAX_GAIN                    (2084.0f)
S#define MIN_GAIN                    (67.0f)
S#define NIR_LED_WAIT_FRAME          (3)
S#define RGB_LED_WAIT_FRAME          (3)
S#elif (IMGSRC_0_TYPE == SENSOR_TYPE_OV02B1B_R) || (IMGSRC_1_TYPE == SENSOR_TYPE_OV02B1B_L)
X#elif (8 == 13) || (9 == 14)
S#define MAX_DEFAULT_NIR_EXP_TIME    (1800)
S#define MIN_DEFAULT_NIR_EXP_TIME    (10)
S#define NIR_DEFAULT_GAIN            (100.0f)
S#define NIR_DEFAULT_FPS             (25)
S#define MAX_GAIN                    (250.0f)    //for face
S#define MIN_GAIN                    (15.0f)
S#define NIR_LED_WAIT_FRAME          (3)
S#define RGB_LED_WAIT_FRAME          (3)
S#if ( CFG_PALM_PRINT_MODE == YES )
S#define PALM_DEFAULT_EXP_TIME       (100)
S#define PALM_DEFAULT_GAIN           (15.0f)     //for palm print
S#define PALM_MAX_GAIN               (35.0f)     //for palm print
S#endif
N#elif (IMGSRC_0_TYPE == SENSOR_TYPE_SP2509_R) || (IMGSRC_1_TYPE == SENSOR_TYPE_SP2509_L)
X#elif (8 == 8) || (9 == 9)
N#define MAX_DEFAULT_NIR_EXP_TIME    (430)
N#define MIN_DEFAULT_NIR_EXP_TIME    (2)
N#define NIR_DEFAULT_GAIN            (100.0f)
N#define NIR_DEFAULT_FPS             (30)
N#define MAX_GAIN                    (220.0f)
N#define MIN_GAIN                    (15.0f)
N#define NIR_LED_WAIT_FRAME          (3)
N#define RGB_LED_WAIT_FRAME          (3)
N#else
S#define MAX_DEFAULT_NIR_EXP_TIME    (26864)
S#define NIR_DEFAULT_GAIN            (3.0f)
S#define NIR_DEFAULT_FPS             (40)
S#define MIN_DEFAULT_NIR_EXP_TIME    (256)
S#define MAX_GAIN                    (15.0f)
S#define MIN_GAIN                    (1.0f)
S#define NIR_LED_WAIT_FRAME          (4)
S#define RGB_LED_WAIT_FRAME          (4)
N#endif
N
N#if ( CFG_PALM_PRINT_MODE == YES )
X#if ( CFG_PALM_PRINT_MODE == 1 )
S#define BRIGHTNESS_TARGET           ( 150 )
S#define BRIGHTNESS_TARGET_RANGE     ( 10 )
N#endif
N
N#if (CFG_SENSOR_0_TYPE == SENSOR_TYPE_GC02M1_R || CFG_SENSOR_0_TYPE == SENSOR_TYPE_GC02M1_L) || \
N    (CFG_SENSOR_1_TYPE == SENSOR_TYPE_GC02M1_R || CFG_SENSOR_1_TYPE == SENSOR_TYPE_GC02M1_L) || \
N    (CFG_SENSOR_TYPE == SENSOR_TYPE_GC2145_GC1054)
X#if (8 == SENSOR_TYPE_GC02M1_R || 8 == SENSOR_TYPE_GC02M1_L) ||     (9 == SENSOR_TYPE_GC02M1_R || 9 == SENSOR_TYPE_GC02M1_L) ||     (21 == SENSOR_TYPE_GC2145_GC1054)
S#define MAX_DEFAULT_RGB_EXP_TIME    (638)
S#define RGB_DEFAULT_GAIN            (500.0f)
S#define RGB_DEFAULT_FPS             (30)
S#define MIN_DEFAULT_RGB_EXP_TIME    (20)
S#define MAX_RGB_GAIN                (1000.0f)
S#define MIN_RGB_GAIN                (67.0f)
S#define RGB_CATEYE_WAIT_FRAME          (4)
N#endif
N
N#if (E2E_N1_ONLY_STRUCTURE_ENABLE == YES)
X#if ((0) == 1)
S    #define STR_550A                    (YES)
S    #if (STR_550A == YES)
S    #define MAX_STR_EXP_TIME            (10800)
S    #else
S    #define MAX_STR_EXP_TIME            (3230)    
S    #endif
N#else
N    #define MAX_STR_EXP_TIME            (MAX_DEFAULT_NIR_EXP_TIME)
N#endif
N#define RGB_LED_DEFAULT_DIM_ENV_STRENGTH  (CFG_E2E_RGB_LED_DEFAULT_DIM_ENV_STRENGTH)
N#define RGB_LED_DEFAULT_DARK_ENV_STRENGTH       (CFG_E2E_RGB_LED_DEFAULT_DARK_ENV_STRENGTH)
N#define DEFAULT_RGB_LED_STRENGTH    (CFG_E2E_RGB_LED_STRENGTH)
N#define DEFAULT_NIR_LED_STRENGTH    (CFG_E2E_NIR_LED_STRENGTH)
N
Ntypedef enum CAM_IMAGE_STATE_e
N{
N    CAM_IMAGE_STATE_NULL = 0,
N    CAM_IMAGE_STATE_ISR,
N    CAM_IMAGE_STATE_RUN,  
N} cam_image_state;
N
N
Nvoid an_nir_gain_setting(float *nir_gain);
Nvoid an_rgb_gain_setting(float *rgb_gain);
N
Ns32 nir_continuous_gain_tune(int WIDTH, uint8_t *Img, int lm_type, int aec_type);
N
Nvoid nir_waiting_led_gain_ready(int WIDTH, uint8_t *Img);
N
Nvoid nir_reduce_exposure(int WIDTH, uint8_t *Img);
N    
Nvoid nir_predict_gain_led_instantly(int WIDTH, uint8_t *Img, float *nir_gain, int eye_range);
N
Nvoid Surrond(int WIDTH, uint8_t *Img, u8 tile_env);
N
Nvoid camera_sensor_rst(void);
N
Nbool nir_sensor_delay_fdfr(void);
X_Bool nir_sensor_delay_fdfr(void);
Nvoid nir_sensor_wait_effect(void);
Nvoid nir_sensor_rst(u8 wait_cnt);
N
N#define DUAL_IDENTICAL_CAM_CLOSED    0
N#define DUAL_IDENTICAL_CAM_INITED    1
N#define DUAL_IDENTICAL_CAM_AEC       2
N#define DUAL_IDENTICAL_CAM_RUN       3
N#define DUAL_IDENTICAL_CAM_SLEEP     4
N
N#if CFG_ONE_SHOT_MODE == YES
X#if 1 == 1
Ns32 kdp_e2e_set_dual_cam_state(u8 cam_sts);
Nu8  kdp_e2e_get_dual_cam_state(void);
N#else
S#define kdp_e2e_set_dual_cam_state(cam_sts) //
S#define kdp_e2e_get_dual_cam_state(void) //
N#endif
N
Nbool rgb_sensor_delay_fdfr(void);
X_Bool rgb_sensor_delay_fdfr(void);
Nvoid rgb_sensor_wait_effect(void);
Nvoid rgb_sensor_rst(u8 wait_cnt);
N
Nu32 kdp_e2e_rgb_aec_clip_bound(void);
Nfloat kdp_e2e_rgb_gain_clip_bound(void);
N
Nu32 kdp_e2e_nir_aec_clip_bound(void);
Nfloat kdp_e2e_nir_gain_clip_bound(void);
N
Nu32 kdp_e2e_str_aec_clip_bound(void);
Nfloat kdp_e2e_str_gain_clip_bound(void);
N
N
N//bool kdp_e2e_cam_delay_fdfr(u8 cam_idx);
N//void kdp_e2e_cam_wait_effect(u8 cam_idx);
N//void kdp_e2e_cam_rst(u8 cam_idx, u8 wait_cnt);
N
N#if ((CFG_AI_TYPE == AI_TYPE_N1)|| (CFG_AI_TYPE == AI_TYPE_N1R1))
X#if ((3 == 2)|| (3 == 3))
Nvoid nir_aec_tune_for_fd_search(void);
Ns32 nir_only_surrond(int nir_width, uint8_t *Img, u8 tile_env);
N#endif
N
N#if ( CFG_PALM_PRINT_MODE == YES )
X#if ( CFG_PALM_PRINT_MODE == 1 )
Ss32 nir_palm_print_continuous_aec(int nir_width, uint8_t *Img, u8 tile_env);
N#endif
N
N#if (AEC_MULTI_THREAD == YES)
X#if ((0) == 1)
Ss32 kdp_e2e_n1_cam_block_check(e2e_nir_cam_params* nir_cam_param, struct frame_info* info);
Svoid kdp_e2e_n1_led_off_proc(e2e_nir_cam_params* nir_cam_params, struct frame_info* info);
Svoid kdp_e2e_n1_led_on_preproc(e2e_nir_cam_params* nir_cam_params, struct frame_info* info);
Svoid n1_aec_fd_search(e2e_nir_cam_params* nir_cam_params, struct frame_info* info);
Svoid lock_vars_n1_aec(e2e_nir_cam_params* nir_cam_params);
Svoid unlock_vars_n1_aec(e2e_nir_cam_params* nir_cam_params);
Svoid kdp_nir_aec_thread(u32 buf_addr);
Svoid kdp_rgb_aec_thread(u32 buf_addr);
Svoid lock_vars_r1_aec(e2e_rgb_cam_params* rgb_cam_params);
Svoid unlock_vars_r1_aec(e2e_rgb_cam_params* rgb_cam_params);
Svoid get_r1_face_region_luma(int32_t WIDTH, uint16_t *pImageRgb, struct landmark_result_s *rgb_p_lm, u8 *Y_left, u8 *Y_right, u8 *back_light_flag);
N#else
Nvoid kdp_e2e_camera_r1_set_aec_roi_preproc(void);
Nvoid kdp_e2e_camera_r1_set_aec_roi(struct facedet_result_s *r1_fd);
Nvoid kdp_e2e_camera_r1_get_lux(u16 *lp_rgb_exp_time, u8 *lp_rgb_dark_mode);
N#endif
N
Nvoid aec_e2e_multiply_factor_set(float luma_target, float luma_curr);
Nvoid kdp_e2e_camera_r1_set_aec_roi_n1r1(struct facedet_result_s *r1_fd);
Nvoid kdp_e2e_camera_r1_set_aec_roi_from_nir(struct facedet_result_s *n1_fd, struct landmark_result_s *n1_lm);
N
Nvoid kdp_e2e_aec_rgb_sync_to_nir_aec(void);
Nvoid cateye_rgb_aec_process(int nir_width, uint8_t *nir_img, struct facedet_result_s *fd, u8 luma_tgt);
Nu8 luma_avg_roi(int nir_width, uint8_t *nir_img, struct facedet_result_s *fd);
N#endif
N
N
N#if (AEC_MULTI_THREAD == YES)
X#if ((0) == 1)
Stypedef struct kl520_camera_param_rgb_struct
S{
S    u8 status;
S    u16 rgb_init_exp_time;
S    u16 rgb_cur_exp_time;
S    u8  rgb_dark_mode;
S    u8 rgb_dark_mode_cnt; // maximum is 5
S    u8 rgb_led_flag;
S    u8 rgb_led_cur_strength;
S    u16 rgb_led_special_cnt; // maximum unsure
S    u8 rgb_lm_motion_cnt; // maximum is 5
S    u8 rgb_dark_env_history_flag;
S    u8 rgb_lv_back_light_cnt;
S    bool rgb_lv_back_light;
S    u8 rgb_face_quality;
S    u8 rgb_corner_y;
S    bool rgb_led_lv_history_flag;
S    u8 step_cnt_rgb_wait_effect;
S    u8 rgb_face_l_luma;
S    u8 rgb_face_r_luma;
S    u8 pre_gain;
S    u8 post_gain;
S    u8 global_gain;
S    u8 y_average;
S    u8 rgb_avg_luma;
S    bool rgb_roi_set;
S    u8 led_breathe_en;
S    bool is_lock; 
S}e2e_rgb_cam_params;
S
Stypedef struct kl520_camera_param_nir_struct
S{
S    u8 status;
S    u16 nir_cur_exp_time;
S    u8 nir_mode;
S    //u8 nir_mode;
S    u8 nir_mode_cnt; // reserved
S    u8 nir_led_flag;
S    u8 nir_led_cur_strength;
S    u8 nir_led_special_cnt; // reserved
S    u8 nir_sensor_setting_cnt;
S    u8 step_cnt_wait_led_gain;
S    u8 nir_sensor_search_cnt;
S    float nir_gain;
S    float init_nir_gain;
S    u8 nir_led_status;
S    u8 nir_skin_luma;
S    u8 nir_env_exception_cnt;
S    bool is_lock; 
S}e2e_nir_cam_params;
N#endif
L 11 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_face.h" 2
N#include "kdp_e2e_prop.h"
L 1 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_prop.h" 1
N#ifndef __KDP_E2E_PROP_H__
N#define __KDP_E2E_PROP_H__
N
N#include "types.h"
N#include "ipc.h"
N
N#define E2E_FD_CHK_SMALL_WIDTH_DEF      (70)    // (112)
N#define E2E_FD_CHK_SMALL_HEIGHT_DEF     (70)    // (112)
N#define E2E_R1_LM_CHK_LOW_CONFIDENT_DEF (0.800)
N#define E2E_R1_LM_CHK_BLUR_DEF          (0.0078125)//(1.0/128)
N#define E2E_N1_LM_CHK_LOW_CONFIDENT_DEF (0.000)  
N#define E2E_N1_LM_CHK_BLUR_DEF          (0.0078125)//(1.0/128)
N#define E2E_DB_DYNAMIC_THRESHOLD_DEF    (0.77f)
N#define E2E_DB_DYNAMIC_THRESHOLD_REMOTE (0.95f)
N#define E2E_DB_R1_WEIGHT_DEF            (0.5)
N#define E2E_DB_PALM_THRESHOLD_DEF       (0.77f)
N
N#define E2E_RGB_NIR_LM_DIFF_THRESHOLD   (30)
N
N#define E2E_DB_THRESHOLD_FID_DEF        (E2E_DB_DYNAMIC_THRESHOLD_DEF - 0.0f)
N#define E2E_DB_THRESHOLD_FID_SELF_DEF   (0.9f)
N#define E2E_DB_THRESHOLD_AGE_DIFF       (0.015f)
N
N#define E2E_N1_LM_RECOG_THRESH_INDOOR   (0.6f)  
N#define E2E_N1_LM_RECOG_THRESH_OUTDOOR  (0.1f)  
N
N#define E2E_NIR_LV_THRESHOLD            (0.8f)
N#define E2E_RGB_LV_THRESHOLD            (0.1f)
N#define E2E_FUSE_LV_THRESHOLD           (0.5f)
N#define E2E_OCCLUSION_THRESHOLD         (0.6f)
N
Ntypedef enum kdp_e2e_prop_attribute_enum {
N    PROP_ATTRIBUTE_AUTO = 0,
N    PROP_ATTRIBUTE_MANUAL,
N} kdp_e2e_prop_attribute;
N
N#define KDP_E2E_PROP_STRUCT(__type) \
Ntypedef struct s_kdp_e2e_prop_value_##__type {  \
N    BOOL adopted;                               \
N    kdp_e2e_prop_attribute attr;                \
N    __type value;                               \
N    const __type default_val;                   \
N} kdp_e2e_prop_value_##__type
X#define KDP_E2E_PROP_STRUCT(__type) typedef struct s_kdp_e2e_prop_value_##__type {      BOOL adopted;                                   kdp_e2e_prop_attribute attr;                    __type value;                                   const __type default_val;                   } kdp_e2e_prop_value_##__type
N
NKDP_E2E_PROP_STRUCT(s32);
Xtypedef struct s_kdp_e2e_prop_value_s32 { BOOL adopted; kdp_e2e_prop_attribute attr; s32 value; const s32 default_val; } kdp_e2e_prop_value_s32;
NKDP_E2E_PROP_STRUCT(float);
Xtypedef struct s_kdp_e2e_prop_value_float { BOOL adopted; kdp_e2e_prop_attribute attr; float value; const float default_val; } kdp_e2e_prop_value_float;
N
Ntypedef struct kdp_e2e_prop_pt_struct
N{
N    u32 x;
N    u32 y;
N} kdp_e2e_prop_pt;
N
Ntypedef struct kdp_e2e_prop_rect_struct
N{
N    unsigned short start_x;
N    unsigned short start_y;
N    unsigned short end_x;
N    unsigned short end_y;
N} kdp_e2e_prop_rect;
N
Ntypedef struct kdp_e2e_prop_struct {
N    BOOL liveness_en;
N    BOOL motion_detect_en;
N    BOOL nose_lm_diff_en;
N    s32 check_bad_pose;
N    BOOL nir_aec_continuous_tune_en;
N    BOOL rgb_led_when_reg_en;
N    BOOL face_check_movement_en;
N    BOOL face_check_position;
N    u32 flow_mode;
N    u32 face_mode;
N    kdp_e2e_prop_value_s32 fd_chk_small_width;
N    kdp_e2e_prop_value_s32 fd_chk_small_height;
N    kdp_e2e_prop_value_float r1_lm_chk_low_confident;
N    kdp_e2e_prop_value_float r1_lm_chk_blur;
N    kdp_e2e_prop_value_float n1_lm_chk_low_confident;
N    kdp_e2e_prop_value_float n1_lm_chk_blur;
N    kdp_e2e_prop_value_float dynamic_threshold;
N    kdp_e2e_prop_value_float r1_weight;
N    kdp_e2e_prop_value_float db_threshold_normal;
N    kdp_e2e_prop_value_float db_threshold_self;
N    kdp_e2e_prop_value_float db_threshold_age_diff;
N    kdp_e2e_prop_value_float db_threshold_remote;    
N    kdp_e2e_prop_value_float nir_lv_threshold;
N    kdp_e2e_prop_value_float rgb_lv_threshold;
N    kdp_e2e_prop_value_float fuse_lv_threshold;
N    kdp_e2e_prop_value_float n1_occlusion_threshold;
N    kdp_e2e_prop_value_s32 rgb_nir_lm_diff_threshold;
N    s32 dst_win_width;
N    s32 dst_win_height;
N    s32 r1_offset_x;
N    s32 r1_offset_y;
N    s32 n1_dst_win_width;
N    s32 n1_dst_win_height;
N    s32 n1_offset_x;
N    s32 n1_offset_y;
N    s32 bbox_tolerance_lines;
N    
N    s32 invalid_score_min;
N    s32 invalid_score_max;
N    s16 rgb_led_enhance_cnt;
N    s8  rgb_led_enhance_step;
N    s8  rgb_led_enhance_min;
N    s8  rgb_led_enhance_max;
N
N    kdp_e2e_prop_rect r1_rc;
N    kdp_e2e_prop_rect n1_rc;
N    kdp_e2e_prop_pt r1_pt_array[LAND_MARK_POINTS];
X    kdp_e2e_prop_pt r1_pt_array[5];
N    kdp_e2e_prop_pt n1_pt_array[LAND_MARK_POINTS];
X    kdp_e2e_prop_pt n1_pt_array[5];
N    kdp_e2e_prop_value_s32 r1_led_value;
N    BOOL age_group_en;
N
N} kdp_e2e_prop;
N
N
Nkdp_e2e_prop* kdp_e2e_prop_get_inst(void);
Nvoid kdp_e2e_prop_init(void);
Nvoid kdp_e2e_prop_enable_liveness(BOOL enable);
Nvoid kdp_e2e_prop_update_db_comp_params(void);
Nvoid kdp_e2e_prop_r1_update_rect(int x, int y, int w, int h);
Nvoid kdp_e2e_prop_n1_update_rect(int x, int y, int w, int h);
Nvoid kdp_e2e_prop_r1_update_pt_array(u32 *pt_array);
Nvoid kdp_e2e_prop_n1_update_pt_array(u32 *pt_array);
N
N#define KDP_E2E_PROP_DECLARE(__member) void kdp_e2e_prop_reset_##__member(void)
NKDP_E2E_PROP_DECLARE(r1_led_value);
Xvoid kdp_e2e_prop_reset_r1_led_value(void);
N
N#define kdp_e2e_prop_reset_value(p, arg) { p->arg.adopted = FALSE; p->arg.attr = PROP_ATTRIBUTE_AUTO; p->arg.value = p->arg.default_val; } 
N#define kdp_e2e_prop_get(p, arg) p->arg
N#define kdp_e2e_prop_set(p, arg, __val) p->arg = __val
N#define kdp_e2e_prop_get_value(p, arg) p->arg.value
N#define kdp_e2e_prop_set_manual_value(p, arg, __val) { \
N    p->arg.attr = PROP_ATTRIBUTE_MANUAL; \
N    if (p->arg.value != __val) { p->arg.adopted = FALSE; p->arg.value = __val; } }
X#define kdp_e2e_prop_set_manual_value(p, arg, __val) {     p->arg.attr = PROP_ATTRIBUTE_MANUAL;     if (p->arg.value != __val) { p->arg.adopted = FALSE; p->arg.value = __val; } }
N#define kdp_e2e_prop_set_auto_value(p, arg, __val) { \
N    if ((p->arg.value != __val) && (PROP_ATTRIBUTE_AUTO == p->arg.attr)) \
N        { p->arg.adopted = FALSE; p->arg.value = __val; } }
X#define kdp_e2e_prop_set_auto_value(p, arg, __val) {     if ((p->arg.value != __val) && (PROP_ATTRIBUTE_AUTO == p->arg.attr))         { p->arg.adopted = FALSE; p->arg.value = __val; } }
N
N#define kdp_e2e_prop_set_adopted(p, arg) p->arg.adopted = TRUE
N#define kdp_e2e_prop_is_adopted(p, arg) (p->arg.adopted == TRUE)
N#define kdp_e2e_prop_is_manual(p, arg) (PROP_ATTRIBUTE_MANUAL == p->arg.attr)
N#define kdp_e2e_prop_set_auto(p, arg) p->arg.attr = PROP_ATTRIBUTE_AUTO
N
N#define kdp_e2e_prop_get2(arg) kdp_e2e_prop_get_inst()->arg
N#define kdp_e2e_prop_set2(arg, __val) kdp_e2e_prop_get_inst()->arg = __val
N#define kdp_e2e_prop_get2_value(arg) (kdp_e2e_prop_get_inst()->arg.value)
N
N
N#endif
L 12 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_face.h" 2
N
N#define KDP_E2E_IMG_SRC_MAX 2
N#define KDP_E2E_IMG_SRC_RGB MIPI_CAM_RGB
N#define KDP_E2E_IMG_SRC_NIR MIPI_CAM_NIR
N#define KDP_E2E_IMG_SRC_LV  KDP_E2E_IMG_SRC_MAX
N#ifndef CFG_RGB_CV_LIVENESS
S#define CFG_RGB_CV_LIVENESS      (YES)
N#endif
N
N#define KDP_E2E_IMAGE_FORMAT_RGB565     (IMAGE_FORMAT_SUB128 | NPU_FORMAT_RGB565)
N#define KDP_E2E_IMAGE_FORMAT_RAW8       (IMAGE_FORMAT_SUB128 | NPU_FORMAT_NIR)
N#define KDP_E2E_IMAGE_FORMAT_LV_NCPU    (KDP_E2E_IMAGE_FORMAT_RAW8 | IMAGE_FORMAT_BYPASS_NPU_OP)
N
N#define E2E_CHK_BREAK(func)     { ret = (func); if (E2E_OK != ret) break; }
N#define FR_LATER                (YES)
N#define USE_R1_FD_POSTPROC      (YES)
N#define USE_R1_LM_POSTPROC      (YES)
N#define USE_N1_FD_POSTPROC      (NO)
N#define USE_N1_LM_POSTPROC      (YES)
N
N#if (CFG_CAMERA_DUAL_1054 == YES)
X#if (1 == 1)
N#define USE_RGB_FR_IN_1054      (YES)
N#else
S#define USE_RGB_FR_IN_1054      (NO)
N#endif
N
N#define USE_LM_MOTION_DETECT    (YES)
N#define USE_NOSE_LM_DIFF        (YES)
N#define USE_AGE_GROUP           (NO)
N#define USE_CHK_BAD_POSE        (YES)
N#define RGB_LED_WHEN_REG        (NO)
N#define CONTINUE_NIR_AEC        (YES)
N#define USE_CHK_R1_MASK         (YES)
N#define USE_LM_SECONDARY        (NO)
N#define USE_EYE_LID_LM          (YES)
N#define USE_RGB_LED_SHORTEN     (YES)
N#define USE_NIR_LED_SHORTEN_RECOG (NO)
N#define LED_OPEN_MEASUREMENT    (NO)
N#define USE_CHK_IOU             (NO)
N#define NIR_OCCULDE_ENABLE      (NO)
N#define NIR_FACE_SEG_ENABLE     (YES)
N#ifndef USE_FACE_QUALITY
S#define USE_FACE_QUALITY        (NO)
N#endif
N#define RGB_FACE_QUALITY_TH_NORMAL      0.5f
N#define RGB_FACE_QUALITY_TH_OTHER       0.1f
N
N#define NIR_FACE_QUALITY_TH_NORMAL      0.2f
N#define NIR_FACE_QUALITY_TH_OTHER       0.05f
N
N#if (CFG_CAMERA_DUAL_1054 == YES || CFG_CAMERA_SINGLE_1054 == YES)
X#if (1 == 1 || CFG_CAMERA_SINGLE_1054 == 1)
N#define USE_RECOG_FR_UPDATE     (NO)
N#else
S#define USE_RECOG_FR_UPDATE     (YES)
N#endif
N
N#define FACE_RECOG_LED_OPEN_NO_FD  (YES)
N
N#if (CFG_CAMERA_DUAL_1054 == YES || CFG_CAMERA_SINGLE_1054 == YES)
X#if (1 == 1 || CFG_CAMERA_SINGLE_1054 == 1)
N#define USE_FR_FACE_FLIP           (NO)
N#else
S#define USE_FR_FACE_FLIP           (YES)
N#endif
N
N#define NIR_LM_SCORE_FILTER
N#define DUAL_FR_DIFF            (YES)
N#define TMP_LM_LIST_SIZE        5
N#define FD_CROP_MODE_NUM        3
N
Ntypedef enum kdp_e2e_nir_fd_mode_enum
N{
N    FD_NIR_IMG_SIZE_MODE = 0,
N    FD_NIR_CROP_MODE,
N    
N} nir_fd_mode;
N
Ntypedef enum kdp_e2e_rgb_fd_mode_enum
N{
N    FD_RGB_NN = 0,
N    FD_RGB_MAPPING,
N    
N} rgb_fd_mode;
N
Ntypedef enum kdp_e2e_nir_led_mode_enum
N{
N    IR_LIGHT = 0,
N    STR_LIGHT,
N    IR_LIGHT_FLASH,
N    NO_LED,
N} nir_led_mode;
N
Ntypedef enum kdp_e2e_nir_aec_enum
N{
N    GAIN_AEC_T = 0,
N    EXP_AEC_T,
N
N} kdp_nir_aec;
N
Ntypedef enum kdp_e2e_rgb_nir_lm_enum
N{
N    RGB_LM_T = 0,
N    NIR_LM_T,
N
N} kdp_rgb_nir_lm;
N
Ntypedef enum kdp_e2e_nir_mode_enum
N{
N    IR_FEW = 0,
N    IR_INFRONT,
N    IR_BACKLIGHT,
N#if CFG_NIR_MODE2_SPLIT == YES
X#if 1 == 1
N    IR_BACKLIGHT_EX,
N#else
S    IR_WINDOW_SIDELIGHT,
N#endif
N    IR_LOTS,
N
N} kdp_nir_mode;
N
Ntypedef enum kdp_e2e_nir_init_flag_enum
N{
N    AEC_STABLE = 0,
N    AEC_PROBE_SURROND,
N    AEC_WATI_EXP_REDUCE,
N    AEC_WAIT_LED_GAIN,
N    AEC_LED_OFF_STATUS,
N    AEC_LED_ON_PREPROC_STATUS,
N    AEC_LED_ON_FACE_FAIL_TUNE,
N    AEC_FACE_STABLE,
N    AEC_SEARCH_FACE_MODE,
N
N} kdp_nir_init_flag;
N
Ntypedef enum kdp_e2e_flow_mode_enum
N{
N    FLOW_MODE_NORMAL = 0,
N    FLOW_MODE_SIM_VIRTUAL,
N    FLOW_MODE_SIM_MODELS,
N    FLOW_MODE_SIM_COMP_R1N1,
N    FLOW_MODE_SIM_PRE_ADD,
N    FLOW_MODE_SIM_COMP_R1,
N
N} kdp_e2e_flow_mode;
N
Ntypedef enum kdp_e2e_face_mode_enum
N{
N    FACE_MODE_NONE = 0,
N    FACE_MODE_ADD,
N    FACE_MODE_RECOGNITION,
N    FACE_MODE_LIVENESS,
N    FACE_MODE_RECOGNITION_TEST,
N    FACE_MODE_COMPARE_1VS1,
N    FACE_MODE_ENG_CAL,
N    FACE_MODE_SNAP_IMG,
N    FACE_MODE_BUSY
N} kdp_e2e_face_mode;
N
N
N//typedef struct kl520_camera_param_rgb_struct
N//{
N//    u16 rgb_init_exp_time;
N//    u16 rgb_cur_exp_time;
N//    u8  rgb_dark_mode;
N//    u8 rgb_dark_mode_cnt; // maximum is 5
N//    u8 rgb_led_flag;
N//    u8 rgb_led_cur_strength;
N//    u16 rgb_led_special_cnt; // maximum unsure
N//    u8 rgb_lm_motion_cnt; // maximum is 5
N//    u8 rgb_dark_env_history_flag;
N//    u8 rgb_lv_back_light_cnt;
N//    bool rgb_lv_back_light;
N//    u8 rgb_face_quality;
N//    u8 rgb_corner_y;
N//    bool rgb_led_lv_history_flag;
N//    u8 step_cnt_rgb_wait_effect;
N//    u8 rgb_face_l_luma;
N//    u8 rgb_face_r_luma;
N//    u8 pre_gain;
N//    u8 post_gain;
N//    u8 global_gain;
N//    u8 y_average;
N//    u8 rgb_avg_luma;
N//    bool rgb_roi_set;
N//    u8 led_breathe_en;
N//}e2e_rgb_cam_params;
N
N//typedef struct kl520_camera_param_nir_struct
N//{
N//    u8 status;
N//    u16 nir_cur_exp_time;
N//    u8 nir_mode;
N//    //u8 nir_mode;
N//    u8 nir_mode_cnt; // reserved
N//    u8 nir_led_flag;
N//    u8 nir_led_cur_strength;
N//    u8 nir_led_special_cnt; // reserved
N//    u8 nir_sensor_setting_cnt;
N//    u8 step_cnt_wait_led_gain;
N//    u8 nir_sensor_search_cnt;
N//    float nir_gain;
N//    float init_nir_gain;
N//    u8 nir_led_status;
N//    u8 nir_skin_luma;
N//    u8 nir_env_exception_cnt;
N//    
N//}e2e_nir_cam_params;
N
N
Ntypedef struct kdp_e2e_face_variables_struct {
N    u8 pre_add;            //Fixed 1bytes
N
N    struct frame_info info;
N    s32 buf_idx[2];
N    u32 user_id;
N    char user_name[MAX_LEN_USERNAME];
X    char user_name[(32)];
N    u8 admin;
N
N    kdp_nir_init_flag init_tile_flag;
N    u8 init_tile;
N    u8 init_exp_tile;
N    float target_tile_max;
N
N    /* These variables will be collected as sub-structures classified as camera sensor related */
N    u16 rgb_init_exp_time;
N    u16 rgb_cur_exp_time;
N    u8 rgb_dark_mode;
N    u8 rgb_dark_mode_cnt; // maximum is 5
N    u8 rgb_led_flag;
N    u8 rgb_led_cur_strength;
N    u16 rgb_led_special_cnt; // maximum unsure
N    u8 rgb_lm_motion_cnt; // maximum is 5
N    u8 rgb_dark_env_history_flag;
N    u8 rgb_lv_back_light_cnt;
N    bool rgb_lv_back_light;
X    _Bool rgb_lv_back_light;
N    u8 rgb_face_quality;
N    u8 rgb_corner_y;
N    bool rgb_led_lv_history_flag;
X    _Bool rgb_led_lv_history_flag;
N    u8 step_cnt_rgb_wait_effect;
N    u8 rgb_face_l_luma;
N    u8 rgb_face_r_luma;
N    u8 pre_gain;
N    u8 post_gain;
N    u8 global_gain;
N    u8 y_average;
N
N    u32 nir_cur_exp_time;
N    kdp_nir_mode nir_mode;
N    //u8 nir_mode;
N    u8 nir_mode_cnt; // reserved
N    u8 nir_led_flag;
N    u8 nir_led_cur_strength;
N    u8 nir_led_special_cnt; // reserved
N    u8 nir_lm_motion_cnt;
N    u8 nir_sensor_setting_cnt;
N    u8 step_cnt_wait_led_gain;
N    u8 nir_face_quality;
N    u16 nir_sensor_search_cnt;
N    float effect_2d;
N    u8 nir_led_on_tile;
N    u8 distance_from_led_on;
N    u8 nir_skin_luma;
N
N    float nir_gain;
N    float init_nir_gain;
N    float nir_lv_cnn_real_score;
N    float nir_lv_cnn_face_real_score;
N    float rgb_lv_cnn_real_score;
N    float fuse_lv_real_score;
N    float nir_lv_cnn_diff;
N    float rgb_lv_cnn_diff;
N    float fuse_lv_diff;
N    float nir_luma_ratio;
N    float nir_lv_hsn_neck_score;
N    float nir_lv_hsn_edge_score;
N    u32 face_nomal_dark_cnt;
N    u32 face_low_score_cnt;
N    s32 lm_diff;
N    float rgb_nir_fr_diff;
N    float *additional_params_0;
N    float *additional_params_1;
N    u8  rgb_age_group;
N    u8  rgb_avg_luma;    
N    float org_rgb_dist;
N    float org_nir_dist;
N    
N    float eye_left_ratio[2];
N    float eye_right_ratio[2];
N    u8 nir_env_exception_cnt;
N    u8 n1r1_sim_status;
N    u8 nir_led_status;
N    u8 ir_led_flow_ready;
N    u8 st_led_flow_ready;
N    u8 rgb_fd_status;
N    
N    u8 rgb_no_fd_nn_cnt;
N    float sl_lv_cnn_real_score;    
N    
N    float id_ref_c;
N    float id_dual_fr_diff;
N
N    bool rgb_roi_set;
X    _Bool rgb_roi_set;
N    u8 led_breathe_en;
N    u8 nir_fd_status;
N    float str_gain;
N    u32 str_exp_time;
N    u8 nir_fd_crop_mode_flag;    //not used any more
N    u8 str_skin_luma;
N    u8 flash_skin_luma;
N    u32 nir_dynamic_max_exp_time;
N    u8 nir_fps;
N
N    u16 rec_cnt;
N    u16 min_fm_num;
N    u16 rec_fm_hist[MAX_FID];
X    u16 rec_fm_hist[(5)];
N
N#if (AEC_MULTI_THREAD == YES) 
X#if ((0) == 1) 
S    e2e_rgb_cam_params rgb_cam_params;
S    e2e_nir_cam_params nir_cam_params;
N#endif
N
N    u8 n1_face_available;
N    u8 r1_face_available;
N
N    float rgb_gain;
N    
N    float fs_feature[17];
N    float darkness;
N    bool n1_inference_ready;
X    _Bool n1_inference_ready;
N    bool r1_inference_ready;
X    _Bool r1_inference_ready;
N    u32  recog_err_not_return;
N    cam_image_state rgb_img_ready;
N    u8   n1_face_nok_cnt;
N    bool occ_for_aec;
X    _Bool occ_for_aec;
N    u8   tile_sat_cnt;
N    u8   rgb_nir_fr_flag;
N    float face_pose_cur_val;
N    float face_pose_best_val;
N    u8   _is_fm_import;
N    u32   norm_variance;
N    u16  n1_fd_x;
N    u16  n1_fd_y;
N    u16  n1_fd_w;
N    u16  n1_fd_h;
N    float lm_length_ratio[5];
N    u8   beard_flag;
N} kdp_e2e_face_variables;
N
Ntypedef struct kdp_e2e_face_model_res_struct {
N    struct facedet_result_s  m_r1_fd __attribute__ ((aligned (16)));
N    struct facedet_result_s  m_r1_fd_aec __attribute__ ((aligned (16)));
N    struct landmark_result_s m_r1_lm __attribute__ ((aligned (16)));
N    struct landmark_result_s m_r1_lm_s __attribute__ ((aligned (16)));
N    struct landmark_result_s m_r1_lm_aec __attribute__ ((aligned (16)));
N    struct fr_result_s       m_r1_fr __attribute__ ((aligned (16)));
N    struct fr_result_s       m_r1_fr_flip __attribute__ ((aligned (16)));
N    struct facedet_result_s  m_n1_fd __attribute__ ((aligned (16)));
N    struct facedet_result_s  m_n1_fd_aec __attribute__ ((aligned (16)));
N    struct landmark_result_s m_n1_lm __attribute__ ((aligned (16)));
N    struct landmark_result_s m_n1_lm_s __attribute__ ((aligned (16)));
N    struct landmark_result_s m_n1_lm_aec __attribute__ ((aligned (16)));
N    struct age_group_result_s m_n1_age_group __attribute__ ((aligned (16)));
N    struct face_quality_result_s m_face_quality_res __attribute__ ((aligned (16)));
N    struct fr_result_s       m_n1_fr __attribute__ ((aligned (16)));
N    struct fr_result_s       m_n1_fr_flip __attribute__ ((aligned (16)));
N#if EYE_LID_2 == NO
X#if EYE_LID_2 == 0
N    struct eye_lid_lm_result_s m_eye_lid_res __attribute__ ((aligned (16)));
N#else
S    struct lv_result_s m_eye_lid_res __attribute__ ((aligned (16)));
N#endif
N    struct face_occlude_result_s m_face_occ_res __attribute__ ((aligned (16)));
N
N#ifdef FDSSD_ONETBLUR_VGG
N    dme_res                  m_od __attribute__ ((aligned (16)));
N#endif
N    struct lv_result_s       m_lv __attribute__ ((aligned (16)));
N	struct dual_landmarks_s  m_dual_lm __attribute__ ((aligned (16)));
N	struct dual_landmarks_s  m_dual_lm_2 __attribute__ ((aligned (16)));
N	struct nir_camera_tune_s m_nir_tune __attribute__ ((aligned (16)));
N} kdp_e2e_face_model_result;
N
N
Nstruct facedet_result_s*    kdp_e2e_get_r1_fd(void);
Nstruct landmark_result_s*   kdp_e2e_get_r1_lm(void);
Nstruct landmark_result_s*   kdp_e2e_get_r1_lm_s(void);
Nstruct fr_result_s*         kdp_e2e_get_r1_fr(void);
N
Nstruct facedet_result_s*    kdp_e2e_get_n1_fd(void);
Nstruct landmark_result_s*   kdp_e2e_get_n1_lm(void);
Nstruct landmark_result_s*   kdp_e2e_get_n1_lm_s(void);
Nstruct fr_result_s*         kdp_e2e_get_n1_fr(void);
N
Nstruct lv_result_s*         kdp_e2e_get_r1n1_lv(void);
Nstruct dual_landmarks_s*    kdp_e2e_get_r1n1_dlm(void);
Nstruct dual_landmarks_s*    kdp_e2e_get_r1n1_dlm_2(void);
Nstruct nir_camera_tune_s*   kdp_e2e_get_r1n1_tune(void);
Nkdp_e2e_face_variables*     kdp_e2e_get_face_variables(void);
Nstruct face_occlude_result_s*    kdp_e2e_get_r1n1_occ(void);
Nstruct face_quality_result_s*      kdp_e2e_get_face_quality(void);
N
Nvoid                        kdp_e2e_rst_r1_fd(void);
Nvoid                        kdp_e2e_rst_r1_lm(void);
Nvoid                        kdp_e2e_rst_r1_fr(void);
Nvoid                        kdp_e2e_rst_n1_fd(void);
Nvoid                        kdp_e2e_rst_n1_lm(void);
Nvoid                        kdp_e2e_rst_n1_fr(void);
N
N
Ns32 kdp_e2e_face_n1_fd_lm_combo(
N    struct kdp_img_cfg *img_cfg,
N    struct facedet_result_s *fd,
N    struct landmark_result_s *lm_out);
N
Nvoid kdp_e2e_face_rst_variables(void);
Nvoid kdp_e2e_face_get_frame_info(int cam_idx, struct frame_info *info);
Nvoid kdp_e2e_face_switch_board_params(int , int );
N///s32 kdp_e2e_face_r1_get_bbox(int *x, int *y, int *w,int *h);
N//s32 kdp_e2e_face_n1_get_bbox(int *x, int *y, int *w,int *h);
Ns32 kdp_e2e_face_init(void);
NBOOL kdp_e2e_face_init_done(void);
Ns32 kdp_e2e_face_r1n1_preproc(void);
Ns32 kdp_e2e_face_n1r1_preproc(void);
N
Ns32 kdp_e2e_face_r1(void);
Ns32 kdp_e2e_face_n1(void);
Ns32 kdp_e2e_face_r1n1_postproc(void);
Ns32 kdp_e2e_face_n1r1_postproc(int flip_face);
Ns32 kdp_e2e_face_r1_only_postproc(void);
Ns32 kdp_e2e_face_n1_only_postproc(void);
Ns32 kdp_e2e_face_cat_eye(void);
N
Ns32 kdp_e2e_palm_preproc(void);
Ns32 kdp_e2e_palm_proc(void);
Ns32 kdp_e2e_palm_post_proc(void);
N
Ns32 kdp_e2e_face_n1_fd_lm(struct kdp_img_cfg *nir_img_cfg, struct facedet_result_s *n1_fd, struct landmark_result_s *n1_lm);
Ns32 kdp_e2e_face_r1_fd_lm(struct kdp_img_cfg *rgb_img_cfg, struct facedet_result_s *r1_fd, struct landmark_result_s *r1_lm);
Ns32 kdp_e2e_face_n1_quality(struct kdp_img_cfg *nir_img_cfg, kdp_e2e_prop* prop, kdp_e2e_face_variables *vars, struct facedet_result_s *n1_fd, struct landmark_result_s *n1_lm, struct landmark_result_s *n1_lm_s);
Ns32 kdp_e2e_face_r1_quality(struct kdp_img_cfg *rgb_img_cfg, kdp_e2e_prop* prop, kdp_e2e_face_variables *vars, struct facedet_result_s *r1_fd, struct landmark_result_s *r1_lm, struct landmark_result_s *r1_lm_s);
Ns32 kdp_e2e_n1_r1_interactive_check(void);
N
N/**
N * @brief To config image setting
N *
N * @param [in] src_index src img index (no need to align with cam src)
N * @param [in] col column size
N * @param [in] row row size
N * @param [in] ch channel size
N * @param [in] fmt propietory image format
N * @param [in] mem_addr image DDR address
N * @param [in] img_buf_idx raw image buffer index
N */
Nvoid kdp_e2e_config_image(int src_idx, s32 col, s32 row, s32 ch,
N                          u32 fmt, u32 addr, int img_buf_idx);
N
Nstruct kdp_img_cfg* kdp_e2e_get_img_cfg(int img_src);
N/**
N * @brief to update image memory address
N *
N * !!! MUST be called after kdp_app_config_image()
N * @param [in] cam_index cam0 or cam1
N * @param [in] image_memory_address new image memory address
N * @return n/a
N */
Nvoid kdp_e2e_set_img_mem_addr(int img_src_idx, s32 img_mem_addr);
N/**
N * @brief output image memory address of specified source
N * @param [in] camera image source (RGB or NIR)
N * @return image memory address being used currently
N */
Nuint32_t kdp_e2e_get_img_mem_addr(int img_src_idx);
N
Nuint32_t kdp_e2e_get_img_mem_len(int img_src_idx);
N
N#if ( CFG_PALM_PRINT_MODE == YES )
X#if ( CFG_PALM_PRINT_MODE == 1 )
Svoid kdp_e2e_bg_init_done( BOOL flag );
N#endif
N#endif
L 8 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_db.h" 2
N
N#define DB_FACE_ADD_IDLE    0
N#define DB_FACE_ADD_GOING   1
N#define DB_FLASH_WRITE      2
N#define DB_FLASH_NO_WRITE   3
N
N#if CFG_FACE_FR50M == 1
S#define DB_DEFAULT_FR_THRESHOLD_LEVEL   2
N#else
N#define DB_DEFAULT_FR_THRESHOLD_LEVEL   4
N#endif
N
N//typedef struct kdp_e2e_db_extra_data_struct {
N//    //u32 user_id;
N//    char user_name[MAX_LEN_USERNAME];
N//    u8 pre_add;            //Fixed 1bytes
N//    u8 admin;
N//    u8  rgb_age_group;
N//    u8 rgb_face_quality;
N//    u8 nir_face_quality;
N//    u8 rgb_corner_y;
N//    u16 rec_cnt;
N//    u16 rec_fm_hist[MAX_FID];
N//    kdp_nir_mode nir_mode;
N//    float fs_feature[17];
N//    float darkness;
N//    float effect_2d;
N//    float nir_gain;
N//    u32 nir_cur_exp_time;
N//    u16  n1_fd_x;
N//    u16  n1_fd_y;
N//    u16  n1_fd_w;
N//    u16  n1_fd_h;
N//    float lm_length_ratio[5];
N//} kdp_e2e_db_extra_data;
N
Ntypedef kdp_app_db_extra_data kdp_e2e_db_extra_data;
N
Nkapp_db_user_data_t* kdp_e2e_get_db_data(void);
Nvoid kdp_e2e_db_init( uint16_t reserve_db_num );
Nvoid kdp_e2e_db_init_flash_load(void);
Nvoid kdp_e2e_db_free(void);
N//s32 kdp_e2e_db_compare_normal(u16 *lp_user_id);
Ns32 kdp_e2e_db_compare_self(u16 lp_user_id, u8 reg_idx, int reserve_db_num);
Ns32 kdp_e2e_db_compare(u16 *lp_user_id, float* thres_arr);
Nvoid kdp_e2e_db_init_thres( void );
N//void kdp_e2e_db_get_thres( float *min_dis, float *db_thres );
Nvoid kdp_e2e_db_set_thres( float min_dis, float db_thres );
Ns32 kdp_e2e_db_compare_one_user(u16 user_id);
Ns32 kdp_e2e_db_register(u16 user_id, u16 fmap_idx, int reserve_db_num );
Ns32 kdp_e2e_db_recog_update(u16 user_id, u16 fmap_idx, int reserve_db_num, float coef );
Ns32 kdp_e2e_db_add(u16 user_id, BOOL db_wo_flash, u16 reserve_db_num );
N//s32 kdp_e2e_db_update(u16 user_id, BOOL db_wo_flash, u16 reserve_db_num );
Ns32 kdp_e2e_db_delete(u8 del_ctrl, u16 user_id);
Ns32 kdp_e2e_db_get_user_info(u16 user_id, u16 *lp_valid_fm0, u16 *lp_valid_fm1, u16 *lp_type);
Ns32 kdp_e2e_db_get_user_info_by_idx(u16 idx, u16 *lp_valid_fm0, u16 *lp_valid_fm1, u16 *lp_type);
Ns32 kdp_e2e_db_abort_reg(void);
N
Ns32 kdp_e2e_db_extra_read(u8 user_idx, kdp_e2e_db_extra_data *data_addr, u32 data_size);
Ns32 kdp_e2e_db_2user_compare( uint8_t* pOutR1, uint32_t fdr_addr_r1_1,uint32_t fdr_addr_r1_2, \
N                              uint8_t* pOutN1, uint32_t fdr_addr_n1_1,uint32_t fdr_addr_n1_2 );
Xs32 kdp_e2e_db_2user_compare( uint8_t* pOutR1, uint32_t fdr_addr_r1_1,uint32_t fdr_addr_r1_2,                               uint8_t* pOutN1, uint32_t fdr_addr_n1_1,uint32_t fdr_addr_n1_2 );
N
Ns32 kdp_e2e_db_write_lock(void);
Ns32 kdp_e2e_db_write_unlock(void);
Ns32 kdp_e2e_db_get_total_num(void);
N
Nvoid kdp_e2e_set_fr_threshold_level(u8 level);
Nu8   kdp_e2e_get_fr_threshold_level(void);
N
Nvoid kdp_e2e_update_user_id(u16 user_idx, u16 user_id);
N
N#endif
L 6 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_util.h" 2
N#include "kdp_e2e_face.h"
N#define LL_LUMA                             (NO)
N#define BOUNDINGBOX_CHECK_LM                (YES)
N#if CFG_AI_TYPE == AI_TYPE_N1 || CFG_LW3D_TYPE != CFG_LW3D_NORMAL
X#if 3 == 2 || 1 != 0
N#define NORMAL_FACE_ANGLE_CHECK             (NO)
N#else
S#define NORMAL_FACE_ANGLE_CHECK             (YES)
N#endif
N#if  BOUNDINGBOX_CHECK_LM == NO
X#if  (1) == 0
S#define BOUNDINGBOX_CHECK_CENTER
N#endif
N
N#define FACE_MOVE_X_THRESH      (40)//30)
N#define FACE_MOVE_Y_THRESH      (40)//30)
N#define FACE_NOT_MOVE_CNT       (3)
N#if (IMGSRC_0_TYPE == SENSOR_TYPE_SC035HGS) || (IMGSRC_1_TYPE == SENSOR_TYPE_SC035HGS)
X#if (8 == 5) || (9 == 5)
S#define FACE_DIST_MAX_THRESH    (80)
N#else
N#if CFG_CAMERA_DUAL_1054 == 1 || CFG_CAMERA_SINGLE_1054 == 1
X#if 1 == 1 || CFG_CAMERA_SINGLE_1054 == 1
N#define FACE_DIST_MAX_THRESH    (120)
N#else
S#define FACE_DIST_MAX_THRESH    (80)
N#endif
N#endif
N#define FACE_DIST_MIN_THRESH    (10)
N#ifndef USE_XGB_DYNAMIC_THRESH
N#define USE_XGB_DYNAMIC_THRESH  (NO)
N#endif
N
N#if BOUNDINGBOX_CHECK_LM == YES
X#if (1) == 1
Ns32 kdp_e2e_util_chk_r1_lm(
N    struct kdp_img_cfg *img_cfg,
N    struct landmark_result_s *r1_lm);
Ns32 kdp_e2e_util_chk_n1_lm(
N    struct landmark_result_s *n1_lm);    
N#endif
N
N//int abs_n(int a);
N
Ns16 kdp_e2e_get_avg_eye_range(struct landmark_result_s *lm);    
N    
Nvoid kdp_e2e_get_mapping_bbox_from_nir(int xywh[4], float coe);
N    
N//s32 kdp_e2e_util_calc_ratio(float curr_luma_ratio, float db_luma_ratio, float cur_luma_ref, float db_luma_ref);
N
N//s32 kdp_e2e_util_calc_ref_range(float id_dual_fr_diff);
N
Ns32 kdp_e2e_util_r1_chk_bbox(struct facedet_result_s *r1_fd);
N
Ns32 kdp_e2e_util_chk_position(struct landmark_result_s *lm, s32 width, s32 height, s32 offset_x, s32 offset_y, s32 e2e_cam );
N
Nfloat kdp_e2e_iou_fd_by_mapping(struct facedet_result_s *r1_fd, struct landmark_result_s *r1_lm);
N
Ns32 kdp_e2e_util_chk_bbox_by_fd(struct facedet_result_s *r1_fd, struct facedet_result_s *n1_fd);
N
Ns32 kdp_e2e_util_n1_chk_bbox_by_lm(struct landmark_result_s *r1_lm, struct landmark_result_s *n1_lm);
N
Ns32 kdp_e2e_util_r1_chk_bad_pose(struct landmark_result_s *r1_lm);
N
Ns32 kdp_e2e_util_r1_chk_mask(struct facedet_result_s *r1_fd);
Ns32 kdp_e2e_util_n1_chk_mask(struct facedet_result_s *n1_fd);
N
Ns32 kdp_e2e_util_n1_chk_bad_pose(struct landmark_result_s *n1_lm);
N
N//s32 kdp_e2e_util_chk_head_pose(u8 reg_idx, u8 force_flag, u8* face_reg_thresh, s8 *lp_pose_val);
N
N//void kdp_e2e_util_measure_camera_distance(struct landmark_result_s *r1_lm, struct landmark_result_s *n1_lm);
N
Nu16 kdp_e2e_util_get_person_to_camera_distance(void);
N
Nint kdp_e2e_util_get_person_position(s32 *x, s32 *y, s32 *w, s32 *h);
N
Nint kdp_e2e_util_get_eye_range(struct landmark_result_s *lm);
Nint kdp_e2e_util_uint_subtract_abs(uint32_t a, uint32_t b, int abs_flag);
N
Nvoid kdp_e2e_util_calc_offset_from_nir_rgb_xy(
N    float* registered_offset_x, float* registered_offset_y, float nir_nose_x, float nir_nose_y, 
N    float rgb_x, float rgb_y);
N
Nvoid kdp_e2e_util_predict_xy_from_offset_xy(
N    float registered_offset_x, float registered_offset_y, float* predicted_x, float* predicted_y, 
N    float lm_x, float lm_y, int eye_range);
N
Nfloat kdp_e2e_util_calc_predict_after_led_y(float rgb_eye_range, float init_exp_tile);
Nfloat kdp_e2e_eye_open_ratio(struct eye_lid_lm_result_s* p_lms);
N
Nint kdp_e2e_check_face_move(struct facedet_result_s* fd);
N//s32 kdp_e2e_util_chk_bad_pose(struct landmark_result_s *p_lm, u32 check_hp_type);
N
Ns32 kdp_e2e_util_face_add_pose_chk(float yaw, float pitch, float roll, float normal_score, u32 check_hp_type);
Ns32 kdp_e2e_util_face_recog_pose_chk(float yaw, float pitch, float roll);
N
Nint kdp_e2e_check_face_position(void);
N    
N//void kdp_e2e_face_status_get(int32_t width, uint8_t *nir_img, struct landmark_result_s *lm, float *get_feat);  
N//float kdp_get_e2e_dynamic_th(kdp_e2e_db_extra_data *vars_db, kdp_e2e_face_variables *vars_cur);    
N#endif
L 14 "..\..\..\..\scpu\include\kl520_include.h" 2
N#include "kdp_e2e_ctrl.h"
L 1 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_ctrl.h" 1
N#ifndef __KDP_E2E_CTRL_H__
N#define __KDP_E2E_CTRL_H__
N
N
N#include "types.h"
N#include "ipc.h"
N#include "board_kl520.h"
N#include "kdp_e2e_n1_only.h"
N#include "kdp_e2e_n1r1.h"
L 1 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_n1r1.h" 1
N#ifndef __KDP_E2E_N1R1_H__
N#define __KDP_E2E_N1R1_H__
N
N#include "kdp_app_fid.h"
N#define USE_N1R1_LED_ON_OFF_SWITCH    (NO)
N
Ns32 kdp_e2e_face_n1r1_environmental_adaptation(struct facedet_result_s *n1_fd, struct landmark_result_s *n1_lm);
N//s32 kdp_e2e_face_n1r1_ncpu_liveness(void);
N//s32 kdp_e2e_face_n1r1_invalid_score(int *lp_updated_e2e_ret);
Ns32 kdp_e2e_face_n1r1(void);
N//void kdp_e2e_face_n1r1_get_luma_ratio(void);
Ns32 kdp_e2e_palm_r1(void);
N#endif
L 10 "..\..\..\..\scpu\lib\kdp_e2e_r1n1\include\kdp_e2e_ctrl.h" 2
N#include "kdp_e2e_face.h"
N//#define VOTE  YES
N
N#define FACE_DARK_TH        1
N#define FACE_QUALITY_TH     2
N#define ENV_BAD_TH          4
N#define FACE_BACK_LIGHT_TH  2
N#define TARGET_LUMA         80
N#define OPEN_RGB_LED_2S
N#define OPEN_RGB_LED_2S_CNT 5
N
Nextern u8 tile_avg_valid_x;
Nextern u8 tile_avg_valid_y;
N#if ( CFG_PALM_PRINT_MODE == YES )
X#if ( CFG_PALM_PRINT_MODE == 1 )
Sextern s16 brightness_stats_0[TILE_AVG_BLOCK_NUMBER];
Sextern s16 brightness_stats_1[TILE_AVG_BLOCK_NUMBER];
Sextern s16 brightness_stats_bg[TILE_AVG_BLOCK_NUMBER];
Sextern s16 brightness_stats_diff[TILE_AVG_BLOCK_NUMBER];
Sextern u8 hand_cnt;
N#endif
N
Nstruct kdp_e2e_ctrl_tile {
N    u16 tile_mean;
N    u8 tile_max;
N    u8 tile_min;
N    u8 tile_saturation_cnt;
N    u8 tile_max_x;
N    u8 tile_max_y;
N};
N
N#if ( CFG_PALM_PRINT_MODE == YES )
X#if ( CFG_PALM_PRINT_MODE == 1 )
Stypedef struct
S{
S    u8  block_num_x;
S    u8  block_num_y;
S    u16 block_size_x;
S    u16 block_size_y;
S    u16 cal_start_x;   //pixel
S    u16 cal_start_y;   //pixel
S    u8  cal_step;      //pixel
S} brightness_stats_info;
N#endif
N
Ntypedef void (*fn_led_open)(u16);
Ntypedef void (*fn_led_close)(void);
N#if ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36515 ) || ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36404 )
X#if ( 2 == 1 ) || ( 2 == 0 )
Stypedef void (*fn_led_light_mode)(u16);
N#endif
N
Ntypedef struct kdp_e2e_ctrl_led_struct {
N    fn_led_open         led_open;
N    fn_led_close        led_close;
N#if ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36515 ) || ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36404 )
X#if ( 2 == 1 ) || ( 2 == 0 )
S    fn_led_light_mode   led_light_mode;
N#endif  
N} kdp_e2e_ctrl_led;
N
Ntypedef int (*fn_strength_get)(void);
Ntypedef struct kdp_e2e_ctrl_light_sensor_struct {
N    fn_strength_get strength_get;
N} kdp_e2e_ctrl_light_sensor;
Ntypedef struct kdp_e2e_ctrl_ops_struct {
N    kdp_e2e_ctrl_led leds[IMGSRC_NUM];
X    kdp_e2e_ctrl_led leds[2];
N    kdp_e2e_ctrl_light_sensor light_sensor;
N} kdp_e2e_ctrl_ops;
N
N
Nkdp_e2e_ctrl_ops* kdp_e2e_ctrl_get_ops(void);
N#if ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36515 ) || ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36404 )
X#if ( 2 == 1 ) || ( 2 == 0 )
Svoid kdp_e2e_ctrl_led_register(u32 led_src_idx, fn_led_open fn_open, fn_led_close fn_close, fn_led_light_mode fn_mode );
N#else
Nvoid kdp_e2e_ctrl_led_register(u32 led_src_idx, fn_led_open fn_open, fn_led_close fn_close);
N#endif
Nvoid kdp_e2e_ctrl_light_sensor_register(fn_strength_get fn_get);
NBOOL kdp_e2e_ctrl_r1_led_tuning_when_normal(struct facedet_result_s *r1_fd, struct landmark_result_s *r1_lm);
NBOOL kdp_e2e_ctrl_r1_led_tuning_when_error(void);
Nvoid kdp_e2e_rgb_led_open_register(void);
N#if (CFG_AI_TYPE == AI_TYPE_N1R1)
X#if (3 == 3)
Ns32 kdp_e2e_ctrl_rgb_led_n1r1(void);
N//void kdp_e2e_n1r1_get_luma_ratio(void);
N#endif
Nvoid kdp_e2e_nir_led_flag_on(void);
Nvoid kdp_e2e_nir_led_flag_off(void);
N#if (E2E_N1_ONLY_STRUCTURE_ENABLE == YES)
X#if ((0) == 1)
Svoid kdp_e2e_n1_off_str_on_switch(void);
Ss32 kdp_e2e_n1_on_str_off_switch(void);
N#endif
N#if (E2E_N1_TWO_STAGE_LED_MODE == YES)
X#if ((0) == 1)
Ss32 kdp_e2e_n1_switch_to_normal_led(void);
Svoid kdp_e2e_n1_switch_to_flash_led(u8 level);
N#endif
N
Nvoid kdp_e2e_n1_on_str_off_gain_exp_recorver(void);
N
N#if VOTE == YES
X#if VOTE == 1
Sint vote(u8 *ret_cnt, int *ret);
N#endif
N
N#if (AEC_MULTI_THREAD == YES)
X#if ((0) == 1)
Svoid write_chk_n1(e2e_nir_cam_params* nir_cam_params, kdp_e2e_face_variables *vars, s32 ret);
Svoid write_chk_r1(e2e_rgb_cam_params* rgb_cam_params, kdp_e2e_face_variables *vars, s32 ret);
N#endif
N
Nint kdp_e2e_nir_tile_value_mean(u8 start_x, u8 end_x, u8 start_y, u8 end_y, struct kdp_e2e_ctrl_tile *tile_info);
Ns32 kdp_e2e_nir_led_open(void);
Ns32 kdp_e2e_ctrl_aec(void);
Nvoid kdp_e2e_rgb_led_gradually(void);
N
N#if ( CFG_PALM_PRINT_MODE == YES )
X#if ( CFG_PALM_PRINT_MODE == 1 )
Svoid kdp_e2e_brightness_stats_show(u8 block_w, u8 block_h, s16 value[]);
Su8 kdp_e2e_aec_brightness_palm_search( u8 block_w, u8 block_h ); 
Svoid kdp_e2e_aec_brightness_stats_set_block( uint16_t size_x, uint16_t size_y, uint8_t step );
Svoid kdp_e2e_aec_brightness_stats_set_area( uint8_t block_x, uint8_t block_y, uint16_t start_x, uint16_t start_y );
Sint kdp_e2e_aec_brightness_stats_cpu_calculate( uint8_t* img_data, uint16_t img_width, uint16_t img_hight, s16 *aec_stats_arr, struct kdp_e2e_ctrl_tile *tile_info );
N#endif
N#endif
L 15 "..\..\..\..\scpu\include\kl520_include.h" 2
N//#define  ANA_GAIN
N
N//#define CFG_CONSOLE_MODE    1
N#ifndef CFG_CONSOLE_MODE
N#if (CFG_COM_BUS_TYPE & COM_BUS_USB) && (CFG_PRODUCTION_TEST != YES)
X#if ((0x04) & 0x80) && (CFG_PRODUCTION_TEST != 1)
S#define CFG_CONSOLE_MODE    1
N#else
N#undef CFG_CONSOLE_MODE
N#endif
N#endif
N
N#define KL520_QUICK_BOOT                    (YES)
N//#define KL520_API_FACE_CLOSE_WITH_DP_CLOSE
N
N#ifdef DEV_TEST_VERSION
S#define KL520_API_SHOW_BOUNDINGBOX          (YES)
N#else
N#define KL520_API_SHOW_BOUNDINGBOX          (NO)
N#endif
N#define KL520_API_SHOW_FAIL_LM              (NO)
N#define KL520_API_SHOW_TOUCH_LOG            (NO)
N
N#define DB_DRAWING_CUSTOMER_COLOR
N
N#define CAMERA_DEVICE_RGB_IDX               (MIPI_CAM_RGB)
N#define CAMERA_DEVICE_NIR_IDX               (MIPI_CAM_NIR)
N
N#define LCD_BUFFER_ADDR                     (KDP_DDR_DRV_LCM_START_ADDR)
N
N//#define ENHANCE_RGB_LED_SWITCH
N#define LIGHT_HIGHER_THRESHOLD              (700)
N#define LIGHT_LOWER_THRESHOLD               (180)
N
N#if BOUNDINGBOX_CHECK_LM == NO
X#if (1) == 0
S#define LCD_FDR_OVERLINE                    (0)
N#else
N#ifdef BOUNDINGBOX_CHECK_CENTER
S    #ifdef CFG_CUSTOM_LCD_FDR_OVERLINE
S    #define LCD_FDR_OVERLINE                (CFG_CUSTOM_LCD_FDR_OVERLINE)
S    #else
S    #define LCD_FDR_OVERLINE                (-50)
S    #endif
N#else
N#define LCD_FDR_OVERLINE                    (30)
N#endif
N#endif
N
N#define LCD_DISPLAY_HINT_BOX_MARGIN         (20)
N#define LCD_DISPLAY_HINT_BOX_LEN            (30)
N#define LCD_DISPLAY_HINT_BOX_PEN_WIDTH      (2)
N#define LCD_DISPLAY_HINT_BOX_COLOR          (GRAY)
N
N#define LCD_DISPLAY_FD_BOX_MARGIN           (20)
N#define LCD_DISPLAY_FD_BOX_LEN              (30)
N#define LCD_DISPLAY_FD_BOX_PEN_WIDTH        (2)
N#define LCD_DISPLAY_FD_BOX_COLOR            (GREEN)
N#define LCD_DISPLAY_FD_EXIST_COLOR          (RED)
N#define LCD_DISPLAY_FD_BOX_LV_OK_COLOR      (GREEN)
N
N#define LCD_DISPLAY_DB_BOX_MARGIN           (20)
N#define LCD_DISPLAY_DB_BOX_LEN              (30)
N#define LCD_DISPLAY_DB_BOX_PEN_WIDTH        (2)
N#define LCD_DISPLAY_DB_BOX_OK_COLOR         (GREEN)
N#define LCD_DISPLAY_DB_BOX_FAIL_COLOR       (RED)
N
N#define LCD_DISPLAY_FD_OK_PEN_WIDTH         (2)
N#define LCD_DISPLAY_FD_OK_COLOR             (GREEN)
N
N#define LCD_DISPLAY_DB_OK_PEN_WIDTH         (1)
N#define LCD_DISPLAY_DB_OK_COLOR             (GREEN)
N
N#define LCD_DISPLAY_LM_BOX_PEN_WIDTH        (1)
N#define LCD_DISPLAY_LM_OK_PEN_WIDTH         (4)
N#define LCD_DISPLAY_LM_OK_COLOR             (GBLUE)
N
N#define LCD_DISPLAY_FDR_FAIL_PEN_WIDTH      (4)
N#define LCD_DISPLAY_FDR_FAIL_COLOR          (YELLOW)
N
N#define KL520_APP_FLAG_FDFR_OK              (1<<0)
N#define KL520_APP_FLAG_FDFR_ERR             (1<<1)
N#define KL520_APP_FLAG_FDFR_TIMEOUT         (1<<2)
N#define KL520_APP_FLAG_FDFR                 (KL520_APP_FLAG_FDFR_OK | KL520_APP_FLAG_FDFR_TIMEOUT | KL520_APP_FLAG_FDFR_ERR)
N#define KL520_APP_FLAG_TOUCH                (1<<3)
N#define KL520_APP_FLAG_TOUCH_DEINIT         (1<<4)
N#define KL520_APP_FLAG_TOUCH_ALL            (KL520_APP_FLAG_TOUCH | KL520_APP_FLAG_TOUCH_DEINIT)
N#define KL520_APP_FLAG_ACTION               (1<<5)
N#define KL520_APP_FLAG_ACTION_TOUCH         (1<<6)
N#define KL520_DEVICE_FLAG_OK                (1<<7)
N#define KL520_DEVICE_FLAG_ERR               (1<<8)
N#define KL520_APP_GUI_STOP                  (1<<9)
N#define KL520_APP_FLAG_COMM                 (1<<10)
N#define KL520_APP_FLAG_COMM_DONE            (1<<11)
N#define KL520_APP_THREAD_ERR                (1<<12)
N#define KL520_APP_FLAG_ALL                  (0X000FFFFF)
N
N#define FLAGS_API_FDFR_ADD_EVT              0x00000200
N#define FLAGS_API_FDFR_RECOGNITION_EVT      0x00000400
N#define FLAGS_API_FDFR_RECOGNITION_TEST_EVT 0x00000800
N#define FLAGS_API_FDFR_CLOSE_EVT            0x00001000
N#define FLAGS_API_FDFR_LIVENESS_EVT         0x00002000
N#define FLAGS_API_FDFR_ABORT_EVT            0x00004000
N#define FLAGS_API_FDFR_SNAPIMG_EVT          0x00008000
N#define FLAGS_API_FDFR_COMPARE_1VS1_EVT     0x00010000
N#define FLAGS_API_FDFR_ALL_EVT              0x0000FF00
N
N#define KL520_CAMERA_SKIP_MS                (0)
N#define KL520_FDFR_SKIP_MS                  (0)
N#define KL520_FDFR_KEEP_MS                  (300)
N
N#define KL520_FACE_SCORE_MIN                (-1)
N#define KL520_FACE_SCORE_MAX                (80)
N/* Possible return value of kl520_api_face_get_result() */
N#define KL520_FACE_OK                       (0)
N#define KL520_FACE_DB_OK                    (1)
N#define KL520_FACE_FAIL                     (2)
N#define KL520_FACE_DB_FAIL                  (3)
N#define KL520_FACE_NOFACE                   (4)
N#define KL520_FACE_NOFACE_AND_TIMEOUT       (5)
N#define KL520_FACE_TIMEOUT                  (6)
N#define KL520_FACE_EXIST                    (7)
N#define KL520_FACE_EMPTY                    (8)
N#define KL520_FACE_FULL                     (9)
N#define KL520_FACE_BADPOSE                  (10)
N
N#define KL520_FACE_INVALID                  (11)
N
N#define KL520_FACE_TOO_FAR                  (12)
N#define KL520_FACE_TOO_NEAR                 (13)
N#define KL520_FACE_WAIT_DONT_MOVE           (14)
N#define KL520_FACE_LIVENESS_OK              (15)    // only for drawing
N#define KL520_FACE_DETECTED                 (16)
N#define KL520_FACE_MASK                     (17)
N#define KL520_FACE_EYE_CLOSE_STATUS_OPEN_EYE    (18)        //KL520_FACE_EYE_CLOSED_CONT
N#define KL520_FACE_EYE_CLOSED                   (19)
N#define KL520_FACE_EYE_CLOSE_UNKNOW_STATUS      (20)
N#define KL520_FACE_TOOUP                    (21)
N#define KL520_FACE_TOODOWN                  (22)
N#define KL520_FACE_TOOLEFT                  (23)
N#define KL520_FACE_TOORIGHT                 (24)
N#define KL520_FACE_LOW_QUALITY              (25)
N#define KL520_FACE_FACE_TO                  (0xFD)	//lmm-edit
N
N#define KL520_FACE_SEND_NEXT_IMAGE          (26)
N#define KL520_FACE_CALLIB_FAIL              (27)
N#define KL520_FACE_ATTACK                   (30)
N
N#if CFG_FMAP_NO_COMP_ENABLE == YES
X#if CFG_FMAP_NO_COMP_ENABLE == 1
S#define KL520_DB_COMP_FAIL_ALLOWED_MAX      (1)
N#else
N#define KL520_DB_COMP_FAIL_ALLOWED_MAX      (1)
N#endif
N
N#if (CFG_CAMERA_DUAL_1054 == 1 || CFG_CAMERA_SINGLE_1054 == 1)
X#if (1 == 1 || CFG_CAMERA_SINGLE_1054 == 1)
N#define NORMAL_POSE_SCORE0  (0.98f)
N#define NORMAL_POSE_SCORE1  (0.85f)
N#define NORMAL_POSE_YAW     (8)
N#define NORMAL_POSE_ROLL    (12)
N#define NORMAL_POSE_UD0     (15)
N#define NORMAL_POSE_UD1     (-15)
N#define MAX_LR_POSE    70
N#define MAX_UD_POSE    70
N#if CFG_ZHIAN == 1
X#if 1 == 1
N#define MIN_LR_POSE    12
N#else
S#define MIN_LR_POSE    6
N#endif
N#define MIN_UD_POSE    1
N#else
S#define NORMAL_POSE_SCORE0  (0.98f)
S#define NORMAL_POSE_SCORE1  (0.85f)
S#define NORMAL_POSE_YAW     (12)
S#define NORMAL_POSE_ROLL    (12)
S#define NORMAL_POSE_UD0     (30)
S#define NORMAL_POSE_UD1     (-30)
S#define MAX_LR_POSE    70
S#define MAX_UD_POSE    70
S#define MIN_LR_POSE    12
S#define MIN_UD_POSE    1
N#endif
N
Nextern const float reg_normal_score0;
Nextern const float reg_normal_score1;
Nextern const s8 reg_normal_pitch0;
Nextern const s8 reg_normal_pitch1;
Nextern const s8 reg_normal_yaw;
Nextern const s8 reg_normal_roll;
N
N#if CFG_AI_TYPE == AI_TYPE_N1
X#if 3 == 2
S#define KL520_THRESH_NORMAL_MAX_UD          (15)
S#define KL520_THRESH_NORMAL_MAX_LR          (10)//8)
S#define KL520_THRESH_LEFT_MIN               (60)
S#define KL520_THRESH_LEFT_MAX               (90)
S#define KL520_THRESH_RIGHT_MIN              (60)
S#define KL520_THRESH_RIGHT_MAX              (90)
N#else
N#define KL520_THRESH_NORMAL_MAX_UD          (15)
N#define KL520_THRESH_NORMAL_MAX_LR          (8)//8)
N#define KL520_THRESH_LEFT_MIN               (60)
N#define KL520_THRESH_LEFT_MAX               (75)
N#define KL520_THRESH_RIGHT_MIN              (60)
N#define KL520_THRESH_RIGHT_MAX              (75)
N#endif
N#define KL520_THRESH_NORMAL_ANGLE_RATIO     (120)
N#ifdef HEAD_POSE_CHECK_PERCENT
N#if CFG_AI_TYPE != AI_TYPE_N1
X#if 3 != 2
N#define KL520_THRESH_UP_MIN                 (8)
N#define KL520_THRESH_DOWN_MIN               (8)
N#else
S#define KL520_THRESH_UP_MIN                 (4)
S#define KL520_THRESH_DOWN_MIN               (4)
N#endif
N#define KL520_THRESH_UP_MAX                 (30)
N#define KL520_THRESH_DOWN_MAX               (30)
N#else
S#define KL520_THRESH_UP_MIN                 (50)
S#define KL520_THRESH_UP_MAX                 (65)
S#define KL520_THRESH_DOWN_MIN               (50)
S#define KL520_THRESH_DOWN_MAX               (65)
N#endif
N
N#define KL520_MIDDLE_LINE                   (70)
N#define KL520_MIDDLE_LINE1                  (20)
N#define KL520_HINT_ARROW_LEN                (20)
N#define KL520_HINT_ARROW                    (10)
N#define LCD_DISPLAY_ARROW_COLOR             (0xFEA0)   //GOLD
N
N
N#define KL520_DEVICE_OK                     (0)
N#define KL520_DEVICE_ERR_NIR_ID             (1<<0)
N#define KL520_DEVICE_ERR_RGB_ID             (1<<1)
N#define KL520_DEVICE_ERR_FLASH_ID           (1<<2)
N#define KL520_DEVICE_ERR_TOUCH_ID           (1<<3)
N#define KL520_DEVICE_ERR_LCM_ID             (1<<4)
N#define KL520_DEVICE_ERR_IOEXTENDER_ID      (1<<5)
N
N#define KL520_API_FACE_NORMAL_RST_TIMEOUT   (YES)
N
N#define KL520_DEFAULT_TIMEOUT_MS            (10)
N#define KL520_DEFAULT_ADD_TIMEOUT_S         (30)
N#define KL520_DEFAULT_REC_TIMEOUT_S         (30)
N#define KL520_DEFAULT_LIVENESS_TIMEOUT_S    (30)
N
N#define KL520_DEFAULT_DB_THR_ENVIR_DIFF_0   (E2E_DB_DYNAMIC_THRESHOLD_DEF)  //environment 0
N#define KL520_DEFAULT_DB_THR_ENVIR_DIFF_1   (E2E_DB_DYNAMIC_THRESHOLD_DEF)  //environment 1
N#define KL520_DEFAULT_DB_THR_ENVIR_DIFF_2   (E2E_DB_DYNAMIC_THRESHOLD_DEF)  //environment 2
N
N#if CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP
X#if 1 == 1
N#ifndef KL520_FACE_ADD_BMP
S#define KL520_FACE_ADD_BMP  1
N#endif
N#endif
N
N#if( CFG_LW3D_TYPE == CFG_LW3D_940 )
X#if( 1 == 2 )
N#else
N#define HEAD_POSE_LR_FIRST          YES
N#endif
N
N#define KDP_CHK_BREAK(func)     { ret = (func); if (0 != ret) break; }
N
N#define ROTATE_180_ENABLE   (0x96)
N#define ROTATE_180_DISABLE  (0xFF)
N
Nextern bool g_bPowerDown;
Xextern _Bool g_bPowerDown;
N
N// jim : new db add mode
Ntypedef enum _KL520_FACE_DB_ADD_MODE_
N{
N    FACE_ADD_MODE_IN_DB = 0,
N    FACE_ADD_MODE_NO_DB
N
N} kl520_face_db_add_mode;
N
Ntypedef enum _KL520_FACE_ADD_MODE_
N{
N    FACE_ADD_MODE_DEFAULT = 0,
N    FACE_ADD_MODE_1_FACE,
N    FACE_ADD_MODE_5_FACES
N
N} kl520_face_add_mode;
N
Ntypedef enum _KL520_FACE_ADD_TYPE_
N{
N    FACE_ADD_TYPE_NORMAL = 0,
N    FACE_ADD_TYPE_LEFT,
N    FACE_ADD_TYPE_RIGHT,
N    FACE_ADD_TYPE_UP,
N    FACE_ADD_TYPE_DOWN,
N
N} kl520_face_add_type;
N
N#if ( KDP_BIT_CTRL_MODE == YES )
X#if ( ( 0 ) == 1 )
Stypedef enum _KL520_BIT_CTRL_FACE_ADD_
S{
S    BIT_CTRL_FACE_ADD_NORMAL    = 0x01,
S    BIT_CTRL_FACE_ADD_RIGHT     = 0x02,
S    BIT_CTRL_FACE_ADD_LEFT      = 0x04,
S    BIT_CTRL_FACE_ADD_DOWN      = 0x08,
S    BIT_CTRL_FACE_ADD_UP        = 0x10,
S
S    BIT_CTRL_FACE_ADD_2FACE_LR  = BIT_CTRL_FACE_ADD_LEFT|BIT_CTRL_FACE_ADD_RIGHT,
S    BIT_CTRL_FACE_ADD_2FACE_UD  = BIT_CTRL_FACE_ADD_UP|BIT_CTRL_FACE_ADD_DOWN,
S    BIT_CTRL_FACE_ADD_4FACE     = BIT_CTRL_FACE_ADD_2FACE_UD|BIT_CTRL_FACE_ADD_2FACE_LR,
S
S    BIT_CTRL_FACE_ADD_FACE_MASK = 0x1F,
S
S} kl520_bit_ctrl_face_add;
N#endif
N
Ntypedef enum _KL520_MOUSE_STATE_
N{
N    MOUSE_NONE,
N    MOUSE_DOWN,
N    MOUSE_MOVE,
N    MOUSE_UP,
N
N} kl520_mouse_state;
N
Ntypedef struct _KL520_MOUSE_INFO_
N{
N    kl520_mouse_state state;
N    short x;
N    short y;
N
N} kl520_mouse_info;
N
Ntypedef struct _KL520_DP_POINT_
N{
N    u32 x;
N    u32 y;
N} kl520_dp_point;
N
Ntypedef struct _KL520_DP_RECT_
N{
N    unsigned short start_x;
N    unsigned short start_y;
N    unsigned short end_x;
N    unsigned short end_y;
N} kl520_dp_rect;
N
N
Ntypedef struct _KL520_DP_DRAW_INFO_
N{
N    kl520_dp_rect r1_rc;
N    kl520_dp_rect n1_rc;
N    kl520_dp_point r1_pt_array[LAND_MARK_POINTS];
X    kl520_dp_point r1_pt_array[5];
N    kl520_dp_point n1_pt_array[LAND_MARK_POINTS];
X    kl520_dp_point n1_pt_array[5];
N    
N    float r1_lm_score;
N    float n1_lm_score;
N    
N    s32 e2e_ret;
N
N    u8 e2e_dist_type;
N    u16 e2e_dist;
N
N    u8 e2e_pos_type;
N    kl520_dp_point  e2e_pos;
N
N    u8 e2e_eye_type;
N    u8 e2e_mask_type;
N
N
N} kl520_dp_draw_info;
N
N
N////////////////
N/* Camera API */
N////////////////
Nu16 kl520_api_camera_open(unsigned int cam_idx);
Nint kl520_api_camera_close(unsigned int cam_idx);
Nint kl520_api_camera_start(unsigned int cam_idx);
Nint kl520_api_camera_stop(unsigned int cam_idx);
Nint kl520_api_camera_get_id(unsigned int cam_idx);
N
N
N///////////////
N/* Touch API */
N///////////////
N/**
N * @brief After receiving the touch event evt_touch_id, the touch information can be obtained through this interface.
N */
Nint kl520_api_mouse_info_get(kl520_mouse_info * info);
N
N//////////////////////
N/* Face-related API */
N/////////////////////
N/*
N * @brief
N*/
N
Nvoid kl520_api_face_set_add_mode(kl520_face_add_mode mode);
Nkl520_face_add_mode kl520_api_face_get_add_mode(void);
Nvoid kl520_api_face_set_db_add_mode(kl520_face_db_add_mode mode);
N/**
N * @brief Face capture
N * The parameter represents the area that camera can display and face type
N * The remaining areas are left to the UI
N * If successful, the event 'evt_face_result_id' is returned asynchronously and the ID of the face can be obtained
N * via kl520_api_face_get_result.
N*/
N
Nint kl520_api_face_add(short x, short y, short w, short h, kl520_face_add_type type);
N
N#if ( KL520_FACE_ADD_BMP == YES )
X#if ( 1 == 1 )
Nint kl520_api_face_add_ex(short x, short y, short w, short h, u8 f_bmp);
N#endif
N
N/**
N * @brief When the application receives evt_face_result_id, it calls the API to get the result.
N * Face ID can be obtained if face record is successful.
N * If face test and verify function is used, the paramter face_id is empty.
N*/
Nint kl520_api_face_get_result(u8* face_id);
N
N/**
N * @brief Delete all information about user ID
N * If the parameter del_ctrl is 1, all user_id in database will be deleted.
N * Otherwise, the specified user_id will be deleted
N*/
Nint kl520_api_face_del(u8 del_ctrl, u8 user_id);
N
N/**
N * @brief Query the face ID is exist or not
N*/
Nint kl520_api_face_query(u8 face_id);
N
N/**
N * @brief Query all face ID in db are exist or not
N*/
Nint kl520_api_face_query_all(u8* total_id_num, u8* face_id);
N
Nu8 kl520_api_face_query_first_avail_user_idx(void);
Nu8 kl520_api_face_query_user_idx(u8 user_id);
N/**
N * @brief Set the face capture timeout time in seconds
N*/
Nint kl520_api_face_add_set_timeout(int timeout);
N/**
N * @brief Get the face capture timeout time in seconds
N*/
Nint kl520_api_face_add_get_timeout(void);
N
N/**
N * @brief Face recognition
N * The parameter represents the area that camera can display
N * The remaining areas are left to the UI
N * If successful, the event 'evt_face_result_id' is returned asynchronously and the ID of the face can be obtained
N * via kl520_api_face_get_result.
N*/
Nint kl520_api_face_recognition(short x, short y, short w, short h);
N
N/**
N * @brief Set the face recognition timeout time in seconds
N*/
Nint kl520_api_face_recognition_set_timeout(int timeout);
N/**
N * @brief Get the face recognition timeout time in seconds
N*/
Nint kl520_api_face_recognition_get_timeout(void);
N
N
N/**
N * @brief Face liveness
N * The parameter represents the area that camera can display
N * The remaining areas are left to the UI
N * If successful, the event 'evt_face_result_id' is returned asynchronously and the ID of the face can be obtained
N * via kl520_api_face_get_result.
N*/
Nint kl520_api_face_liveness(short x, short y, short w, short h);
N
N//snap image
Nint kl520_api_snap_image(short x, short y, short w, short h);
N
N/**
N * @brief Set the face liveness timeout time in seconds
N*/
Nint kl520_api_face_liveness_set_timeout(int timeout);
N/**
N * @brief Get the face liveness timeout time in seconds
N*/
Nint kl520_api_face_liveness_get_timeout(void);
N
Nvoid kl520_api_face_set_curr_face_id(u8 curr_face_id);
Nu8 kl520_api_face_get_curr_face_id(void);
N
N/**
N * @brief Handle events during kl520_api_face_add_internal
N*/
Nint kl520_api_add_wait_and_get(void);
N
N/**
N * @brief The internal process of registering faces
N*/
N
Nint kl520_api_face_add_internal(short x, short y, short w, short h, kl520_face_add_type type);
N
N#if ( KL520_FACE_ADD_BMP == YES )
X#if ( 1 == 1 )
Nint kl520_api_face_add_internal_ex(short x, short y, short w, short h, u8 f_bmp);
N#endif
N
N/**
N * @brief Face liveness Test mode
N * Through evt_face_result_id notification, the application receives the event and calls kl520_face_get_result to get the result.
N*/
Nint kl520_api_face_recognition_test(short x, short y, short w, short h);
N
N/**
N * @brief Turn off Face Related Functions
N*/
Nvoid kl520_api_face_close(void);
N
N
Nu16 kl520_api_touch_get_device_id(void);
N
N#if ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36515 ) || ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36404 )
X#if ( 2 == 1 ) || ( 2 == 0 )
Svoid kl520_api_led_register_hook(u32 cam_idx, fn_led_open fn_open, fn_led_close fn_close, fn_led_light_mode fn_mode);
N#else
Nvoid kl520_api_led_register_hook(u32 cam_idx, fn_led_open fn_open, fn_led_close fn_close);
N#endif
Nvoid kl520_api_light_sensor_register_hook(fn_strength_get fn_get);
Nvoid kl520_api_camera_register_hook(u32 cam_idx, fn_power_hook fn_power_on, fn_power_hook fn_power_off);
Nvoid kl520_api_touch_register_hook(fn_power_hook fn_power_on, fn_power_hook fn_power_off);
Nint kl520_api_touch_open(void);
Nint kl520_api_touch_start(void);
Nint kl520_api_touch_stop(void);
NBOOL kl520_api_touch_is_started(void);
Nvoid kl520_api_touch_set_x_range_max(int x_range_max);
Nvoid kl520_api_touch_set_y_range_max(int y_range_max);
Nvoid kl520_api_touch_set_x_axis_inverse(int on_off);
Nvoid kl520_api_touch_set_y_axis_inverse(int on_off);
N
N
N#endif
L 31 "..\..\user\main.c" 2
N#include "kl520_api.h"
L 1 "..\..\..\..\scpu\include\kl520_api.h" 1
N#ifndef __KL520_API_H__
N#define __KL520_API_H__
N
N#include "kl520_include.h"
N#include "version.h"
L 1 "..\..\..\..\scpu\device\include\Kneron\version.h" 1
N#ifndef __VERSION_H__
N#define __VERSION_H__
N
N#define DRAM_MISCDATA_SIZE 	0x00000010
N
N#if ( (CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP) || (CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP_USR) )
X#if ( (1 == 1) || (1 == 3) )
N#define UART_MAJOR_VERSION                       (2)
N#define UART_MINOR_VERSION                       (0)
N#else
S#define UART_MAJOR_VERSION                       (0)
S#define UART_MINOR_VERSION                       (0)
N#endif
N#define UART_PROTOCOL_VERSION                    ( UART_MAJOR_VERSION<<8 | UART_MINOR_VERSION )
N
Nstruct fw_misc_data {
N    unsigned char version[4];
N    unsigned int date;
N};
N
Nextern struct fw_misc_data g_model_version;
N
N#endif
L 6 "..\..\..\..\scpu\include\kl520_api.h" 2
N#include "kl520_api_device_id.h"
L 1 "..\..\..\..\scpu\device\include\Kneron\kl520_api_device_id.h" 1
N#pragma once
N#include "base.h"
N#include "version.h"
N#include "ipc.h"
N
N#define NIR_SENSOR_ID   0x132
N#define RGB_SENSOR_ID   0x2145
N#define FLASH_ID        0xc8
N#define LCM_ID          0x8552//0x404 dummy
N#define TOUCH_ID        0x82
N#define DEVICE_NOT_INIT 0xFFFF
N
Ntypedef struct __device_id
N{
N    char device_name[12];
N    int id;
N} device_id;
N
Ntypedef struct __system_info
N{
N    u32 unique_id;
N    u32 spl_version;
N    struct fw_misc_data fw_scpu_version;
N    struct fw_misc_data fw_ncpu_version;
N#if ( UART_PROTOCOL_VERSION >= 0x0200 )
X#if ( ( (2)<<8 | (0) ) >= 0x0200 )
N    u16 com_protocol_version;
N#endif
N    int model_count;
N    struct kdp_model_s **model_infos;
N    device_id device_id_0;
N    device_id device_id_1;
N    device_id device_id_2;
N    device_id device_id_3;
N    device_id device_id_4;
N    //device_id device_id_5;
N    device_id *extra_device_id_array;
N    u32 extra_device_cnt;
N    //device_id device_id_6;
N} system_info;
N
N
L 7 "..\..\..\..\scpu\include\kl520_api.h" 2
N
N///////////////
N/* timer API */
N///////////////
N/**
N * @brief Timer initialization
N * @sample kl520_api_timer_init(PWMTIMER4,PWMTMR_100MSEC_PERIOD)
N */
NBOOL kl520_api_timer_init(pwmtimer timer, u32 tick);
N
N/**
N * @brief Timer tick reset
N */
Nvoid kl520_api_timer_tick_reset(pwmtimer timer);
N
N/**
N * @brief Closing of timer
N */
N int kl520_api_timer_close(pwmtimer timer);
N 
N 
N/**
N * @brief Timer interruption
N */
Nvoid kl520_api_tmr2_user(u32 *tick);
Nvoid kl520_api_tmr3_user(u32 *tick);
Nvoid kl520_api_tmr4_user(u32 *tick);
Nvoid kl520_api_tmr5_user(u32 *tick);
Nvoid kl520_api_tmr6_user(u32 *tick);
N
N/**
N * @brief Get Display backlight, range 0-100
N */
Nint kl520_api_dp_get_backlight(void);
N/**
N * @brief Set Display backlight, range 0-100
N */
Nint kl520_api_dp_set_backlight(int light);
N
N/**
N * @brief Display the screen and brush the contents of LCD_BUFFER_ADDR onto the Display.
N */
Nint kl520_api_dp_fresh(void);
N
Nvoid kl520_api_dp_layout_enable(void);
Nvoid kl520_api_dp_layout_disable(void);
NBOOL kl520_api_dp_layout_get(void);
N
N
Nvoid kl520_api_dp_five_face_enable(void);
Nvoid kl520_api_dp_five_face_disable(void);
NBOOL kl520_api_dp_five_face_get(void);
N
N///////////////////////
N/* Basic Drawing API */
N///////////////////////
Nint kl520_api_dp_set_pen_rgb565(unsigned short rgb565, unsigned int pen_width);
Nint kl520_api_dp_draw_line(u32 xs, u32 ys, u32 xe, u32 ye);
Nint kl520_api_dp_draw_bitmap(u32 org_x, u32 org_y, u32 width, u32 height, void *buf);
N
N
Nint kl520_api_dp_fill_rect(u32 org_x, u32 org_y, u32 width, u32 height);
Nint kl520_api_dp_draw_rect(int x, int y, int width, int height);
N/////////////
N/* LCD API */
N/////////////
Nint kl520_api_dp_get_device_id(void);
N
N////////////////////////
N/* Display layout API */
N////////////////////////
Nint kl520_api_dp_open(u32 width, u32 height);
Nu8 kl520_api_dp_init_get(void);
N
Nint kl520_api_dp_fresh_bg(u16 nColor, u8 nWidth);
N
Nvoid kl520_api_dp_close(void);
N
Nvoid kl520_api_dp_layout(void);
N
Nvoid kl520_pose_timer_stop(void);
Nvoid kl520_pose_timer_delete(void);
N
Nvoid kl520_api_dp_layout_pose(void);
N
Nvoid kl520_api_dp_layout_pose_with_customized_size_img(void);
N
Nvoid _kl520_api_dp_layout_lm(kl520_dp_draw_info *info, int flag);
Nint kl520_api_get_scpu_version(struct fw_misc_data *g_fw_misc);
Nint kl520_api_get_ncpu_version(struct fw_misc_data *g_fw_misc);
Nstruct fw_misc_data *kl520_api_get_model_version(void);
N
Nu32 kl520_api_get_unique_id(void);
Nu16 kl520_api_memxfer_get_device_id(void);
Nint kl520_api_get_version_info(system_info* t_system_info);
Nint kl520_api_get_device_info(system_info* t_system_info);
Nvoid kl520_api_free_device_info(system_info* t_system_info);
N
N
NosEventFlagsId_t kl520_api_get_event(void);
N
Nvoid kl520_api_face_notify(int face_status);
N
N///////////////
N/*  Measure execution time API */
N///////////////
N//        MEASURE_STAMP(E_MEASURE_FRAME_1_CAP_STR1)  \
N//        MEASURE_STAMP(E_MEASURE_FRAME_1_CAP_STR2)  \
N//        MEASURE_STAMP(E_MEASURE_FRAME_1_CAP_STR3)  \
N//        MEASURE_STAMP(E_MEASURE_FRAME_1_CAP_STR4)  \
N
X
N#define FOREACH_MEASURE_STAMP(MEASURE_STAMP) \
N        MEASURE_STAMP(E_MEASURE_MAIN_BOOT)   \
N        MEASURE_STAMP(E_MEASURE_CHECK_OTA) \
N        MEASURE_STAMP(E_MEASURE_CHECK_OTA_DONE) \
N        MEASURE_STAMP(E_MEASURE_OS_START)  \
N        MEASURE_STAMP(E_MEASURE_TOUCH_INIT)  \
N        MEASURE_STAMP(E_MEASURE_TOUCH_INIT_DONE)  \
N        MEASURE_STAMP(E_MEASURE_LOAD_MODEL)  \
N        MEASURE_STAMP(E_MEASURE_LOAD_MODEL_VAR_RESET)  \
N        MEASURE_STAMP(E_MEASURE_LOAD_MODEL_FACE_INIT)  \
N        MEASURE_STAMP(E_MEASURE_LOAD_MODEL_PROP_INIT)  \
N        MEASURE_STAMP(E_MEASURE_LOAD_MODEL_SETTING_INIT)  \
N        MEASURE_STAMP(E_MEASURE_LOAD_MODEL_DB_INIT)  \
N        MEASURE_STAMP(E_MEASURE_LOAD_MODEL_END)   \
N        MEASURE_STAMP(E_MEASURE_RGB_INIT)  \
N        MEASURE_STAMP(E_MEASURE_RGB_INIT_DONE)  \
N        MEASURE_STAMP(E_MEASURE_NIR_INIT)  \
N        MEASURE_STAMP(E_MEASURE_NIR_INIT_DONE)  \
N        MEASURE_STAMP(E_MEASURE_RGB_STR)  \
N        MEASURE_STAMP(E_MEASURE_RGB_END)  \
N        MEASURE_STAMP(E_MEASURE_NIR_STR)  \
N        MEASURE_STAMP(E_MEASURE_NIR_END)  \
N        MEASURE_STAMP(E_MEASURE_SYS_READY)  \
N        MEASURE_STAMP(E_MEASURE_VERIFY_MSG)  \
N        MEASURE_STAMP(E_MEASURE_THR_TASKS_INIT)  \
N        MEASURE_STAMP(E_MEASURE_THR_TASKS_INIT_RDY)  \
N        MEASURE_STAMP(E_MEASURE_THR_CONSOLE_RDY)  \
N        MEASURE_STAMP(E_MEASURE_THR_OTA_RDY)  \
N        MEASURE_STAMP(E_MEASURE_THR_CAM_RDY)  \
N        MEASURE_STAMP(E_MEASURE_BACKLIGHT_ON)  \
N        MEASURE_STAMP(E_MEASURE_API_FACE_REC_STR)  \
N        MEASURE_STAMP(E_MEASURE_API_RUN_STAT_CHK)  \
N        MEASURE_STAMP(E_MEASURE_THR_FDFR_INIT_RDY)  \
N        MEASURE_STAMP(E_MEASURE_THR_FDFR_OPEN_RDY)  \
N        MEASURE_STAMP(E_MEASURE_THR_FDFR_REC_STR)  \
N        MEASURE_STAMP(E_MEASURE_NIR_ISR_01)  \
N        MEASURE_STAMP(E_MEASURE_NIR_ISR_02)  \
N        MEASURE_STAMP(E_MEASURE_NIR_ISR_03)  \
N        MEASURE_STAMP(E_MEASURE_NIR_ISR_04)  \
N        MEASURE_STAMP(E_MEASURE_NIR_ISR_05)  \
N        MEASURE_STAMP(E_MEASURE_NIR_ISR_06)  \
N        MEASURE_STAMP(E_MEASURE_NIR_ISR_07)  \
N        MEASURE_STAMP(E_MEASURE_NIR_ISR_08)  \
N        MEASURE_STAMP(E_MEASURE_NIR_ISR_09)  \
N        MEASURE_STAMP(E_MEASURE_NIR_ISR_10)  \
N        MEASURE_STAMP(E_MEASURE_RGB_ISR_01)  \
N        MEASURE_STAMP(E_MEASURE_RGB_ISR_02)  \
N        MEASURE_STAMP(E_MEASURE_RGB_ISR_03)  \
N        MEASURE_STAMP(E_MEASURE_RGB_ISR_04)  \
N        MEASURE_STAMP(E_MEASURE_RGB_ISR_05)  \
N        MEASURE_STAMP(E_MEASURE_RGB_ISR_06)  \
N        MEASURE_STAMP(E_MEASURE_RGB_ISR_07)  \
N        MEASURE_STAMP(E_MEASURE_RGB_ISR_08)  \
N        MEASURE_STAMP(E_MEASURE_RGB_ISR_09)  \
N        MEASURE_STAMP(E_MEASURE_RGB_ISR_10)  \
N        MEASURE_STAMP(E_MEASURE_FRAME_1_FACE_STR)  \
N        MEASURE_STAMP(E_MEASURE_FRAME_1_FACE_END)  \
N        MEASURE_STAMP(E_MEASURE_FRAME_2_FACE_STR)  \
N        MEASURE_STAMP(E_MEASURE_FRAME_2_FACE_END)  \
N        MEASURE_STAMP(E_MEASURE_FRAME_3_FACE_STR)  \
N        MEASURE_STAMP(E_MEASURE_FRAME_3_FACE_END)  \
N        MEASURE_STAMP(E_MEASURE_FRAME_4_FACE_STR)  \
N        MEASURE_STAMP(E_MEASURE_FRAME_4_FACE_END)  \
N        MEASURE_STAMP(E_MEASURE_FRAME_5_FACE_STR)  \
N        MEASURE_STAMP(E_MEASURE_FRAME_5_FACE_END)  \
N        MEASURE_STAMP(E_MEASURE_FACE_PREEXEC_END)  \
N        MEASURE_STAMP(E_MEASURE_FACE_DB_COMP_STR)  \
N        MEASURE_STAMP(E_MEASURE_FACE_DB_COMP_END)  \
N        MEASURE_STAMP(E_MEASURE_EVENT_SEND_OK)  \
N        MEASURE_STAMP(E_MEASURE_FACE_FACE_OK)  \
N        MEASURE_STAMP(E_MEASURE_FACE_REC_END)  \
N        MEASURE_STAMP(E_MEASURE_FACE_DB_FAIL)  \
N        MEASURE_STAMP(E_MEASURE_FACE_CLOSE_STR)  \
N        MEASURE_STAMP(E_MEASURE_FACE_CLOSE_END)  \
N        MEASURE_STAMP(E_MEASURE_FACTORY_STR)  \
N        MEASURE_STAMP(E_MEASURE_FACTORY_END)  \
N        MEASURE_STAMP(E_MEASURE_LED_STR)  \
N        MEASURE_STAMP(E_MEASURE_LED_END)  \
N        MEASURE_STAMP(E_MEASURE_NIR_FD_STR)  \
N        MEASURE_STAMP(E_MEASURE_NIR_FD_END)  \
N        MEASURE_STAMP(E_MEASURE_NIR_LM_STR)  \
N        MEASURE_STAMP(E_MEASURE_NIR_LM_END)  \
N        MEASURE_STAMP(E_MEASURE_NIR_LM_S_STR)  \
N        MEASURE_STAMP(E_MEASURE_NIR_LM_S_END)  \
N        MEASURE_STAMP(E_MEASURE_NIR_QUALITY_STR)  \
N        MEASURE_STAMP(E_MEASURE_NIR_QUALITY_END)  \
N        MEASURE_STAMP(E_MEASURE_NIR_POSE_STR)  \
N        MEASURE_STAMP(E_MEASURE_NIR_POSE_END)  \
N        MEASURE_STAMP(E_MEASURE_RGB_FD_STR)  \
N        MEASURE_STAMP(E_MEASURE_RGB_FD_END)  \
N        MEASURE_STAMP(E_MEASURE_RGB_LM_STR)  \
N        MEASURE_STAMP(E_MEASURE_RGB_LM_END)  \
N        MEASURE_STAMP(E_MEASURE_RGB_LM_S_STR)  \
N        MEASURE_STAMP(E_MEASURE_RGB_LM_S_END)  \
N        MEASURE_STAMP(E_MEASURE_NIR_LV_STR)  \
N        MEASURE_STAMP(E_MEASURE_NIR_LV_END)  \
N        MEASURE_STAMP(E_MEASURE_NIR_HSN_STR)  \
N        MEASURE_STAMP(E_MEASURE_NIR_HSN_END)  \
N        MEASURE_STAMP(E_MEASURE_FUSE_STR)  \
N        MEASURE_STAMP(E_MEASURE_FUSE_END)  \
N        MEASURE_STAMP(E_MEASURE_NIR_FR_STR)  \
N        MEASURE_STAMP(E_MEASURE_NIR_FR_END)  \
N        MEASURE_STAMP(E_MEASURE_RESERVED0)  \
N        MEASURE_STAMP(E_MEASURE_RESERVED1)  \
N        MEASURE_STAMP(E_MEASURE_RESERVED2)  \
N        MEASURE_STAMP(E_MEASURE_NUM)  \
N
X#define FOREACH_MEASURE_STAMP(MEASURE_STAMP)         MEASURE_STAMP(E_MEASURE_MAIN_BOOT)           MEASURE_STAMP(E_MEASURE_CHECK_OTA)         MEASURE_STAMP(E_MEASURE_CHECK_OTA_DONE)         MEASURE_STAMP(E_MEASURE_OS_START)          MEASURE_STAMP(E_MEASURE_TOUCH_INIT)          MEASURE_STAMP(E_MEASURE_TOUCH_INIT_DONE)          MEASURE_STAMP(E_MEASURE_LOAD_MODEL)          MEASURE_STAMP(E_MEASURE_LOAD_MODEL_VAR_RESET)          MEASURE_STAMP(E_MEASURE_LOAD_MODEL_FACE_INIT)          MEASURE_STAMP(E_MEASURE_LOAD_MODEL_PROP_INIT)          MEASURE_STAMP(E_MEASURE_LOAD_MODEL_SETTING_INIT)          MEASURE_STAMP(E_MEASURE_LOAD_MODEL_DB_INIT)          MEASURE_STAMP(E_MEASURE_LOAD_MODEL_END)           MEASURE_STAMP(E_MEASURE_RGB_INIT)          MEASURE_STAMP(E_MEASURE_RGB_INIT_DONE)          MEASURE_STAMP(E_MEASURE_NIR_INIT)          MEASURE_STAMP(E_MEASURE_NIR_INIT_DONE)          MEASURE_STAMP(E_MEASURE_RGB_STR)          MEASURE_STAMP(E_MEASURE_RGB_END)          MEASURE_STAMP(E_MEASURE_NIR_STR)          MEASURE_STAMP(E_MEASURE_NIR_END)          MEASURE_STAMP(E_MEASURE_SYS_READY)          MEASURE_STAMP(E_MEASURE_VERIFY_MSG)          MEASURE_STAMP(E_MEASURE_THR_TASKS_INIT)          MEASURE_STAMP(E_MEASURE_THR_TASKS_INIT_RDY)          MEASURE_STAMP(E_MEASURE_THR_CONSOLE_RDY)          MEASURE_STAMP(E_MEASURE_THR_OTA_RDY)          MEASURE_STAMP(E_MEASURE_THR_CAM_RDY)          MEASURE_STAMP(E_MEASURE_BACKLIGHT_ON)          MEASURE_STAMP(E_MEASURE_API_FACE_REC_STR)          MEASURE_STAMP(E_MEASURE_API_RUN_STAT_CHK)          MEASURE_STAMP(E_MEASURE_THR_FDFR_INIT_RDY)          MEASURE_STAMP(E_MEASURE_THR_FDFR_OPEN_RDY)          MEASURE_STAMP(E_MEASURE_THR_FDFR_REC_STR)          MEASURE_STAMP(E_MEASURE_NIR_ISR_01)          MEASURE_STAMP(E_MEASURE_NIR_ISR_02)          MEASURE_STAMP(E_MEASURE_NIR_ISR_03)          MEASURE_STAMP(E_MEASURE_NIR_ISR_04)          MEASURE_STAMP(E_MEASURE_NIR_ISR_05)          MEASURE_STAMP(E_MEASURE_NIR_ISR_06)          MEASURE_STAMP(E_MEASURE_NIR_ISR_07)          MEASURE_STAMP(E_MEASURE_NIR_ISR_08)          MEASURE_STAMP(E_MEASURE_NIR_ISR_09)          MEASURE_STAMP(E_MEASURE_NIR_ISR_10)          MEASURE_STAMP(E_MEASURE_RGB_ISR_01)          MEASURE_STAMP(E_MEASURE_RGB_ISR_02)          MEASURE_STAMP(E_MEASURE_RGB_ISR_03)          MEASURE_STAMP(E_MEASURE_RGB_ISR_04)          MEASURE_STAMP(E_MEASURE_RGB_ISR_05)          MEASURE_STAMP(E_MEASURE_RGB_ISR_06)          MEASURE_STAMP(E_MEASURE_RGB_ISR_07)          MEASURE_STAMP(E_MEASURE_RGB_ISR_08)          MEASURE_STAMP(E_MEASURE_RGB_ISR_09)          MEASURE_STAMP(E_MEASURE_RGB_ISR_10)          MEASURE_STAMP(E_MEASURE_FRAME_1_FACE_STR)          MEASURE_STAMP(E_MEASURE_FRAME_1_FACE_END)          MEASURE_STAMP(E_MEASURE_FRAME_2_FACE_STR)          MEASURE_STAMP(E_MEASURE_FRAME_2_FACE_END)          MEASURE_STAMP(E_MEASURE_FRAME_3_FACE_STR)          MEASURE_STAMP(E_MEASURE_FRAME_3_FACE_END)          MEASURE_STAMP(E_MEASURE_FRAME_4_FACE_STR)          MEASURE_STAMP(E_MEASURE_FRAME_4_FACE_END)          MEASURE_STAMP(E_MEASURE_FRAME_5_FACE_STR)          MEASURE_STAMP(E_MEASURE_FRAME_5_FACE_END)          MEASURE_STAMP(E_MEASURE_FACE_PREEXEC_END)          MEASURE_STAMP(E_MEASURE_FACE_DB_COMP_STR)          MEASURE_STAMP(E_MEASURE_FACE_DB_COMP_END)          MEASURE_STAMP(E_MEASURE_EVENT_SEND_OK)          MEASURE_STAMP(E_MEASURE_FACE_FACE_OK)          MEASURE_STAMP(E_MEASURE_FACE_REC_END)          MEASURE_STAMP(E_MEASURE_FACE_DB_FAIL)          MEASURE_STAMP(E_MEASURE_FACE_CLOSE_STR)          MEASURE_STAMP(E_MEASURE_FACE_CLOSE_END)          MEASURE_STAMP(E_MEASURE_FACTORY_STR)          MEASURE_STAMP(E_MEASURE_FACTORY_END)          MEASURE_STAMP(E_MEASURE_LED_STR)          MEASURE_STAMP(E_MEASURE_LED_END)          MEASURE_STAMP(E_MEASURE_NIR_FD_STR)          MEASURE_STAMP(E_MEASURE_NIR_FD_END)          MEASURE_STAMP(E_MEASURE_NIR_LM_STR)          MEASURE_STAMP(E_MEASURE_NIR_LM_END)          MEASURE_STAMP(E_MEASURE_NIR_LM_S_STR)          MEASURE_STAMP(E_MEASURE_NIR_LM_S_END)          MEASURE_STAMP(E_MEASURE_NIR_QUALITY_STR)          MEASURE_STAMP(E_MEASURE_NIR_QUALITY_END)          MEASURE_STAMP(E_MEASURE_NIR_POSE_STR)          MEASURE_STAMP(E_MEASURE_NIR_POSE_END)          MEASURE_STAMP(E_MEASURE_RGB_FD_STR)          MEASURE_STAMP(E_MEASURE_RGB_FD_END)          MEASURE_STAMP(E_MEASURE_RGB_LM_STR)          MEASURE_STAMP(E_MEASURE_RGB_LM_END)          MEASURE_STAMP(E_MEASURE_RGB_LM_S_STR)          MEASURE_STAMP(E_MEASURE_RGB_LM_S_END)          MEASURE_STAMP(E_MEASURE_NIR_LV_STR)          MEASURE_STAMP(E_MEASURE_NIR_LV_END)          MEASURE_STAMP(E_MEASURE_NIR_HSN_STR)          MEASURE_STAMP(E_MEASURE_NIR_HSN_END)          MEASURE_STAMP(E_MEASURE_FUSE_STR)          MEASURE_STAMP(E_MEASURE_FUSE_END)          MEASURE_STAMP(E_MEASURE_NIR_FR_STR)          MEASURE_STAMP(E_MEASURE_NIR_FR_END)          MEASURE_STAMP(E_MEASURE_RESERVED0)          MEASURE_STAMP(E_MEASURE_RESERVED1)          MEASURE_STAMP(E_MEASURE_RESERVED2)          MEASURE_STAMP(E_MEASURE_NUM)  
N#if (MEASURE_RECOGNITION == YES)
X#if ((0) == 1)
S#define GENERATE_ENUM(ENUM) ENUM,
S#define GENERATE_STRING(STRING) #STRING,
S
Stypedef enum _KL520_MEASURE_STAMP_E {
S    FOREACH_MEASURE_STAMP(GENERATE_ENUM)
S}measure_stamp_e;
S
Sstatic const char *MEASURE_STAMP_STRING[] = {
S    FOREACH_MEASURE_STAMP(GENERATE_STRING)
S};
N#endif
N
N#define NUM_OF_MEASURE (E_MEASURE_NUM)
N
Nvoid kl520_measure_init(void);
N#if (MEASURE_RECOGNITION == YES)
X#if ((0) == 1)
Svoid kl520_measure_stamp(measure_stamp_e eStamp);
N#else 
N#define kl520_measure_stamp(a) //
N#endif
Nvoid kl520_measure_info(void);
N
N/**
N * @brief set user log level
N * \param[in]       cpu_id  0 : scpu, 1 : ncpu
N * \param[in]       level   refer to dbg.h for definition of levels
N * \return          NULL
N*/
Nvoid kl520_api_log_set_user_level(u32 cpu_id, u8 level);
N
Nvoid kl520_api_set_rgb_led_level(BOOL reset, s32 level);
N
N
Nint kl520_engineering_calibration(u8 type, u32 *args);
N
Nvoid kl520_api_ota_switch_SCPU(void);
Nvoid kl520_api_ota_switch_NCPU(void);
Nint kl520_api_model_count(void);
Nint kl520_api_model_version(uint8_t idx);
N
N
N///////////////
N/*  Customer Info API */
N///////////////
Ntypedef struct _KL520_CUSTOMER_INFO_
N{
N    u8  nCusInfo0;
N    u16 nCusInfo1;
N    u32 nCusInfo2;
N    u64 nCusInfo3;
N    u8 nReleaseKey[16];
N    u8 eye_mode_en;
N    u8 verify_threshold;
N    u8 live_threshold;
N    u16 exp_time;
N    u8 gain1;
N    u8 gain2;
N    u8 user_rotate_180;
N    u8 user_db_offset;
N} kl520_customer_info;
N
Nint kl520_api_customer_get(kl520_customer_info *cusinfo);
Nint kl520_api_customer_write(kl520_customer_info *cusinfo);
NBOOL kl520_api_customer_chk_key_exist(u8* ptr, u8 nLen);
Nint kl520_api_customer_clr(void);
Nu32 kl520_api_customer_info(void);
N
N#endif
L 32 "..\..\user\main.c" 2
N#include "scu_reg.h"
L 1 "..\..\..\..\scpu\drivers\include\scu_reg.h" 1
N#ifndef __SCU_REG_H__
N#define __SCU_REG_H__
N
N
N#include "kneron_mozart.h"
N#include "types.h"
N#include "io.h"
N
N
N#define SCU_REG_BTUP_STS                                (SCU_FTSCU100_PA_BASE + 0x0000)
N#define SCU_REG_BTUP_CTRL                               (SCU_FTSCU100_PA_BASE + 0x0004)
N#define SCU_REG_PWR_CTRL                                (SCU_FTSCU100_PA_BASE + 0x0008)
N#define SCU_REG_PWR_MOD                                 (SCU_FTSCU100_PA_BASE + 0x0020)
N#define SCU_REG_INT_STS                                 (SCU_FTSCU100_PA_BASE + 0x0024)
N#define SCU_REG_INT_EN                                  (SCU_FTSCU100_PA_BASE + 0x0028)
N#define SCU_REG_PLL_CTRL                                (SCU_FTSCU100_PA_BASE + 0x0030)
N#define SCU_REG_PLL2_CTRL                               (SCU_FTSCU100_PA_BASE + 0x0040)
N#define SCU_REG_DLL_CTRL                                (SCU_FTSCU100_PA_BASE + 0x0044)
N#define SCU_REG_PWR_VCCSTS                              (SCU_FTSCU100_PA_BASE + 0x0048)
N#define SCU_REG_AHBCLKG                                 (SCU_FTSCU100_PA_BASE + 0x0050)
N#define SCU_REG_SLP_AHBCLKG                             (SCU_FTSCU100_PA_BASE + 0x0058)
N#define SCU_REG_APBCLKG                                 (SCU_FTSCU100_PA_BASE + 0x0060)
N#define SCU_REG_APBCLKG2                                (SCU_FTSCU100_PA_BASE + 0x0064)
N#define SCU_REG_SLP_APBCLKG                             (SCU_FTSCU100_PA_BASE + 0x0068)
N#define SCU_REG_SLP_WAKUP_ST                            (SCU_FTSCU100_PA_BASE + 0x00C0)
N#define SCU_REG_SLP_WAKUP_EN                            (SCU_FTSCU100_PA_BASE + 0x00C4)
N#define SCU_REG_RTC_TIME1                               (SCU_FTSCU100_PA_BASE + 0x0200)
N#define SCU_REG_RTC_TIME2                               (SCU_FTSCU100_PA_BASE + 0x0204)
N#define SCU_REG_RTC_ALM1                                (SCU_FTSCU100_PA_BASE + 0x0208)
N#define SCU_REG_RTC_ALM2                                (SCU_FTSCU100_PA_BASE + 0x020C)
N#define SCU_REG_RTC_CTRL                                (SCU_FTSCU100_PA_BASE + 0x0210)
N
N
N/* Boot-up Status Register (Offset: 0x0000) */
N#define SCU_REG_BTUP_STS_RTC_BTUPTS                     BIT17   // RTC Alarm
N#define SCU_REG_BTUP_STS_PWRBTN_STS                     BIT16   // PWR Button
N#define SCU_REG_BTUP_STS_PMR                            BIT11   // Power Off mode
N#define SCU_REG_BTUP_STS_SMR                            BIT10   // Dormant mode
N#define SCU_REG_BTUP_STS_WDR                            BIT9    // Watchdog reset
N#define SCU_REG_BTUP_STS_HWR                            BIT8    // Hardware reset
N#define SCU_REG_BTUP_STS_PMR1                           BIT7    // Power mode 1
N#define SCU_REG_BTUP_STS_PMR2                           BIT6    // Power mode 2
N/* Boot-up Control Register (Offset: 0x0004) */
N#define SCU_REG_BTUP_CTRL_RTC_BU_EN                     BIT17
N#define SCU_REG_BTUP_CTRL_PWRBTN_EN                     BIT16
N#define SCU_REG_BTUP_CTRL_GPO_1_OUT                     BIT1
N#define SCU_REG_BTUP_CTRL_GPO_OUT                       BIT0
N/* Power Control Register (Offset: 0x0008) */
N#define SCU_REG_PWR_CTRL_PWRUP_UPDATE                   BIT24
N#define SCU_REG_PWR_CTRL_PWRUP_CTRL_DOMAIN_DDRCK        BIT10 // DDRCK domain
N#define SCU_REG_PWR_CTRL_PWRUP_CTRL_DOMAIN_NPU          BIT9 // NPU domain
N#define SCU_REG_PWR_CTRL_PWRUP_CTRL_DOMAIN_DEFAULT      BIT8 // Default domain
N#define SCU_REG_PWR_CTRL_PWRUP_CTRL_MASK                (SCU_REG_PWR_CTRL_PWRUP_CTRL_DOMAIN_DDRCK | \
N                                                         SCU_REG_PWR_CTRL_PWRUP_CTRL_DOMAIN_NPU | \
N                                                         SCU_REG_PWR_CTRL_PWRUP_CTRL_DOMAIN_DEFAULT)
X#define SCU_REG_PWR_CTRL_PWRUP_CTRL_MASK                (SCU_REG_PWR_CTRL_PWRUP_CTRL_DOMAIN_DDRCK |                                                          SCU_REG_PWR_CTRL_PWRUP_CTRL_DOMAIN_NPU |                                                          SCU_REG_PWR_CTRL_PWRUP_CTRL_DOMAIN_DEFAULT)
N
N#define SCU_REG_PWR_CTRL_PWRDN_CTRL_DOMAIN_DDRCK        BIT2 // DDRCK domain
N#define SCU_REG_PWR_CTRL_PWRDN_CTRL_DOMAIN_NPU          BIT1 // NPU domain
N#define SCU_REG_PWR_CTRL_PWRDN_CTRL_DOMAIN_DEFAULT      BIT0 // Default domain
N#define SCU_REG_PWR_CTRL_PWRDN_CTRL_MASK                (SCU_REG_PWR_CTRL_PWRDN_CTRL_DOMAIN_DDRCK | \
N                                                         SCU_REG_PWR_CTRL_PWRDN_CTRL_DOMAIN_NPU | \
N                                                         SCU_REG_PWR_CTRL_PWRDN_CTRL_DOMAIN_DEFAULT)
X#define SCU_REG_PWR_CTRL_PWRDN_CTRL_MASK                (SCU_REG_PWR_CTRL_PWRDN_CTRL_DOMAIN_DDRCK |                                                          SCU_REG_PWR_CTRL_PWRDN_CTRL_DOMAIN_NPU |                                                          SCU_REG_PWR_CTRL_PWRDN_CTRL_DOMAIN_DEFAULT)
N
N
N/* Power Mode Register (Offset: 0x0020) */
N#define SCU_REG_PWR_MOD_SELFR_CMD_OFF                   BIT31 // DDR/SDR self-refresh command off
N#define SCU_REG_PWR_MOD_FCS_PLL2_RSTn                   BIT30 // PLL2 resets in the frequency change sequence
N#define SCU_REG_PWR_MOD_FCS_DLL_RSTn                    BIT29 // DLL resets in the frequency change sequence
N#define SCU_REG_PWR_MOD_FCS_PLL_RSTn                    BIT28 // PLL resets in the frequency change sequence
N#define SCU_REG_PWR_MOD_SW_RST                          BIT10 // Softwar Reset
N#define SCU_REG_PWR_MOD_FCS                             BIT6  // Frequency Change Sequence (FCS)
N#define SCU_REG_PWR_MOD_BUS_SPEED                       BIT5  // BUS speed change command
N#define SCU_REG_PWR_MOD_SOFTOFF                         BIT1
N#define SCU_REG_PWR_MOD_SET_SOFTOFF(val)                SET_MASKED_BIT(SCU_REG_PWR_MOD, val, 1)
N
N/* Interrupt Status Register (Offset : 0x024) */
N#define SCU_REG_INT_STS_PWRSTATE_CHG                    BIT28 //Power domain state change status
N#define SCU_REG_INT_STS_RTC_SEC                         BIT18 //RTC second out interrupt status
N#define SCU_REG_INT_STS_RTC_PER                         BIT17 //RTC periodic interrupt status
N#define SCU_REG_INT_STS_RTC_ALARM                       BIT16 //RTC alarm interrupt status
N#define SCU_REG_INT_STS_PLL_UPDATE                      BIT8 //PLL update finish interrupt status
N#define SCU_REG_INT_STS_FCS                             BIT6 //FCS command finish interrupt status
N#define SCU_REG_INT_STS_BUSSPEED                        BIT5 //BUS speed finish interrupt status
N#define SCU_REG_INT_STS_WAKEUP                          BIT3 //Wake up event status in the sleep mode
N#define SCU_REG_INT_STS_PWRBTN_RISE                     BIT1 //Power button rising interrupt status at the working state
N#define SCU_REG_INT_STS_PWRBTN_FALL                     BIT0 //Power button falling interrupt status at the working state
N
N/* PLL Control Register (Offset: 0x0030) */
N#define SCU_REG_PLL_CTRL_GET_CLKIN_MUX()                GET_BITS(SCU_EXTREG_USB_OTG_CTRL, 4, 5)
N#define SCU_REG_PLL_CTRL_SET_CLKIN_MUX(val)             SET_MASKED_BITS(SCU_EXTREG_USB_OTG_CTRL, val, 4, 5)
N#define SCU_REG_PLL_CTRL_CLKIN_MUX_BIT_START            4
N#define SCU_REG_PLL_CTRL_CLKIN_MUX_MASK                 BIT4 | BIT5 | BIT6 | BIT7
N#define SCU_REG_PLL_CTRL_PLLEN                          BIT0
N
N#define SCU_REG_PLL_CTRL_SET_PLLEN(val)                 SET_MASKED_BIT(SCU_REG_DLL_CTRL, val, 0)
N
N/* Software Reset Mask Register (Offset: 0x0040) */
N#define SCU_REG_PLL2_CTRL_PLL2EN                        BIT0
N#define SCU_REG_PLL2_CTRL_SET_PLL2EN(val)               SET_MASKED_BIT(SCU_REG_PLL2_CTRL, val, 0)
N/* Software Reset Mask Register (Offset: 0x0044) */
N#define SCU_REG_DLL_CTRL_DLLEN                          BIT0
N#define SCU_REG_DLL_CTRL_SET_DLLEN(val)                 SET_MASKED_BIT(SCU_REG_DLL_CTRL, val, 0)
N/* Power Domain Voltage Supplied Status Register (Offset: 0x0048) */
N#define SCU_REG_PWR_VCCSTS_GET_PWR_READY()              GET_BITS(SCU_REG_PWR_VCCSTS, 0, 2)
N#define SCU_REG_PWR_VCCSTS_PWR_READY_DOMAIN_DDRCK       BIT2
N#define SCU_REG_PWR_VCCSTS_PWR_READY_DOMAIN_NPU         BIT1
N#define SCU_REG_PWR_VCCSTS_PWR_READY_DOMAIN_DEFAULT     BIT0
N#define SCU_REG_PWR_VCCSTS_PWR_READY_DOMAIN_MASK        (SCU_REG_PWR_VCCSTS_PWR_READY_DOMAIN_DDRCK | \
N                                                         SCU_REG_PWR_VCCSTS_PWR_READY_DOMAIN_NPU | \
N                                                         SCU_REG_PWR_VCCSTS_PWR_READY_DOMAIN_DEFAULT)
X#define SCU_REG_PWR_VCCSTS_PWR_READY_DOMAIN_MASK        (SCU_REG_PWR_VCCSTS_PWR_READY_DOMAIN_DDRCK |                                                          SCU_REG_PWR_VCCSTS_PWR_READY_DOMAIN_NPU |                                                          SCU_REG_PWR_VCCSTS_PWR_READY_DOMAIN_DEFAULT)
N
N/* AHB Clock Control Register (AHBCLKG, 0x050~0x054) in working state */
N#define SCU_REG_AHBCLKG_HCLK_EN_DPI1_HCLK               BIT21
N#define SCU_REG_AHBCLKG_HCLK_EN_DPI0_HCLK               BIT20
N
N/* APB Clock Control Register (0x060, 0x64) in working state */
N#define SCU_REG_APBCLKG2_PCLK_EN_MIPI_RX1_PHY_PCLK      BIT1
N#define SCU_REG_APBCLKG2_PCLK_EN_MIPI_RX0_PHY_PCLK      BIT0
N
N#define SCU_REG_APBCLKG_PCLK_EN_CSIRX1_PCLK             BIT29
N#define SCU_REG_APBCLKG_PCLK_EN_CSIRX0_PCLK             BIT28
N#define SCU_REG_APBCLKG_PCLK_EN_GPIO_PCLK               BIT20
N#define SCU_REG_APBCLKG_PCLK_EN_PWM_PCLK                BIT17
N#define SCU_REG_APBCLKG_PCLK_EN_I2C3_PCLK               BIT5
N#define SCU_REG_APBCLKG_PCLK_EN_I2C2_PCLK               BIT4
N#define SCU_REG_APBCLKG_PCLK_EN_I2C1_PCLK               BIT3
N#define SCU_REG_APBCLKG_PCLK_EN_I2C0_PCLK               BIT2
N
N#define SCU_REG_APBCLKG2                                (SCU_FTSCU100_PA_BASE + 0x0064)
N
N/* Wakeup Event Status Register (Offset : 0x0C0) */
N#define SCU_REG_SLP_WAUP_EN_GET_SLP_WAKUP_ST0()         GET_BIT(SCU_REG_SLP_WAKUP_ST, 0)
N#define SCU_REG_SLP_WAUP_EN_SET_SLP_WAKUP_ST0(val)      SET_MASKED_BIT(SCU_REG_SLP_WAKUP_ST, val, 0)
N
N/* Wakeup Event Enable Register (Offset : 0x0C4) */
N#define SCU_REG_SLP_WAUP_EN_GET_SLP_WAKUP_EN0()         GET_BIT(SCU_REG_SLP_WAKUP_EN, 0)
N#define SCU_REG_SLP_WAUP_EN_SET_SLP_WAKUP_EN0(val)      SET_MASKED_BIT(SCU_REG_SLP_WAKUP_EN, val, 0)
N
N
N#endif
L 33 "..\..\user\main.c" 2
N#include "scu_extreg.h"
L 1 "..\..\..\..\scpu\drivers\include\scu_extreg.h" 1
N#ifndef __SCU_EXTREG_H__
N#define __SCU_EXTREG_H__
N
N
N#include "kneron_mozart.h"
N#include "types.h"
N#include "io.h"
N
N
N/* I/O pinmux mode */
Nenum {
N    PINMUX_MODE0 = 0,
N    PINMUX_MODE1,
N    PINMUX_MODE2,
N    PINMUX_MODE3,
N    PINMUX_MODE4,
N    PINMUX_MODE5,
N    PINMUX_MODE6,
N    PINMUX_MODE7, 
N};
N
N
N#define PINMUX_SET(reg, mode)                       outw(reg, ((inw(reg) & ~(BIT(2) | BIT(1) | BIT(0))) | mode))
N#define PINMUX_CLR(reg)                             outw(reg, (inw(reg) & ~(BIT(2) | BIT(1) | BIT(0))))
N
N
N#define SCU_EXTREG_PLL0_SETTING                             (SCU_EXTREG_PA_BASE + 0x0000)
N#define SCU_EXTREG_PLL1_SETTING                             (SCU_EXTREG_PA_BASE + 0x0004)
N#define SCU_EXTREG_PLL2_SETTING                             (SCU_EXTREG_PA_BASE + 0x0008)
N#define SCU_EXTREG_PLL3_SETTING                             (SCU_EXTREG_PA_BASE + 0x000C)
N#define SCU_EXTREG_PLL4_SETTING                             (SCU_EXTREG_PA_BASE + 0x0010)
N#define SCU_EXTREG_PLL5_SETTING                             (SCU_EXTREG_PA_BASE + 0x003C)
N#define SCU_EXTREG_CLK_EN0                                  (SCU_EXTREG_PA_BASE + 0x0014)
N#define SCU_EXTREG_CLK_EN1                                  (SCU_EXTREG_PA_BASE + 0x0018)
N#define SCU_EXTREG_CLK_EN2                                  (SCU_EXTREG_PA_BASE + 0x001C)
N#define SCU_EXTREG_CLK_MUX_SEL                              (SCU_EXTREG_PA_BASE + 0x0020)
N#define SCU_EXTREG_CLK_DIV0                                 (SCU_EXTREG_PA_BASE + 0x0024)
N#define SCU_EXTREG_CLK_DIV1                                 (SCU_EXTREG_PA_BASE + 0x0028)
N#define SCU_EXTREG_CLK_DIV2                                 (SCU_EXTREG_PA_BASE + 0x002C)
N#define SCU_EXTREG_CLK_DIV3                                 (SCU_EXTREG_PA_BASE + 0x0030)
N#define SCU_EXTREG_CLK_DIV4                                 (SCU_EXTREG_PA_BASE + 0x0034)
N#define SCU_EXTREG_CLK_DIV5                                 (SCU_EXTREG_PA_BASE + 0x0038)
N#define SCU_EXTREG_SWRST_MASK0                              (SCU_EXTREG_PA_BASE + 0x0040)
N#define SCU_EXTREG_SWRST_MASK1                              (SCU_EXTREG_PA_BASE + 0x0044)
N#define SCU_EXTREG_SWRST_MASK2                              (SCU_EXTREG_PA_BASE + 0x0048)
N#define SCU_EXTREG_SWRST                                    (SCU_EXTREG_PA_BASE + 0x004C)
N#define SCU_EXTREG_CM4_NCPU_CTRL                            (SCU_EXTREG_PA_BASE + 0x0068)
N#define SCU_EXTREG_DDR_CTRL                                 (SCU_EXTREG_PA_BASE + 0x0080)
N#define SCU_EXTREG_USB_OTG_CTRL                             (SCU_EXTREG_PA_BASE + 0x008C)
N#define SCU_EXTREG_CSIRX_CTRL0                              (SCU_EXTREG_PA_BASE + 0x0090)
N#define SCU_EXTREG_CSIRX_CTRL1                              (SCU_EXTREG_PA_BASE + 0x0094)
N#define SCU_EXTREG_DPI2AHB_CTRL                             (SCU_EXTREG_PA_BASE + 0x009C)
N#define SCU_EXTREG_MISC                                     (SCU_EXTREG_PA_BASE + 0x00B0)
N#define SCU_EXTREG_CLK_DIV6                                 (SCU_EXTREG_PA_BASE + 0x00D0)
N#define SCU_EXTREG_CLK_DIV7                                 (SCU_EXTREG_PA_BASE + 0x00D4)
N#define SCU_EXTREG_SPI_CS_N                                 (SCU_EXTREG_PA_BASE + 0x0100)
N#define SCU_EXTREG_SPI_CLK                                  (SCU_EXTREG_PA_BASE + 0x0104)
N#define SCU_EXTREG_SPI_DO                                   (SCU_EXTREG_PA_BASE + 0x0108)
N#define SCU_EXTREG_SPI_DI                                   (SCU_EXTREG_PA_BASE + 0x010C)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0110)
N
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL                        (SCU_EXTREG_PA_BASE + 0x0114)
N#define SCU_EXTREG_SWJ_TRST_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0118)
N#define SCU_EXTREG_SWJ_TDI_IOCTRL                           (SCU_EXTREG_PA_BASE + 0x011C)
N#define SCU_EXTREG_SWJ_SWDITMS_IOCTRL                       (SCU_EXTREG_PA_BASE + 0x0120)
N#define SCU_EXTREG_SWJ_SWCLKTCK_IOCTRL                      (SCU_EXTREG_PA_BASE + 0x0124)
N#define SCU_EXTREG_SWJ_TDO_IOCTRL                           (SCU_EXTREG_PA_BASE + 0x0128)
N#define SCU_EXTREG_LC_PCLK_IOCTRL                           (SCU_EXTREG_PA_BASE + 0x012C)
N#define SCU_EXTREG_LC_VS_IOCTRL                             (SCU_EXTREG_PA_BASE + 0x0130)
N#define SCU_EXTREG_LC_HS_IOCTRL                             (SCU_EXTREG_PA_BASE + 0x0134)
N#define SCU_EXTREG_LC_DE_IOCTRL                             (SCU_EXTREG_PA_BASE + 0x0138)
N#define SCU_EXTREG_LC_DATA0_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x013C)
N#define SCU_EXTREG_LC_DATA1_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0140)
N#define SCU_EXTREG_LC_DATA2_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0144)
N#define SCU_EXTREG_LC_DATA3_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0148)
N#define SCU_EXTREG_LC_DATA4_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x014C)
N#define SCU_EXTREG_LC_DATA5_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0150)
N#define SCU_EXTREG_LC_DATA6_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0154)
N#define SCU_EXTREG_LC_DATA7_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0158)
N#define SCU_EXTREG_LC_DATA8_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x015C)
N#define SCU_EXTREG_LC_DATA9_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0160)
N#define SCU_EXTREG_LC_DATA10_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x0164)
N#define SCU_EXTREG_LC_DATA11_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x0168)
N#define SCU_EXTREG_LC_DATA12_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x016C)
N#define SCU_EXTREG_LC_DATA13_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x0170)
N#define SCU_EXTREG_LC_DATA14_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x0174)
N#define SCU_EXTREG_LC_DATA15_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x0178)
N#define SCU_EXTREG_SD_CLK_IOCTRL                            (SCU_EXTREG_PA_BASE + 0x017C)
N#define SCU_EXTREG_SD_CMD_IOCTRL                            (SCU_EXTREG_PA_BASE + 0x0180)
N#define SCU_EXTREG_SD_DATA0_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0184)
N#define SCU_EXTREG_SD_DATA1_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0188)
N#define SCU_EXTREG_SD_DATA2_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x018C)
N#define SCU_EXTREG_SD_DATA3_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0190)
N#define SCU_EXTREG_UART0_RX_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0194)
N#define SCU_EXTREG_UART0_TX_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0198)
N#define SCU_EXTREG_I2C0_CLK_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x019C)
N#define SCU_EXTREG_I2C0_DATA_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x01A0)
N#define SCU_EXTREG_PWM0_IOCTRL                              (SCU_EXTREG_PA_BASE + 0x01A4)
N#define SCU_EXTREG_OTG_DRV_VBUS_IOCTRL                      (SCU_EXTREG_PA_BASE + 0x01A8)
N#define SCU_EXTREG_SPARE0_IOCTRL                            (SCU_EXTREG_PA_BASE + 0x01B0)
N#define SCU_EXTREG_SPARE1_IOCTRL                            (SCU_EXTREG_PA_BASE + 0x01B4)
N
N
N/* PLL110HH0L */
N/* PLL0 Setting Register (Offset: 0x0000) -- Default power domain */
N/* PLL0 is the clock source of system CM4, system / peripheral bus */
N#define SCU_EXTREG_PLL0_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL0_SETTING, 24, 30)
N#define SCU_EXTREG_PLL0_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL0_SETTING, 16, 20)
N#define SCU_EXTREG_PLL0_SETTING_GET_cc()                    GET_BITS(SCU_EXTREG_PLL0_SETTING, 12, 13)
N#define SCU_EXTREG_PLL0_SETTING_GET_f()                     GET_BITS(SCU_EXTREG_PLL0_SETTING, 8, 9)
N#define SCU_EXTREG_PLL0_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL0_SETTING, 0)
N
N#define SCU_EXTREG_PLL0_SETTING_SET_ns()                    SET_MASKED_BITS(SCU_EXTREG_PLL0_SETTING, 24, 30)
N#define SCU_EXTREG_PLL0_SETTING_SET_ms()                    SET_MASKED_BITS(SCU_EXTREG_PLL0_SETTING, 16, 20)
N#define SCU_EXTREG_PLL0_SETTING_SET_cc()                    SET_MASKED_BITS(SCU_EXTREG_PLL0_SETTING, 12, 13)
N#define SCU_EXTREG_PLL0_SETTING_SET_f()                     SET_MASKED_BITS(SCU_EXTREG_PLL0_SETTING, 8, 9)
N#define SCU_EXTREG_PLL0_SETTING_SET_en()                    SET_MASKED_BIT(SCU_EXTREG_PLL0_SETTING, 0)
N
N/* PLL110HH0L */
N/* PLL1 Setting Register (Offset: 0x0004) -- NPU power domain */
N/* PLL1 is the clock source of neural CM4, and nerual bus */
N#define SCU_EXTREG_PLL1_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL1_SETTING, 24, 30)
N#define SCU_EXTREG_PLL1_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL1_SETTING, 16, 20)
N#define SCU_EXTREG_PLL1_SETTING_GET_cc()                    GET_BITS(SCU_EXTREG_PLL1_SETTING, 12, 13)
N#define SCU_EXTREG_PLL1_SETTING_GET_f()                     GET_BITS(SCU_EXTREG_PLL1_SETTING, 8, 9)
N#define SCU_EXTREG_PLL1_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL1_SETTING, 0)
N
N#define SCU_EXTREG_PLL1_SETTING_SET_ns(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL1_SETTING, val, 24, 30)
N#define SCU_EXTREG_PLL1_SETTING_SET_ms(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL1_SETTING, val, 16, 20)
N#define SCU_EXTREG_PLL1_SETTING_SET_cc(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL1_SETTING, val, 12, 13)
N#define SCU_EXTREG_PLL1_SETTING_SET_f(val)                  SET_MASKED_BITS(SCU_EXTREG_PLL1_SETTING, val, 8, 9)
N#define SCU_EXTREG_PLL1_SETTING_SET_en(val)                 SET_MASKED_BIT(SCU_EXTREG_PLL1_SETTING, val, 0)
N
N/* PLL110HH0L */
N/* PLL2 Setting Register (Offset: 0x0008) -- NPU power domain */
N/* PLL2 is the clock source of DDR controller */
N#define SCU_EXTREG_PLL2_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL2_SETTING, 24, 30)
N#define SCU_EXTREG_PLL2_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL2_SETTING, 16, 20)
N#define SCU_EXTREG_PLL2_SETTING_GET_cc()                    GET_BITS(SCU_EXTREG_PLL2_SETTING, 12, 13)
N#define SCU_EXTREG_PLL2_SETTING_GET_f()                     GET_BITS(SCU_EXTREG_PLL2_SETTING, 8, 9)
N#define SCU_EXTREG_PLL2_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL2_SETTING, 0)
N
N#define SCU_EXTREG_PLL2_SETTING_SET_ns(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL2_SETTING, val, 24, 30)
N#define SCU_EXTREG_PLL2_SETTING_SET_ms(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL2_SETTING, val, 16, 20)
N#define SCU_EXTREG_PLL2_SETTING_SET_cc(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL2_SETTING, val, 12, 13)
N#define SCU_EXTREG_PLL2_SETTING_SET_f(val)                  SET_MASKED_BITS(SCU_EXTREG_PLL2_SETTING, val, 8, 9)
N#define SCU_EXTREG_PLL2_SETTING_SET_en(val)                 SET_MASKED_BIT(SCU_EXTREG_PLL2_SETTING, val, 0)
N
N/* PLL510HH0L */
N/* PLL3 Setting Register (Offset: 0x000C) -- NPU power domain */
N/* PLL3 is the clock source of MIPI CSI RX0 */
N#define SCU_EXTREG_PLL3_SETTING_ps_MASK                     (BIT24|BIT25|BIT26|BIT27|BIT28)
N#define SCU_EXTREG_PLL3_SETTING_ns_MASK                     (BIT12|BIT13|BIT14|BIT15|BIT16|BIT17|BIT18|BIT19|BIT20)
N#define SCU_EXTREG_PLL3_SETTING_ms_MASK                     (BIT8|BIT9|BIT10)
N#define SCU_EXTREG_PLL3_SETTING_is_MASK                     (BIT4|BIT5|BIT6)
N#define SCU_EXTREG_PLL3_SETTING_rs_MASK                     (BIT2|BIT3)
N
N#define SCU_EXTREG_PLL3_SETTING_ps_START                    24
N#define SCU_EXTREG_PLL3_SETTING_ns_START                    12
N#define SCU_EXTREG_PLL3_SETTING_ms_START                    8
N#define SCU_EXTREG_PLL3_SETTING_is_START                    4
N#define SCU_EXTREG_PLL3_SETTING_rs_START                    2
N
N
N#define SCU_EXTREG_PLL3_SETTING_GET_ps()                    GET_BITS(SCU_EXTREG_PLL3_SETTING, 24, 28)
N#define SCU_EXTREG_PLL3_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL3_SETTING, 12, 20)
N#define SCU_EXTREG_PLL3_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL3_SETTING, 8, 10)
N#define SCU_EXTREG_PLL3_SETTING_GET_is()                    GET_BITS(SCU_EXTREG_PLL3_SETTING, 4, 6)
N#define SCU_EXTREG_PLL3_SETTING_GET_rs()                    GET_BITS(SCU_EXTREG_PLL3_SETTING, 2, 3)
N#define SCU_EXTREG_PLL3_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL3_SETTING, 0)
N
N#define SCU_EXTREG_PLL3_SETTING_SET_ps(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL3_SETTING, val, 24, 28)
N#define SCU_EXTREG_PLL3_SETTING_SET_ns(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL3_SETTING, val, 12, 20)
N#define SCU_EXTREG_PLL3_SETTING_SET_ms(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL3_SETTING, val, 8, 10)
N#define SCU_EXTREG_PLL3_SETTING_SET_is(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL3_SETTING, val, 4, 6)
N#define SCU_EXTREG_PLL3_SETTING_SET_rs(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL3_SETTING, val, 2, 3)
N#define SCU_EXTREG_PLL3_SETTING_SET_en(val)                 SET_MASKED_BIT(SCU_EXTREG_PLL3_SETTING, val, 0)
N
N/* PLL510HH0L */
N/* PLL4 Setting Register (Offset: 0x0010) -- Default domain */
N/* PLL4 is the clock source of NPU or audio master clock */
N#define SCU_EXTREG_PLL4_SETTING_GET_ps()                    GET_BITS(SCU_EXTREG_PLL4_SETTING, 24, 28)
N#define SCU_EXTREG_PLL4_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL4_SETTING, 12, 20)
N#define SCU_EXTREG_PLL4_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL4_SETTING, 8, 10)
N#define SCU_EXTREG_PLL4_SETTING_GET_is()                    GET_BITS(SCU_EXTREG_PLL4_SETTING, 4, 6)
N#define SCU_EXTREG_PLL4_SETTING_GET_rs()                    GET_BITS(SCU_EXTREG_PLL4_SETTING, 2, 3)
N#define SCU_EXTREG_PLL4_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL4_SETTING, 0)
N
N#define SCU_EXTREG_PLL4_SETTING_SET_ps(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL4_SETTING, val, 24, 28)
N#define SCU_EXTREG_PLL4_SETTING_SET_ns(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL4_SETTING, val, 12, 20)
N#define SCU_EXTREG_PLL4_SETTING_SET_ms(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL4_SETTING, val, 8, 10)
N#define SCU_EXTREG_PLL4_SETTING_SET_is(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL4_SETTING, val, 4, 6)
N#define SCU_EXTREG_PLL4_SETTING_SET_rs(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL4_SETTING, val, 2, 3)
N#define SCU_EXTREG_PLL4_SETTING_SET_en(val)                 SET_MASKED_BIT(SCU_EXTREG_PLL4_SETTING, val, 0)
N
N/* Clock Enable Register 0 (Offset: 0x0014) */
N#define SCU_EXTREG_CLK_EN0_GET_ncpu_traceclk()              GET_BIT(SCU_EXTREG_CLK_EN0, 24)
N#define SCU_EXTREG_CLK_EN0_GET_scpu_traceclk()              GET_BIT(SCU_EXTREG_CLK_EN0, 23)
N#define SCU_EXTREG_CLK_EN0_GET_ncpu_fclk_src()              GET_BIT(SCU_EXTREG_CLK_EN0, 22)
N#define SCU_EXTREG_CLK_EN0_GET_pll4_fref_pll0()             GET_BIT(SCU_EXTREG_CLK_EN0, 12)
N#define SCU_EXTREG_CLK_EN0_GET_pll5_out2()                  GET_BIT(SCU_EXTREG_CLK_EN0, 9)
N#define SCU_EXTREG_CLK_EN0_GET_pll5_out1()                  GET_BIT(SCU_EXTREG_CLK_EN0, 8)
N#define SCU_EXTREG_CLK_EN0_GET_pll4_out1()                  GET_BIT(SCU_EXTREG_CLK_EN0, 6)
N#define SCU_EXTREG_CLK_EN0_GET_pll3_out2()                  GET_BIT(SCU_EXTREG_CLK_EN0, 5)
N#define SCU_EXTREG_CLK_EN0_GET_pll3_out1()                  GET_BIT(SCU_EXTREG_CLK_EN0, 4)
N#define SCU_EXTREG_CLK_EN0_GET_pll2_out()                   GET_BIT(SCU_EXTREG_CLK_EN0, 2)
N#define SCU_EXTREG_CLK_EN0_GET_pll1_out()                   GET_BIT(SCU_EXTREG_CLK_EN0, 1)
N
N#define SCU_EXTREG_CLK_EN0_SET_ncpu_traceclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 24)
N#define SCU_EXTREG_CLK_EN0_SET_scpu_traceclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 23)
N#define SCU_EXTREG_CLK_EN0_SET_ncpu_fclk_src(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 22)
N#define SCU_EXTREG_CLK_EN0_SET_pll4_fref_pll0(val)          SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 12)
N#define SCU_EXTREG_CLK_EN0_SET_pll5_out2(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 9)
N#define SCU_EXTREG_CLK_EN0_SET_pll5_out1(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 8)
N#define SCU_EXTREG_CLK_EN0_SET_pll4_out1(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 6)
N#define SCU_EXTREG_CLK_EN0_SET_pll3_out2(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 5)
N#define SCU_EXTREG_CLK_EN0_SET_pll3_out1(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 4)
N#define SCU_EXTREG_CLK_EN0_SET_pll2_out(val)                SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 2)
N#define SCU_EXTREG_CLK_EN0_SET_pll1_out(val)                SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 1)
N
N/* Clock Enable Register 1 (Offset: 0x0018) */
N#define SCU_EXTREG_CLK_EN1_GET_spi_clk()                    GET_BIT(SCU_EXTREG_CLK_EN1, 24)
N#define SCU_EXTREG_CLK_EN1_GET_npu()                        GET_BIT(SCU_EXTREG_CLK_EN1, 23)
N#define SCU_EXTREG_CLK_EN1_GET_adcclk()                     GET_BIT(SCU_EXTREG_CLK_EN1, 22)
N#define SCU_EXTREG_CLK_EN1_GET_wdt_extclk()                 GET_BIT(SCU_EXTREG_CLK_EN1, 21)
N#define SCU_EXTREG_CLK_EN1_GET_sdclk()                      GET_BIT(SCU_EXTREG_CLK_EN1, 20)
N#define SCU_EXTREG_CLK_EN1_GET_TxHsPllRefClk()              GET_BIT(SCU_EXTREG_CLK_EN1, 16)
N#define SCU_EXTREG_CLK_EN1_GET_tx_EscClk()                  GET_BIT(SCU_EXTREG_CLK_EN1, 14)
N#define SCU_EXTREG_CLK_EN1_GET_csitx_dsi()                  GET_BIT(SCU_EXTREG_CLK_EN1, 13)
N#define SCU_EXTREG_CLK_EN1_GET_csitx_csi()                  GET_BIT(SCU_EXTREG_CLK_EN1, 12)
N#define SCU_EXTREG_CLK_EN1_GET_csirx1_TxEscClk()            GET_BIT(SCU_EXTREG_CLK_EN1, 10)
N#define SCU_EXTREG_CLK_EN1_GET_csirx1_csi()                 GET_BIT(SCU_EXTREG_CLK_EN1, 9)
N#define SCU_EXTREG_CLK_EN1_GET_csirx1_vc0()                 GET_BIT(SCU_EXTREG_CLK_EN1, 8)
N#define SCU_EXTREG_CLK_EN1_GET_csirx0_TxEscClk()            GET_BIT(SCU_EXTREG_CLK_EN1, 6)
N#define SCU_EXTREG_CLK_EN1_GET_csirx0_csi()                 GET_BIT(SCU_EXTREG_CLK_EN1, 5)
N#define SCU_EXTREG_CLK_EN1_GET_csirx0_vc0()                 GET_BIT(SCU_EXTREG_CLK_EN1, 4)
N#define SCU_EXTREG_CLK_EN1_GET_LC_SCALER()                  GET_BIT(SCU_EXTREG_CLK_EN1, 1)
N#define SCU_EXTREG_CLK_EN1_GET_LC_CLK()                     GET_BIT(SCU_EXTREG_CLK_EN1, 0)
N
N#define SCU_EXTREG_CLK_EN1_SET_spi_clk(val)                 SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 24)
N#define SCU_EXTREG_CLK_EN1_SET_npu(val)                     SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 23)
N#define SCU_EXTREG_CLK_EN1_SET_adcclk(val)                  SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 22)
N#define SCU_EXTREG_CLK_EN1_SET_wdt_extclk(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 21)
N#define SCU_EXTREG_CLK_EN1_SET_sdclk(val)                   SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 20)
N#define SCU_EXTREG_CLK_EN1_SET_TxHsPllRefClk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 16)
N#define SCU_EXTREG_CLK_EN1_SET_tx_EscClk(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 14)
N#define SCU_EXTREG_CLK_EN1_SET_csitx_dsi(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 13)
N#define SCU_EXTREG_CLK_EN1_SET_csitx_csi(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 12)
N#define SCU_EXTREG_CLK_EN1_SET_csirx1_TxEscClk(val)         SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 10)
N#define SCU_EXTREG_CLK_EN1_SET_csirx1_csi(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 9)
N#define SCU_EXTREG_CLK_EN1_SET_csirx1_vc0(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 8)
N#define SCU_EXTREG_CLK_EN1_SET_csirx0_TxEscClk(val)         SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 6)
N#define SCU_EXTREG_CLK_EN1_SET_csirx0_csi(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 5)
N#define SCU_EXTREG_CLK_EN1_SET_csirx0_vc0(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 4)
N#define SCU_EXTREG_CLK_EN1_SET_LC_SCALER(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 1)
N#define SCU_EXTREG_CLK_EN1_SET_LC_CLK(val)                  SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 0)
N
N/* Clock Enable Register 2 (Offset: 0x001C) */
N#define SCU_EXTREG_CLK_EN2_GET_tmr1_extclk3()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 29)
N#define SCU_EXTREG_CLK_EN2_GET_tmr1_extclk2()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 28)
N#define SCU_EXTREG_CLK_EN2_GET_tmr1_extclk1()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 27)
N#define SCU_EXTREG_CLK_EN2_GET_tmr0_extclk3()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 26)
N#define SCU_EXTREG_CLK_EN2_GET_tmr0_extclk2()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 25)
N#define SCU_EXTREG_CLK_EN2_GET_tmr0_extclk1()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 24)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk6()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 21)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk5()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 20)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk4()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 19)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk3()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 18)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk2()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 17)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk1()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 16)
N#define SCU_EXTREG_CLK_EN2_GET_uart1_3_fref()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 15)
N#define SCU_EXTREG_CLK_EN2_GET_uart1_2_fref()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 14)
N#define SCU_EXTREG_CLK_EN2_GET_uart1_1_fref()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 13)
N#define SCU_EXTREG_CLK_EN2_GET_uart1_0_fref()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 12)
N#define SCU_EXTREG_CLK_EN2_GET_uart0_fref()                 GET_BIT(SCU_EXTREG_PLL2_SETTING, 8)
N#define SCU_EXTREG_CLK_EN2_GET_ssp1_1_sspclk()              GET_BIT(SCU_EXTREG_PLL2_SETTING, 6)
N#define SCU_EXTREG_CLK_EN2_GET_ssp1_0_sspclk()              GET_BIT(SCU_EXTREG_PLL2_SETTING, 4)
N#define SCU_EXTREG_CLK_EN2_GET_ssp0_1_sspclk()              GET_BIT(SCU_EXTREG_PLL2_SETTING, 2)
N#define SCU_EXTREG_CLK_EN2_GET_ssp0_0_sspclk()              GET_BIT(SCU_EXTREG_PLL2_SETTING, 0)
N
N#define SCU_EXTREG_CLK_EN2_SET_tmr1_extclk3(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 29)
N#define SCU_EXTREG_CLK_EN2_SET_tmr1_extclk2(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 28)
N#define SCU_EXTREG_CLK_EN2_SET_tmr1_extclk1(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 27)
N#define SCU_EXTREG_CLK_EN2_SET_tmr0_extclk3(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 26)
N#define SCU_EXTREG_CLK_EN2_SET_tmr0_extclk2(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 25)
N#define SCU_EXTREG_CLK_EN2_SET_tmr0_extclk1(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 24)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk6(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 21)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk5(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 20)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk4(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 19)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk3(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 18)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk2(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 17)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk1(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 16)
N#define SCU_EXTREG_CLK_EN2_SET_uart1_3_fref(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 15)
N#define SCU_EXTREG_CLK_EN2_SET_uart1_2_fref(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 14)
N#define SCU_EXTREG_CLK_EN2_SET_uart1_1_fref(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 13)
N#define SCU_EXTREG_CLK_EN2_SET_uart1_0_fref(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 12)
N#define SCU_EXTREG_CLK_EN2_SET_uart0_fref(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 8)
N#define SCU_EXTREG_CLK_EN2_SET_ssp1_1_sspclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 6)
N#define SCU_EXTREG_CLK_EN2_SET_ssp1_0_sspclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 4)
N#define SCU_EXTREG_CLK_EN2_SET_ssp0_1_sspclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 2)
N#define SCU_EXTREG_CLK_EN2_SET_ssp0_0_sspclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 0)
N
N/* Clock Mux Selection Register (Offset: 0x0020) */
N#define SCU_EXTREG_CLK_MUX_SEL_GET_ncpu_traceclk()          GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 14)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_scpu_traceclk_src()      GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 13)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_csirx1_clk()             GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 12)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_npu_clk()                GET_BITS(SCU_EXTREG_CLK_MUX_SEL, 8, 9)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_pll4_fref()              GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 6)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_uart_0_irda_uclk()       GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 4)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_ssp1_1_sspclk()          GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 3)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_ssp1_0_sspclk()          GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 2)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_ssp0_1_sspclk()          GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 1)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_ssp0_0_sspclk()          GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 0)
N
N#define SCU_EXTREG_CLK_MUX_SEL_SET_ncpu_traceclk(val)       SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 14)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_scpu_traceclk_src(val)   SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 13)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_csirx1_clk(val)          SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 12)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_npu_clk(val)             SET_MASKED_BITS(SCU_EXTREG_CLK_MUX_SEL, val, 8, 9)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_pll4_fref(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 6)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_uart_0_irda_uclk(val)    SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 4)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_ssp1_1_sspclk(val)       SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 3)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_ssp1_0_sspclk(val)       SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 2)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_ssp0_1_sspclk(val)       SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 1)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_ssp0_0_sspclk(val)       SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 0)
N
N/* Clock Divider Register 0 (Offset: 0x0024) */
N#define SCU_EXTREG_CLK_DIV0_GET_ncpu_fclk()                 GET_BITS(SCU_EXTREG_CLK_DIV0, 28, 31)
N#define SCU_EXTREG_CLK_DIV0_GET_sdclk2x()                   GET_BITS(SCU_EXTREG_CLK_DIV0, 24, 27)
N#define SCU_EXTREG_CLK_DIV0_GET_spi_clk()                   GET_BITS(SCU_EXTREG_CLK_DIV0, 20, 23)
N#define SCU_EXTREG_CLK_DIV0_GET_pll4_fref_pll0()            GET_BITS(SCU_EXTREG_CLK_DIV0, 8, 12)
N
N#define SCU_EXTREG_CLK_DIV0_SET_ncpu_fclk(val)              SET_MASKED_BITS(SCU_EXTREG_CLK_DIV0, val, 28, 31)
N#define SCU_EXTREG_CLK_DIV0_SET_sdclk2x(val)                SET_MASKED_BITS(SCU_EXTREG_CLK_DIV0, val, 24, 27)
N#define SCU_EXTREG_CLK_DIV0_SET_spi_clk(val)                SET_MASKED_BITS(SCU_EXTREG_CLK_DIV0, val, 20, 23)
N#define SCU_EXTREG_CLK_DIV0_SET_pll4_fref_pll0(val)         SET_MASKED_BITS(SCU_EXTREG_CLK_DIV0, val, 8, 12)
N/* Clock Divider Register 1 (Offset: 0x0028) */
N#define SCU_EXTREG_CLK_DIV1_GET_csirx0_TxEscClk()           GET_BITS(SCU_EXTREG_CLK_DIV1, 28, 31)
N#define SCU_EXTREG_CLK_DIV1_GET_csirx0_csi()                GET_BITS(SCU_EXTREG_CLK_DIV1, 20, 24)
N#define SCU_EXTREG_CLK_DIV1_GET_csirx0_vc0()                GET_BITS(SCU_EXTREG_CLK_DIV1, 12, 16)
N#define SCU_EXTREG_CLK_DIV1_GET_LC_CLK()                    GET_BITS(SCU_EXTREG_CLK_DIV1, 4, 8)
N#define SCU_EXTREG_CLK_DIV1_GET_LC_SCALER_CLK()             GET_BITS(SCU_EXTREG_CLK_DIV1, 0, 3)
N
N#define SCU_EXTREG_CLK_DIV1_SET_csirx0_TxEscClk(val)        SET_MASKED_BITS(SCU_EXTREG_CLK_DIV1, val, 28, 31)
N#define SCU_EXTREG_CLK_DIV1_SET_csirx0_csi(val)             SET_MASKED_BITS(SCU_EXTREG_CLK_DIV1, val, 20, 24)
N#define SCU_EXTREG_CLK_DIV1_SET_csirx0_vc0(val)             SET_MASKED_BITS(SCU_EXTREG_CLK_DIV1, val, 12, 16)
N#define SCU_EXTREG_CLK_DIV1_SET_LC_CLK(val)                 SET_MASKED_BITS(SCU_EXTREG_CLK_DIV1, val, 4, 8)
N#define SCU_EXTREG_CLK_DIV1_SET_LC_SCALER_CLK(val)          SET_MASKED_BITS(SCU_EXTREG_CLK_DIV1, val, 0, 3)
N/* Clock Divider Register 2 (Offset: 0x002C) */
N#define SCU_EXTREG_CLK_DIV2_GET_npu_clk_pll5()              GET_BITS(SCU_EXTREG_CLK_DIV2, 16, 18)
N#define SCU_EXTREG_CLK_DIV2_GET_npu_clk_pll4()              GET_BITS(SCU_EXTREG_CLK_DIV2, 12, 14)
N#define SCU_EXTREG_CLK_DIV2_GET_npu_clk_pll0()              GET_BITS(SCU_EXTREG_CLK_DIV2, 8, 10)
N
N#define SCU_EXTREG_CLK_DIV2_SET_npu_clk_pll5(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV2, val, 16, 18)
N#define SCU_EXTREG_CLK_DIV2_SET_npu_clk_pll4(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV2, val, 12, 14)
N#define SCU_EXTREG_CLK_DIV2_SET_npu_clk_pll0(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV2, val, 8, 10)
N/* Clock Divider Register 3 (Offset: 0x0030) */
N#define SCU_EXTREG_CLK_DIV3_GET_ssp0_1_sspclk_slv()         GET_BITS(SCU_EXTREG_CLK_DIV3, 24, 26) 
N#define SCU_EXTREG_CLK_DIV3_GET_ssp0_1_sspclk_mst()         GET_BITS(SCU_EXTREG_CLK_DIV3, 16, 21)
N#define SCU_EXTREG_CLK_DIV3_GET_ssp0_0_sspclk_slv()         GET_BITS(SCU_EXTREG_CLK_DIV3, 8, 10)
N#define SCU_EXTREG_CLK_DIV3_GET_ssp0_0_sspclk_mst()         GET_BITS(SCU_EXTREG_CLK_DIV3, 0, 5)
N
N#define SCU_EXTREG_CLK_DIV3_SET_ssp0_1_sspclk_slv(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV3, val, 24, 26) 
N#define SCU_EXTREG_CLK_DIV3_SET_ssp0_1_sspclk_mst(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV3, val, 16, 21)
N#define SCU_EXTREG_CLK_DIV3_SET_ssp0_0_sspclk_slv(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV3, val, 8, 10)
N#define SCU_EXTREG_CLK_DIV3_SET_ssp0_0_sspclk_mst(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV3, val, 0, 5)
N/* Clock Divider Register 4 (Offset: 0x0034) */
N#define SCU_EXTREG_CLK_DIV4_GET_ssp1_1_sspclk_slv()         GET_BITS(SCU_EXTREG_CLK_DIV4, 24, 26)
N#define SCU_EXTREG_CLK_DIV4_GET_ssp1_1_sspclk_mst()         GET_BITS(SCU_EXTREG_CLK_DIV4, 16, 21)
N#define SCU_EXTREG_CLK_DIV4_GET_ssp1_0_sspclk_slv()         GET_BITS(SCU_EXTREG_CLK_DIV4, 8, 10)
N#define SCU_EXTREG_CLK_DIV4_GET_ssp1_0_sspclk_mst()         GET_BITS(SCU_EXTREG_CLK_DIV4, 0, 5)
N
N#define SCU_EXTREG_CLK_DIV4_SET_ssp1_1_sspclk_slv(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV4, val, 24, 26)
N#define SCU_EXTREG_CLK_DIV4_SET_ssp1_1_sspclk_mst(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV4, val, 16, 21)
N#define SCU_EXTREG_CLK_DIV4_SET_ssp1_0_sspclk_slv(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV4, val, 8, 10)
N#define SCU_EXTREG_CLK_DIV4_SET_ssp1_0_sspclk_mst(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV4, val, 0, 5)
N
N/* PLL510HH0L */
N/* PLL5 Setting Register (Offset: 0x003C) -- Disp -- NPU Domain */
N/* PLL5 is the clock source of pixel clock, MIPI CSI/DPI TX clock, or MIPI CSI RX1 clock*/
N#define SCU_EXTREG_PLL5_SETTING_ps_MASK                     (BIT24|BIT25|BIT26|BIT27|BIT28)
N#define SCU_EXTREG_PLL5_SETTING_ns_MASK                     (BIT12|BIT13|BIT14|BIT15|BIT16|BIT17|BIT18|BIT19|BIT20)
N#define SCU_EXTREG_PLL5_SETTING_ms_MASK                     (BIT8|BIT9|BIT10)
N#define SCU_EXTREG_PLL5_SETTING_is_MASK                     (BIT4|BIT5|BIT6)
N#define SCU_EXTREG_PLL5_SETTING_rs_MASK                     (BIT2|BIT3)
N
N#define SCU_EXTREG_PLL5_SETTING_ps_START                    24
N#define SCU_EXTREG_PLL5_SETTING_ns_START                    12
N#define SCU_EXTREG_PLL5_SETTING_ms_START                    8
N#define SCU_EXTREG_PLL5_SETTING_is_START                    4
N#define SCU_EXTREG_PLL5_SETTING_rs_START                    2
N
N#define SCU_EXTREG_PLL5_SETTING_GET_ps()                    GET_BITS(SCU_EXTREG_PLL5_SETTING, 24, 28)
N#define SCU_EXTREG_PLL5_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL5_SETTING, 12, 20)
N#define SCU_EXTREG_PLL5_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL5_SETTING, 8, 10)
N#define SCU_EXTREG_PLL5_SETTING_GET_is()                    GET_BITS(SCU_EXTREG_PLL5_SETTING, 4, 6)
N#define SCU_EXTREG_PLL5_SETTING_GET_rs()                    GET_BITS(SCU_EXTREG_PLL5_SETTING, 2, 3)
N#define SCU_EXTREG_PLL5_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL5_SETTING, 0)
N
N#define SCU_EXTREG_PLL5_SETTING_SET_ps(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL5_SETTING, val, 24, 28)
N#define SCU_EXTREG_PLL5_SETTING_SET_ns(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL5_SETTING, val, 12, 20)
N#define SCU_EXTREG_PLL5_SETTING_SET_ms(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL5_SETTING, val, 8, 10)
N#define SCU_EXTREG_PLL5_SETTING_SET_is(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL5_SETTING, val, 4, 6)
N#define SCU_EXTREG_PLL5_SETTING_SET_rs(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL5_SETTING, val, 2, 3)
N#define SCU_EXTREG_PLL5_SETTING_SET_en(val)                 SET_MASKED_BIT(SCU_EXTREG_PLL5_SETTING, val, 0)
N
N/* Software Reset mask Register 0 (Offset: 0x0040) */
N#define SCU_EXTREG_SWRST_MASK0_GET_cpu_resetreq_n()         GET_BIT(SCU_EXTREG_SWRST_MASK0, 0)
N
N#define SCU_EXTREG_SWRST_MASK0_SET_cpu_resetreq_n(val)      SET_MASKED_BIT(SCU_EXTREG_SWRST_MASK0, val, 0)
N
N/* Software Reset mask Register 1 (Offset: 0x0044) */
N#define SCU_EXTREG_SWRST_MASK1_lcm_reset_n                  BIT23
N#define SCU_EXTREG_SWRST_MASK1_AResetn_u_FTLCDC210          BIT20
N#define SCU_EXTREG_SWRST_MASK1_PRESETn_u_FTLCDC210          BIT19
N#define SCU_EXTREG_SWRST_MASK1_TV_RSTn_FTLCDC210            BIT18
N#define SCU_EXTREG_SWRST_MASK1_LC_SCALER_RSTn_FTLCDC210     BIT17
N#define SCU_EXTREG_SWRST_MASK1_LC_RSTn_FTLCDC210            BIT16
N
N#define SCU_EXTREG_SWRST_MASK1_GET_lcm_reset_n()            GET_BIT(SCU_EXTREG_PLL5_SETTING, 23)
N#define SCU_EXTREG_SWRST_MASK1_SET_lcm_reset_n(val)         SET_MASKED_BIT(SCU_EXTREG_PLL5_SETTING, val, 23)
N
N/* Software Reset mask Register 2 (Offset: 0x0048) */
N
N
N/* Software Reset Register (Offset: 0x004C) */
N#define SCU_EXTREG_SWRST_GET_NPU_resetn()                   GET_BIT(SCU_EXTREG_SWRST, 2)
N#define SCU_EXTREG_SWRST_GET_PD_NPU_resetn()                GET_BIT(SCU_EXTREG_SWRST, 1)
N#define SCU_EXTREG_SWRST_GET_LCDC_resetn()                  GET_BIT(SCU_EXTREG_SWRST, 0)
N
N#define SCU_EXTREG_SWRST_SET_NPU_resetn(val)                SET_MASKED_BIT(SCU_EXTREG_SWRST, val, 2)
N#define SCU_EXTREG_SWRST_SET_PD_NPU_resetn(val)             SET_MASKED_BIT(SCU_EXTREG_SWRST, val, 1)
N#define SCU_EXTREG_SWRST_SET_LCDC_resetn(val)               SET_MASKED_BIT(SCU_EXTREG_SWRST, val, 0)
N
N/* CM4 NCPU Control Register 0 (Offset: 0x0068) */
N#define SCU_EXTREG_CM4_NCPU_CTRL_GET_wakeup()               GET_BIT(SCU_EXTREG_CM4_NCPU_CTRL, 12)
N#define SCU_EXTREG_CM4_NCPU_CTRL_SET_wakeup(val)            SET_MASKED_BIT(SCU_EXTREG_CM4_NCPU_CTRL, val, 12)
N
N/* DDR CTRL Register 0 (Offset: 0x0080) */
N#define SCU_EXTREG_DDR_CTRL_Dphy_resetn                     BIT29
N#define SCU_EXTREG_DDR_CTRL_wakeup                          BIT28
N#define SCU_EXTREG_DDR_CTRL_SELFBIAS                        BIT15
N
N#define SCU_EXTREG_DDR_CTRL_SET_Dphy_resetn(val)            SET_MASKED_BIT(SCU_EXTREG_DDR_CTRL, val, 29)
N#define SCU_EXTREG_DDR_CTRL_SET_wakeup(val)                 SET_MASKED_BIT(SCU_EXTREG_DDR_CTRL, val, 28)
N#define SCU_EXTREG_DDR_CTRL_SET_SELFBIAS(val)               SET_MASKED_BIT(SCU_EXTREG_DDR_CTRL, val, 15)
N
N/* USB OTG CTRL Register (Offset: 0x008C) */
N#define SCU_EXTREG_USB_OTG_CTRL_GET_EXTCTRL_SUSPENDM()      GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 8)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_u_iddig()               GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 7)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_wakeup()                GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 6)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_l1_wakeup()             GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 5)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_OSCOUTEN()              GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 4)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_PLLALIV()               GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 3)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_XTLSEL()                GET_BITS(SCU_EXTREG_USB_OTG_CTRL, 1, 2)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_OUTCLKSEL()             GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 0)
N
N#define SCU_EXTREG_USB_OTG_CTRL_SET_EXTCTRL_SUSPENDM(val)   SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 8)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_u_iddig(val)            SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 7)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_wakeup(val)             SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 6)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_l1_wakeup(val)          SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 5)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_OSCOUTEN(val)           SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 4)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_PLLALIV(val)            SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 3)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_XTLSEL(val)             SET_MASKED_BITS(SCU_EXTREG_USB_OTG_CTRL, val, 1, 2)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_OUTCLKSEL(val)          SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 0)
N
N/* CSIRX CTRL Register 0 (Offset: 0x0090) */
N#define SCU_EXTREG_CSIRX_CTRL0_apb_rst_n                    BIT28
N#define SCU_EXTREG_CSIRX_CTRL0_pwr_rst_n                    BIT25
N#define SCU_EXTREG_CSIRX_CTRL0_sys_rst_n                    BIT24
N#define SCU_EXTREG_CSIRX_CTRL0_ClkLnEn                      BIT1
N#define SCU_EXTREG_CSIRX_CTRL0_Enable                       BIT0
N
N#define SCU_EXTREG_CSIRX_CTRL0_GET_apb_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 28)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_pwr_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 25)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_sys_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 24)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DP1()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 17)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DN1()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 16)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DP0()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 15)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DN0()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 14)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_CKP()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 13)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_CKN()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 12)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_ClkLnEn()                GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 1)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_Enable()                 GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 0)
N
N#define SCU_EXTREG_CSIRX_CTRL0_SET_apb_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 28)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_pwr_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 25)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_sys_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 24)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_DP1(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 17)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_DN1(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 16)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_DP0(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 15)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_DN0(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 14)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_CKP(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 13)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_CKN(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 12)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_ClkLnEn(val)             SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 1)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_Enable(val)              SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 0)
N
N/* CSIRX CTRL Register 1 (Offset: 0x0094) */
N#define SCU_EXTREG_CSIRX_CTRL1_apb_rst_n                    BIT28
N#define SCU_EXTREG_CSIRX_CTRL1_pwr_rst_n                    BIT25
N#define SCU_EXTREG_CSIRX_CTRL1_sys_rst_n                    BIT24
N#define SCU_EXTREG_CSIRX_CTRL1_ClkLnEn                      BIT1
N#define SCU_EXTREG_CSIRX_CTRL1_Enable                       BIT0
N
N#define SCU_EXTREG_CSIRX_CTRL1_GET_apb_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 28)
N#define SCU_EXTREG_CSIRX_CTRL1_GET_pwr_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 25)
N#define SCU_EXTREG_CSIRX_CTRL1_GET_sys_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 24)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DP1_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 17)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DN1_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 16)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DP0_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 15)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DN0_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 14)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_CKP_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 13)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_CKN_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 12)
N#define SCU_EXTREG_CSIRX_CTRL1_GET_ClkLnEn()                GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 1)
N#define SCU_EXTREG_CSIRX_CTRL1_GET_Enable()                 GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 0)
N
N#define SCU_EXTREG_CSIRX_CTRL1_SET_apb_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 28)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_pwr_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 25)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_sys_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 24)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_DP1_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 17)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_DN1_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 16)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_DP0_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 15)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_DN0_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 14)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_CKP_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 13)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_CKN_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 12)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_ClkLnEn(val)             SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 1)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_Enable(val)              SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 0)
N
N/* DPIAHB Control Register (Offset: 0x009C) */
N#define SCU_EXTREG_DPI2AHB_CTRL_rst_n_1                     BIT7
N#define SCU_EXTREG_DPI2AHB_CTRL_apb_rst_n_1                 BIT6
N#define SCU_EXTREG_DPI2AHB_CTRL_sys_rst_n_1                 BIT5
N#define SCU_EXTREG_DPI2AHB_CTRL_pwr_rst_n_1                 BIT4
N#define SCU_EXTREG_DPI2AHB_CTRL_rst_n                       BIT3
N#define SCU_EXTREG_DPI2AHB_CTRL_apb_rst_n                   BIT2
N#define SCU_EXTREG_DPI2AHB_CTRL_sys_rst_n                   BIT1
N#define SCU_EXTREG_DPI2AHB_CTRL_pwr_rst_n                   BIT0
N
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_rst_n_1()               GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 7)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_apb_rst_n_1()           GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 6)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_sys_rst_n_1()           GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 5)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_pwr_rst_n_1()           GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 4)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_rst_n()                 GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 3)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_apb_rst_n()             GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 2)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_sys_rst_n()             GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 1)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_pwr_rst_n()             GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 0)
N
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_rst_n_1(val)            SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 7)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_apb_rst_n_1(val)        SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 6)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_sys_rst_n_1(val)        SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 5)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_pwr_rst_n_1(val)        SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 4)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_rst_n(val)              SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 3)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_apb_rst_n(val)          SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 2)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_sys_rst_n(val)          SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 1)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_pwr_rst_n(val)          SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 0)
N
N/* Misc Register (Offset: 0x00B0) */
N#define SCU_EXTREG_MISC_GET_smr_por_n()                     GET_BITS(SCU_EXTREG_MISC, 4, 6)
N#define SCU_EXTREG_MISC_GET_lcm_cken()                      GET_BIT(SCU_EXTREG_MISC, 12)
N#define SCU_EXTREG_MISC_SET_lcm_cken(val)                   SET_MASKED_BIT(SCU_EXTREG_MISC, val, 12)
N
N
N#define SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DDRCK      BIT6
N#define SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_NPU        BIT5
N#define SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DEFAULT    BIT4
N#define SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_MASK       (SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DDRCK | \
N                                                             SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_NPU | \
N                                                             SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DEFAULT)
X#define SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_MASK       (SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DDRCK |                                                              SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_NPU |                                                              SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DEFAULT)
N
N/* Clock Divider Register 6 (Offset: 0x00D0) */
N#define SCU_EXTREG_CLK_DIV6_GET_uart1_3_fref()              GET_BITS(SCU_EXTREG_CLK_DIV6, 24, 26)
N#define SCU_EXTREG_CLK_DIV6_GET_uart1_2_fref()              GET_BITS(SCU_EXTREG_CLK_DIV6, 20, 22)
N#define SCU_EXTREG_CLK_DIV6_GET_uart1_1_fref()              GET_BITS(SCU_EXTREG_CLK_DIV6, 16, 18)
N#define SCU_EXTREG_CLK_DIV6_GET_uart1_0_fref()              GET_BITS(SCU_EXTREG_CLK_DIV6, 12, 14)
N#define SCU_EXTREG_CLK_DIV6_GET_uart0_fref()                GET_BITS(SCU_EXTREG_CLK_DIV6, 8, 10)
N#define SCU_EXTREG_CLK_DIV6_GET_uart0_fir_fref()            GET_BITS(SCU_EXTREG_CLK_DIV6, 0, 4)
N
N#define SCU_EXTREG_CLK_DIV6_SET_uart1_3_fref(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 24, 26)
N#define SCU_EXTREG_CLK_DIV6_SET_uart1_2_fref(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 20, 22)
N#define SCU_EXTREG_CLK_DIV6_SET_uart1_1_fref(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 16, 18)
N#define SCU_EXTREG_CLK_DIV6_SET_uart1_0_fref(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 12, 14)
N#define SCU_EXTREG_CLK_DIV6_SET_uart0_fref(val)             SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 8, 10)
N#define SCU_EXTREG_CLK_DIV6_SET_uart0_fir_fref(val)         SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 0, 4)
N/* Clock Divider Register 7 (Offset: 0x00D4) */
N#define SCU_EXTREG_CLK_DIV7_csirx1_TxEscClk_pll3_MASK       (BIT16|BIT17|BIT18|BIT19)
N#define SCU_EXTREG_CLK_DIV7_csi1_csi_pll3_MASK              (BIT8|BIT9|BIT10|BIT11|BIT12)
N#define SCU_EXTREG_CLK_DIV7_csi1_vc0_pll3_MASK              (BIT0|BIT1|BIT2|BIT3|BIT4)
N
N#define SCU_EXTREG_CLK_DIV7_csirx1_TxEscClk_pll3_START      16
N#define SCU_EXTREG_CLK_DIV7_csi1_csi_pll3_MASK_START        8
N#define SCU_EXTREG_CLK_DIV7_csi1_vc0_pll3_MASK_START        0
N
N#define SCU_EXTREG_CLK_DIV7_GET_ncpu_traceclk_div()         GET_BITS(SCU_EXTREG_CLK_DIV7, 23, 25)
N#define SCU_EXTREG_CLK_DIV7_GET_scpu_traceclk_div()         GET_BITS(SCU_EXTREG_CLK_DIV7, 20, 22)
N//csirx1_TxEscClk_pll5 / tx_TxEscClk / 
N#define SCU_EXTREG_CLK_DIV7_GET_csirx1_TxEscClk_pll3()      GET_BITS(SCU_EXTREG_CLK_DIV7, 16, 19)
N//csirx1_csi_pll3 / csitx_csi / dsitx_dsi / csirx1_csi_clk_pll5
N#define SCU_EXTREG_CLK_DIV7_GET_csi1_csi_pll3()             GET_BITS(SCU_EXTREG_CLK_DIV7, 8, 12)
N//csirx1_csi_pll3 / csitx_csi / dsitx_dsi / csirx1_csi_clk_pll5
N#define SCU_EXTREG_CLK_DIV7_GET_csi1_vc0_pll3()             GET_BITS(SCU_EXTREG_CLK_DIV7, 0, 4)
N
N#define SCU_EXTREG_CLK_DIV7_SET_ncpu_traceclk_div(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV7, val, 23, 25)
N#define SCU_EXTREG_CLK_DIV7_SET_scpu_traceclk_div(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV7, val, 20, 22)
N#define SCU_EXTREG_CLK_DIV7_SET_csirx1_TxEscClk_pll3(val)   SET_MASKED_BITS(SCU_EXTREG_CLK_DIV7, val, 16, 19)
N#define SCU_EXTREG_CLK_DIV7_SET_csi1_csi_pll3(val)          SET_MASKED_BITS(SCU_EXTREG_CLK_DIV7, val, 8, 12)
N#define SCU_EXTREG_CLK_DIV7_SET_csi1_vc0_pll3(val)          SET_MASKED_BITS(SCU_EXTREG_CLK_DIV7, val, 0, 4)
N
N
N/* SPI_CS_N IO control register (Offset 0x0100) */
N#define SCU_EXTREG_SPI_CS_N_GET_dcsr()                      GET_BITS(SCU_EXTREG_SPI_CS_N, 5, 8)
N#define SCU_EXTREG_SPI_CS_N_GET_pd()                        GET_BIT(SCU_EXTREG_SPI_CS_N, 4)
N#define SCU_EXTREG_SPI_CS_N_GET_pu()                        GET_BIT(SCU_EXTREG_SPI_CS_N, 3)
N
N#define SCU_EXTREG_SPI_CS_N_SET_dcsr(val)                   SET_MASKED_BITS(SCU_EXTREG_SPI_CS_N, val, 5, 8)
N#define SCU_EXTREG_SPI_CS_N_SET_pd(val)                     SET_MASKED_BIT(SCU_EXTREG_SPI_CS_N, 4)
N#define SCU_EXTREG_SPI_CS_N_SET_pu(val)                     SET_MASKED_BIT(SCU_EXTREG_SPI_CS_N, 3)
N
N/* SPI_CLK IO control register (Offset 0x0104) */
N#define SCU_EXTREG_SPI_CLK_GET_dcsr()                       GET_BITS(SCU_EXTREG_SPI_CLK, 5, 8)
N#define SCU_EXTREG_SPI_CLK_GET_pd()                         GET_BIT(SCU_EXTREG_SPI_CLK, 4)
N#define SCU_EXTREG_SPI_CLK_GET_pu()                         GET_BIT(SCU_EXTREG_SPI_CLK, 3)
N#define SCU_EXTREG_SPI_CLK_SET_dcsr(val)                    SET_MASKED_BITS(SCU_EXTREG_SPI_CLK, val, 5, 8)
N#define SCU_EXTREG_SPI_CLK_SET_pd(val)                      SET_MASKED_BIT(SCU_EXTREG_SPI_CLK, 4)
N#define SCU_EXTREG_SPI_CLK_SET_pu(val)                      SET_MASKED_BIT(SCU_EXTREG_SPI_CLK, 3)
N
N/* SPI_CLK IO control register (Offset 0x0108) */
N#define SCU_EXTREG_SPI_DO_GET_dcsr()                        GET_BITS(SCU_EXTREG_SPI_DO, 5, 8)
N#define SCU_EXTREG_SPI_DO_GET_pd()                          GET_BIT(SCU_EXTREG_SPI_DO, 4)
N#define SCU_EXTREG_SPI_DO_GET_pu()                          GET_BIT(SCU_EXTREG_SPI_DO, 3)
N#define SCU_EXTREG_SPI_DO_SET_dcsr(val)                     SET_MASKED_BITS(SCU_EXTREG_SPI_DO, val, 5, 8)
N#define SCU_EXTREG_SPI_DO_SET_pd(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_DO, 4)
N#define SCU_EXTREG_SPI_DO_SET_pu(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_DO, 3)
N
N/* SPI_CLK IO control register (Offset 0x010C) */
N#define SCU_EXTREG_SPI_DI_GET_dcsr()                        GET_BITS(SCU_EXTREG_SPI_DI, 5, 8)
N#define SCU_EXTREG_SPI_DI_GET_pd()                          GET_BIT(SCU_EXTREG_SPI_DI, 4)
N#define SCU_EXTREG_SPI_DI_GET_pu()                          GET_BIT(SCU_EXTREG_SPI_DI, 3)
N#define SCU_EXTREG_SPI_DI_SET_dcsr(val)                     SET_MASKED_BITS(SCU_EXTREG_SPI_DI, val, 5, 8)
N#define SCU_EXTREG_SPI_DI_SET_pd(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_DI, 4)
N#define SCU_EXTREG_SPI_DI_SET_pu(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_DI, 3)
N
N
N/* SPI_CLK IO control register (Offset 0x0110) */
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_GET_dcsr()                        GET_BITS(SCU_EXTREG_SPI_WP_N_IOCTRL, 5, 8)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_GET_pd()                          GET_BIT(SCU_EXTREG_SPI_WP_N_IOCTRL, 4)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_GET_pu()                          GET_BIT(SCU_EXTREG_SPI_WP_N_IOCTRL, 3)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_SET_dcsr(val)                     SET_MASKED_BITS(SCU_EXTREG_SPI_WP_N_IOCTRL, val, 5, 8)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_SET_pd(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_WP_N_IOCTRL, 4)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_SET_pu(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_WP_N_IOCTRL, 3)
N
N/* SPI_CLK IO control register (Offset 0x0114) */
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_GET_pd()                          GET_BIT(SCU_EXTREG_SPI_HOLD_N_IOCTRL, 4)
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_GET_dcsr()                        GET_BITS(SCU_EXTREG_SPI_HOLD_N_IOCTRL, 5, 8)
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_GET_pu()                          GET_BIT(SCU_EXTREG_SPI_HOLD_N_IOCTRL, 3)
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_SET_dcsr(val)                     SET_MASKED_BITS(SCU_EXTREG_SPI_HOLD_N_IOCTRL, val, 5, 8)
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_SET_pd(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_HOLD_N_IOCTRL, 4)
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_SET_pu(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_HOLD_N_IOCTRL, 3)
N
N
N
N/* LC_DATA6 IO control register (Offset 0x0154) */
N#define SCU_EXTREG_LC_DATA6_GET_dcsr()                      GET_BITS(SCU_EXTREG_LC_DATA6_IOCTRL, 5, 8)
N#define SCU_EXTREG_LC_DATA6_GET_pd()                        GET_BIT(SCU_EXTREG_LC_DATA6_IOCTRL, 4)
N#define SCU_EXTREG_LC_DATA6_GET_pu()                        GET_BIT(SCU_EXTREG_LC_DATA6_IOCTRL, 3)
N#define SCU_EXTREG_LC_DATA6_SET_dcsr(val)                   SET_MASKED_BITS(SCU_EXTREG_LC_DATA6_IOCTRL, val, 5, 8)
N#define SCU_EXTREG_LC_DATA6_SET_pd(val)                     SET_MASKED_BIT(SCU_EXTREG_LC_DATA6_IOCTRL, 4)
N#define SCU_EXTREG_LC_DATA6_SET_pu(val)                     SET_MASKED_BIT(SCU_EXTREG_LC_DATA6_IOCTRL, 3)
N
N/* LC_DATA7 IO control register (Offset 0x0158) */
N#define SCU_EXTREG_LC_DATA7_GET_dcsr()                      GET_BITS(SCU_EXTREG_LC_DATA7_IOCTRL, 5, 8)
N#define SCU_EXTREG_LC_DATA7_GET_pd()                        GET_BIT(SCU_EXTREG_LC_DATA7_IOCTRL, 4)
N#define SCU_EXTREG_LC_DATA7_GET_pu()                        GET_BIT(SCU_EXTREG_LC_DATA7_IOCTRL, 3)
N#define SCU_EXTREG_LC_DATA7_SET_dcsr(val)                   SET_MASKED_BITS(SCU_EXTREG_LC_DATA7_IOCTRL, val, 5, 8)
N#define SCU_EXTREG_LC_DATA7_SET_pd(val)                     SET_MASKED_BIT(SCU_EXTREG_LC_DATA7_IOCTRL, 4)
N#define SCU_EXTREG_LC_DATA7_SET_pu(val)                     SET_MASKED_BIT(SCU_EXTREG_LC_DATA7_IOCTRL, 3)
N
N//LC DATA 15
N#define SCU_EXTREG_LC_DATA15_GET_dcsr()                     GET_BITS(SCU_EXTREG_LC_DATA15_IOCTRL, 5, 8)
N#define SCU_EXTREG_LC_DATA15_SET_dcsr(val)                  SET_MASKED_BITS(SCU_EXTREG_LC_DATA15_IOCTRL, val, 5, 8)
N
Ntypedef struct {
N    volatile unsigned int pll0_setting;
N    volatile unsigned int pll1_setting;
N    volatile unsigned int pll2_setting;
N    volatile unsigned int pll3_setting;
N    volatile unsigned int pll4_setting;
N    volatile unsigned int clk_en0;
N    volatile unsigned int clk_en1;
N    volatile unsigned int clk_en2;
N    volatile unsigned int clk_muxsel;
N    volatile unsigned int clk_div0;
N    volatile unsigned int clk_div1;
N    volatile unsigned int clk_div2;
N    volatile unsigned int clk_div3;
N    volatile unsigned int clk_div4;
N    volatile unsigned int clk_div5;
N    volatile unsigned int reserved01;
N    volatile unsigned int pll5_setting;    
N    volatile unsigned int clk_div6;
N    volatile unsigned int clk_div7;    
N    volatile unsigned int reserved02[10];
N    volatile unsigned int spi_cs_n_io;
N    volatile unsigned int spi_clk_io;
N    volatile unsigned int spi_do_io;
N    volatile unsigned int spi_di_io;
N    volatile unsigned int spi_wp_n_io;
N    volatile unsigned int spi_hold_n_io;
N    volatile unsigned int swj_trst_io;
N    volatile unsigned int swj_tdi_io;
N    volatile unsigned int swj_swditms_io;
N    volatile unsigned int swj_swclktck_io;
N    volatile unsigned int swj_swj_tdo_io;
N    volatile unsigned int lc_pclk_io;
N    /* To Do */
N    
N} kdp520_scu_extreg;
N
N
N#endif
L 34 "..\..\user\main.c" 2
N#include "bootloader.h"
L 1 "..\..\..\..\scpu\lib\kdp_system\inc\bootloader.h" 1
N#ifndef __BOOTLOADER_H__
N#define __BOOTLOADER_H__
N
N
N#include "types.h"
N
Nu32 kdp_sys_get_spl_version(void);
N
N
N#endif
L 35 "..\..\user\main.c" 2
N#include "power.h"
L 1 "..\..\..\..\scpu\drivers\include\power.h" 1
N#ifndef __POWER_H__
N#define __POWER_H__
N
N
N#include "types.h"
N
N/* Power Domains */
N#define POWER_DOMAIN_DEFAULT        1
N#define POWER_DOMAIN_NPU            2
N#define POWER_DOMAIN_DDRCK          3
N
Nenum power_mgr_ops {
N    POWER_MGR_OPS_FCS = 0,
N    POWER_MGR_OPS_CHANGE_BUS_SPEED,
N    POWER_MGR_OPS_PLL_UPDATE,
N    POWER_MGR_OPS_SLEEPING,    
N};
N
Nenum power_mgr_mode {
N    POWER_MGR_MODE_RTC = 0,          //rtc
N    POWER_MGR_MODE_ALWAYSON,         //rtc + default 
N    POWER_MGR_MODE_FULL,             //rtc + default + ddr + npu
N    POWER_MGR_MODE_RETENTION,        //rtc + default + ddr(self-refresh)
N    POWER_MGR_MODE_DEEP_RETENTION    //rtc + ddr(self-refresh)
N};
N
Nvoid power_mgr_ops(enum power_mgr_ops ops);
Nvoid power_mgr_set_mode(enum power_mgr_mode mode);
N//low level power manager api
Nvoid power_mgr_set_domain(u32 domain, int enable);
Nvoid power_mgr_set_domain_2(u32 types, BOOL enable);
Nvoid power_mgr_sw_reset(void);
Nvoid power_mgr_softoff(enum power_mgr_mode mode);
N//#define DEBUG_POWER_MGR
N#ifndef DEBUG_POWER_MGR
Nvoid power_mgr_test(void);
N#endif
N
N
N#endif
L 36 "..\..\user\main.c" 2
N#include "system.h"
L 1 "..\..\..\..\scpu\drivers\include\system.h" 1
N#ifndef __SYSTEM_H__
N#define __SYSTEM_H__
N
N
Nvoid system_init(void);
Nvoid system_wakeup_ncpu(unsigned char wakeup_all);
Nvoid system_init_ncpu(void);
Nvoid load_ncpu_fw(int reset_flag);
N
N#endif
L 37 "..\..\user\main.c" 2
N#include "clock.h"
L 1 "..\..\..\..\scpu\drivers\include\clock.h" 1
N#ifdef USE_KDRV
S#include "drivers.h"
S#include "kdrv_clock.h"
N#else
N#ifndef __CLOCK_H__
N#define __CLOCK_H__
N
N
N#include <types.h>
N
Nenum clk {
N    CLK_PLL1            = 1,
N    CLK_PLL1_OUT,
N    CLK_PLL2,
N    CLK_PLL2_OUT,
N    CLK_PLL3,
N    CLK_PLL3_OUT1,
N    CLK_PLL3_OUT2,
N    CLK_PLL4,
N    CLK_PLL4_OUT,
N    CLK_PLL5,
N    CLK_PLL5_OUT1,
N    CLK_PLL5_OUT2,
N
N    CLK_FCS_PLL2        = 20,
N    CLK_FCS_DLL,
N    CLK_PLL4_FREF_PLL0,
N
N    CLK_BUS_SAHB        = 30,
N    CLK_BUS_NAHB,
N    CLK_BUS_PAHB1,
N    CLK_BUS_PAHB2,
N    CLK_BUS_APB0,
N    CLK_BUS_APB1,
N
N    CLK_SCPU            = 50,
N    CLK_SCPU_TRACE,
N
N    CLK_NCPU            = 60,
N    CLK_NCPU_TRACE,
N    CLK_NPU,
N
N    /* Peripheral clocks */
N    CLK_SPI_CLK         = 100,
N    CLK_ADC_CLK,
N    CLK_WDT_EXT_CLK,
N    CLK_SD_CLK,
N    CLK_MIPI_TXHSPLLREF_CLK,
N    CLK_MIPI_TX_ESC_CLK,
N    CLK_MIPI_CSITX_DSI_CLK,
N    CLK_MIPI_CSITX_CSI_CLK,
N    CLK_MIPI_CSIRX1_TXESC_CLK,
N    CLK_MIPI_CSIRX1_CSI_CLK,
N    CLK_MIPI_CSIRX1_VC0_CLK,
N    CLK_MIPI_CSIRX0_TXESC_CLK,
N    CLK_MIPI_CSIRX0_CSI_CLK,
N    CLK_MIPI_CSIRX0_VC0_CLK,
N    CLK_LC_SCALER,
N    CLK_LC_CLK,
N    CLK_TMR1_EXTCLK3,
N    CLK_TMR1_EXTCLK2,
N    CLK_TMR1_EXTCLK1,
N    CLK_TMR0_EXTCLK3,
N    CLK_TMR0_EXTCLK2,
N    CLK_TMR0_EXTCLK1,
N    CLK_PWM_EXTCLK6,
N    CLK_PWM_EXTCLK5,
N    CLK_PWM_EXTCLK4,
N    CLK_PWM_EXTCLK3,
N    CLK_PWM_EXTCLK2,
N    CLK_PWM_EXTCLK1,
N    CLK_UART1_3_FREF,
N    CLK_UART1_2_FREF,
N    CLK_UART1_1_FREF,
N    CLK_UART1_0_FREF,
N    CLK_UART0_FREF,
N    CLK_SSP1_1_SSPCLK,
N    CLK_SSP1_0_SSPCLK,
N    CLK_SSP0_1_SSPCLK,
N    CLK_SSP0_0_SSPCLK,
N};
N
Nenum pll_setting {
N    PLL_MS=0,
N    PLL_NS,
N    PLL_PS,
N    CSIRX0_TXESCCLK,
N    CSIRX0_CSI,
N    CSIRX0_VC0,
N    CSIRX1_TXESCCLK,
N    CSIRX1_CSI,
N    CSIRX1_VC0
N};
N#define CLOCK_MUXSEL_NCPU_TRACECLK_DEFAULT              0x10000000
N#define CLOCK_MUXSEL_NCPU_TRACECLK_FROM_SCPU_TRACECLK   0x20000000
N#define CLOCK_MUXSEL_NCPU_TRACECLK_MASK                 0x30000000
N#define CLOCK_MUXSEL_SCPU_TRACECLK_SRC_PLL0DIV3         0x01000000
N#define CLOCK_MUXSEL_SCPU_TRACECLK_SRC_PLL0DIV2         0x02000000
N#define CLOCK_MUXSEL_SCPU_TRACECLK_MASK                 0x03000000
N#define CLOCK_MUXSEL_CSIRX1_CLK_PLL5                    0x00100000
N#define CLOCK_MUXSEL_CSIRX1_CLK_PLL3                    0x00200000
N#define CLOCK_MUXSEL_CSIRX1_CLK_MASK                    0x00300000
N#define CLOCK_MUXSEL_NPU_CLK_PLL4                       0x00010000
N#define CLOCK_MUXSEL_NPU_CLK_PLL5                       0x00020000
N#define CLOCK_MUXSEL_NPU_CLK_PLL0                       0x00040000
N#define CLOCK_MUXSEL_NPU_CLK_MASK                       0x00070000
N#define CLOCK_MUXSEL_PLL4_FREF_PLL0DIV                  0x00001000
N#define CLOCK_MUXSEL_PLL4_FREF_OSC                      0x00002000
N#define CLOCK_MUXSEL_PLL4_MASK                          0x00003000
N#define CLOCK_MUXSEL_UART_0_IRDA_UCLK_UART              0x00000100
N#define CLOCK_MUXSEL_UART_0_IRDA_UCLK_IRDA              0x00000200
N#define CLOCK_MUXSEL_UART_0_IRDA_UCLK_MASK              0x00000300
N
N#define PLL3_INITED_IN_SYTEM_INIT
N
N//enum clock_mux_selection {
N//    ncpu_traceclk_default = 0x10000000,
N//    ncpu_traceclk_from_scpu_traceclk = 0x20000000,
N//    scpu_traceclk_src_pll0div3 = 0x01000000,
N//    scpu_traceclk_src_pll0div2 = 0x02000000,    
N//};
N
Nenum pll_id {
N    /* pll_0 = 0, */
N    pll_1 = 0,
N    pll_2,
N    pll_3,
N    pll_4,
N    pll_5
N};
N
Nenum scuclkin_type {
N    scuclkin_osc = 0,
N    scuclkin_rtcosc,
N    scuclkin_pll0div3,
N    scuclkin_pll0div4,
N};
N
Nstruct clock_value {
N    u16 ms;
N    u16 ns;
N    u16 ps;
N    u8 div;
N    u8 enable;
N};
N
Nstruct clock_list {
N    struct clock_list *next;
N};
N
Nstruct clock_node;
Ntypedef int (*fn_set)(struct clock_node *, struct clock_value *);
Nstruct clock_node {
N    struct clock_node *parent;
N    struct clock_node *child_head;
N    struct clock_node *child_next;
N    fn_set set;//int (*set)(struct clock_node *, struct clock_value *);
N    u8 is_enabled;
N    char name[15];
N
N};
N
N
Nextern struct clock_node clock_node_pll1_out;
N
Nvoid clock_mgr_init(void);
Nvoid clock_mgr_open(struct clock_node *node, struct clock_value *clock_val);
Nvoid clock_mgr_close(struct clock_node *node);
Nvoid clock_mgr_set_scuclkin(enum scuclkin_type type, BOOL enable);
Nvoid clock_mgr_set_muxsel(u32 flags);
Nu32  clock_mgr_calculate_clockout(enum pll_id id, u16 ms, u16 ns, u16 F_ps);
N
Nvoid clock_mgr_open_pll1(void);
Nvoid clock_mgr_open_pll2(void);
Nvoid clock_mgr_open_pll3(void);
Nvoid clock_mgr_open_pll4(void);
Nvoid clock_mgr_open_pll5(void);
N
Nvoid clock_mgr_close_pll1(void);
Nvoid clock_mgr_close_pll2(void);
Nvoid clock_mgr_close_pll4(void);
N
N//void clock_mgr_change_pll3_clock(u32 ms, u32 ns, u32 ps, 
N//        u32 csi0_txesc, u32 csi0_csi, u32 csi0_vc0,
N//        u32 csi1_txesc, u32 csi1_csi, u32 csi1_vc0);
Nvoid clock_mgr_change_pll3_clock(u16 *pll_table);
Nvoid clock_mgr_change_pll5_clock(u32 ms, u32 ns, u32 ps);
N
Nvoid debug_pll_clock(void);
N
Nvoid clk_enable(enum clk clk);
Nvoid clk_disable(enum clk clk);
N
N#endif
N#endif // end of #ifdef USE_KDRV
L 38 "..\..\user\main.c" 2
N#include "pinmux.h"
L 1 "..\..\..\..\common\include\pinmux.h" 1
N#ifndef __PINMUX_H__
N#define __PINMUX_H__
N
N
N#include "scu_extreg.h"
N
N
N#define PINMUX_SPI_WP_N_GET()           GET_BITS(SCU_EXTREG_SPI_WP_N_IOCTRL, 0, 2)
N#define PINMUX_SPI_WP_N_SET(val)        SET_MASKED_BITS(SCU_EXTREG_SPI_WP_N_IOCTRL, val, 0, 2)
N#define PINMUX_SPI_WP_N_GPIO0           3
N
N#define PINMUX_SPI_HOLD_N_GET()         GET_BITS(SCU_EXTREG_SPI_HOLD_N_IOCTRL, 0, 2)
N#define PINMUX_SPI_HOLD_N_SET(val)      SET_MASKED_BITS(SCU_EXTREG_SPI_HOLD_N_IOCTRL, val, 0, 2)
N#define PINMUX_SPI_HOLD_N_GPIO1         3
N
N#define PINMUX_SWJ_TRST_GET()           GET_BITS(SCU_EXTREG_SWJ_TRST_IOCTRL, 0, 2)
N#define PINMUX_SWJ_TRST_SET(val)        SET_MASKED_BITS(SCU_EXTREG_SWJ_TRST_IOCTRL, val, 0, 2)
N#define PINMUX_SWJ_TRST_GPIO2           3
N#define PINMUX_SWJ_TRST_I2C0_CLK        (7)
N
N#define PINMUX_SWJ_TDI_GET()            GET_BITS(SCU_EXTREG_SWJ_TDI_IOCTRL, 0, 2)
N#define PINMUX_SWJ_TDI_SET(val)         SET_MASKED_BITS(SCU_EXTREG_SWJ_TDI_IOCTRL, val, 0, 2)
N#define PINMUX_SWJ_TDI_GPIO3            3
N#define PINMUX_SWJ_TDI_I2C0_DATA        (7)
N
N#define PINMUX_SWJ_SWDITMS_GET()        GET_BITS(SCU_EXTREG_SWJ_SWDITMS_IOCTRL, 0, 2)
N#define PINMUX_SWJ_SWDITMS_SET(val)     SET_MASKED_BITS(SCU_EXTREG_SWJ_SWDITMS_IOCTRL, val, 0, 2)
N#define PINMUX_SWJ_SWDITMS_GPIO4        3
N
N#define PINMUX_SWJ_SWCLKTCK_GET()       GET_BITS(SCU_EXTREG_SWJ_SWCLKTCK_IOCTRL, 0, 2)
N#define PINMUX_SWJ_SWCLKTCK_SET(val)    SET_MASKED_BITS(SCU_EXTREG_SWJ_SWCLKTCK_IOCTRL, val, 0, 2)
N#define PINMUX_SWJ_SWCLKTCK_GPIO5       3
N
N#define PINMUX_SWJ_TDO_GET()            GET_BITS(SCU_EXTREG_SWJ_TDO_IOCTRL, 0, 2)
N#define PINMUX_SWJ_TDO_SET(val)         SET_MASKED_BITS(SCU_EXTREG_SWJ_TDO_IOCTRL, val, 0, 2)
N#define PINMUX_SWJ_TDO_GPIO6            3
N#define PINMUX_SWJ_TDO_PWM4             5
N
N#define PINMUX_LC_PCLK_GET()            GET_BITS(SCU_EXTREG_LC_PCLK_IOCTRL, 0, 2)
N#define PINMUX_LC_PCLK_SET(val)         SET_MASKED_BITS(SCU_EXTREG_LC_PCLK_IOCTRL, val, 0, 2)
N#define PINMUX_LC_PCLK_GPIO7            3
N#define PINMUX_LC_PCLK                  0
N
N#define PINMUX_LC_VS_GET()              GET_BITS(SCU_EXTREG_LC_VS_IOCTRL, 0, 2)
N#define PINMUX_LC_VS_SET(val)           SET_MASKED_BITS(SCU_EXTREG_LC_VS_IOCTRL, val, 0, 2)
N#define PINMUX_LC_VS_LCM_DB0            7
N#define PINMUX_LC_VS_GPIO8              3
N#define PINMUX_LC_VS                    0
N
N#define PINMUX_LC_HS_GET()              GET_BITS(SCU_EXTREG_LC_HS_IOCTRL, 0, 2)
N#define PINMUX_LC_HS_SET(val)           SET_MASKED_BITS(SCU_EXTREG_LC_HS_IOCTRL, val, 0, 2)
N#define PINMUX_LC_HS_LCM_DB1            7
N#define PINMUX_LC_HS_GPIO9              3
N#define PINMUX_LC_HS                    0
N
N#define PINMUX_LC_DE_GET()              GET_BITS(SCU_EXTREG_LC_DE_IOCTRL, 0, 2)
N#define PINMUX_LC_DE_SET(val)           SET_MASKED_BITS(SCU_EXTREG_LC_DE_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DE_LCM_DB2            7
N#define PINMUX_LC_DE_GPIO10             3
N#define PINMUX_LC_DE                    0
N
N#define PINMUX_LC_DATA0_GET()           GET_BITS(SCU_EXTREG_LC_DATA0_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA0_SET(val)        SET_MASKED_BITS(SCU_EXTREG_LC_DATA0_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA0_LCM_DB3         7
N#define PINMUX_LC_DATA0_GPIO11          3
N#define PINMUX_LC_DATA0                 0
N
N#define PINMUX_LC_DATA1_GET()           GET_BITS(SCU_EXTREG_LC_DATA1_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA1_SET(val)        SET_MASKED_BITS(SCU_EXTREG_LC_DATA1_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA1_LCM_DB4         7
N#define PINMUX_LC_DATA1_GPIO12          3
N#define PINMUX_LC_DATA1                 0
N
N#define PINMUX_LC_DATA2_GET()           GET_BITS(SCU_EXTREG_LC_DATA2_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA2_SET(val)        SET_MASKED_BITS(SCU_EXTREG_LC_DATA2_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA2_LCM_DB5         7
N#define PINMUX_LC_DATA2_GPIO13          3
N#define PINMUX_LC_DATA2                 0
N
N#define PINMUX_LC_DATA3_GET()           GET_BITS(SCU_EXTREG_LC_DATA3_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA3_SET(val)        SET_MASKED_BITS(SCU_EXTREG_LC_DATA3_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA3_LCM_DB6         7
N#define PINMUX_LC_DATA3_GPIO14          3
N#define PINMUX_LC_DATA3                 0
N
N#define PINMUX_LC_DATA4_GET()           GET_BITS(SCU_EXTREG_LC_DATA4_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA4_SET(val)        SET_MASKED_BITS(SCU_EXTREG_LC_DATA4_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA4_LCM_DB7         7
N#define PINMUX_LC_DATA4_GPIO15          3
N#define PINMUX_LC_DATA4                 0
N
N#define PINMUX_LC_DATA5_GET()           GET_BITS(SCU_EXTREG_LC_DATA5_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA5_SET(val)        SET_MASKED_BITS(SCU_EXTREG_LC_DATA5_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA5_LCM_DB8         7
N#define PINMUX_LC_DATA5_GPIO16          3
N#define PINMUX_LC_DATA5                 0
N
N#define PINMUX_LC_DATA6_GET()           GET_BITS(SCU_EXTREG_LC_DATA6_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA6_SET(val)        SET_MASKED_BITS(SCU_EXTREG_LC_DATA6_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA6_LCM_DB9         7
N#define PINMUX_LC_DATA6_GPIO17          3
N#define PINMUX_LC_DATA6_UART2_TX        1
N#define PINMUX_LC_DATA6                 0
N
N#define PINMUX_LC_DATA7_GET()           GET_BITS(SCU_EXTREG_LC_DATA7_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA7_SET(val)        SET_MASKED_BITS(SCU_EXTREG_LC_DATA7_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA7_LCM_DB10        7
N#define PINMUX_LC_DATA7_GPIO18          3
N#define PINMUX_LC_DATA7_UART2_RX        1
N#define PINMUX_LC_DATA7                 0
N
N#define PINMUX_LC_DATA8_GET()           GET_BITS(SCU_EXTREG_LC_DATA8_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA8_SET(val)        SET_MASKED_BITS(SCU_EXTREG_LC_DATA8_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA8_LCM_DB11        7
N#define PINMUX_LC_DATA8_GPIO19          3
N#define PINMUX_LC_DATA8_DPI             5
N#define PINMUX_LC_DATA8                 0
N
N#define PINMUX_LC_DATA9_GET()           GET_BITS(SCU_EXTREG_LC_DATA9_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA9_SET(val)        SET_MASKED_BITS(SCU_EXTREG_LC_DATA9_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA9_LCM_DB12        7
N#define PINMUX_LC_DATA9_GPIO20          3
N#define PINMUX_LC_DATA9_DPI             5
N#define PINMUX_LC_DATA9                 0
N
N#define PINMUX_LC_DATA10_GET()          GET_BITS(SCU_EXTREG_LC_DATA10_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA10_SET(val)       SET_MASKED_BITS(SCU_EXTREG_LC_DATA10_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA10_LCM_DB13       7
N#define PINMUX_LC_DATA10_GPIO21         3
N#define PINMUX_LC_DATA10_DPI            5
N#define PINMUX_LC_DATA10                0
N
N#define PINMUX_LC_DATA11_GET()          GET_BITS(SCU_EXTREG_LC_DATA11_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA11_SET(val)       SET_MASKED_BITS(SCU_EXTREG_LC_DATA11_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA11_LCM_DB14       7
N#define PINMUX_LC_DATA11_GPIO0          3
N#define PINMUX_LC_DATA11_DPI            5
N#define PINMUX_LC_DATA11                0
N
N#define PINMUX_LC_DATA12_GET()          GET_BITS(SCU_EXTREG_LC_DATA12_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA12_SET(val)       SET_MASKED_BITS(SCU_EXTREG_LC_DATA12_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA12_PWM5			2
N#define PINMUX_LC_DATA12_LCM_DB15       7
N#define PINMUX_LC_DATA12_GPIO1          3
N#define PINMUX_LC_DATA12_DPI            5
N#define PINMUX_LC_DATA12                0
N#define PINMUX_LC_DATA12_SPI1_CLK       (4)
N
N#define PINMUX_LC_DATA13_GET()          GET_BITS(SCU_EXTREG_LC_DATA13_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA13_SET(val)       SET_MASKED_BITS(SCU_EXTREG_LC_DATA13_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA13_LCM_DB16       7
N#define PINMUX_LC_DATA13_GPIO2          3
N#define PINMUX_LC_DATA13_DPI            5
N#define PINMUX_LC_DATA13                0
N
N#define PINMUX_LC_DATA14_GET()          GET_BITS(SCU_EXTREG_LC_DATA14_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA14_SET(val)       SET_MASKED_BITS(SCU_EXTREG_LC_DATA14_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA14_LCM_DB17       7
N#define PINMUX_LC_DATA14_GPIO3          3
N#define PINMUX_LC_DATA14_DPI            5
N#define PINMUX_LC_DATA14                0
N#define PINMUX_LC_DATA14_SPI1_DI        (4)
N
N#define PINMUX_LC_DATA15_GET()          GET_BITS(SCU_EXTREG_LC_DATA15_IOCTRL, 0, 2)
N#define PINMUX_LC_DATA15_SET(val)       SET_MASKED_BITS(SCU_EXTREG_LC_DATA15_IOCTRL, val, 0, 2)
N#define PINMUX_LC_DATA15_LCM_SCn        7
N#define PINMUX_LC_DATA_GPIO4            3
N#define PINMUX_LC_DATA15_DPI            5
N#define PINMUX_LC_DATA15                0
N#define PINMUX_LC_DATA15_SPI1_DO        (4)
N
N#define PINMUX_SD_CLK_GET()             GET_BITS(SCU_EXTREG_SD_CLK_IOCTRL, 0, 2)
N#define PINMUX_SD_CLK_SET(val)          SET_MASKED_BITS(SCU_EXTREG_SD_CLK_IOCTRL, val, 0, 2)
N#define PINMUX_SD_CLK_LC_DATA16         1
N#define PINMUX_SD_CLK_LCM_WR            7
N#define PINMUX_SD_CLK_GPIO22            3
N#define PINMUX_SD_CLK_I2C1_CLK	        4
N#define PINMUX_SD_CLK_DPI               5
N
N#define PINMUX_SD_CMD_GET()             GET_BITS(SCU_EXTREG_SD_CMD_IOCTRL, 0, 2)
N#define PINMUX_SD_CMD_SET(val)          SET_MASKED_BITS(SCU_EXTREG_SD_CMD_IOCTRL, val, 0, 2)
N#define PINMUX_SD_CMD_LC_DATA17         1
N#define PINMUX_SD_CMD_LCM_RS            7
N#define PINMUX_SD_CMD_GPIO23            3
N#define PINMUX_SD_CMD_I2C1_DATA	        4
N#define PINMUX_SD_CMD_DPI               5
N
N#define PINMUX_SD_DATA0_GET()           GET_BITS(SCU_EXTREG_SD_DATA0_IOCTRL, 0, 2)
N#define PINMUX_SD_DATA0_SET(val)        SET_MASKED_BITS(SCU_EXTREG_SD_DATA0_IOCTRL, val, 0, 2)
N#define PINMUX_SD_DATA0_LC_DATA18       1
N#define PINMUX_SD_DATA0_LCM_RD          7
N#define PINMUX_SD_DATA0_GPIO24          3
N#define PINMUX_SD_DATA0_DPI             5
N
N#define PINMUX_SD_DATA1_GET()           GET_BITS(SCU_EXTREG_SD_DATA1_IOCTRL, 0, 2)
N#define PINMUX_SD_DATA1_SET(val)        SET_MASKED_BITS(SCU_EXTREG_SD_DATA1_IOCTRL, val, 0, 2)
N#define PINMUX_SD_DATA1_LC_DATA19       1
N#define PINMUX_SD_DATA1_LCM_RESETn      7
N#define PINMUX_SD_DATA1_GPIO25          3
N#define PINMUX_SD_DATA1_DPI             5
N
N#define PINMUX_SD_DATA2_GET()           GET_BITS(SCU_EXTREG_SD_DATA2_IOCTRL, 0, 2)
N#define PINMUX_SD_DATA2_SET(val)        SET_MASKED_BITS(SCU_EXTREG_SD_DATA2_IOCTRL, val, 0, 2)
N#define PINMUX_SD_DATA2_LC_DATA20       1
N#define PINMUX_SD_DATA2_LCM_BLCTRL      7
N#define PINMUX_SD_DATA2_GPIO26          3
N
N#define PINMUX_SD_DATA3_GET()           GET_BITS(SCU_EXTREG_SD_DATA3_IOCTRL, 0, 2)
N#define PINMUX_SD_DATA3_SET(val)        SET_MASKED_BITS(SCU_EXTREG_SD_DATA3_IOCTRL, val, 0, 2)
N#define PINMUX_SD_DATA3_LC_DATA21       1
N#define PINMUX_SD_DATA3_LCM_TP_INT1     7
N#define PINMUX_SD_DATA3_GPIO27          3
N
N#define PINMUX_UART0_RX_GET()           GET_BITS(SCU_EXTREG_UART0_RX_IOCTRL, 0, 2)
N#define PINMUX_UART0_RX_SET(val)        SET_MASKED_BITS(SCU_EXTREG_UART0_RX_IOCTRL, val, 0, 2)
N#define PINMUX_UART0_RX_GPIO7           3
N
N#define PINMUX_UART0_TX_GET()           GET_BITS(SCU_EXTREG_UART0_TX_IOCTRL, 0, 2)
N#define PINMUX_UART0_TX_SET(val)        SET_MASKED_BITS(SCU_EXTREG_UART0_TX_IOCTRL, val, 0, 2)
N#define PINMUX_UART0_TX_GPIO28          3
N
N#define PINMUX_I2C0_CLK_GET()           GET_BITS(SCU_EXTREG_I2C0_CLK_IOCTRL, 0, 2)
N#define PINMUX_I2C0_CLK_SET(val)        SET_MASKED_BITS(SCU_EXTREG_I2C0_CLK_IOCTRL, val, 0, 2)
N#define PINMUX_I2C0_CLK_GPIO29          3
N
N#define PINMUX_I2C0_DATA_GET()          GET_BITS(SCU_EXTREG_I2C0_DATA_IOCTRL, 0, 2)
N#define PINMUX_I2C0_DATA_SET(val)       SET_MASKED_BITS(SCU_EXTREG_I2C0_DATA_IOCTRL, val, 0, 2)
N#define PINMUX_I2C0_DATA_GPIO30         3
N
N#define PINMUX_PWM0_GET()               GET_BITS(SCU_EXTREG_PWM0_IOCTRL, 0, 2)
N#define PINMUX_PWM0_SET(val)            SET_MASKED_BITS(SCU_EXTREG_PWM0_IOCTRL, val, 0, 2)
N#define PINMUX_PWM0                     0
N#define PINMUX_PWM0_GPIO31              3
N
N#define PINMUX_OTG_DRV_VBUS_GET()       GET_BITS(SCU_EXTREG_OTG_DRV_VBUS_IOCTRL, 0, 2)
N#define PINMUX_OTG_DRV_VBUS_SET(val)    SET_MASKED_BITS(SCU_EXTREG_OTG_DRV_VBUS_IOCTRL, val, 0, 2)
N
N#define PINMUX_SPARE0_GET()             GET_BITS(SCU_EXTREG_SPARE0_IOCTRL, 0, 2)
N#define PINMUX_SPARE0_SET(val)          SET_MASKED_BITS(SCU_EXTREG_SPARE0_IOCTRL, val, 0, 2)
N
N#define PINMUX_SPARE1_GET()             GET_BITS(SCU_EXTREG_SPARE1_IOCTRL, 0, 2)
N#define PINMUX_SPARE1_SET(val)          SET_MASKED_BITS(SCU_EXTREG_SPARE1_IOCTRL, val, 0, 2)
N
N#define DEBUG_PINMUX
N#ifdef DEBUG_PINMUX
Nvoid debug_pinmux(void);
N#endif
N
Ntypedef enum {
N    IO_NORMAL = 0,
N    IO_INPUT,
N    IO_OUTPUT,
N} IO_STATUS;
N
Nvoid pinmux_init(void);
Nextern void pinmux_set_spi_do_driving_strength(int high);
N
N#endif
L 39 "..\..\user\main.c" 2
N#include "power_manager.h"
L 1 "..\..\..\..\scpu\drivers\include\power_manager.h" 1
N/*
N * Kneron Power Manager driver
N *
N * Copyright (C) 2019 Kneron, Inc. All rights reserved.
N *
N */
N
N#ifndef __POWER_MANAGER_H__
N#define __POWER_MANAGER_H__
N
N#include "base.h"
N
N/* SCU_REG_INT_EN & SCU_REG_INT_STS */
N#define SCU_INT_RTC_PERIODIC        BIT17
N#define SCU_INT_RTC_ALARM           BIT16
N#define SCU_INT_PLL_UPDATE          BIT8
N#define SCU_INT_FCS                 BIT6
N#define SCU_INT_BUSSPEED            BIT5
N#define SCU_INT_WAKEUP              BIT3
N#define SCU_INT_PWRBTN_RISE         BIT1
N#define SCU_INT_PWRBTN_FALL         BIT0
N
Nenum pm_device_id {
N    PM_DEVICE_NONE = 0,
N    PM_DEVICE_CAMERA1,
N    PM_DEVICE_CAMERA2,
N    PM_DEVICE_DISPLAY1,
N    PM_DEVICE_DISPLAY2,
N    PM_DEVICE_HOST_COM,
N    PM_DEVICE_OTA_UPDATE,
N    PM_DEVICE_NCPU_INFERENCE,
N    PM_DEVICE_UNUSED4,
N    PM_DEVICE_UNUSED5,
N    PM_DEVICE_UNUSED6,
N    PM_DEVICE_UNUSED7,
N    PM_DEVICE_UNUSED8,
N    PM_DEVICE_MAX,
N};
N
N/* Prototypes for callback functions */
Ntypedef int (*pm_call)(enum pm_device_id dev_id);
N
Nstruct pm_s {
N    pm_call     nap;
N    pm_call     wakeup_nap;
N    pm_call     deep_nap;
N    pm_call     wakeup_deep_nap;
N    pm_call     sleep;
N    pm_call     wakeup_sleep;
N    pm_call     deep_sleep;
N    pm_call     wakeup_deep_sleep;
N};
N
N/* PM APIs */
N__NO_RETURN void power_manager_cpu_idle(void);
X__declspec(noreturn) void power_manager_cpu_idle(void);
Nvoid power_manager_init(void);
Nvoid power_manager_error_notify(uint32_t code, void *object_id);
Nvoid power_manager_reset(void);
Nvoid power_manager_sleep(void);
Nvoid power_manager_deep_sleep(void);
Nvoid power_manager_shutdown(void);
N
N/* Registration APIs */
Nint power_manager_register(enum pm_device_id dev_id, struct pm_s *pm_p);
Nvoid power_manager_unregister(enum pm_device_id dev_id, struct pm_s *pm_p);
N
N#endif
L 40 "..\..\user\main.c" 2
N#include "kl520_api_fdfr.h"
L 1 "..\..\..\..\scpu\share\kl520_api_fdfr.h" 1
N#ifndef __KL520_API_FDFR_H__
N#define __KL520_API_FDFR_H__
N
N#include "board_kl520.h"
N
N#include "framework/v2k_image.h"
N#include "board_cfg.h"
N#include "kl520_include.h"
N#include "kdp_e2e_face.h"
N#include "kl520_api_camera.h"
L 1 "..\..\..\..\scpu\share\kl520_api_camera.h" 1
N#ifndef __KL520_API_CAMERA_H__
N#define __KL520_API_CAMERA_H__
N
N
N#include "kdp_camera.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp_camera.h" 1
N/*
N * KDP Camera driver header
N *
N * Copyright (C) 2019 Kneron, Inc. All rights reserved.
N *
N */
N
N#ifndef __KDP_CAMERA_H__
N#define __KDP_CAMERA_H__
N
N#include "types.h"
N
N
Nenum {
N    KDP_CAM_0,
N    KDP_CAM_1,
N    KDP_CAM_NUM,    // = IMGSRC_NUM
N};
N
Nenum camera_state {
N    CAMERA_STATE_IDLE = 0,
N    CAMERA_STATE_INITED,
N    CAMERA_STATE_RUNNING,
N    CAMERA_STATE_IN_FDR_INFERENCE,
N    CAMERA_STATE_IN_FDR_REGISTRATION,
N};
N
Nenum display_state {
N    DISPLAY_STATE_CLOSED = 0,
N    DISPLAY_STATE_OPENED,
N    DISPLAY_STATE_RUNNING,
N};
N
Nstruct cam_format {
N    unsigned int width;
N    unsigned int height;
N    unsigned int pixelformat;    /* fourcc */
N    unsigned int field;          /* enum v2k_field */
N    unsigned int bytesperline;   /* for padding, zero if unused */
N    unsigned int sizeimage;
N    unsigned int colorspace;     /* enum v2k_colorspace */
N};
N
Nstruct cam_capability {
N    char driver[16];
N    char desc[16];
N    unsigned int version;
N    unsigned int capabilities;
N};
N
Nstruct cam_ops {
N    int (*open)(unsigned int cam_idx);
N    void (*close)(unsigned int cam_idx);
N    int (*set_format)(unsigned int cam_idx, struct cam_format *format);
N    int (*get_format)(unsigned int cam_idx, struct cam_format *format);
N    int (*buffer_init)(unsigned int cam_idx);
N    int (*start_capture)(unsigned int cam_idx);
N    int (*stop_capture)(unsigned int cam_idx);
N    int (*buffer_prepare)(unsigned int cam_idx);
N    int (*buffer_capture)(unsigned int cam_idx, int *addr, int *size);
N    int (*stream_on)(unsigned int cam_idx);
N    int (*stream_off)(unsigned int cam_idx);
N    int (*query_capability)(unsigned int cam_idx, struct cam_capability *cap);
N    int (*set_gain)(unsigned int cam_idx, u8 gain1, u8 gain2);
N    int (*set_exp_time)(unsigned int cam_idx, u8 gain1, u8 gain2);
N    int (*get_lux)(unsigned int cam_idx, u16* exposure, u8* pre_gain, u8* post_gain, u8* global_gain, u8* y_average);
N    int (*set_aec_roi)(unsigned int cam_idx, u8 x1, u8 x2, u8 y1, u8 y2, u8 center_x1, u8 center_x2, u8 center_y1, u8 center_y2);
N    int (*set_mirror)(unsigned int cam_idx, BOOL enable);
N    int (*set_flip)(unsigned int cam_idx, BOOL enable);
N    int (*set_led)(unsigned int cam_idx, BOOL enable);
N    int (*get_device_id)(unsigned int cam_idx);
N    int (*set_fps)(unsigned int cam_idx, u8 fps);
N    int (*set_aec_en)(unsigned int cam_idx, BOOL enable);
N	#if CFG_ONE_SHOT_MODE == YES
X	#if 1 == 1
N    int (*sleep)(unsigned int cam_idx, BOOL enable);    
N	#endif
N    int (*get_tile_en)(unsigned int cam_idx);
N};
N
Nint kdp_camera_init(void);
N
Nint kdp_camera_open(unsigned int cam_idx);
N
Nvoid kdp_camera_close(unsigned int cam_idx);
N
Nint kdp_camera_query_capability(unsigned int cam_idx, struct cam_capability *cap);
Nint kdp_camera_get_device_info(unsigned int cam_idx, struct cam_capability *cap);
N
Nint kdp_camera_set_frame_format(unsigned int cam_idx, struct cam_format *format);
N
Nint kdp_camera_get_frame_format(unsigned int cam_idx, struct cam_format *format);
N
Nint kdp_camera_buffer_init(unsigned int cam_idx);
N
Nint kdp_camera_start(unsigned int cam_idx);
N
Nint kdp_camera_stop(unsigned int cam_idx);
N
Nint kdp_camera_buffer_prepare(unsigned int cam_idx);
N
Nint kdp_camera_buffer_capture(unsigned int cam_idx, int *addr, int *size);
N
Nint kdp_camera_stream_on(unsigned int cam_idx);
N
Nint kdp_camera_stream_off(unsigned int cam_idx);
N
Nint kdp_camera_set_gain(unsigned int cam_idx, int gain1, int gain2);
N
Nint kdp_camera_set_exp_time(unsigned int cam_idx, int gain1, int gain2);
N
Nint kdp_camera_get_lux(unsigned int cam_idx, u16* exposure, u8* pre_gain, u8* post_gain, u8* global_gain, u8* y_average);
N
Nint kdp_camera_set_aec_roi(unsigned int cam_idx, u8 x1, u8 x2, u8 y1, u8 y2, u8 center_x1, u8 center_x2, u8 center_y1, u8 center_y2);
N
Nint kdp_camera_set_mirror(unsigned int cam_idx, BOOL enable);
N
Nint kdp_camera_set_flip(unsigned int cam_idx, BOOL enable);
N
Nint kdp_camera_set_led(unsigned int cam_idx, BOOL enable);
N
Nint kdp_camera_set_fps(unsigned int cam_idx, u8 fps);
N
Nint kdp_camera_controller_register(unsigned int cam_idx, struct cam_ops *cam_ops_p);
N
Nint kdp_camera_controller_unregister(unsigned int cam_idx, struct cam_ops *cam_ops_p);
N
Nint kdp_camera_get_device_id(unsigned int cam_idx);
N
Nint kdp_camera_get_tile_en(unsigned int cam_idx);
N
Nint kdp_camera_set_aec_en(unsigned int cam_idx, BOOL enable);
N
N#endif // __KDP_CAMERA_H__
L 6 "..\..\..\..\scpu\share\kl520_api_camera.h" 2
N
N#define MODIFY_CAM_DISP_CT_FLOW
N
N//Permanent Control
N#define API_CTRL_CAM_OPEN       (0x30)
N#define API_CTRL_CAM_CLOS       (0x20)
N#define API_CTRL_CAM_STAR       (0x0C)
N#define API_CTRL_CAM_STOP       (0x08)
N#define API_CTRL_DISP_OPEN      (0xC0)  //DISP: Display
N#define API_CTRL_DISP_CLOS      (0x80)
N
N#define API_CTRL_CAM_EN         (API_CTRL_CAM_OPEN|API_CTRL_CAM_STAR)
N#define API_CTRL_CAM_DIS        (API_CTRL_CAM_CLOS|API_CTRL_CAM_STOP)
N
N//#define API_CTRL_CAM_DISP_EN    (API_CTRL_CAM_EN|API_CTRL_DISP_OPEN)
N//#define API_CTRL_CAM_DISP_DIS   (API_CTRL_CAM_DIS|API_CTRL_DISP_CLOS)
N
Nenum DEV_INIT_STATE
N{
N    DEV_INIT_STATE_UNINIT = 0,
N    DEV_INIT_STATE_INITED,
N    DEV_INIT_STATE_ERROR,
N};
N
Nenum kdp_device_status_code_e{
N    KDP_DEVICE_STATUS_OK = 0,
N    KDP_DEVICE_STATUS_ERROR = -1,
N    KDP_DEVICE_STATUS_IDLE,
N    KDP_DEVICE_STATUS_BUSY,
N
N    KDP_DEVICE_CAMERA_NULL = 0x100,
N    KDP_DEVICE_CAMERA_IDLE,
N    KDP_DEVICE_CAMERA_RUNNING,
N    KDP_DEVICE_CAMERA_IDLE_PERM,
N    // KDP_DEVICE_CAMERA_INFERENCE,
N    // KDP_DEVICE_CAMERA_REGISTRATION,
N
N    // KDP_DEVICE_DISPLAY_CLOSED = 0x200,
N    // KDP_DEVICE_DISPLAY_OPENED,
N    // KDP_DEVICE_DISPLAY_RUNNING
N};
N
Nenum CAM_THREAD_STATE
N{
N    CAM_THREAD_STATE_NULL = 0,
N    CAM_THREAD_STATE_OPEN,
N    CAM_THREAD_STATE_START,
N    CAM_THREAD_STATE_STOP,
N};
N
Nenum DEV_STATE
N{
N    DEV_STATE_NULL = 0,
N    DEV_STATE_IDLE,
N    DEV_STATE_RUN,
N};
N
Nenum PERM_STATE
N{
N    PERMANENT_NULL = 0,
N    PERMANENT_CAM,
N    PERMANENT_DISP,
N    PERMANENT_GUI,
N    PERMANENT_CAM_DISP,
N    PERMANENT_DISABLE,
N};
N
Nenum CTRL_STATE
N{
N    CTRL_COMM = 0,  //For console
N    CTRL_CMD,
N    CTRL_GUI,
N};
N
N//extern BOOL g_bBootupGuiHighPriority;
N//extern enum CAM_THREAD_STATE g_eCamThreadState;
N
Ns32 kl520_api_cam_disp_ctrl(u8 nCt, unsigned int nCamIdx, enum PERM_STATE ePermSt);
Ns32 kl520_api_cam_disp_close_perm_state_chk(void);
Ns32 kl520_api_cam_disp_state_rst(void);
Ns32 kl520_api_disp_open_chk(void);
Ns32 kl520_api_disp_close_chk(void);
Nvoid kl520_api_disp_resolution_set(u32 nW, u32 nH);
N
Nextern void kl520_api_hmi_ctrl_state_reset(enum CTRL_STATE ePermSt);
Nextern void kl520_api_hmi_ctrl_state_set(enum CTRL_STATE ePermSt);
Nenum kdp_device_status_code_e kl520_api_cam_state_get(unsigned int nCamIdx);
Nextern BOOL kl520_api_cam_to_dp_thread_alive(void);
N
Nextern u16 kl520_api_set_exposure_only( u8 nCamIdx, u32 nExpTime );
N
N#endif
L 11 "..\..\..\..\scpu\share\kl520_api_fdfr.h" 2
N
Nenum kl520_fdfr_status_code_e{
N    FDFR_STATUS_OK              = 0,
N    FDFR_STATUS_IDLE            = 1,
N    FDFR_STATUS_COMP_OK         = 2,
N    FDFR_STATUS_COMP_FAIL       = 3,
N    FDFR_STATUS_EXIST           = 4,
N    FDFR_STATUS_NOFACE          = 5,
N    FDFR_STATUS_FULL            = 6,
N    FDFR_STATUS_OPENED          = 7,
N
N    FDFR_STATUS_NEXT            = 10,
N    FDFR_STATUS_DETECTED        = 11,
N    FDFR_STATUS_BAD_POSE        = 12,
N    FDFR_STATUS_TOO_FAR         = 13,
N    FDFR_STATUS_TOO_NEAR        = 14,
N    FDFR_STATUS_WAIT_DONT_MOVE  = 15,
N    FDFR_STATUS_INVALID         = 16,
N    FDFR_STATUS_MASK            = 17,
N    FDFR_STATUS_EYE_CLOSE_STATUS_OPEN_EYE   = 18,
N    FDFR_STATUS_EYE_CLOSED                  = 19,
N    FDFR_STATUS_EYE_CLOSE_UNKNOW_STATUS     = 20,
N    FDFR_STATUS_TOOUP           = 22,
N    FDFR_STATUS_TOODOWN         = 23,
N    FDFR_STATUS_TOOLEFT         = 24,
N    FDFR_STATUS_TOORIGHT        = 25,
N    FDFR_STATUS_LOW_QUALITY     = 26,
N    FDFR_STATUS_CALLIB_FAIL     = 27,
N    FDFR_STATUS_NORMAL          = 28,
N    FDFR_STATUS_EYE_CLOSE_STATUS_CLOSE_EYE = 29,
N    FDFR_STATUS_ATTACK          = 30,
N    FDFR_STATUS_EMPTY           = 31,
N    FDFR_STATUS_ERROR           = -1,
N    FDFR_STATUS_TIMEOUT         = -2,
N    FDFR_STATUS_NOFACE_AND_TIMEOUT  = -3,
N    
N};
N#ifdef CFG_AI_3D_EXTEND_RANGE
S//#define FACE_DIST_MAX_THRESH    (200)
S//#define FACE_DIST_MIN_THRESH    (1)
N#else
N//#define FACE_DIST_MAX_THRESH    (100)   //74
N//#define FACE_DIST_MIN_THRESH    (20)
N#endif
N
N#define FACE_BAD_POSE_CNT       (2)
N#define FACE_BAD_POSE_LED_CNT   (2)
N#define FACE_ATTACK_CNT         (10)
N
N#define USE_FDFR_DRAWING_TIMER
N#define DB_OFFSET_CMD          NO
N
N#if (CFG_PANEL_TYPE == NULL) && ((CFG_AI_TYPE == AI_TYPE_N1R1) || CFG_AI_TYPE == AI_TYPE_N1)
X#if (0 == 0) && ((3 == 3) || 3 == 2)
N#define FACE_POSTITON_UP_THRESH     (NIR_IMG_SOURCE_H / 20)
N#define FACE_POSTITON_DOWN_THRESH   (NIR_IMG_SOURCE_H - NIR_IMG_SOURCE_H / 20)
N#define FACE_POSTITON_LEFT_THRESH   (NIR_IMG_SOURCE_W / 20)
N#define FACE_POSTITON_RIGHT_THRESH  (NIR_IMG_SOURCE_W - NIR_IMG_SOURCE_W / 20)
N#else
S#define FACE_POSTITON_UP_THRESH     (DISPLAY_HEIGHT/8)
S#define FACE_POSTITON_DOWN_THRESH   (DISPLAY_HEIGHT - DISPLAY_HEIGHT/8)
S#define FACE_POSTITON_LEFT_THRESH   (DISPLAY_WIDTH/8)
S#define FACE_POSTITON_RIGHT_THRESH  (DISPLAY_WIDTH - DISPLAY_WIDTH/8)
N#endif
N
N#define FDFR_COM_EVENT_CLOSED    (1)
N
Nextern kdp_e2e_face_mode m_face_mode;
N
Nextern BOOL g_bRecognitionMandatoryFlag;
Nextern u32 face_reg_sts;
N
N//int kl520_api_fdfr_facemode_get(void);
Nvoid kl520_api_fdfr_set_flow_mode(BOOL );
Nvoid kl520_api_fdfr_model_init(void);
Ns32 kl520_api_face_preexecute_stage1(void);
Ns32 kl520_api_face_preexecute_stage2(void);
Ns32 kl520_api_face_preexecute_stage3(void);
Ns32 kl520_api_face_preexecute_colse(void);
Ns32 kl520_api_face_preempt_init(void);
Nvoid kl520_api_tasks_init(void);
Nvoid kl520_api_tasks_init_wait_ready(void);
Nint kl520_api_fdfr_exist_thread(void);
Nint kl520_api_fdfr_element(void);
Nvoid kl520_api_fdfr_terminate_thread(void);
N
Nextern bool b_en_aec_only;
Xextern _Bool b_en_aec_only;
Nextern uint8_t m_curr_face_id;
Nextern kl520_dp_draw_info dp_draw_info;
Ninline void _api_fdfr_set_event(u32 flags_api_fdfr_state, u32 kl520_app_flag_state, bool CLR);
Xinline void _api_fdfr_set_event(u32 flags_api_fdfr_state, u32 kl520_app_flag_state, _Bool CLR);
N
Nextern void api_fdfr_face_recognition_set_mandatory_event(void);
N
NBOOL kl520_api_ui_fsm_dp_layout_get(void);
N
Nvoid kl520_api_fdfr_init_thrd(void);
Nvoid kl520_api_fdfr_start(void);
Nvoid kl520_api_fdfr_stop(void);
N
Nu8 kl520_is_fdfr_abort(void);
Nvoid kl520_set_fdfr_abort(u8 flag);
Nu8 kl520_fdfr_opened(void);
N
Nu8 kl520_api_get_start_user_id(void);
N
Nu8 is_enroll_customize_uid(void);
Nvoid set_enroll_customize_uid(u8 uid);
Nu8 get_enroll_customize_uid(void);
Nvoid set_enroll_overwrite_flag(u8 flag);
Nu8 get_enroll_overwrite_flag(void);
N
N#ifdef CUSTOMIZE_DB_OFFSET
Nu8 get_user_db_offset(void);
Nvoid load_user_db_offset(void);
Nvoid update_user_db_offset(u8 offset);
Nvoid reset_user_db_offset(void);
N#endif
N
Nvoid kl520_customer_info_init(void);
N
Nvoid switch_palm_mode(u8 mode);
N
N#endif
L 41 "..\..\user\main.c" 2
N#include "framework/framework.h"
L 1 "..\..\..\..\scpu\framework\include\framework/framework.h" 1
N#ifndef __FRAMEWORK_H__
N#define __FRAMEWORK_H__
N
N
Nvoid framework_init(void);
N
N#endif
L 42 "..\..\user\main.c" 2
N#include "drivers.h"
L 1 "..\..\..\..\scpu\drivers\include\drivers.h" 1
N#ifndef __DRIVERS_H__
N#define __DRIVERS_H__
N
N//#define USE_KDRV
N#ifdef USE_KDRV
S#include "kdrv_adc.h"
S#include "kdrv_mpu.h"
S#include "kdrv_ddr.h"
S#include "kdrv_clock.h"
S#include "kdrv_power.h"
S#include "kdrv_system.h"
S#include "kdrv_uart.h"
S#define kdp520_adc_init                 kdrv_adc_initialize
S#define kdp520_adc_read                 kdrv_adc_read
S#define mpu_config                      kdrv_mpu_config
S#define mpu_niram_enable                kdrv_mpu_niram_enable
S#define mpu_niram_disalbe               kdrv_mpu_niram_disable
S#define ddr_init                        kdrv_ddr_system_init
S#define ddr_self_refresh_enter          kdrv_ddr_self_refresh_enter
S#define ddr_self_refresh_exit           kdrv_ddr_self_refresh_exit
S#define ddr_wakeup                      kdrv_ddr_wakeup
S#define clock_mgr_set_scuclkin          kdrv_clock_set_scuclkin
S#define clock_mgr_init                  kdrv_clock_initialize
S#define clk_enable                      kdrv_clock_enable
S#define clk_disable                     kdrv_clock_disable
S#define clock_mgr_change_pll3_clock     kdrv_clock_change_pll3_clock
S#define clock_mgr_change_pll5_clock     kdrv_clock_change_pll5_clock
S#define POWER_MGR_OPS_FCS               POWER_OPS_FCS
S#define POWER_MGR_OPS_CHANGE_BUS_SPEED  POWER_OPS_CHANGE_BUS_SPEED
S#define POWER_MGR_OPS_PLL_UPDATE        POWER_OPS_PLL_UPDATE
S#define POWER_MGR_OPS_SLEEPING          POWER_OPS_SLEEPING
S#define POWER_MGR_MODE_RTC              POWER_MODE_RTC
S#define POWER_MGR_MODE_ALWAYSON         POWER_MODE_ALWAYSON
S#define POWER_MGR_MODE_FULL             POWER_MODE_FULL
S#define POWER_MGR_MODE_RETENTION        POWER_MODE_RETENTION
S#define POWER_MGR_MODE_DEEP_RETENTION   POWER_MODE_DEEP_RETENTION
S#define power_mgr_softoff               kdrv_power_softoff
S#define power_mgr_sw_reset              kdrv_power_sw_reset
S#define power_mgr_set_domain            kdrv_power_set_domain
S#define power_mgr_ops                   kdrv_power_ops
S#define system_init                     kdrv_system_init
S#define system_init_ncpu                kdrv_system_init_ncpu
S#define kdp_uart_dev_id                 kdrv_uart_dev_id_t
S#define kdp_gets(__port, __buf)         kdrv_uart_get_string((kdrv_uart_handle_t)__port, __buf)
S#define kdp_uart_GetRxCount             kdrv_uart_get_rx_count
S#define kdp_uart_read                   kdrv_uart_read
S#define kdp_uart_write                  kdrv_uart_write
N#else
N#include "kdp520_adc.h" // will be removed in next version
L 1 "..\..\..\..\scpu\drivers\include\kdp520_adc.h" 1
N#ifndef __KDP520_ADC_H
N#define __KDP520_ADC_H
N
N#include "types.h"
N
N/* ADC Resource Configuration */
Ntypedef struct {
N  int				io_base;		// I2C register interface
N  int				irq;				// I2C Event IRQ Number
N} kdp_adc_resource;
N
Nstruct kdp_adc_regs {
N	/* DATA: offset 0x000~0x01C */
N	UINT32		data[8];
N	/* reserve */
N	UINT32		reserve[24];
N	/* THRHOLD: offset 0x080~0x09C */
N	UINT32		thrhold[8];
N#define HTHR_EN         (1<<31)
N#define HTHR(x)         (((x)&0xFFF)<<16)
N#define LTHR_EN         (1<<15)
N#define LTHR(x)         (((x)&0xFFF)<<0)
N	/* reserve */
N	UINT32		reserve1[24];
N	/* CTRL: offset 0x100 */
N	UINT32		ctrl;
N#define SCAN_NUM(x)			(x<<16)
N#define SCANMODE_CONT   (1<<9)
N#define SCANMODE_SGL    (1<<8)
N#define SWSTART					(1<<4)
N#define ADC_EN          (1<<0)
N	/* TRIM: offset 0x104 */
N	UINT32		trim;
N	/* INTEN: offset 0x108 */
N	UINT32		inten;
N#define CHDONE_INTEN(x) (1<<((x)+8))
N#define TS_OVR_INTREN 	(1<<3)
N#define TS_UDR_INTREN   (1<<2)
N#define STOP_INTEN      (1<<1)
N#define DONE_INTEN      (1<<0)
N	/* INTST: offset 0x10C */
N	UINT32		intst;
N#define CH_INTRSTS(x)			(1<<((x)+8))
N#define TS_THDOD_INTRSTS	(1<<3)
N#define TS_THDUD_INTRSTS	(1<<2)
N#define ADC_STOP_INTRSTS	(1<<1)
N#define ADC_DONE_INTSTS		(1<<0)
N	/* TPARAM: offset 0x110 */
N	UINT32		tparam;
N	/* TPARAM1: offset 0x114 */
N	UINT32		smpr;
N	/* reserve */
N	UINT32		reserve2;
N	/* PRESCAL: offset 0x11C */
N	UINT32		prescal;
N	/* SQR: 		offset 0x120 */
N	UINT32 		sqr;
N	
N};
N
Nvoid kdp520_adc_init(void);
NINT32 kdp520_adc_uninit(kdp_adc_resource *res);
Nvoid kdp520_adc_reset(kdp_adc_resource *res);
Nvoid kdp520_adc_enable(kdp_adc_resource *res, int mode);
Nint kdp520_adc_read(int id);
N
N#endif //__KDP520_ADC_H
L 50 "..\..\..\..\scpu\drivers\include\drivers.h" 2
N#define kdev_flash_erase_sector kdp_flash_erase_sector
N#define kdev_flash_get_status kdp_flash_get_status
N#define kdev_flash_programdata kdp_flash_program_data
N#define kdev_flash_readdata kdp_flash_read_data
N#define kdev_flash_status_t ARM_FLASH_STATUS
N#define kdev_status_t kdp_status_t
N#define kdrv_power_sw_reset power_mgr_sw_reset
N#endif
N
Nint kdp_drv_init(void);
N
N
N#endif
L 43 "..\..\user\main.c" 2
N#include "kdp_model.h"
L 1 "..\..\..\..\scpu\lib\kdp_application\include\kdp_model.h" 1
N#ifndef __MODEL_MGR_H__
N#define __MODEL_MGR_H__
N
N#include <stdint.h>
N#include "ipc.h"
N#include "base.h"
N#include "kdp_app.h"
N#include "kdp_com.h"
L 1 "..\..\..\..\scpu\lib\kdp_application\include\kdp_com.h" 1
N/********************************************************************
N * Copyright (c) 2020 Kneron, Inc. All Rights Reserved.
N *
N * The information contained herein is property of Kneron, Inc.
N * Terms and conditions of usage are described in detail in Kneron
N * STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information.
N * NO WARRANTY of ANY KIND is provided. This heading must NOT be removed
N * from the file.
N ********************************************************************/
N
N/**@addtogroup  KDP_COM
N * @{
N * @brief       Kneron NPU driver
N * @copyright   Copyright (C) 2020 Kneron, Inc. All rights reserved.
N */
N
N#ifndef KDP_COM_H
N#define KDP_COM_H
N
N#include "cmsis_os2.h"
N#include "types.h"
N#include "ipc.h"
N
Ntypedef void (*ipc_handler_t)(int ipc_idx, int state);
N
N#define CMD_FLAGS(i)                (kdp_com_get_output_ptr()->cmd_flags[i])
N#define CMD_FLAGS_IS_ACTIVE(i)      (kdp_com_get_output_ptr()->cmd_flags[i] == IMAGE_STATE_ACTIVE)
N#define CMD_FLAGS_IS_INACTIVE(i)    (kdp_com_get_output_ptr()->cmd_flags[i] == IMAGE_STATE_INACTIVE)
N#define CMD_STATUS(i)               (kdp_com_get_input_ptr()->cmd_status[i])
N#define CMD_STATUS_IS_NPU_BUSY(i)   (kdp_com_get_input_ptr()->cmd_status[i] == IMAGE_STATE_NPU_BUSY)
N#define CMD_STATUS_IS_NPU_DONE(i)   (kdp_com_get_input_ptr()->cmd_status[i] == IMAGE_STATE_NPU_DONE)
N#define CMD_STATUS_IS_PROC_DONE(i)  (kdp_com_get_input_ptr()->cmd_status[i] == IMAGE_STATE_POST_PROCESSING_DONE)
N
N
N/**
N * @brief Initialize NPU functionality
N * @param ipc_handler IPC callback
N */
Nvoid kdp_com_init(BOOL log_enable, ipc_handler_t ipc_handler);
N/**
N * @brief Set model information
N * @param model_info_addr model information address
N * @param info_idx information index
N * @param slot_idx slot index
N */
Nvoid kdp_com_set_model(struct kdp_model_s *model_info_addr, uint32_t info_idx, int32_t slot_idx, uint32_t model_type);
N
N/**
N * @brief Get available COM
N * @return COM index
N */
Nint kdp_com_get_avail_com(void);
N
N/**
N * @brief Set active model index
N * @param index model slot index
N * @return available COM
N */
Nint kdp_com_set_model_active(uint32_t index);
N
N/**
N * @brief Get active model index
N * @return index
N */
Nint kdp_com_get_model_active(void);
N
N/**
N * @brief Set active image index
N * @param index image index
N * @return available COM
N */
Nint kdp_com_set_image_active(uint32_t index);
N
N/**
N * @brief Get active image index
N * @return index
N */
Nint kdp_com_get_image_active(void);
N
N/**
N * @brief Set SCPU debug level
N * @param lvl level
N */
Nvoid kdp_com_set_scpu_debug_lvl(uint32_t lvl);
N
N/**
N * @brief Set NCPU debug level
N * @param lvl level
N */
Nvoid kdp_com_set_ncpu_debug_lvl(uint32_t lvl);
N
N/**
N * @brief Trigger NCPU interrupt
N */
Nvoid kdp_com_ncpu_trigger_int(uint32_t model_type);
N
N/**
N * @brief Get ncpu_to_scpu_s
N * @return IPC struct
N */
Nstruct ncpu_to_scpu_s* kdp_com_get_input_ptr(void);
N
N/**
N * @brief Get scpu_to_ncpu_s
N * @return IPC struct
N */
Nstruct scpu_to_ncpu_s* kdp_com_get_output_ptr(void);
N
NBOOL kdp_com_is_inited(void);
N
N#endif
L 9 "..\..\..\..\scpu\lib\kdp_application\include\kdp_model.h" 2
N#include "model_type.h"
N
N#define KDP_MODEL_ALL_MODELS  -1
N
N/* flash memory table
N *    BOOT related       :  192K(reserved)      0x0         - 0x2FFFF
N *    FLASH_ADDR_HEAD    :                      0x30000
N *    FID database       :  512K(reserved)      0x80000     - 0xFFFFF
N *    fw_info.bin        :    4K(reserved)      0x100000    - 0x100FFF  : real use: depend on model count
N *      - model count : 4 bytes
N *      - models      :sizeof(struct kdp_model_s)*count
N *      - ddr end addr:4 bytes
N *
N *    bin files for models: (4K aligned)        0x101000     - ??       : real use: depend model size
N *      - cmd.bin + weight.bin + setup.bin
N *    FLASH_ADDR_END                            0x101000 + model size   -> + 4K alignment
N */
N
N/* size of fw_info.bin & all_models.bin */
N#define MODEL_MGR_SIZE_MODEL_INFO  224      // (232 - 4 -4 )   todo: must specify the size
N#define MODEL_MGR_SIZE_MODEL_POOL  3572576  // todo: musth specify the size
N
N#define MODEL_MGR_FLASH_ADDR_HEAD               0x00143000
N#define MODEL_MGR_FLASH_ADDR_MODEL_COUNT        (MODEL_MGR_FLASH_ADDR_HEAD)
N#define MODEL_MGR_FLASH_ADDR_MODEL_INFO         (MODEL_MGR_FLASH_ADDR_MODEL_COUNT + 4)
N#define MODEL_MGR_FLASH_ADDR_MODEL_DDR_END_ADDR (MODEL_MGR_FLASH_ADDR_MODEL_INFO  + MODEL_MGR_SIZE_MODEL_INFO)
N#define MODEL_MGR_FLASH_ADDR_MODEL_POOL         0x00144000
N
N/* These crc values will ONLY change if model is changed in FLASH */
N#define MODEL_INFO_CRC16_VALUE  0x5341
N#define MODEL_INFO_SUM32_VALUE  0x00eee074
N
N#ifndef FLASH_MODEL_HAS_CRC_CHECK
N#define MODEL0_FD_CRC16_VALUE   0x939f   /* original: 0x4318 */
N#define MODEL1_LM_CRC16_VALUE   0x1cd0   /* original: 0xfce0 */
N#define MODEL3_FR_CRC16_VALUE   0x5df0   /* original: 0xb359 */
N#define MODEL0_FD_SUM32_VALUE   0xf9e571d8
N#define MODEL1_LM_SUM32_VALUE   0x3f96c4fc
N#define MODEL3_FR_SUM32_VALUE   0xbc998f45
N#endif
N
Nenum kdp_model_status_code_e {
N    KDP_MODEL_OK = 0,
N    KDP_MODEL_UNKNOWN_ERR,
N    KDP_MODEL_ABORT,
N    KDP_MODEL_FDR_WRONG_USAGE = 0x100, // KDP_MODEL_FID_CODES
N    KDP_MODEL_FDR_NO_FACE,
N    KDP_MODEL_FDR_BAD_POSE,
N    KDP_MODEL_FDR_NO_ALIVE,
N    KDP_MODEL_FDR_FR_FAIL,
N    KDP_MODEL_SIZE_SMALL,
N    KDP_MODEL_FDR_NO_LM
N};
N
Nenum kdp_model_rc {
N    // 0 - 9 is reserved for ncpu return
N    // defined in ipc.h
N    // IMAGE_STATE_INACTIVE == 0
N    // IMAGE_STATE_ACTIVE == 1
N    // IMAGE_STATE_NPU_DONE == 2
N    // IMAGE_STATE_DONE == 3
N
N    KDP_MODEL_RUN_RC_ABORT = 10,
N    KDP_MODEL_RUN_RC_ERROR = 11,
N    KDP_MODEL_RUN_RC_END
N};
N
N/* ############################
N * ##    Public Functions    ##
N * ############################ */
Nint kdp_model_get_raw_img_idx(int ipc_com_idx);
Nstruct kdp_img_raw_s* kdp_model_get_raw_img(const struct kdp_img_cfg *img_cfg);
Nstruct kdp_img_raw_s* kdp_model_get_raw_img_by_idx(int idx);
N/**
N * @brief Get raw image config
N * @param idx image index
N * @return raw image config
N */
Nstruct kdp_img_raw_s* kdp_model_get_raw_img_by_idx(int idx);
N
N/**
N * @brief Init model functionality
N */
Nvoid kdp_ipc_init(BOOL log_enable);
N
N/**
N * @brief A wrapper of load_model
N * @param model_index_p: model info index,
N *                    0-n: info_index of model to load
N *                    -1 means to load all models
N * @return always 0
N */
Nint32_t kdp_model_load_model(int8_t model_info_index);
N
N/**
N * @brief A wrapper of load_model_info
N * @param [in] is_model_from_ddr: if model is from ddr/host command
N */
Nvoid kdp_model_reload_model_info(bool from_ddr);
Xvoid kdp_model_reload_model_info(_Bool from_ddr);
N
N/**
N * @brief Refresh all models
N */
Nvoid kdp_model_refresh_models(void);
N
N/**
N * @brief Output model_info of specified index
N * @param[in] idx_p the index of programmed models
N * @return model_info defined in ipc.h
N */
Nstruct kdp_model_s* kdp_model_get_model_info(int idx_p);
N
N/**
N * @brief Specify output address for model run in ncpu/npu
N          !!! must be called after kmdw_model_config_model()
N * @return always 0
N */
Nint32_t kmdw_model_config_result(osEventFlagsId_t result_evt, uint32_t result_evt_flag);
N
N//int32_t kdp_model_run(uint32_t model_type);
N
N/**
N * @brief Config model image
N * @param img_cfg image config
N * @param crop_box image crop config
N * @param pad_values image padding config
N * @param ext_param extra param
N */
Nvoid kdp_model_config_img(struct kdp_img_cfg *img_cfg, struct kdp_crop_box_s *crop_box,
N                          struct kdp_pad_value_s *pad_values, void *ext_param);
N
Nint32_t kdp_model_config_liveness_img(struct kdp_img_cfg *p_kdp_image_p,
N                                      struct kdp_img_cfg *p_rgb_kdp_image_p,
N                                      struct kdp_crop_box_s *p_kdp_crop_box_p,
N                                      struct dual_landmarks_s *p_ext_pararms_p,
N                                      struct dual_landmarks_s *p_ext_pararms_2_p,
N                                      struct nir_camera_tune_s *p_nir_tune_p );
N
N/**
N * @brief Run model
N * @param tag model tag
N * @param output model output
N * @param model_type model type
N * @param dme DME mode
N * @return kmdw_model_rc
N */
Nint kdp_model_run(const char *tag, void *output, uint32_t model_type, bool dme);
Xint kdp_model_run(const char *tag, void *output, uint32_t model_type, _Bool dme);
Nint kdp_model_run_ex(const char *tag, void *output,
N                      uint32_t model_type, bool model_from_ddr,
X                      uint32_t model_type, _Bool model_from_ddr,
N                      struct kdp_img_cfg *img_cfg,
N                      struct kdp_crop_box_s *crop_bbox,
N                      struct kdp_pad_value_s *pad_values,	 
N                      void *ext_param);
N
Nint32_t kdp_model_fd(struct facedet_result_s *out,
N                     struct kdp_img_cfg *img_cfg);
N
Nint32_t kdp_model_crop_fd(struct facedet_result_s *out, int32_t* xywh, 
N                     struct kdp_img_cfg *img_cfg);
N
Nint32_t kdp_model_lm(struct landmark_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     struct facedet_result_s *fd_bbox);
N
Nint32_t kdp_model_face_pose(struct face_occlude_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     struct landmark_result_s *lm);
N
Nint32_t kdp_model_lm_s(struct landmark_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     struct facedet_result_s *fd_bbox);
N
Nint32_t kdp_model_eye_lid(struct landmark_result_s *lm, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     struct eye_lid_lm_result_s *eye_lid, int eid);
N
Nint32_t kdp_model_fr(struct fr_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     struct facedet_result_s *fd_bbox,
N                     struct landmark_result_s *lm_pts, int flip_face);
N                     
Nint32_t kdp_model_face_quality(struct face_quality_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     struct facedet_result_s *fd_bbox,
N                     struct landmark_result_s *lm_pts);
N
Nint32_t kdp_model_cv_lv(struct lv_result_s *p_lv_output_p, /*output*/
N                     struct kdp_img_cfg *p_nir_img_setting_p,
N                     struct kdp_img_cfg *p_rgb_img_setting_p,
N                     struct dual_landmarks_s *p_lm_pts_p, // dual landmarks
N                     struct dual_landmarks_s *p_lm_pts_2_p, // second dual landmarks
N                     struct nir_camera_tune_s *p_nir_tune_p,
N                     uint32_t model_type_p);
N
Nint32_t kdp_model_fuse_lv(struct lv_result_s *p_lv_output_p, /*output*/
N                     struct kdp_img_cfg *p_nir_img_setting_p,
N                     struct kdp_img_cfg *p_rgb_img_setting_p,
N                     struct dual_landmarks_s *p_lm_pts_p, // dual landmarks
N                     struct nir_camera_tune_s *p_nir_tune_p,
N                     uint32_t model_type_p);
N
N/**
N * @brief  do nir liveness
N */										 
Nint32_t kdp_model_nir_lv(struct lv_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     //struct facedet_result_s *fd_bbox,
N                     struct landmark_result_s *lm_pts, // not use now
N                     uint32_t model_type);
N
Nint32_t kdp_model_nir_eye_lv(struct lv_result_s *out,
N                     struct kdp_img_cfg *img_cfg,
N                     struct landmark_result_s *lm_pts,
N                     uint32_t model_type);
N/**
N * @brief  do nir hsn liveness
N */										 
Nint32_t kdp_model_nir_hsn_lv(struct lv_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     //struct facedet_result_s *fd_bbox,
N                     struct landmark_result_s *lm_pts, // not use now
N                     uint32_t model_type);
N/**
N * @brief  do nir sl liveness
N */										 
Nint32_t kdp_model_nir_sl_lv(struct lv_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     struct facedet_result_s  *pfd,
N                     struct landmark_result_s *lm_pts, // not use now
N                     uint32_t model_type);    
N
Nint32_t kdp_model_fuse_nir_lv(struct lv_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     //struct facedet_result_s *fd_bbox,
N                     struct landmark_result_s *lm_pts, // not use now
N                     uint32_t model_type);
N
Nint32_t kdp_model_hand(dme_res *out,
N                     struct kdp_img_cfg *img_cfg);
N                     
Nint32_t kdp_model_hand_kp(struct hand_kp_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     struct facedet_result_s *fd_bbox);
Nint32_t kdp_model_palm_lv(struct lv_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     struct facedet_result_s *fd_bbox);
N
Nint32_t kdp_model_palm_print_fm(struct fr_result_s *out, /*output*/
N                     struct kdp_img_cfg *img_cfg,
N                     struct hand_kp_result_s *lm_pts);
N/**
N * @brief Abort model execution
N */
Nvoid kdp_model_abort(void);
N
N#if DEBUG
S
S/**
S * @brief Dump model debug info
S */
Svoid kdp_model_dump_model_info(void);
S
N#endif
N
Nvoid kdp_model_init_addr( u32 head, u32 model_count, u32 model_info, u32 ddr_end_addr , u32 model_pool);
Nvoid kdp_model_show_info(void);
Nint kdp_model_version(u8 idex);
Nint kdp_model_get_model_count(void);
Nint kdp_model_info_get( uint32_t *second_last_start, uint32_t *last_start ,uint32_t *model_size );
Nvoid kdp_model_info_reload(void);
Nvoid kdp_model_info_clear(void);
Nvoid kdp_model_info_reload_test(void);
Nuint8_t kdp_model_load_flag( uint8_t model_index_p);
N
Nint32_t kdp_model_config_result_addr(int model_slot_idx, void *addr_p);
Nint32_t kdp_model_config_model(uint32_t model_type, bool model_from_ddr);
Xint32_t kdp_model_config_model(uint32_t model_type, _Bool model_from_ddr);
Nint32_t kdp_model_config_virtual_model(uint32_t model_type);
Nvoid kdp_model_show_info(void);
Nu8 kdp_all_model_version(void);
Nint kdp_clc_all_model_size(void);
Nint kdp_crc_offset_in_fwinfo(void);
Nvoid kdp_set_model_offset( u32 offset);
Nu32 kdp_get_model_offset(void);
Nvoid kdp_set_fwinfo_offset( u32 offset);
Nu32 kdp_get_fwinfo_offset(void);
N
Nu8 kdp_is_abort_flag(void);
Nvoid kdp_set_abort_flag(u8 flag);
N
Nu8 kdp_is_palm_mode(void);
Nvoid kdp_set_palm_mode(u8 pm);
N
N#define DB_DEFAULT_RGB_TO_NIR_RATIO     85
Nvoid kdp_set_rgb_to_nir_ratio(u8 ratio);
Nu8   kdp_get_rgb_to_nir_ratio(void);
N
N#endif
L 44 "..\..\user\main.c" 2
N#include "user_io.h"
L 1 "..\..\user\user_io.h" 1
N#ifndef __USER_IO_H__
N#define __USER_IO_H__
N
N#include "types.h"
N
N#define IOEXT_P0     (1<<0)
N#define IOEXT_P1     (1<<1)
N#define IOEXT_P2     (1<<2)
N#define IOEXT_P3     (1<<3)
N#define IOEXT_P4     (1<<4)
N#define IOEXT_P5     (1<<5)
N#define IOEXT_P6     (1<<6)
N#define IOEXT_P7     (1<<7)
N
N#if ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36515 )
X#if ( 2 == 1 )
S#define IO_LED1      ( 1 << 0 )
S#define IO_LED2      ( 1 << 1 )
N#endif
N
Ntypedef enum __io_ext_reg
N{
N    IOEXT_REG_ID = 0x10,
N    IOEXT_REG_DIR_P0 = 0x04,
N    IOEXT_REG_DIR_P1 = 0x05,
N    IOEXT_REG_SET_IO_P0 = 0x02,
N    IOEXT_REG_SET_IO_P1 = 0x03,
N    IOEXT_REG_SET_SYS_CFG = 0x11,
N    IOEXT_REG_SET_LED_SW = 0x12,
N} io_ext_reg;
N
N#if ( CFG_LED_DRIVER_TYPE == LED_DRIVER_AW36515 )
X#if ( 2 == 1 )
Stypedef enum __io_led_mode
S{
S    LED_STANDBY_MODE = 0x80,
S    LED_TORCH_MODE = 0x88,
S    LED_FLASH_MODE = 0x8C,
S} io_led_mode;
S
Sextern void led_set_light_mode( io_led_mode nMode );
N#endif
N
N//extern void rgb_led_init(u16 duty);
N//extern void nir_led_init(u16 duty);
Nextern void backlight_init(void);
Nextern void rgb_led_open(u16 level);
Nextern void rgb_led_close(void);
Nextern void nir_led_open(u16 level);
Nextern void nir_led_close(void);
Nextern void rgb_camera_power_on(void);
Nextern void rgb_camera_power_off(void);
Nextern void nir_camera_power_on(void);
Nextern void nir_camera_power_off(void);
Nextern void lcd_power_on(void);
Nextern void lcd_power_off(void);
Nextern void tp_power_on(void);
Nextern void tp_power_off(void);
N
Nvoid user_io_init(void);
Nextern int user_io_get_backlight(void);
Nextern int user_io_set_backlight(int light);
Nextern void user_io_chk_backlight(void);
Nextern int user_io_light_sensor_get(void);
N
Nu32 user_io_get_extra_device_cnt(void);
Nu32 user_io_get_extra_device_id(u32 device_idx);
Nvoid user_io_get_extra_device_name(u32 device_idx, char *out_name, u32 max_lenth);
N
Nvoid user_io_poweroff(void);
Nvoid user_console_cmd01(void);
Nvoid user_console_cmd02(void);
Nvoid user_console_cmd03(void);
Nvoid user_console_cmd04(void);
Nvoid user_console_cmd05(void);
N
N#endif    //__USER_IO_H__
L 45 "..\..\user\main.c" 2
N#include "user_ui.h"
L 1 "..\..\user\user_ui.h" 1
N#ifndef __USER_UI_H__
N#define __USER_UI_H__
N
N#pragma once
N#include "board_kl520.h"
N
N#define GUI_V1                          (0)
N#define GUI_V2                          (1)
N#define GUI_VERSION_TYPE                (GUI_V2)
N
N#define DISPLAY_RESULT_HOLD_TIME        (1500)  //ms
N
Nvoid kl520_api_ddr_img_init(void);
Nvoid kl520_api_ddr_img_user(void);
Nvoid user_ui_init(void);
N
N#endif    //__USER_UI_H__
L 46 "..\..\user\main.c" 2
N#include "mpu.h"
L 1 "..\..\..\..\scpu\drivers\include\mpu.h" 1
N#ifndef __MPU_H__
N#define __MPU_H__
N
Nvoid mpu_config(void);
Nvoid mpu_niram_enable(void);
Nvoid mpu_niram_disable(void);
N#endif
L 47 "..\..\user\main.c" 2
N#include "flash.h"
L 1 "..\..\..\..\scpu\drivers\include\media\flash\flash.h" 1
N#ifndef __FLASH_H__
N#define __FLASH_H__
N
N
N#include "types.h"
N#include "board_kl520.h"
N#include "kdp_flash_def.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp_flash_def.h" 1
N#ifndef __KDP_FLASH_H__
N#define __KDP_FLASH_H__
N
N
N#include "board_kl520.h"
N
N#define FLASH_CODE_OPT              (YES)
N
Ntypedef enum
N{
N    KDP_STATUS_ERROR = 0,            /**< flash driver status error */
N    KDP_STATUS_OK,           /**< flash driver status OK */
N} kdp_status_t;
N
Ntypedef struct _flash_paramter
N{
N    UINT32  signature;							    //0x00
N    UINT8   PTP;								        //0x0C
N    UINT8   ID;									        //0x10
N    UINT8   erase_4K_support;				    //0x00 => 0x30[1:0];
N    UINT32  flash_size_KByte;				    //0x04~0x07 => 0x34~0x37
N    UINT16  page_size_Bytes;				    //0x28 => 0x58[7:4]=0x8
N    UINT16  sector_size_Bytes;
N    UINT32  block_size_Bytes;				    //how many sectors in one block
N    UINT16  total_sector_numbers;
N}FLASH_PARMATER_T;
N
N/**
N\brief Flash Sector information
N*/
Ntypedef struct _ARM_FLASH_SECTOR {
N  uint32_t start;                       ///< Sector Start address
N  uint32_t end;                         ///< Sector End address (start+size-1)
N} const ARM_FLASH_SECTOR;
N
N/**
N\brief Flash information
N*/
Ntypedef struct _ARM_FLASH_INFO {
N  ARM_FLASH_SECTOR *sector_info;        ///< Sector layout information (NULL=Uniform sectors)
N  uint32_t          sector_count;       ///< Number of sectors
N  uint32_t          sector_size;        ///< Uniform sector size in bytes (0=sector_info used) 
N  uint32_t          page_size;          ///< Optimal programming page size in bytes
N  uint32_t          program_unit;       ///< Smallest programmable unit in bytes
N  uint8_t           erased_value;       ///< Contents of erased memory (usually 0xFF)
N  uint32_t          flash_size;
N} ARM_FLASH_INFO;    
N//} const ARM_FLASH_INFO;
N
N/**
N\brief Flash Status
N*/
Ntypedef struct _ARM_FLASH_STATUS {
N  uint32_t busy  : 1;                   ///< Flash busy flag
N  uint32_t error : 1;                   ///< Read/Program/Erase error flag (cleared on start of next operation)
N} ARM_FLASH_STATUS;
N
N
N
N#endif
L 8 "..\..\..\..\scpu\drivers\include\media\flash\flash.h" 2
N#include "usr_flash_img_table.h"
L 1 "..\..\config\usr_flash_img_table.h" 1
N#ifndef __USR_FLASH_IMG_TABLE_H__
N#define __USR_FLASH_IMG_TABLE_H__
N
N
N#define USR_FLASH_SETTINGS_ADDR                             (KDP_FLASH_LAST_ADDR + 0x00000000) // 0x00FD3000, file=flash_bin\usr_settings.bin
N#define USR_FLASH_SETTINGS_SIZE                             0x00001000
N#define USR_FLASH_LAST_ADDR                                 0x00FD4000
N
N#endif
L 9 "..\..\..\..\scpu\drivers\include\media\flash\flash.h" 2
N
N
N#if (FLASH_VENDOR_SELECT==GD25Q256D)
X#if (2==0)
S#include "GD25Q256D.h"
S#elif (FLASH_VENDOR_SELECT==GD25S512MD)
X#elif (2==1)
S#include "GD25S512MD.h"
N#elif (FLASH_VENDOR_SELECT==W25Q256JV)
X#elif (2==2)
N#include "W25Q256JV.h"
L 1 "..\..\..\..\scpu\drivers\include\media\flash\W25Q256JV.h" 1
N
N
N#ifndef __W25Q256JV_H__
N#define __W25Q256JV_H__
N#include "flash.h"
L 1 "..\..\..\..\scpu\drivers\include\media\flash\flash.h" 1
N#ifndef __FLASH_H__
S#define __FLASH_H__
S
S
S#include "types.h"
S#include "board_kl520.h"
S#include "kdp_flash_def.h"
S#include "usr_flash_img_table.h"
S
S
S#if (FLASH_VENDOR_SELECT==GD25Q256D)
S#include "GD25Q256D.h"
S#elif (FLASH_VENDOR_SELECT==GD25S512MD)
S#include "GD25S512MD.h"
S#elif (FLASH_VENDOR_SELECT==W25Q256JV)
S#include "W25Q256JV.h"
S#elif (FLASH_VENDOR_SELECT==W25M512JV)
S#include "W25M512JV.h"
S#endif
S
S
S
S
S
S#define FLASH_TYPE_NOR_FLASH        (0)
S#define FLASH_TYPE_NAND_FLASH       (1)
S#define FLASH_TYPE                  (FLASH_TYPE_NOR_FLASH)
S
S
S//#if ( FLASH_TYPE == FLASH_TYPE_NOR_FLASH)
S//#define GD25Q256D                   (0)
S//#define GD25S512MD                  (1)
S//#define W25Q256JV                   (2)
S//#define W25M512JV                   (3)
S//#else
S//
S//#error"Please select correct flash type"
S//
S//#endif
S//
S//#define FLASH_VENDOR_SELECT         (GD25S512MD)
S
S
S
S
S#define FLASH_WORKING_EN            (1)
S#define FLASH_READ_ARRANGE_EN       (1)
S#define FLASH_PROG_ARRANGE_EN       (1)
S#define FLASH_QUAD_EN               (YES)
S#define SPI_QUAD_MODE
S#define SPI_BUS_SPEED_100MHZ        (0x01)
S#define SPI_BUS_SPEED_50MHZ         (0x02)
S#define SPI_BUS_SPEED_25MHZ         (0x04)
S#define SPI_BUS_SPEED               (SPI_BUS_SPEED_100MHZ)
S
S
S
S
S
S
S//void kdp_flash_register_device( struct kdp_dev_flash *flash_struct );
Skdp_status_t kdp_flash_initialize(void);
Sint kdp_flash_uninitialize(void);
Skdp_status_t kdp_flash_read_data(UINT32 addr, void *data, UINT32 target_Bytes);
Skdp_status_t kdp_flash_program_data(UINT32 addr, UINT8 *data, UINT32 send_bytes);
Skdp_status_t kdp_flash_erase_sector(UINT32 address);
Skdp_status_t kdp_flash_erase_multi_sectors(UINT32 nstart_index,  UINT32 nend_index);
Skdp_status_t kdp_flash_erase_chip(void);
Skdp_status_t kdp_flash_get_status(void);
Skdp_status_t kdp_flash_get_info(void);
SUINT8 kdp_flash_get_id(void);
Svoid kdp_flash_erase_4k(u32 offset);
Svoid kdp_flash_erase_64k(u32 offset);
Svoid kdp_flash_dma_read_stop(void);
Svoid kdp_flash_dma_write_stop(void);
Svoid kdp_flash_set_protect_bypass(UINT8 bypass);
S
S
Stypedef struct kdp_dev_flash
S{
S    kdp_status_t        (*initial)             (void);
S    kdp_status_t        (*program)             ( UINT32 addr, UINT8 *data, UINT32 send_bytes);
S    kdp_status_t        (*read)                (uint32_t addr, void *data, uint32_t target_Bytes);
S    kdp_status_t        (*erasemultisector)    (UINT32 nstart_add,  UINT32 nend_add);
S    kdp_status_t        (*erase4KB)            (UINT32 address);
S    kdp_status_t        (*erase64KB)           (UINT32 offset);
S    kdp_status_t        (*eraseallchip)        (void);
S    kdp_status_t        (*get_info)            (void);
S    UINT8               (*get_id)              (void);
S    kdp_status_t        (*GetStatus)           (void);
S    void                (*set_bypass)          (UINT8 bypass);
S}FLASH_DEV;
S
N#endif
N
N
N
N
L 6 "..\..\..\..\scpu\drivers\include\media\flash\W25Q256JV.h" 2
N#if (FLASH_VENDOR_SELECT == W25Q256JV )
X#if (2 == 2 )
N
N
N
N
N/*******************************************
N * for status command (0x05)
N ********************************************/
N#define STATUS_05_CMD0      0x0
N#define STATUS_05_CMD1      0x01000000
N#define STATUS_05_CMD2      0x01
N#define STATUS_05_CMD3      (0x05000008)
N
N/*******************************************
N * read status command (0x35)
N ********************************************/
N#define STATUS_35_CMD0      (0x0)
N#define STATUS_35_CMD1      (0x01000000)
N#define STATUS_35_CMD2      (0x01)
N#define STATUS_35_CMD3      (0x35000008)
N
N/*******************************************
N * for status command (0x15)
N ********************************************/
N#define STATUS_15_CMD0      0x0
N#define STATUS_15_CMD1      0x01000000
N#define STATUS_15_CMD2      0x1
N#define STATUS_15_CMD3      (0x15000008)
N
N/*******************************************
N * write control command (0x06)    //06 non-volatile
N                                   //50 volatile
N ********************************************/
N#define WRITE_CON_06_CMD0      0x0
N#define WRITE_CON_06_CMD1      0x01000000
N#define WRITE_CON_06_CMD2      0x0
N#define WRITE_CON_06_CMD3      (0x06000002)
N/*******************************************
N * write control command (0x50)    //50 volatile
N                                   
N ********************************************/
N#define WRITE_CON_50_CMD0      0x0
N#define WRITE_CON_50_CMD1      0x01000000
N#define WRITE_CON_50_CMD2      0x0
N#define WRITE_CON_50_CMD3      (0x50000002)
N/*******************************************
N * Disable control command (0x06)
N ********************************************/
N#define WRITE_CON_04_CMD0      0x0
N#define WRITE_CON_04_CMD1      0x01000000
N#define WRITE_CON_04_CMD2      0x0
N#define WRITE_CON_04_CMD3      (0x04000002)
N
N/*******************************************
N * for write status register (0x31)
N ********************************************/
N#define WRITE_STAT_31_CMD0      0x0
N#define WRITE_STAT_31_CMD1      0x01000000
N#define WRITE_STAT_31_CMD2      0x1
N#define WRITE_STAT_31_CMD3      (0x31000002)
N
N/*******************************************
N * for write status register (0x11)
N ********************************************/
N#define WRITE_STAT_11_CMD0      0x0
N#define WRITE_STAT_11_CMD1      0x01000001
N#define WRITE_STAT_11_CMD2      0x00
N#define WRITE_STAT_11_CMD3      (0x11000002)
N
N/*******************************************
N * for read chip id command (0x9F)
N ********************************************/
N#define PARA_5A_CMD0            0x0C
N#define PARA_5A_CMD1            0x01080003
N#define PARA_5A_CMD2            0x8
N#define PARA_5A_CMD3            (0x5A000008)
N
N/*******************************************
N * for 4Bytes or 3Bytes 4KByte sector erase command (0x21)
N ********************************************/
N#define ERASE_4K_21_CMD0      0x0
N#define ERASE_4K_21_CMD1      0x01000004
N#define ERASE_4K_21_CMD2      0x0
N#define ERASE_4K_21_CMD3      (0x21000002)
N
N
N/*******************************************
N * for block erase command (0x52):32KB Block Erase
N ********************************************/
N#define ERASE_32K_52_CMD0      0x0
N#define ERASE_32K_52_CMD1      0x01000003
N#define ERASE_32K_52_CMD2      0x0
N#define ERASE_32K_52_CMD3      (0x52000002)
N
N
N/*******************************************
N * for 4Bytes or 3Byte 64KByte erase command (0xDC)
N ********************************************/
N#define ERASE_64K_DC_CMD0      0x0
N#define ERASE_64K_DC_CMD1      0x01000004
N#define ERASE_64K_DC_CMD2      0x0
N#define ERASE_64K_DC_CMD3      (0xDC000002)
N
N/*******************************************
N * for chip erase command (0xC7):Erase all
N ********************************************/
N#define CHIP_ERASE_C7_CMD0      0x0
N#define CHIP_ERASE_C7_CMD1      0x01000000
N#define CHIP_ERASE_C7_CMD2      0x0
N#define CHIP_ERASE_C7_CMD3      (0xC7000002)
N
N/*******************************************
N * set 4Bytes command (0xB7)
N ********************************************/
N#define ENTER_4B_ADD_B7_CMD0      0x0
N#define ENTER_4B_ADD_B7_CMD1      0x01000000
N#define ENTER_4B_ADD_B7_CMD2      0x0
N#define ENTER_4B_ADD_B7_CMD3      (0xB7000002)
N
N/*******************************************
N * Exit 4Bytes command (0xE9)
N ********************************************/
N#define EXIT_4B_ADD_E9_CMD0      0x0
N#define EXIT_4B_ADD_E9_CMD1      0x01000000
N#define EXIT_4B_ADD_E9_CMD2      0x0
N#define EXIT_4B_ADD_E9_CMD3      (0xE9000002)
N
N
N
N/*******************************************
N * for 4Bytes 4xIO read data command device (0xEC)
N ********************************************/
N#define QUAD_READ_EC_CMD0       0x0
N#define QUAD_READ_EC_CMD1       0x01060004                    //6 dummy cycle, because in quad mode 1Byte use 2 clock so that 3 dummy need 6 dummy
N#define QUAD_READ_EC_CMD2       0x0
N#define QUAD_READ_EC_CMD3       (0xEC000080)
N
N
N
N/*******************************************
N * for Quad page write command (0x34)
N ********************************************/
N#define QPAGE_WRITE_34_CMD0      0x0
N#define QPAGE_WRITE_34_CMD1      0x01000004
N#define QPAGE_WRITE_34_CMD2      0x0
N#define QPAGE_WRITE_34_CMD3      (0x34000042)
N
N
N/*******************************************
N * for 4Bytes page write command (0x12)
N ********************************************/
N#define PAGE_WRITE_12_CMD0      0x0
N#define PAGE_WRITE_12_CMD1      0x01000004
N#define PAGE_WRITE_12_CMD2      0x0
N#define PAGE_WRITE_12_CMD3      (0x12000002|SPI020_CE_VALUE|SPI020_INTR_CFG)
N
N
N/*******************************************
N * for read chip id command (0x9F)
N ********************************************/
N#define RDID_9F_CMD0      0x0
N#define RDID_9F_CMD1      0x01000000
N#define RDID_9F_CMD2      0x3
N#define RDID_9F_CMD3      (0x9F000000|SPI020_CE_VALUE|SPI020_INTR_CFG)
N
N
N//enable reset
N#define RESET_66_CMD0      0x0
N#define RESET_66_CMD1      0x01000000
N#define RESET_66_CMD2      0x00
N#define RESET_66_CMD3      (0x66000002)
N
N// reset device
N#define RESET_99_CMD0      0x0
N#define RESET_99_CMD1      0x01000000
N#define RESET_99_CMD2      0x00
N#define RESET_99_CMD3      (0x99000002)
N
N
N
N//---flash information----
N#define     FLASH_SIGNATURE             (0x50444653)
N#define     FLASH_PAGE_SIZE_256_CODE    (0x8)
N#define     FLASH_PAGE_SIZE_X_CODE      (0xFF)
N
N
Nextern void nor_flash_quad_mode_en(UINT8 enable);
Nextern UINT8 norflash_get_info(void);
Nextern kdp_status_t norflash_4k_erase(UINT32 address);
Nextern kdp_status_t norflash_32k_erase(UINT32 offset);
Nextern kdp_status_t norflash_64k_erase(UINT32 offset);
Nextern kdp_status_t norflash_chip_erase(void);
Nextern kdp_status_t norflash_read(uint32_t addr, void *data, uint32_t target_Bytes);
Nextern kdp_status_t norflash_program( UINT32 addr, UINT8 *data, UINT32 send_bytes);
Nextern kdp_status_t norflash_erase_multi_sector(UINT32 nstart_add,  UINT32 nend_add);
Nextern struct kdp_dev_flash flash_vendor;
N
Nextern void kdp520_flash_check_status_til_ready(void);
Nextern void kdp520_flash_dma_read_stop(void);
Nextern void kdp520_flash_dma_write_stop(void);
Nextern void kdp520_flash_quad_enable(UINT8 enable);
N
N
N
N
N
N
N
N
N
N#endif
N#endif  //end if #if (FLASH_VENDOR_SELECT == W25Q256JV )
L 17 "..\..\..\..\scpu\drivers\include\media\flash\flash.h" 2
N#elif (FLASH_VENDOR_SELECT==W25M512JV)
X#elif (2==W25M512JV)
S#include "W25M512JV.h"
N#endif
N
N
N
N
N
N#define FLASH_TYPE_NOR_FLASH        (0)
N#define FLASH_TYPE_NAND_FLASH       (1)
N#define FLASH_TYPE                  (FLASH_TYPE_NOR_FLASH)
N
N
N//#if ( FLASH_TYPE == FLASH_TYPE_NOR_FLASH)
N//#define GD25Q256D                   (0)
N//#define GD25S512MD                  (1)
N//#define W25Q256JV                   (2)
N//#define W25M512JV                   (3)
N//#else
N//
N//#error"Please select correct flash type"
N//
N//#endif
N//
N//#define FLASH_VENDOR_SELECT         (GD25S512MD)
N
N
N
N
N#define FLASH_WORKING_EN            (1)
N#define FLASH_READ_ARRANGE_EN       (1)
N#define FLASH_PROG_ARRANGE_EN       (1)
N#define FLASH_QUAD_EN               (YES)
N#define SPI_QUAD_MODE
N#define SPI_BUS_SPEED_100MHZ        (0x01)
N#define SPI_BUS_SPEED_50MHZ         (0x02)
N#define SPI_BUS_SPEED_25MHZ         (0x04)
N#define SPI_BUS_SPEED               (SPI_BUS_SPEED_100MHZ)
N
N
N
N
N
N
N//void kdp_flash_register_device( struct kdp_dev_flash *flash_struct );
Nkdp_status_t kdp_flash_initialize(void);
Nint kdp_flash_uninitialize(void);
Nkdp_status_t kdp_flash_read_data(UINT32 addr, void *data, UINT32 target_Bytes);
Nkdp_status_t kdp_flash_program_data(UINT32 addr, UINT8 *data, UINT32 send_bytes);
Nkdp_status_t kdp_flash_erase_sector(UINT32 address);
Nkdp_status_t kdp_flash_erase_multi_sectors(UINT32 nstart_index,  UINT32 nend_index);
Nkdp_status_t kdp_flash_erase_chip(void);
Nkdp_status_t kdp_flash_get_status(void);
Nkdp_status_t kdp_flash_get_info(void);
NUINT8 kdp_flash_get_id(void);
Nvoid kdp_flash_erase_4k(u32 offset);
Nvoid kdp_flash_erase_64k(u32 offset);
Nvoid kdp_flash_dma_read_stop(void);
Nvoid kdp_flash_dma_write_stop(void);
Nvoid kdp_flash_set_protect_bypass(UINT8 bypass);
N
N
Ntypedef struct kdp_dev_flash
N{
N    kdp_status_t        (*initial)             (void);
N    kdp_status_t        (*program)             ( UINT32 addr, UINT8 *data, UINT32 send_bytes);
N    kdp_status_t        (*read)                (uint32_t addr, void *data, uint32_t target_Bytes);
N    kdp_status_t        (*erasemultisector)    (UINT32 nstart_add,  UINT32 nend_add);
N    kdp_status_t        (*erase4KB)            (UINT32 address);
N    kdp_status_t        (*erase64KB)           (UINT32 offset);
N    kdp_status_t        (*eraseallchip)        (void);
N    kdp_status_t        (*get_info)            (void);
N    UINT8               (*get_id)              (void);
N    kdp_status_t        (*GetStatus)           (void);
N    void                (*set_bypass)          (UINT8 bypass);
N}FLASH_DEV;
N
N#endif
N
N
N
N
L 48 "..\..\user\main.c" 2
N#include "kdp_ddr_table.h"
N#include "kdp_memory.h"
L 1 "..\..\..\..\scpu\lib\kdp_application\misc\kdp_memory.h" 1
N/*
N * Kneron memory APIs
N *
N * Copyright (C) 2019 Kneron, Inc. All rights reserved.
N *
N */
N
N#ifndef __KDP_MEMORY_H_
N#define __KDP_MEMORY_H_
N
N#include <stdint.h>
N
N/**
N * @brief To initialize available DDR block 
N * @param start_addr the start address of DDR block
N * @param eed_addr the end address of DDR block
N */
Nvoid        kdp_ddr_init(uint32_t start_addr, uint32_t end_addr);
N
N/**
N * @brief to reserve DDR memory
N * @param numbtye size in byte
N * @return the address of reserve block
N */
Nuint32_t    kdp_ddr_reserve(uint32_t numbyte);
N
N/**
N * @brief to release allocated memory
N * @param addr DDR address
N */
Nvoid        kdp_ddr_free(uint32_t addr);
N
N#endif
N
L 50 "..\..\user\main.c" 2
N#include "kdp_camera.h"
N#include "ota_update.h"
L 1 "..\..\..\..\scpu\middleware\ota\ota_update.h" 1
N#ifndef __OTA_UPDATE_H__
N#define __OTA_UPDATE_H__
N#include "board_kl520.h"
N#include "host_msg.h"
L 1 "..\..\..\..\scpu\middleware\comm\host_msg.h" 1
N#ifndef __MSG_H__
N#define __MSG_H__
N#include "board_kl520.h"
N
N#include "com.h"
L 1 "..\..\..\..\common\include\com.h" 1
N/**
N * @file      com.h
N * @brief     Basic communcation structure
N * @copyright (c) 2018 Kneron Inc. All right reserved.
N */
N#ifndef __COM_H__
N#define __COM_H__
N
N#include <stdint.h>
N
N#if defined(__arm__)
X#if 1L
N#pragma anon_unions
N#endif
N
N#define CUSTOMER_SETTING_REMOVE_CMD
N
Ntypedef enum {
N    CMD_NONE = 0,
N    CMD_MEM_READ,
N    CMD_MEM_WRITE,
N    CMD_DATA,
N    CMD_ACK_NACK,
N    CMD_STS_CLR,
N    CMD_MEM_CLR,
N    CMD_CRC_ERR,
N    CMD_TEST_ECHO,
N    CMD_FILE_WRITE,
N    CMD_FLASH_MEM_WRITE,  // single sector flash write
N
N    CMD_RESET = 0x20,
N    CMD_SYSTEM_STATUS,
N    CMD_OTA_UPDATE,
N    CMD_UPDATE_MODEL,
N
N    CMD_SNAPSHOT,       //0x24
N    CMD_SNAPSHOT_CHECK, //0x25
N    CMD_RECEIVE_IMAGE, //0x26
N    CMD_SIM_START, //0x27
N    CMD_EXTRA_MAP, //0x28
N    CMD_EXTRA_MAP_CHECK, //0x29
N    CMD_E2E_SET_MODE,
N    CMD_E2E_FACE_ADD,
N    CMD_E2E_FACE_RECOGNITION,
N    CMD_E2E_FACE_RECOGNITION_TEST,
N    CMD_E2E_FACE_LIVENESS,
N    CMD_E2E_FACE_PRE_ADD,
N
N
N    CMD_QUERY_APPS = 0x30,
N    CMD_SELECT_APP,
N    CMD_SET_MODE,
N    CMD_SET_EVENTS,
N    CMD_UPDATE,
N    CMD_IMG_RESULT,  // only RESP message is used.  No CMD version is implemented
N    CMD_ABORT,
N
N	CMD_E2E_FACE_COMAPRE_1VS1,
N	CMD_OPEN_FDR_THREAD,
N	CMD_CLOSE_FDR_THREAD,
N
N    CMD_SFID_START = 0x108,
N    CMD_SFID_NEW_USER,
N    CMD_SFID_ADD_DB,
N    CMD_SFID_DELETE_DB,
N    CMD_SEND_IMAGE,
N    CMD_SFID_LW3D_START,
N    CMD_SEND_LW3D,
N    CMD_SFID_EDIT_DB,
N
N    CMD_DME_START = 0x118,
N    CMD_DME_CONFIG,
N    CMD_DME_SEND_IMAGE,
N
N    // Flash command
N    CMD_FLASH_INFO = 0x1000,
N    CMD_FLASH_CHIP_ERASE,
N    CMD_FLASH_SECTOR_ERASE,
N    CMD_FLASH_READ,
N    CMD_FLASH_WRITE,
N
N    // debug utility command
N    CMD_DBG_USB_MEM_WR = 0x2000,
N    CMD_DBG_SET_MODEL_TYPE = 0x2001,
N
N    // for Camera tool
N    CMD_DOWNLOAD_IMAGE_NIR = 0x2100,
N    CMD_DOWNLOAD_IMAGE_RGB,
N    CMD_SET_NIR_AGC,
N    CMD_SET_NIR_AEC,
N    CMD_SET_RGB_AGC,
N    CMD_SET_RGB_AEC,
N    CMD_SET_NIR_LED,
N    CMD_SET_RGB_LED,
N    CMD_CAM_CONNECT,
N    CMD_NIR_FD_RES,
N    CMD_NIR_LM_RES,
N    CMD_RGB_FD_RES,
N    CMD_RGB_LM_RES,
N    CMD_NIR_GET_CONF,
N    CMD_RGB_GET_CONF,
N
N
N    //Jeff add
N    CMD_SCPU_UPDATE = 0x3000,
N    CMD_NCPU_UPDATE,
N    CMD_MODEL_UPDATE,
N
N    CMD_GUI_CTRL_SERIES = 0x4000,
N    CMD_GUI_REGISTER,
N    CMD_GUI_RECOGNIZE,
N    CMD_GUI_DELETE_ALL,
N
N    CMD_CLOUD_UPDATE_DB = 0x5000,
N    CMD_FDFR_THREAD_CLOSE = 0x6000,
N    CMD_EXPORT_STREAM_IMG = 0x6100,
N    CMD_CAPTRUE_SENSOR = 0x6101,
N
N} Cmd;
N
Ntypedef struct {
N    uint16_t preamble;
N    uint16_t ctrl; /* payload_len & ctrl info */
N    uint16_t cmd;
N    uint16_t msg_len;
N} __attribute__((packed)) MsgHdr;
N
Ntypedef struct {
N    uint32_t param1;
N    uint32_t param2;
N    uint8_t data[];
N} __attribute__((packed)) CmdPram;
N
Ntypedef struct {
N    union {
N        uint32_t error;
N        uint32_t param1;
N    } __attribute__((packed));
N    uint32_t param2;
N    uint8_t data[];
N} __attribute__((packed)) RspPram;
N
Ntypedef struct {
N    uint32_t op_parm1;
N    uint32_t op_parm2;
N    uint8_t  data[];
N} __attribute__((packed)) OpPram;
N
N
N#define NO_ERROR        0
N#define PARAM_ERR       1
N#define RSP_NOT_IMPLEMENTED 0xFFFE
N#define RSP_UKNOWN_CMD  0xFFFF
N#define BAD_CONFIRMATION 2  // CMD_RESET RESPONSE
N#define BAD_MODE         1
N#define FILE_ERROR       1  // File data transfer error
N
N#define MSG_HDR_CMD     0xA583
N#define MSG_HDR_RSP     0x8A35
N#define MSG_HDR_VAL     0xA553  // this is used by the pre-packet code
N#define MSG_HDR_SIZE    16  // includes both MsgHdr and CmdPram addr & len
N#define PKT_CRC_FLAG    0x4000
N
N#if (HAPS_ID == 2)
S#define MSG_DATA_BUF_MAX    0x890
N#else
N#define MSG_DATA_BUF_MAX    0x2400  // used for testing (worst case msg payload is 4096+72)
N#endif
N
N#define UPDATE_MODULE_NONE 0
N#define UPDATE_MODULE_SCPU 0x07
N#define UPDATE_MODULE_NCPU 0x08
N
N#endif
L 6 "..\..\..\..\scpu\middleware\comm\host_msg.h" 2
N#define FLAG_COMM_START      BIT(0)
N#define FLAG_COMM_ISR        BIT(1)
N#define FLAG_COMM_TIMER      BIT(2)
N#define FLAG_COMM_APP_DONE   BIT(3) // for tid_appmgr
N#define FLAG_COMM_USB_DONE   BIT(4)
N#define FLAG_COMM_UART_DONE  BIT(5)
N
N#define USB_HOST                (YES)
N
N#if USB_HOST == 1
X#if (1) == 1
N#define FLAG_COMM_RX_DONE    FLAG_COMM_USB_DONE
N#else
S#define FLAG_COMM_RX_DONE    FLAG_COMM_UART_DONE
N#endif
N
Nenum WR_MODE {
N    WMODE_DEF = 0, // regular response message, send immediately
N    WMODE_ACK,     // ack packet, send immediately
N    WMODE_ALT      // FR data, send only after response message is done
N};
N
N/* Modified MSG_DATA_BUF_MAX from 0x100 to 0x1400 to improve the speed of testcase verification */
N//extern u8 msg_rbuf[MSG_DATA_BUF_MAX + sizeof(MsgHdr)+ sizeof(RspPram) + 4 + 4];
N//extern u8 msg_tbuf[MSG_DATA_BUF_MAX + sizeof(MsgHdr)+ sizeof(RspPram) + 4 + 4];
Nextern u8* msg_rbuf;
Nextern u8* msg_tbuf;
N
Nvoid kcomm_msg_init(osThreadId_t tid_comm);
Nextern int32_t kcomm_read(u32 address, u32 size);
Nint kcomm_write_msg(u8 *buf, int len, int crc_flag);
Nint kcomm_write(u8 *buf, int len, int mode);
Nvoid kcomm_wait(void);
Nvoid kcomm_send_no_rsp(void);
Nvoid kcomm_send_rsp(u16 cmd, u8 *buf, int len);
N
Nu16 gen_crc16(u8 *data, u32 size);
N
N#endif
L 5 "..\..\..\..\scpu\middleware\ota\ota_update.h" 2
N
N#include "kdp_flash_table.h"
N#include "kl520_include.h"
N#include "ota.h"
L 1 "..\..\..\..\scpu\middleware\ota\ota.h" 1
N#ifndef __OTA_H__
N#define __OTA_H__
N#include "board_kl520.h"
N#include "kl520_com.h"
L 1 "..\..\..\..\scpu\middleware\comm\kl520_com.h" 1
N#ifndef __KL520_COM_H__
N#define __KL520_COM_H__
N#include "board_kl520.h"
N
N#if CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_LWCOM
X#if 0 == 0
N#if ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_DEF )
X#if ( 1 == 0 )
S#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
Stypedef enum kl520_com_flags_enum {
S    KL520_COM_NORMAL = 0,
S    KL520_COM_HAS_ADDITIONAL_IO = 1,
S
S} kl520_com_flags;
S#endif
S
S#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
S#include "host_uart_com.h"
S#include "drivers.h"
S#include "kdp_uart.h"
S
S
S#if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
S#define	COM_BUS_RESPONSE_OFFESET	(14)		//data size packet
S#else
S#define	COM_BUS_RESPONSE_OFFESET	(0)
S#endif
S
S#define     COM_BUS_HEAD_RX                         ((UINT32)0x78875AA5)
S#define     COM_BUS_HEAD_RX_1                       ((COM_BUS_HEAD_RX&0xFF000000)>>24 )
S#define     COM_BUS_HEAD_RX_2                       ((COM_BUS_HEAD_RX&0x00FF0000)>>16 )
S#define     COM_BUS_HEAD_RX_3                       ((COM_BUS_HEAD_RX&0x0000FF00)>>8 )
S#define     COM_BUS_HEAD_RX_4                       ((COM_BUS_HEAD_RX&0x000000FF)>>0 )
S
S#define     COM_BUS_HEAD_TX                         ((UINT32)(~(COM_BUS_HEAD_RX)) )
S#define     COM_BUS_TAIL                            (0x7887)
S#define     COM_BUS_TAIL_1                          (COM_BUS_TAIL&0xFF)
S#define     COM_BUS_TAIL_2                          ((COM_BUS_TAIL>>8)&0xFF)
S
S#define     COM_BUS_GET_DATA_HEAD_TX                (0xC410C410)
S
S//error code
S#define     COM_BUS_HEAD_CHECK_ERROR                (0xEEE0)
S#define     COM_BUS_TAIL_CHECK_ERROR                (0xEEE1)
S#define     COM_BUS_LENGTH_CHECK_ERROR              (0xEEE2)
S#define     COM_BUS_PACKET_OK                       (0x66)
S
S
S//=================================
S
Stypedef enum {
S    DEV_UART,
S    DEV_SPI,
S    DEV_I2C,
S    DEV_USB,
S    DEV_SDIO,
S    DEV_OTG,
S    TOTAL_DEV,
S    DEV_NULL=0xFF,
S} dev_type;
S
Sstruct st_com_type
S{
S    dev_type com_type; //0~4: uart0~uart4, 0x11: SPI1, 0xFF: nothing
S    UINT8 uart_port;
S    kdp_uart_dev_id dev_id;
S    kl520_com_flags flags;
S    UINT8 *tx_buffer;
S    UINT32 *tx_buffer_index;
S    UINT8 *rx_buffer;
S    UINT32 *rx_buffer_index;
S
S    UINT32 head;
S    UINT16 host_number;
S    UINT16 cmd;
S    UINT16 data_len;
S    UINT16 data_start_index; //data end_index = data_start_index + data_len
S    UINT32 checksum;
S    UINT8 no_head_tail_en; //response bit or not
S};
S
S
Stypedef struct kl520_com_user_ops_struct {
S    u16     (*packet_analyze)(struct st_com_type *st_com);
S    void    (*packet_response_w_tx_buffer)( struct st_com_type *st_com, UINT8 *in_data, UINT16 in_data_legn );
S    void    (*parser)(struct st_com_type *st_com);
S} kl520_com_user_ops;
S
S// struct st_com_format
S// {
S// //20200 1 2 1  on going!!
S
S// };
S
Sextern struct st_com_type stCom_type;
Sextern void kl520_com_thread(void);
S
SUINT16 kneron_lwcom_packet_analyze( struct st_com_type *st_com );
Svoid kneron_lwcom_packet_response_w_tx_buffer( struct st_com_type *st_com, UINT8 *in_data, UINT16 in_data_legn );
Svoid kneron_lwcom_packet_response_brief_w_tx_buffer( struct st_com_type *st_com, UINT16 host_number, UINT16 status );
Svoid kneron_lwcom_set_parameter( struct st_com_type *st_com, UINT16 nhost_number, UINT16 cmd );
S
Sextern void kl520_com_buf_addr_init(void);
Sextern void kl520_com_init(kl520_com_flags flags);
Sextern void kl520_com_bus_init(void);
Sextern UINT8 kl520_com_response_Done_check(void);
Sextern UINT8 kl520_com_response( struct st_com_type *st_com );
S
S//-----
Sextern void kl520_com_initial( kl520_com_flags flags );
Sextern void kl520_com_reconfig_baud_rate(int rate);
Svoid kl520_com_reg_user_ops(kl520_com_user_ops *ops);
S
S#endif
S
N#elif ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP )
X#elif ( 1 == 1 )
N#include "kdp_comm.h"
L 1 "..\..\..\..\scpu\middleware\kdp_comm\kdp_comm.h" 1
N#ifndef __KDP_COMM_H__
N#define __KDP_COMM_H__
N
N//#define BYTE_ALIGN   __attribute__ ((packed))
N//#pragma pack(1)
N#include "board_kl520.h"
N
N#if CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_LWCOM
X#if 0 == 0
N#if ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP )
X#if ( 1 == 1 )
N
N#include "host_uart_com.h"
L 1 "..\..\..\..\scpu\middleware\comm\host_uart_com.h" 1
N#ifndef __UART_COM_H__
N#define __UART_COM_H__
N#include "board_kl520.h"
N#include "host_msg.h"
N#include <stdarg.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
N     /* be cooperative with glibc */
N     typedef __CLIBNS va_list __gnuc_va_list;
X     typedef  va_list __gnuc_va_list;
N     #define __GNUC_VA_LIST
N     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 6 "..\..\..\..\scpu\middleware\comm\host_uart_com.h" 2
N
Nextern void kdp_uart_app_com(u8 port, u32 baudrate, u8* buffer, u32 size);
N
N#ifdef USB_HOST
N#else
Sextern void kdp_uart_com_init(void);
Sextern void kdp_uart_com_write(uint8_t *p, int32_t len);
Sextern int kdp_uart_com_read(uint8_t *BufferPtr, uint32_t BufferLen);
N#endif
N#endif
L 12 "..\..\..\..\scpu\middleware\kdp_comm\kdp_comm.h" 2
N#include "drivers.h"
N#include "kdp_uart.h"
N//#include "user_com_protoco.h"
N#if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
X#if ( (0x04)&0x00000F00 )
S#define	COM_BUS_RESPONSE_OFFESET	(14)		//data size packet
N#else
N#define	COM_BUS_RESPONSE_OFFESET	(0)
N#endif
N
N#if (CFG_COM_UART_MSG == COM_UART_MSG_KDP)
X#if (1 == 0)
S#include "kdp_comm_msg_define.h"
N#else
N#include "user_comm_msg_define.h"
L 1 "..\..\user\user_comm_msg_define.h" 1
N#ifndef __USER_COMM_MSG_DEFINE_H__
N#define __USER_COMM_MSG_DEFINE_H__
N
N
N//--------------------PROTOCOL
N#define     COM_BUS_HEAD_RX                         ((UINT32)(0xEFAA))
N#define     COM_BUS_HEAD_RX_1                       ((COM_BUS_HEAD_RX&0x0000FF00)>>8 )
N#define     COM_BUS_HEAD_RX_2                       ((COM_BUS_HEAD_RX&0x000000FF)>>0 )
N
N#define     COM_BUS_HEAD_TX                         ((UINT32)(0xEFAA))
N#define     COM_BUS_HEAD_TX_1                       ((COM_BUS_HEAD_TX&0x0000FF00)>>8 )
N#define     COM_BUS_HEAD_TX_2                       ((COM_BUS_HEAD_TX&0x000000FF)>>0 )
N
N#define     COM_BUS_TAIL                            (0x7887)
N#define     COM_BUS_TAIL_1                          (COM_BUS_TAIL&0xFF)
N#define     COM_BUS_TAIL_2                          ((COM_BUS_TAIL>>8)&0xFF)
N
N#define     COM_BUS_GET_DATA_HEAD_TX                (0xC410C410)
N
N//error code
N#define     COM_BUS_HEAD_CHECK_ERROR                (0xEEE0)
N#define     COM_BUS_TAIL_CHECK_ERROR                (0xEEE1)
N#define     COM_BUS_PACKAGE_SIZE_ERROR              (0xEEE2)
N#define     COM_BUS_CHECK_SUM_ERROR                 (0xEEE3)
N#define     COM_BUS_DATA_SIZE_ERROR                 (0xEEE4)
N#define     COM_BUS_ENCRYPTION_ERROR                (0xEEE5)
N#define     COM_BUS_PACKET_OK                       (0x66)
N
N// Host to Module                   // KID: kneron ID
N	//Register and recognition
N#define KID_RESET 0x10                     //v stop and clear all in-processing messages. enter standby mode
N#define KID_GET_STATUS 0x11                //v to ping the module and get the status
N#define KID_VERIFY 0x12                    //v to verify the person in front of the camera
N#define KID_ENROLL 0x13                    //v to enroll and register the persion in front of the camera
N
N#define KID_ENROLL_OVERWRITE 0x14
N
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N
N	//Snapshot
N//#define KID_SNAP_IMAGE 0x16                //v to snap a picture and save it
N//#define KID_GET_SAVED_IMAGE 0x17           //v to get size of saved image
N//#define KID_UPLOAD_IMAGE 0x18              //v upload images
N
N#define KID_ENROLL_SINGLE 0x1D
N
N	//User info
N#define KID_DEL_USER 0x20                  //v Delete the specified user with user id
N#define KID_DEL_ALL 0x21                   //v Delete all registerred users
N#define KID_GET_USER_INFO 0x22             //v Get user info
N#define KID_FACE_RESET 0x23                //v Reset face status
N#define KID_GET_ALL_USER_ID 0x24           //v get all users ID
N
N#define KID_ENROLL_ITG 0x26
N#endif
N
N	//Version info
N#define KID_GET_VERSION 0x30               //v get version information
N#define KID_GET_VERSION_ZA 0x6a               //zcy v get version information
N#define KID_GET_VERSION_ZAPRD 0x3a               //zcy v get version information
N#define KID_GET_VERSION_HARDWARE 0x3b               //zcy v get version information
N
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N	//OTA
N#define KID_START_OTA 0x40                 //v ask the module to enter OTA mode
N#define KID_STOP_OTA 0x41                  //v ask the module to exit OTA mode
N#define KID_GET_OTA_STATUS 0x42            //v query the current ota status
N#define KID_OTA_HEADER 0x43                //v the ota header data
N#define KID_OTA_PACKET 0x44                //v the data packet, carries real firmware data
N#endif
N
N	//Encryption
N#define KID_INIT_ENCRYPTION 0x50           //v initialize encrypted communication
N#define KID_CONFIG_BAUDRATE 0x51           //v config uart baudrate
N#define KID_SET_RELEASE_ENC_KEY 0x52       //v set release encrypted key(Warning!!!:Once set, the KEY will not be able to modify)
N#define KID_SET_DEBUG_ENC_KEY 0x53         //v set debug encrypted key
N
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N	//Log
N//#define KID_GET_LOG_FILE 0x60              // get log file
N//#define KID_UPLOAD_LOG_FILE 0x61           // upload log file
N
N#if ( CFG_FMAP_EXTRA_ENABLE == YES ) && ( CFG_FMAP_AP_CTRL_TYPE > EX_FM_DISABLE )
X#if ( 0 == 1 ) && ( 3 > 0 )
S#define KID_SW_EXP_FM_MODE 0x70
S#define KID_SW_EXP_DB_MODE 0x71
S#if CFG_FMAP_AP_CTRL_TYPE >= EX_FM_UART_AP_CTRL_MAIN_DB // uart contrl
S#define KID_EXP_FM_DATA 0x72
S#define KID_EXP_DB_DATA 0x73
S#define KID_IMP_DB_DATA 0x74
S
S#define KID_IMP_IMG_DATA 0x76
S#endif //CFG_FMAP_AP_CTRL_TYPE >= EX_FM_UART_AP_CTRL_MAIN_DB // uart contrl
N#endif //( CFG_FMAP_EXTRA_ENABLE == YES ) && ( CFG_FMAP_AP_CTRL_TYPE > EX_FM_DISABLE )
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N#define KID_IMP_FM_DATA 0x75
N//#define KID_SET_EXP_MASS_DATA_HEADER 0x78  //v
N#define KID_SET_IMP_MASS_DATA_HEADER 0x79
N#endif
N
N//#define KID_EXP_ALL_DB 0x7A
N//#define KID_IMP_ALL_DB 0x7B
N#endif
N
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N#define KID_DB_EXPORT_REQUEST   0x7C
N#define KID_UPLOAD_DATA         0x7D
N#define KID_DB_IMPORT_REQUEST   0x7E
N#define KID_DOWNLOAD_DATA       0x7F
N#endif
N
N//-----0xA0-0xAF Unit control
N#if ( CFG_PRODUCTION_TEST == YES ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 1 ) || ( IGNORE_PRODUCTION_TEST == 1 )
S//#define KID_TURN_ON_CAMERA              ( 0x80 ) //
S//#define KID_TURN_OFF_CAMERA             ( 0x81 ) //
S//#define KID_TURN_ON_VIS_LED             ( 0x82 ) //Visible
S//#define KID_TURN_OFF_VIS_LED            ( 0x83 ) //
S#define KID_TURN_ON_IR_LED              ( 0x84 ) //
S#define KID_TURN_OFF_IR_LED             ( 0x85 ) //
S//#define KID_TURN_ON_STRUCT_LED          ( 0x86 ) //
S//#define KID_TURN_OFF_STRUCT_LED         ( 0x87 ) //
S//#define KID_TURN_ON_PANEL               ( 0x88 )
S//#define KID_TURN_OFF_PANEL              ( 0x89 )
S#define KID_SET_EXP_TIME                ( 0x8A )
S#define KID_SET_GAIN                    ( 0x8B )
N#endif
N
N    //MP
N#define KID_SW_BOOT_PART 0xAA
N#define KID_GET_CUR_PART 0xAB
N
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N#define KID_KN_SNAP_IMAGE 0xAC
N#define KID_KN_GET_SAVED_IMAGE 0xAD
N#define KID_KN_UPLOAD_IMAGE 0xAE
N#endif
N
N// user cmd
N#define KID_SOFT_RESET   0xCA
N#define KID_KN_DEVICE_INFO  0xCB
N#define KID_MP_CALIBRATION  0xCC
N#define KID_USER_ROTATE_180 0xCD
N
N#if ( CFG_PRODUCTION_TEST == YES ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 1 ) || ( IGNORE_PRODUCTION_TEST == 1 )
S#if CFG_SNAPSHOT_ENABLE == 1 || CFG_SNAPSHOT_ENABLE == 2
S#define KID_SNAPSHOT_MODE   0xCE
S#endif
N#endif
N    
N#if ((CFG_COM_BUS_TYPE&COM_BUS_USB_MASK) != COM_BUS_USB_MASK)
X#if (((0x04)&0x00000080) != 0x00000080)
N	//Other
N#define KID_SET_THRESHOLD_LEVEL 0xD4       //v Set threshold level
N#define KID_DEBUG_MODE 0xF0                //v
N//#define KID_GET_DEBUG_INFO 0xF1            //v get size of debug information
N//#define KID_UPLOAD_DEBUG_INFO 0xF2         //v upload debug information
N
N#endif
N
N#define KID_DEMO_MODE 0xFE                 //v enter demo mode, verify flow will skip feature comparation step.
N#define KID_POWERDOWN 0xED                 //v be prepared to power off
N
N#define CMD_REPLY_RESULT_MACRO(CMD_TYPE)    \
N    CMD_TYPE(MR_SUCCESS, 0x00) \
N    CMD_TYPE(MR_REJECTED, 0x01) \
N    CMD_TYPE(MR_ABORTED, 0x02) \
N    CMD_TYPE(MR_FAILED_DEV_OPEN_FAIL, 0x04) \
N    CMD_TYPE(MR_FAILED_UNKNOWN_REASON, 0x05) \
N    CMD_TYPE(MR_FAILED_INVALID_PARAM, 0x06) \
N    CMD_TYPE(MR_FAILED_OOM, 0x07) \
N    CMD_TYPE(MR_FAILED_UNKNOWN_USER, 0x08) \
N    CMD_TYPE(MR_FAILED_MAX_USER, 0x09) \
N    CMD_TYPE(MR_FAILED_FACE_ENROLLED, 0x0A) \
N    CMD_TYPE(MR_FAILED_LIVENESS_CHECK, 0x0C) \
N    CMD_TYPE(MR_FAILED_TIME_OUT, 0x0D) \
N    CMD_TYPE(MR_FAILED_AUTHORIZATION, 0x0E) \
N    CMD_TYPE(MR_FAILED_READ_FILE, 0x13) \
N    CMD_TYPE(MR_FAILED_WRITE_FILE, 0x14) \
N    CMD_TYPE(MR_FAILED_NO_ENCRYPT, 0x15) \
N    CMD_TYPE(MR_FAILED_STORE_ERR, 0x16) \
N    CMD_TYPE(MR_FAILED_NO_IMG, 0x17) \
N    CMD_TYPE(MR_FAILED_NO_IDX, 0x18) \
N    CMD_TYPE(MR_FAILED_BUF_OVERFLOW, 0x19) \
N    CMD_TYPE(MR_FAILED_MASS_DATA_HEAD_EMPTY, 0x30) \
N    CMD_TYPE(MR_FAILED_MASS_DATA_DB_ABNORMAL, 0x31) \
N    CMD_TYPE(MR_FAILED_MASS_DATA_FM_ABNORMAL, 0x32) \
N    CMD_TYPE(MR_FAILED_NOT_READY, 0x33) \
N    CMD_TYPE(MR_FAILED_EXISTED_USER, 0x34) \
N    CMD_TYPE(MR_FAILED_IDX_OVERFLOW, 0x35) \
N    CMD_TYPE(MR_CONTIUNOUS, 0x36) \
N    CMD_TYPE(MR_SUCCESS_BUT_DEL_USER, 0x40) \
N    CMD_TYPE(MR_FAILED_INVALID_CMD, 0xFF) \
N
X#define CMD_REPLY_RESULT_MACRO(CMD_TYPE)        CMD_TYPE(MR_SUCCESS, 0x00)     CMD_TYPE(MR_REJECTED, 0x01)     CMD_TYPE(MR_ABORTED, 0x02)     CMD_TYPE(MR_FAILED_DEV_OPEN_FAIL, 0x04)     CMD_TYPE(MR_FAILED_UNKNOWN_REASON, 0x05)     CMD_TYPE(MR_FAILED_INVALID_PARAM, 0x06)     CMD_TYPE(MR_FAILED_OOM, 0x07)     CMD_TYPE(MR_FAILED_UNKNOWN_USER, 0x08)     CMD_TYPE(MR_FAILED_MAX_USER, 0x09)     CMD_TYPE(MR_FAILED_FACE_ENROLLED, 0x0A)     CMD_TYPE(MR_FAILED_LIVENESS_CHECK, 0x0C)     CMD_TYPE(MR_FAILED_TIME_OUT, 0x0D)     CMD_TYPE(MR_FAILED_AUTHORIZATION, 0x0E)     CMD_TYPE(MR_FAILED_READ_FILE, 0x13)     CMD_TYPE(MR_FAILED_WRITE_FILE, 0x14)     CMD_TYPE(MR_FAILED_NO_ENCRYPT, 0x15)     CMD_TYPE(MR_FAILED_STORE_ERR, 0x16)     CMD_TYPE(MR_FAILED_NO_IMG, 0x17)     CMD_TYPE(MR_FAILED_NO_IDX, 0x18)     CMD_TYPE(MR_FAILED_BUF_OVERFLOW, 0x19)     CMD_TYPE(MR_FAILED_MASS_DATA_HEAD_EMPTY, 0x30)     CMD_TYPE(MR_FAILED_MASS_DATA_DB_ABNORMAL, 0x31)     CMD_TYPE(MR_FAILED_MASS_DATA_FM_ABNORMAL, 0x32)     CMD_TYPE(MR_FAILED_NOT_READY, 0x33)     CMD_TYPE(MR_FAILED_EXISTED_USER, 0x34)     CMD_TYPE(MR_FAILED_IDX_OVERFLOW, 0x35)     CMD_TYPE(MR_CONTIUNOUS, 0x36)     CMD_TYPE(MR_SUCCESS_BUT_DEL_USER, 0x40)     CMD_TYPE(MR_FAILED_INVALID_CMD, 0xFF) 
N#define TO_ENUM(result, value) result=value,
N#define TO_STR(result, value)  {case result: return #result; break;}
N
Nenum uart_reply_result {
N    CMD_REPLY_RESULT_MACRO(TO_ENUM)
X    MR_SUCCESS=0x00, MR_REJECTED=0x01, MR_ABORTED=0x02, MR_FAILED_DEV_OPEN_FAIL=0x04, MR_FAILED_UNKNOWN_REASON=0x05, MR_FAILED_INVALID_PARAM=0x06, MR_FAILED_OOM=0x07, MR_FAILED_UNKNOWN_USER=0x08, MR_FAILED_MAX_USER=0x09, MR_FAILED_FACE_ENROLLED=0x0A, MR_FAILED_LIVENESS_CHECK=0x0C, MR_FAILED_TIME_OUT=0x0D, MR_FAILED_AUTHORIZATION=0x0E, MR_FAILED_READ_FILE=0x13, MR_FAILED_WRITE_FILE=0x14, MR_FAILED_NO_ENCRYPT=0x15, MR_FAILED_STORE_ERR=0x16, MR_FAILED_NO_IMG=0x17, MR_FAILED_NO_IDX=0x18, MR_FAILED_BUF_OVERFLOW=0x19, MR_FAILED_MASS_DATA_HEAD_EMPTY=0x30, MR_FAILED_MASS_DATA_DB_ABNORMAL=0x31, MR_FAILED_MASS_DATA_FM_ABNORMAL=0x32, MR_FAILED_NOT_READY=0x33, MR_FAILED_EXISTED_USER=0x34, MR_FAILED_IDX_OVERFLOW=0x35, MR_CONTIUNOUS=0x36, MR_SUCCESS_BUT_DEL_USER=0x40, MR_FAILED_INVALID_CMD=0xFF,
N};
N
Nchar *_str_uart_reply(enum uart_reply_result result);
N
N#pragma diag_suppress 111
Ninline char *_str_uart_reply(enum uart_reply_result result)
N{
N    switch (result)
N    {
N        CMD_REPLY_RESULT_MACRO(TO_STR)
X        {case MR_SUCCESS: return "MR_SUCCESS"; break;} {case MR_REJECTED: return "MR_REJECTED"; break;} {case MR_ABORTED: return "MR_ABORTED"; break;} {case MR_FAILED_DEV_OPEN_FAIL: return "MR_FAILED_DEV_OPEN_FAIL"; break;} {case MR_FAILED_UNKNOWN_REASON: return "MR_FAILED_UNKNOWN_REASON"; break;} {case MR_FAILED_INVALID_PARAM: return "MR_FAILED_INVALID_PARAM"; break;} {case MR_FAILED_OOM: return "MR_FAILED_OOM"; break;} {case MR_FAILED_UNKNOWN_USER: return "MR_FAILED_UNKNOWN_USER"; break;} {case MR_FAILED_MAX_USER: return "MR_FAILED_MAX_USER"; break;} {case MR_FAILED_FACE_ENROLLED: return "MR_FAILED_FACE_ENROLLED"; break;} {case MR_FAILED_LIVENESS_CHECK: return "MR_FAILED_LIVENESS_CHECK"; break;} {case MR_FAILED_TIME_OUT: return "MR_FAILED_TIME_OUT"; break;} {case MR_FAILED_AUTHORIZATION: return "MR_FAILED_AUTHORIZATION"; break;} {case MR_FAILED_READ_FILE: return "MR_FAILED_READ_FILE"; break;} {case MR_FAILED_WRITE_FILE: return "MR_FAILED_WRITE_FILE"; break;} {case MR_FAILED_NO_ENCRYPT: return "MR_FAILED_NO_ENCRYPT"; break;} {case MR_FAILED_STORE_ERR: return "MR_FAILED_STORE_ERR"; break;} {case MR_FAILED_NO_IMG: return "MR_FAILED_NO_IMG"; break;} {case MR_FAILED_NO_IDX: return "MR_FAILED_NO_IDX"; break;} {case MR_FAILED_BUF_OVERFLOW: return "MR_FAILED_BUF_OVERFLOW"; break;} {case MR_FAILED_MASS_DATA_HEAD_EMPTY: return "MR_FAILED_MASS_DATA_HEAD_EMPTY"; break;} {case MR_FAILED_MASS_DATA_DB_ABNORMAL: return "MR_FAILED_MASS_DATA_DB_ABNORMAL"; break;} {case MR_FAILED_MASS_DATA_FM_ABNORMAL: return "MR_FAILED_MASS_DATA_FM_ABNORMAL"; break;} {case MR_FAILED_NOT_READY: return "MR_FAILED_NOT_READY"; break;} {case MR_FAILED_EXISTED_USER: return "MR_FAILED_EXISTED_USER"; break;} {case MR_FAILED_IDX_OVERFLOW: return "MR_FAILED_IDX_OVERFLOW"; break;} {case MR_CONTIUNOUS: return "MR_CONTIUNOUS"; break;} {case MR_SUCCESS_BUT_DEL_USER: return "MR_SUCCESS_BUT_DEL_USER"; break;} {case MR_FAILED_INVALID_CMD: return "MR_FAILED_INVALID_CMD"; break;}
N    default:
N        break;
N    }
N    
N    return "";
N}
N#pragma diag_warning 111
N
N
N#endif    //__USER_COMM_MSG_DEFINE_H__
N
L 25 "..\..\..\..\scpu\middleware\kdp_comm\kdp_comm.h" 2
N#endif
N
N//#define v MR_SUCCESS     0     // success   //Lucien
N//#define v MR_REJECTED    1     // module rejected this command
N//#define v MR_ABORTED     2     // algo aborted
N//#define v MR_FAILED4_CAMERA  4 // camera open failed
N//#define v MR_FAILED4_UNKNOWNREASON  5 // UNKNOWN_ERROR
N//#define MR_FAILED4_INVALIDPARAM  6  // invalid param
N//#define MR_FAILED4_NOMEMORY  7      // no enough memory
N//#define MR_FAILED4_UNKNOWNUSER  8   // no user enrolled
N//#define MR_FAILED4_MAXUSER  9       // exceed maximum user number
N//#define MR_FAILED4_FACEENROLLED  10 // this face has been enrolled
N//#define MR_FAILED4_LIVENESSCHECK  12// liveness check failed
N//#define MR_FAILED4_TIMEOUT  13      // exceed the time limit
N//#define x MR_FAILED4_AUTHORIZATION  14// authorization failed
N//#define x MR_FAILED4_CAMERAFOV  15    // camera fov test failed
N//#define x MR_FAILED4_CAMERAQUA  16    // camera quality test failed
N//#define x MR_FAILED4_CAMERASTRU  17   // camera structure test failed
N//#define x MR_FAILED4_BOOT_TIMEOUT  18 // boot up timeout
N//#define x MR_FAILED4_READ_FILE   19    // read file failed
N//#define x MR_FAILED4_WRITE_FILE  20   // write file failed
N//#define x MR_FAILED4_NO_ENCRYPT  21   // encrypt must be set
N
N#pragma pack(1)
Ntypedef enum kl520_com_flags_enum {
N    KL520_COM_NORMAL = 0,
N    KL520_COM_HAS_ADDITIONAL_IO = 1,
N
N} kl520_com_flags;
N
N//=================================
Ntypedef enum {
N    DEV_UART,
N    DEV_SPI,
N    DEV_I2C,
N    DEV_USB,
N    DEV_SDIO,
N    DEV_OTG,
N    TOTAL_DEV,
N    DEV_NULL=0xFF,
N} dev_type;
N
Nstruct st_com_type
N{
N    dev_type com_type; //0~4: uart0~uart4, 0x11: SPI1, 0xFF: nothing
N    UINT8 uart_port;
N    kdp_uart_dev_id dev_id;
N    kl520_com_flags flags;
N    UINT8 *tx_buffer;
N    UINT32 *tx_buffer_index;
N    UINT8 *rx_buffer;
N    UINT32 *rx_buffer_index;
N    u8 *parser_buffer;
N    u32 parser_cnt;
N    UINT32 parser_end;
N
N    UINT16 head;  //syncword
N    UINT8 cmd;    //msgid
N    UINT16 host_number;//not used
N    UINT16 data_len;//size
N    UINT16 data_start_index; //data end_index = data_start_index + data_len
N    UINT32 checksum; // exp suncWord XOR-alg-result
N
N#if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
X#if ( (0x04)&0x00000F00 )
S    UINT8 no_head_tail_en; //response bit or not deshiman no
N#endif
N};
N
Ntypedef struct kl520_com_user_ops_struct {
N    u16     (*packet_analyze)(struct st_com_type *st_com);
N    void    (*parser)(struct st_com_type *st_com);
N} kl520_com_user_ops;
N
Nextern struct st_com_type stCom_type;
N
N#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
X#if ( (0x04)&0x0000007F ) || ( (0x04)&0x00000F00 )
N#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
X#if ( (0x04)&0x0000007F )
Nextern void kl520_com_reconfig_baud_rate(int rate);
N#endif
N
Nextern void kl520_com_buf_addr_init(void);
Nextern void kl520_com_init(kl520_com_flags flags);
Nextern void kl520_com_initial( kl520_com_flags flags );
Nextern UINT8 kl520_com_response( struct st_com_type *st_com );
Nextern UINT8 kl520_com_response_Done_check(void);
NUINT16 kneron_lwcom_packet_analyze( struct st_com_type *st_com );
Nvoid kl520_com_reg_user_ops(kl520_com_user_ops *ops);
Nextern void kl520_com_thread(void);
N#endif
N
N
Nextern void kl520_com_bus_init(void);
N
N//-----
N#pragma pack()
N//#endif
N#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_USB_MASK )
X#if ( (0x04)&0x0000007F ) || ( (0x04)&0x00000080 )
N//--------------------PARAER
N// error code for cmd parser
N#define NO_ERROR        0
N#define NO_MATCH        1
N#define RSP_NOT_IMPLEMENTED 0xFFFE
N#define RSP_UKNOWN_CMD  0xFFFF
N#define BAD_CONFIRMATION 2  // CMD_RESET RESPONSE
N#define BAD_MODE         1
N#define FILE_ERROR       1  // File data transfer error
N
N#endif
N#endif
N#endif
N#endif    //__KDP_COMM_H__
L 116 "..\..\..\..\scpu\middleware\comm\kl520_com.h" 2
N#elif ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_DEF_USR )
X#elif ( 1 == 2 )
S#include "user_com.h"
S#elif ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP_USR )
S#include "user_comm.h"
N#endif
N#endif
N#endif
L 5 "..\..\..\..\scpu\middleware\ota\ota.h" 2
N
N#include "kdp_flash_def.h"
N#include "usr_flash_img_table.h"
N
N#define OTA_BOOT_CONFIG_LOG         (YES)
N#define OTA_CONFIG_LOG_EN           (NO)
N#define OTA_LOG_EN                  (YES)
N#define OTA_TIMING_DEBUG_EN         (NO)
N
N#define OTA_FULL_CONSOLE_EN        (NO)
N
N
N#define OTA_CRC_CHECK_EN            (YES)
N
N
N#if (IMAGE_SIZE == IMAGE_64MB)
X#if (16 == 64)
S#define OTA_USER_BACKUP             (YES)
S#define OTA_USER_BACKUP_SEPERATE    (YES)
S#define OTA_USER_BOOT_CHECK         (YES)
N#else
N#define OTA_USER_BACKUP             (NO)
N#define OTA_USER_BACKUP_SEPERATE    (NO)
N#endif
N
N//----flash OTA related
N
N#define FLASH_HEAD_RX           (0x78875AA5)
N#define FLASH_HEAD_RX_1         ((FLASH_HEAD_RX&0xFF000000)>>24 )
N#define FLASH_HEAD_RX_2         ((FLASH_HEAD_RX&0x00FF0000)>>16 )
N#define FLASH_HEAD_RX_3         ((FLASH_HEAD_RX&0x0000FF00)>>8 )
N#define FLASH_HEAD_RX_4         ((FLASH_HEAD_RX&0x000000FF)>>0 )
N
N
N
N#define FLASH_HEAD_TX           (~(0x78875AA5))
N#define FLASH_TAIL              (0x7887)
N#define FLASH_TAIL_1            (FLASH_TAIL&0xFF)
N#define FLASH_TAIL_2            ((FLASH_TAIL>>8)&0xFF)
N
N
N#define FLASH_GET_DATA_HEAD_TX                  (0xC410C410)
N
N
N#define FLASH_PACKET_HEAD_BYTE_SIZE             (4)
N#define FLASH_PACKET_SECTOR_BYTE_SIZE           (2)
N#define FLASH_PACKET_DATA_SIZE_BYTE_SIZE        (2)
N#define FLASH_PACKET_DATA_BYTE_SIZE             (1)
N#define FLASH_PACKET_RESPONSE_BYTE_SIZE         (1)
N#define FLASH_PACKET_ACTION_BYTE_SIZE           (1)
N#define FLASH_PACKET_CHECKSUM_BYTE_SIZE         (4)
N
N#define FLASH_PACKET_TAIL_BYTE_SIZE             (2)
N
N
N//error code
N#define PACKET_HEAD_CHECK_ERROR                 (0xE0)
N#define PACKET_TAIL_CHECK_ERROR                 (0xE1)
N
N#define FLASH_PACKET_OK                         (0x66)
N
N
N//cmd code
N#define FLASH_PROGRAM_ACT                       (0xF0)
N#define FLASH_READ_ACT                          (0xF1)
N#define FLASH_ERASE_SECTOR_ACT                  (0xF2)
N#define FLASH_DATA_TO_DDR_ACT                   (0xF3)
N#define FLASH_LARGE_PROGRAM                     (0xFD)
N#define FLASH_UI_MODEL_INFO                     (0xFE)      //tool or host told "UI image", fw_info and "All model" bin file size to 520
N#define FLASH_MODEL_SIZE                        (0xFA)      //response partial model size to host
N
N#define	FLASH_CMD_ACT                           (0x00)		//for future use
N
N#define	FLASH_READ_NIR_ACT                      (0xE1)
N#define	FLASH_READ_RGB_ACT                      (0xE2)
N#define	FLASH_READ_ALL_ACT                      (0xE3)
N
N#define FLASH_CMD_ACT_NUM_INIT                  (0x01)
N#define FLASH_CMD_ACT_NUM_NIR                   (0x02)
N#define FLASH_CMD_ACT_NUM_RGB                   (0x03)
N#define FLASH_CMD_XXXXXXXXXX                    (0x04)
N#define FLASH_CMD_ACT_NUM_SW_VERSION            (0x05)//??
N#define FLASH_CMD_ACT_NUM_PROC_DONE             (0x06)
N#define FLASH_CMD_ACT_NUM_SEL_SCPU              (0x07)
N#define FLASH_CMD_ACT_NUM_SEL_NCPU              (0x08)
N
N#define FLASH_CMD_ACT_NUM_SEL_MODEL             (0x09)
N#define FLASH_CMD_ACT_NUM_SEL_IMAGE_UPDATE      (0x0A)
N#define FLASH_CMD_ACT_NUM_SEL_FW_INFO           (0x0B)
N#define FLASH_CMD_ACT_NUM_SEL_MODEL_PARTIAL     (0x0C)
N
N
N
N//status code
N#define FLASH_STATUS_OK                     (0x7855)
N#define FLASH_STATUS_FAIL                   (0xEEEE)	//packet fail
N#define FLASH_STATUS_COMPARE_FAIL           (0xEEE0)
N#define FLASH_STATUS_RECEIVE_FAIL           (0xEEE1)
N#define FLASH_STATUS_PROGRAM_FAIL           (0xEEE2)
N#define FLASH_STATUS_RECEIVE_OVER_SIZE_FAIL (0xEEE3)
N#define FLASH_STATUS_READ_CONFIG_FAIL       (0xEEE4)
N#define FLASH_STATUS_CRC_FAIL               (0xEEE5)
N#define FLASH_STATUS_MODEL_AREA_FAIL        (0xEEE6)
N
N
N
N
N//---flash controoler related
N//----flash machine status
N#define FLASH_DRV_FAIL                      ( 0xE2 )
N#define FLASH_DRV_PROGRAM_FAIL              ( 0xE3 )
N#define FLASH_DRV_OK                        ( 1 )
N#define FLASH_DRV_BUSY                      ( 2 )
N#define FLASH_DRV_NOTHING                   ( 0x88 )
N
N
N
N
N//Bin files in flash size and index
N#define SCPU_SIZE                           ( KDP_FLASH_FW_SCPU_SIZE )
N#define NCPU_SIZE                           ( KDP_FLASH_FW_NCPU_SIZE )
N#define BOOT_CFG_SIZE                       ( PARTITION_CFG_SIZE )
N
N#define SCPU0_START_SECTOR_INDEX            (KDP_FLASH_FW_SCPU_ADDR>>12 )
N#define SCPU0_END_SECTOR_INDEX              ( ((KDP_FLASH_FW_SCPU_ADDR + SCPU_SIZE)>>12) - 1)
N#define NCPU0_START_SECTOR_INDEX            (KDP_FLASH_FW_NCPU_ADDR/4096)
N#define NCPU0_END_SECTOR_INDEX              ( ((KDP_FLASH_FW_NCPU_ADDR + KDP_FLASH_FW_NCPU_SIZE)>>12) - 1)
N#define BOOT_CFG0_START_SECTOR_INDEX        ( KDP_FLASH_BOOT_CFG0_ADDR>>12 )
N#define BOOT_CFG0_END_SECTOR_INDEX          ( KDP_FLASH_BOOT_CFG0_ADDR>>12 )
N
N#define SCPU1_START_SECTOR_INDEX            ( KDP_FLASH_FW_SCPU1_ADDR>>12 )
N#define SCPU1_END_SECTOR_INDEX              ( ((KDP_FLASH_FW_SCPU1_ADDR + SCPU_SIZE)>>12) - 1)
N#define NCPU1_START_SECTOR_INDEX            ( KDP_FLASH_FW_NCPU1_ADDR>>12 )
N#define NCPU1_END_SECTOR_INDEX              ( ((KDP_FLASH_FW_NCPU1_ADDR + NCPU_SIZE)>>12) - 1 )
N#define BOOT_CFG1_START_SECTOR_INDEX        ( KDP_FLASH_BOOT_CFG1_ADDR >>12 )
N#define BOOT_CFG1_END_SECTOR_INDEX          ( KDP_FLASH_BOOT_CFG1_ADDR >>12 )
N
N#define MODEL_START_SECTOR_INDEX            (KDP_FLASH_ALL_MODELS_ADDR>>12)
N#define MODEL_END_SECTOR_INDEX              ( ((KDP_FLASH_ALL_MODELS_ADDR+KDP_FLASH_ALL_MODELS_SIZE)>>12) -1 )
N#define USR_IMAGE_START_SECTOR_INDEX        (USR_FLASH_SETTINGS_ADDR>>12)
N#define USR_IMAGE_END_SECTOR_INDEX          ( (( USR_FLASH_SETTINGS_ADDR+USR_FLASH_SETTINGS_SIZE ) >> 12) -1 )
N#define FW_INFO_START_SECTOR_INDEX          (KDP_FLASH_FW_INFO_ADDR>>12)
N
N#if (IMAGE_SIZE == IMAGE_64MB)
X#if (16 == 64)
S//model update add
S#define MODEL_START_SECTOR_INDEX_1            ((KDP_FLASH_ALL_MODELS_ADDR+KDP_FLASH_ALL_MODEL_OFFSET_1)>>12)
S#define USR_IMAGE_START_SECTOR_INDEX_1        ((USR_FLASH_SETTINGS_ADDR+USR_FLASH_SETTINGS_OFFSET_1)>>12)
S#define FW_INFO_START_SECTOR_INDEX_1          ((KDP_FLASH_FW_INFO_ADDR+KDP_FLASH_FW_INFO_OFFSET_1)>>12)
N#endif
N
N
N#define FLAGS_FLASH_START       (1<<1)
N//--------------------------------------------
N
Nextern void Drv_test_function_main(void);
Nextern UINT8    *gu8OTA_Rx_buffer;
Nextern UINT32   gu8OTA_Rx_buffer_index;
Nextern UINT8    *gu8OTA_Tx_buffer;
Nextern UINT32   gu8OTA_Tx_buffer_index;
N
N//--------------------------------------------
Nenum eflash_flow
N{
N	eflash_init =  0x00,
N	eflash_program = 0xF0,
N	eflash_read =  0xF1,
N	eflash_erase = 0xF2,
N	eflash_store_DDR = 0xF3,
N	eflash_model_size = FLASH_MODEL_SIZE ,
X	eflash_model_size = (0xFA) ,
N	eflash_large_program = FLASH_LARGE_PROGRAM,
X	eflash_large_program = (0xFD),
N	eflash_ui_image_info = FLASH_UI_MODEL_INFO,
X	eflash_ui_image_info = (0xFE),
N	eflash_NIR =   FLASH_READ_NIR_ACT,
X	eflash_NIR =   (0xE1),
N	eflash_RGB =   FLASH_READ_RGB_ACT,
X	eflash_RGB =   (0xE2),
N 	eflash_ALL =   FLASH_READ_ALL_ACT,   
X 	eflash_ALL =   (0xE3),   
N	eflash_idle =  0xFF ,
N};
N
Nenum eOTA_flow
N{
N
N    eOTA_init = 0,          //clear Uart buffer and flags!
N    eOTA_packet_analyze,
N    eOTA_response_doing,
N    eOTA_error_report,
N    eOTA_idle,
N
N};
N
Nenum eOTA_bin
N{
N    eOTA_bin_scpu = 0,
N    eOTA_bin_ncpu,
N    eOTA_bin_all_model,
N    eOTA_bin_ui_image,
N    eOTA_bin_fw_info,
N    eOTA_bin_partial_model,
N    eOTA_bin_null,
N};
N
N
N
Nstruct st_OTA_format
N{
N    UINT32  head;                   //packet start
N    UINT16  host_number;
N    UINT16  cmd_stat;
N    UINT16  sector_index;
N    UINT8   action_number;
N    UINT16  data_size;              //how many bytes need to read or program
N    UINT32  check_sum;
N    UINT16  tail;                   //packet end
N    UINT16	status;                 //response use
N    //packet related
N    UINT8   busy_flag;
N    UINT8   *ptr;
N    UINT32  *ptr_index;
N    UINT16  data_offset;
N    UINT32  buf_max_size;
N    //UINT16    data_end_offset;
N    UINT32  packet_ddr_ptr;
N};
N
Ntypedef struct st_OTA_flash
N{
N    enum eOTA_flow flow;
N    struct st_OTA_format 	receive_cmd;
N    struct st_OTA_format 	send_response;
N
N    //for packet use
N    UINT32	*temp_buffer;
N    UINT32	temp_buffer_index;
N    UINT32	temp_buffer_size;
N
N    //boot info and offset
N    UINT32  pass_sector_count;          //passed sector count
N    UINT32  sector_offset;              //offset in flash address
N    UINT16  sector_acc;
N    UINT16  target_sectors;             //total bin file need sectors
N    enum eOTA_bin   bin_type;                   //0:SCPU, 1:NCPU,2:model,3:user_UIimage, 4:fw_info, 5:partial mode ... , 0xFF:unknown
N    UINT32  target_bytes;               //how many bytes in this bin
N
N    UINT16  sn_cpu_status;              //record OTA update status, 0: update done, oxEEE?: fail
N                                        //cpu program sequence, for error check
N                                        //bit 0: spcu idle flag, bit 1: npcu idle flag,
N                                        //bit 2: scpu ready for program, bit 3: ncpu ready for program
N                                        //bit 4: spcu program Done flag, bit 5: npcu program done flag,
N                                        //bit 6: scpu forbiden, bit 7: ncpu forbiden
N    //save packet to DDR
N    UINT32  *ddr_ptr;                   //save bin to DDR for program use
N    UINT32  ddr_ptr_index;              //how many bytes in ddr_ptr
N    UINT32  CRC;
N
N    //model related parameter
N    UINT32  second_last_start_add;     //find the last second model address
N    UINT32  aligned_offset;
N    UINT32  last_start_add;
N    UINT32  model_size;
N
N}OTA_FLASHt;
N
Nextern OTA_FLASHt stOTA;
Nextern osThreadId_t com_bus_tid;
N
N/* Please move the following code to kdp_ota */
Nextern void Drv_OTA_Thread( void );
Nextern void Drv_OTA_main( void );
Nextern void Drv_OTA_init(OTA_FLASHt * stota);
Nvoid Drv_Uart2_Tx_arrange( void * data_ptr , UINT16 len);
Nextern UINT16 drv_flash_main( OTA_FLASHt * stota  );
Nextern void ota_thread_event_set(void);
Nextern UINT32 drv_read_all_model_crc(void);
NUINT32 drv_read_each_model_crc(uint8_t idx);
Nextern UINT32 Drv_utility_checksum( UINT8 * buf, UINT16 start, UINT16 end );
N
N#endif
L 9 "..\..\..\..\scpu\middleware\ota\ota_update.h" 2
N
N#define SCPU_PARTITION0_START_IN_FLASH    KDP_FLASH_FW_SCPU_ADDR
N#define NCPU_PARTITION0_START_IN_FLASH    KDP_FLASH_FW_NCPU_ADDR
N#define PARTITION_0_CFG_START_IN_FLASH    KDP_FLASH_BOOT_CFG0_ADDR
N
N#define SCPU_PARTITION1_START_IN_FLASH    KDP_FLASH_FW_SCPU1_ADDR
N#define NCPU_PARTITION1_START_IN_FLASH    KDP_FLASH_FW_NCPU1_ADDR
N#define PARTITION_1_CFG_START_IN_FLASH    KDP_FLASH_BOOT_CFG1_ADDR
N
N#define SCPU_START_ADDRESS          0x10102000
N#define NCPU_START_ADDRESS          0x28000000
N#define OTA_START_DDR_ADDR          0x60000000
N
N#define SCPU_IMAGE_SIZE             KDP_FLASH_FW_SCPU_SIZE
N#define NCPU_IMAGE_SIZE             KDP_FLASH_FW_NCPU_SIZE
N#define MODEL_IMAGE_SIZE            KDP_FLASH_ALL_MODELS_SIZE
N#define USER_IMG_IMAGE_SIZE         USR_FLASH_SETTINGS_SIZE
N#define FW_INFO_IMAGE_SIZE          KDP_FLASH_FW_INFO_SIZE
N
N#define PARTITION_CFG_SIZE          32
N
N#define OTA_UPDATE_SUCCESS 0
N#define OTA_AUTH_FAIL 251
N#define OTA_FLASH_FAIL 252
N#define OTA_DOWNLOAD_FAIL 253
N
N// scpu and ncpu boot config status
N#define  BOOT_STATE_CONFIRMED           0x1
N#define  BOOT_STATE_FIRST_BOOT          0x2
N#define  BOOT_STATE_POST_FIRST_BOOT     0x4
N#define  BOOT_STATE_NOT_CONFIRMED       0x8
N
N//user config boot status
N#define  USER_STATE_ACTIVE              0x1
N#define  USER_STATE_ON_GOING            0x2
N#define  USER_STATE_WAIT_ACTIVE         0x4
N#define  USER_STATE_INACTIVE            0x8
N
N
N
N#define USER_PARTITION_SCPU             (0x00)
N#define USER_PARTITION_NCPU             (0x01)
N#define USER_PARTITION_FW_INFO          (0x02)
N#define USER_PARTITION_MODEL            (0x03)
N#define USER_PARTITION_UI_IMG           (0x04)
N
N
N#define OTA_JUDGE_SIZE                  (5)
N
N#define OTA_AREA_BIT                    (1<<7)
N#define OTA_STATUS_BIT                  (0xF)
N
N
N#define OTA_STAT_NOTHING                (0x0)       //no OTA, no check, means this area is OK
N#define OTA_STAT_DO_OTA                 (0x1)       //??
N#define OTA_STAT_BOOT_JUDGE_OK          (0x2)       //CRC and flag OK, use new area
N#define OTA_STAT_BOOT_JUDGE_OTA_FAIL    (0x3)       //flag error and use org area
N#define OTA_STAT_BOOT_JUDGE_CRC_FAIL    (0x4)       //CRC error and use org area
N
N
N#define SCPU_CRC_START                  (20)
N#define SCPU_CRC_OFFSET                 (0)
N#define NCPU_CRC_OFFSET                 (4)
N#define FW_INFO_CRC_OFFSET              (8)
N#define MODEL_CRC_OFFSET                (12)
N#define UI_CRC_OFFSET                   (16)
N
N
N
N
N#if (IMAGE_SIZE == IMAGE_64MB)
X#if (16 == 64)
S//-------------------------------------------
S//model related     OTA_USER_BACKUP...........
S//-------------------------------------------
S//#define KDP_FLASH_USER_CFG0_ADDR            (8191*4096)     //area 0 last sector
S//#define KDP_FLASH_USER_CFG1_ADDR            (0x02000000)    //area 1 first sector
S
S#define KDP_FLASH_FW_INFO_ADDR_1            (KDP_FLASH_FW_INFO_ADDR+KDP_FLASH_FW_INFO_OFFSET_1/*0x02000000*/)
S#define KDP_FLASH_FW_INFO_SIZE_1            (0x0000017C)
S#define KDP_FLASH_ALL_MODELS_ADDR_1         (KDP_FLASH_ALL_MODELS_ADDR+KDP_FLASH_ALL_MODEL_OFFSET_1/*0x02000000*/)
S#define KDP_FLASH_ALL_MODELS_SIZE_1         (0x01101F30)
S//UI image related
S#define USR_FLASH_SETTINGS_ADDR_1           (USR_FLASH_SETTINGS_ADDR+KDP_FLASH_USER_OFFSET_1/*0x02000000*/)
S
S//temp add
S//#define KDP_FLASH_FW_INFO_OFFSET_1          (0x02000000)
S//#define KDP_FLASH_ALL_MODEL_OFFSET_1        (0x02000000)
S#define USR_FLASH_SETTINGS_OFFSET_1         (KDP_FLASH_USER_OFFSET_1)//0x02000000)
N#endif
N
Ntypedef struct {
N    u32 partition_id;
N    u32 seq;
N    u32 flag;
N} ota_boot_cfg_item_t;
N
Ntypedef struct {
N    ota_boot_cfg_item_t scpu_cfg;
N    ota_boot_cfg_item_t ncpu_cfg;
N} ota_boot_cfg_t;
N
Ntypedef struct {
N    ota_boot_cfg_item_t fw_info;
N    ota_boot_cfg_item_t model;
N    ota_boot_cfg_item_t ui_img;
N}ota_user_cfg;
N
N
Nint ota_get_active_ncpu_partition(void);
Nint ota_update_scpu(void);
Nint ota_update_ncpu(void);
Nint ota_update_model(u32 size);
Nint ota_update_case( u8 update_case, u32 data_addr, u32 size );
Nint ota_update_switch_active_partition(u32 partition);
N
Nextern int ota_handle_first_time_boot(void);
Nextern void ota_init_partition_boot_cfg(void);
Nextern void ota_burn_in_config( UINT8  partition );
Nextern int ota_update_scpu_flag_status( void );
Nextern int ota_update_ncpu_flag_status( void );
Nextern int ota_get_active_scpu_partition(void);
Nextern int ota_get_active_ncpu_partition(void);
Nextern void ota_update_show_config(void);
Nextern int ota_get_scpu_flag_status( void );
Nextern int ota_update_force_switch_active_partition( u32 partition );
Nextern void ota_user_config_init(void);
N
N#if (OTA_USER_BACKUP == YES )
X#if ((0) == 1 )
Sextern void ota_user_config_init_partial( u8 partition , u8 idx);
Sextern int ota_user_get_active_area_partial( u8 partition );
Sextern void ota_user_debug_show(void);
Sextern void ota_user_read_cfg(void);
Sextern void ota_user_config_init(void);
Sextern int ota_user_check_on_going_area( u32 partition );
Sextern int ota_user_select_inactive_area(u32 partition);
Sextern int ota_user_select_wait_active_area( u32 partition );
S#if ( OTA_USER_BACKUP_SEPERATE == YES )
Sextern int ota_user_get_active_area( uint8_t idx );
S#else
Sextern int ota_user_get_active_area( void );
S#endif
Sextern int ota_user_area_boot_check( void );
Sextern void ota_user_dummy_changes_status(void);
Sextern int ota_get_wait_active_area(u32 partition );
S
Sextern void ota_update_boot_judge(void);
S
N#endif
N
Nextern u32 ota_crc32( u8 *buf, size_t size);
N
N
N#define CMD_UPDATE_FW CMD_OTA_UPDATE
N#define kmdw_ota_switch_active_partition ota_update_switch_active_partition     //return value are the same, printf diff data, flash read and write different,
N#define kmdw_ota_update_scpu ota_update_scpu                                    //dev ota!!
N#define kmdw_ota_update_ncpu ota_update_ncpu                                    //dev ota!!
N#define kmdw_ota_update_model ota_update_model                                  //dev ota!!
N#define kmdw_ota_init(__arg1, __arg2) ota_handle_first_time_boot()      //these two parameter no use in dev, return value the same
N
N#endif
L 52 "..\..\user\main.c" 2
N#include "ota.h"
N#include "kl520_api_ssp.h"
L 1 "..\..\..\..\scpu\share\kl520_api_ssp.h" 1
N#ifndef __KL520_API_SSP_SPI_H__
N#define __KL520_API_SSP_SPI_H__
N
N
N#include "types.h"
N#include "kdp520_ssp.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp520_ssp.h" 1
N#ifndef __KDP520_SSP_H__
N#define __KDP520_SSP_H__
N
N
N#include "types.h"
N#include "kneron_mozart.h"
N#include "board_cfg.h"
N
N
N#if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MS_EN ) && ( ( ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )&( ~COM_BUS_SPI_MS_EN ) ) == 0 )
X#if ( (0x04)&0x800 ) && ( ( ( (0x04)&0x00000F00 )&( ~0x800 ) ) == 0 )
S#error "Please select correct spi number for SPI master"
N#endif
N
N
N
N#define	SSP_SPI_TIME_TEST_EN		(NO)
N#define SSP_REG_BASE_M		(SPI_FTSSP010_0_PA_BASE)	//SPI_FTSSP010_1_PA_BASE
N#define SSP_REG_BASE_S		(SPI_FTSSP010_1_PA_BASE)	//SPI_FTSSP010_0_PA_BASE
N
N#define SSP_REG_CR0	0x0
N#define SSP_REG_CR1	0x4
N#define SSP_REG_CR2	0x8
N#define SSP_REG_STS	0xc
N#define SSP_REG_INTR_CR	0x10
N#define SSP_REG_INTR_STS	0x14
N#define SSP_REG_DATA_PORT	0x18
N#define SSP_REG_CR3	0x1C
N#define SSP_REG_REVISION	0x60
N#define SSP_REG_FEATURE	0x64
N
N/* REG_CR0 field */
N#define ssp_CR0_FSDBK	(1 << 17)
N#define ssp_CR0_SCLKFDBK	(1 << 16)
N#define ssp_CR0_SPIFSPO	(1 << 15) /* Frame/Sync polarity, SPI only */
N#define ssp_CR0_FFMT_MASK	(7 << 12)
N#define ssp_CR0_FFMT_SSP	(0 << 12)
N#define ssp_CR0_FFMT_SPI	(1 << 12)
N#define ssp_CR0_FFMT_MWR	(2 << 12)
N#define ssp_CR0_FFMT_I2S	(3 << 12)
N#define ssp_CR0_FFMT_ACL	(4 << 12)
N#define ssp_CR0_FFMT_SPDIF	(5 << 12)
N#define ssp_CR0_SPI_FLASH	(1 << 11) 
N#define ssp_CR0_VALIDITY	(1 << 10) // SPDIF validity
N#define ssp_CR0_FSDIS_MASK	(3 << 8)
N#define ssp_CR0_FSDIST(x)	((x & 0x3) << 8) // frame/sync and data distance, I2S only
N#define ssp_CR0_LOOPBACK	(1 << 7)
N#define ssp_CR0_LSB	(1 << 6) // 0: MSB, 1:LSB tx and rx first
N#define ssp_CR0_FSPO	(1 << 5) // Frame/Sync polarity, I2S or MWR only
N#define ssp_CR0_FSJSTFY	(1 << 4) // Padding data in front(1) or back(0) of serial data
N#define ssp_CR0_MODE_MASK	(3 << 2)
N#define ssp_CR0_MSTR_STREO	(3 << 2)
N#define ssp_CR0_MSTR_MONO	(2 << 2)
N#define ssp_CR0_SLV_STREO	(1 << 2)
N#define ssp_CR0_SLV_MONO	(0 << 2)
N#define ssp_CR0_MSTR_SPI	(3 << 2)
N#define ssp_CR0_SLV_SPI	(1 << 2)
N#define ssp_CR0_SCLKPO_0	(0 << 1) // SCLK polarity, SPI only
N#define ssp_CR0_SCLKPO_1	(1 << 1) // SCLK polarity, SPI only
N#define FTSSP020_CR0_SCLKPH_0	(0 << 0) // SCLK phase, SPI only
N#define FTSSP020_CR0_SCLKPH_1	(1 << 0) // SCLK phase, SPI only
N
N/* REG_CR1 field */
N#define ssp_CR1_PDL(x)	((x & 0xff) << 24) // Padding data length
N#define ssp_CR1_PDL_MASK	(0xff << 24)
N#define ssp_CR1_SDL(x)	((x & 0x7f) << 16) // Serial data length
N#define ssp_CR1_SDL_MASK	(0x7f << 16)
N#define ssp_SDL_MAX_BYTES_MASK	(0x7f)
N#define ssp_CR1_SCLKDIV(x)	(x & 0xffff)
N#define ssp_CR1_SCLKDIV_MASK	(0xffff)
N
N/* REG_CR2 field */
N#define ssp_CR2_FSOS(x)	((x & 0x3) << 10) // frame/sync output select, SPI only
N#define ssp_CR2_FSOS_MASK	(3 << 10)
N#define ssp_CR2_FS 	(1 << 9) // 0: low, 1: high frame/sync output
N#define ssp_CR2_TXEN	(1 << 8)
N#define ssp_CR2_RXEN	(1 << 7)
N#define ssp_CR2_SSPRST	(1 << 6)
N#define ssp_CR2_ACRST	(1 << 5)
N#define ssp_CR2_ACWRST	(1 << 4)
N#define ssp_CR2_TXFCLR	(1 << 3) // W1C, Clear TX FIFO
N#define ssp_CR2_RXFCLR	(1 << 2) // W1C, Clear RX FIFO
N#define ssp_CR2_TXDOE	(1 << 1) // TX Data Output Enable, SSP slave only
N#define ssp_CR2_SSPEN	(1 << 0)
N
N/* REG_STS 0xC field */
N#define ssp_STS_TFVE(x)	((x >> 12) & 0x3f) // TX FIFO valid entries
N#define ssp_STS_RFVE(x)	((x >> 4) & 0x3f) // RX FIFO valid entries
N#define ssp_STS_BUSY	(1 << 2)
N#define ssp_STS_TFNF	(1 << 1) // TX FIFO not full
N#define ssp_STS_RFF	(1 << 0) // RX FIFO full
N
N/* REG_INTR_CR 0x10 field */
N#define ssp_INTCR_RFTHOD_UNIT	(1 << 17)
N#define ssp_INTCR_TFTHOD(x)	((x & 0x1f) << 12)
N#define ssp_INTCR_TFTHOD_MASK	(0x1f << 12)
N#define ssp_INTCR_RFTHOD(x)	((x & 0x1f) << 7)
N#define ssp_INTCR_RFTHOD_MASK	(0x1f << 7)
N#define ssp_INTCR_AC97FCEN	(1 << 6)
N#define ssp_INTCR_TFDMAEN	(1 << 5)
N#define ssp_INTCR_RFDMAEN	(1 << 4)
N#define ssp_INTCR_TFTHIEN	(1 << 3)
N#define ssp_INTCR_RFTHIEN	(1 << 2)
N#define ssp_INTCR_TFURIEN	(1 << 1)
N#define ssp_INTCR_RFORIEN	(1 << 0)
N
N/* REG_INTR_STS 0x14 field */
N#define ssp_INTSTS_AC97CI	(1 << 4)
N#define ssp_INTSTS_TFTHI	(1 << 3) // TX FIFO threshold
N#define ssp_INTSTS_RFTHI	(1 << 2) // RX FIFO threshold
N#define ssp_INTSTS_TFUI	(1 << 1) // TX FIFO underrun
N#define ssp_INTSTS_RFORI	(1 << 0) // RX FIFO overrun
N
N/* REG_CR3 0x1C field */
N#define ssp_CR3_DPDL(x)	((x & 0xff) << 16) // Padding Data length
N#define ssp_CR3_DPDL_MASK	(0xff << 16)
N#define ssp_CR3_DPDLEN	(1 << 12)
N#define ssp_CR3_PCL(x)	(x & 0x3ff) // Padding Cycle length
N#define ssp_CR3_PCL_MASK	0x3ff
N
N
N// REG_FEATURE 0x64 field
N#define ssp_FEA_TXFIFO_DEPTH(x)	((x >> 16) & 0xff)
N#define ssp_FEA_RXFIFO_DEPTH(x)	((x >> 8) & 0xff)
N
N//===========================================================================
N#define	SPI_TX_FIFO_TH		(4)
N#define	SPI_RX_FIFO_TH		(4)
N#define SPI_MAX_FIFO        (16)
N
N#define		SPI_PACKET_HEAD								(0x78875A01)
N#define		SPI_PACKET_READ_LARGE_HEAD		(0x78875A02)
N#define		SPI_PACKET_WRITE_LARGE_HEAD		(0x78875A03)
N
N// SPI only
Ntypedef enum {
N    SPI_CS_LOW = 0,
N    SPI_CS_HI = ssp_CR0_SPIFSPO,
X    SPI_CS_HI = (1 << 15),
N} SPI_CHIP_SELECT;
N
N
Ntypedef enum {
N    // CLKPO = 0, CLKPHA = 0
N    SPI_MODE_0 = (ssp_CR0_SCLKPO_0 | FTSSP020_CR0_SCLKPH_0),
X    SPI_MODE_0 = ((0 << 1) | (0 << 0)),
N    // CLKPO = 0, CLKPHA = 1
N    SPI_MODE_1 = (ssp_CR0_SCLKPO_0 | FTSSP020_CR0_SCLKPH_1),
X    SPI_MODE_1 = ((0 << 1) | (1 << 0)),
N    // CLKPO = 1, CLKPHA = 0
N    SPI_MODE_2 = (ssp_CR0_SCLKPO_1 | FTSSP020_CR0_SCLKPH_0),
X    SPI_MODE_2 = ((1 << 1) | (0 << 0)),
N    // CLKPO = 1, CLKPHA = 1
N    SPI_MODE_3 = (ssp_CR0_SCLKPO_1 | FTSSP020_CR0_SCLKPH_1),
X    SPI_MODE_3 = ((1 << 1) | (1 << 0)),
N    SPI_MODE_MAX
N} SPI_MODE_TYPE;
N
Nenum e_spi
N{
N    //case
N    e_spi_init_slave = 0,
N    e_spi_init_master,
N    e_spi_enable,
N    e_spi_rx ,
N    e_spi_rx_check,
N    e_spi_tx ,
N    e_spi_tx_status_check ,
N    e_spi_tx_large ,        //for future command mode use
N    e_spi_rx_large ,        //receive command action
N    e_spi_master_tx_rx,
N    e_spi_disable ,
N    e_spi_idle ,
N    e_spi_tx_xor,
N
N
N    //return status
N    e_spi_ret_init_done,
N    e_spi_ret_enable_done,
N    e_spi_ret_rxbusy,
N    e_spi_ret_rxdone,
N    e_spi_ret_rx_xor_OK,
N    e_spi_ret_rx_xor_error,
N
N    e_spi_ret_txbusy,
N    e_spi_ret_txdone,
N    e_spi_ret_disableDone,
N    e_spi_ret_tx_xor_done,
N    e_spi_ret_idle,
N};
N
Nstruct st_ssp_spi
N{
N    UINT32  reg_base_address;               //base address
N    UINT8   IP_type;                        //3: master 0:slave
N    UINT8   SDL;                            //data length
N    UINT8   target_Txfifo_depth;            //max is 16Byte
N    UINT8   target_Rxfifo_depth;            //max is 16Byte
N    UINT8   tx_rx_en;                       //0: all disable, 1:Tx enable, 2:Rx enable, 3:Tx and Rx are all enable
N    UINT8   spi_sw_type;                    //0:polling(no interrupt IRQ), 1:interrupt+polling, 2:DMA only
N    UINT8   interrupt_en;                   //0x00:no interurpt, 0x08: Tx int ebable, 0x04:Rx interupt enable,
N                                            //0x0C: Tx and Rx interrupt are all enable
N
N
N    //buffer related
N    volatile UINT8  *Tx_buffer;
N    volatile UINT32 *Tx_buffer_index;
N    volatile UINT32 *Tx_buffer_current_index;
N    volatile UINT8  Tx_done_flag;           //0: no done, 1: done flag
N
N
N    volatile UINT8  *Rx_buffer;
N    volatile UINT32 *Rx_buffer_index;
N    volatile UINT32 buffer_max_size;
N    volatile UINT32 pre_size;
N    
N    enum e_spi  eflow;
N
N    volatile UINT8      *Rx_tempbuffer;
N    volatile UINT32     Rx_tempbuffer_index;
N};
N
N#if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MS_EN ) && ( ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )&( ~COM_BUS_SPI_MS_EN ) )
X#if ( (0x04)&0x800 ) && ( ( (0x04)&0x00000F00 )&( ~0x800 ) )
Sextern UINT8   gTx_buff_SP_MASTER[];
Sextern UINT8   gRx_buff_SP_MASTER[];
Sextern UINT32  gTx_buff_index_SP_MASTER;
Sextern UINT32  gTx_buff_current_index_SP_MASTER;
Sextern UINT32  gRx_buff_index_SP_MASTER;
N#endif
N
N#if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
X#if ( (0x04)&0x00000F00 )
Sextern struct st_ssp_spi driver_ssp_master_ctx;
N#endif
Nextern struct st_ssp_spi driver_ssp_ctx;
N
N
Nint kdp_ssp_rxfifo_valid_entries( UINT32 base_addr );
Nint kdp_ssp_busy(int base_addr);	
Nvoid kdp_ssp_clear_txhw(int base_addr);
Nvoid kdp_ssp_clear_rxhw(int base_addr);
N
N/* public api */
Nvoid kdp_ssp_clear_tx_buf_index( struct st_ssp_spi *stspi );
Nvoid kdp_ssp_clear_tx_current_buf_index( struct st_ssp_spi *stspi );
Nvoid kdp_ssp_clear_tx_done_flag( struct st_ssp_spi *stspi );
Nenum e_spi kdp_ssp_statemachine( struct st_ssp_spi *st_spi, enum e_spi espi_flow);
N
NUINT32 kdp_ssp_get_tx_buf_index( struct st_ssp_spi *stspi );
Nvoid kdp_ssp_write_buff( struct st_ssp_spi *stspi, UINT8 *src, UINT16 nlen );
NUINT16 kdp_ssp_get_tx_current_buf_index( struct st_ssp_spi *stspi );
NUINT8 kdp_ssp_get_tx_done_flag( struct st_ssp_spi *stspi );
Nvoid kdp_ssp_clear_rx_buf_index( struct st_ssp_spi *stspi );
NUINT32 kdp_ssp_get_rx_buf_index( struct st_ssp_spi *stspi );
Nvoid kdp_ssp_pre_write_to_fifo( struct st_ssp_spi *stspi, UINT8 target_byte );
Nvoid kdp_slave_request_init(void);
Nvoid kdp_slave_request_active(void);
Nvoid kdp_slave_request_inactive(void);
Nvoid Drv_ssp_SPI_master_transmit( struct st_ssp_spi *st_spi , UINT32 rx_target_size, UINT8 rx_all  );
Nvoid drv_rx_polling_receive_all( struct st_ssp_spi *stspi );
N
N#endif 
L 7 "..\..\..\..\scpu\share\kl520_api_ssp.h" 2
N#include "kdp520_gpio.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp520_gpio.h" 1
N#ifndef __GPIO_H
N#define __GPIO_H
N
N#include "types.h"
N 
N#define GPIO_DOUT_OFFSET            0x0
N#define GPIO_DIN_OFFSET             0x4
N#define GPIO_PINOUT_OFFSET          0x8
N#define GPIO_PIN_BYPASS             0xC
N#define GPIO_DATASET                0x10
N#define GPIO_DATACLR                0x14
N#define GPIO_PULLENABLE             0x18
N#define GPIO_PULLTYPE               0x1C
N#define GPIO_INT_ENABLE             0x20
N#define GPIO_INT_RAWSTATE           0x24
N#define GPIO_INT_MASKSTATE          0x28
N#define GPIO_INT_MASK               0x2C
N#define GPIO_INT_CLEAR              0x30
N#define GPIO_INT_TRIGGER            0x34
N#define GPIO_INT_BOTH               0x38
N#define GPIO_INT_RISENEG            0x3C
N#define GPIO_INT_BOUNCEENABLE       0x40
N#define GPIO_INT_PRESCALE           0x44	
N
N
N#define GPIO_NUM               		32
N#define GPIO_EDGE             		0
N#define GPIO_LEVEL               	1	
N#define SINGLE                    	0
N#define BOTH                      	1
N
N
N#define GPIO_DIR_OUTPUT			1
N#define GPIO_DIR_INPUT			0
N
N#define GPIO_INPUT                  0
N#define GPIO_OUTPUT                 1
N
N#define LOW							0
N#define HIGH						1
N
N#define GPIO_0                      0
N#define GPIO_1                      1
N#define GPIO_2                      2
N#define GPIO_3                      3
N#define GPIO_4                      4
N#define GPIO_5                      5
N#define GPIO_6                      6
N#define GPIO_7                      7
N#define GPIO_8                      8
N#define GPIO_9                      9
N#define GPIO_10                     10
N#define GPIO_11                     11
N#define GPIO_12                     12
N#define GPIO_13                     13
N#define GPIO_14                     14
N#define GPIO_15                     15
N#define GPIO_16                     16 	
N#define GPIO_17                     17	
N#define GPIO_18                     18	
N#define GPIO_19                     19	
N#define GPIO_20                     20
N#define GPIO_21                     21
N#define GPIO_22                     22
N#define GPIO_23                     23
N#define GPIO_24                     24
N#define GPIO_25                     25
N#define GPIO_26                     26
N#define GPIO_27                     27
N#define GPIO_28                     28
N#define GPIO_29                     29
N#define GPIO_30                     30
N#define GPIO_31                     31
N#define GPIO_NULL                   (0xFF)
N
N#define BUTTON_0	GPIO_16
N#define BUTTON_1	GPIO_17
N#define BUTTON_2	GPIO_18
N#define BUTTON_3	GPIO_19
N
N
N#ifndef GPIO_TEST_H
N#define GPIO_TEST_H
N
N#define GPIO_KEYPAD_SWITCH	0x98100024
N#define GPIO_INPUT		0
N#define GPIO_OUTPUT		1
N#define GPIO_EDGE		0
N#define GPIO_LEVEL		1
N#define GPIO_Rising		0
N#define GPIO_Falling		1
N#define GPIO_High		0
N#define GPIO_LOW		1
N#define GPIO_LED_NUM		16
N#define GPIO_LED_BASE		16
N
N
N#endif
N
Ntypedef int (*kdp520_gpio_get_dcsr)(void);
Ntypedef void (*kdp520_gpio_set_dcsr)(int);
Ntypedef struct _kdp520_gpio_custom_dcsr_param {
N    u32 level;
N    kdp520_gpio_get_dcsr get_dcsr_func;
N    kdp520_gpio_set_dcsr set_dcsr_func;
N} kdp520_gpio_custom_dcsr_param;
N
N/*  -------------------------------------------------------------------------------
N *   API
N *  -------------------------------------------------------------------------------
N */
N
Nextern unsigned int kdp520_gpio_readdata(void);
Nextern void kdp520_gpio_writedata(unsigned int data);
Nextern void kdp520_gpio_setdata(unsigned int data);
Nextern void kdp520_gpio_cleardata(unsigned int data);
N
Nextern void kdp520_gpio_pullenable(unsigned int pin);  
Nextern void kdp520_gpio_pulldisable(unsigned int pin);  
Nextern void kdp520_gpio_pullhigh(unsigned int pin);  
Nextern void kdp520_gpio_pulllow(unsigned int pin);
Nextern BOOL kdp520_gpio_israwint(unsigned int pin);
N
Nextern void kdp520_gpio_enableint(unsigned int pin, unsigned int trigger, unsigned int active);
Nextern void kdp520_gpio_disableint(unsigned int pin);
Nextern void kdp520_gpio_enablebounce(unsigned int pin, unsigned int clkdiv);
Nextern void kdp520_gpio_disablebounce(unsigned int pin);
N
Nextern void kdp520_gpio_setdir(unsigned int pin, unsigned int dir);
Nextern void kdp520_gpio_setbypass(unsigned int pin);
Nextern void kdp520_gpio_setedgemode(unsigned int pin, unsigned int both);
N
Nextern unsigned int kdp520_gpio_getintmaskstatus(void);
Nextern void kdp520_gpio_clearint(unsigned int data);
N
Nextern void kdp520_gpio_setintmask(unsigned int pin);
Nextern void kdp520_gpio_setintunmask(unsigned int pin);
Nextern void kdp520_gpio_setintenable(unsigned int pin);
Nextern void kdp520_gpio_setintdisable(unsigned int pin);
Nextern void kdp520_gpio_settrigger(unsigned int pin, unsigned int trigger);
Nextern void kdp520_gpio_setactivemode(unsigned int pin, unsigned int active);
N
Nextern void kdp520_gpio_setmode(unsigned int pin);
Nextern void kdp520_wait_gpio_int(unsigned int pin);
Nextern void kdp520_set_int_occurred(unsigned int occurred);
Nextern BOOL kdp520_get_int_occurred(unsigned int pin);
Nextern void kdp520_clear_int_occurred(unsigned int pin);
N
Nextern void kdp520_gpio_set_dcsr_param(kdp520_gpio_custom_dcsr_param* dst_param, kdp520_gpio_custom_dcsr_param* src_param);
N
N#endif /* __GPIO_H */
L 8 "..\..\..\..\scpu\share\kl520_api_ssp.h" 2
N
N
Nextern UINT8 kl520_api_ssp_spi_sample(void);
Nextern void kl520_api_ssp_spi1_slave_req_init(void);
Nextern void kl520_api_ssp_spi1_slave_inactive(void);
Nextern void kl520_api_ssp_spi1_slave_active(void);
Nextern void kl520_api_ssp_spi1_clear_rx_hw(void);
Nextern void kl520_api_ssp_spi1_clear_tx_hw(void);
Nextern void kl520_api_ssp_spi1_clear_rx_buff_size(struct st_ssp_spi *stspi );
Nextern void kl520_api_ssp_spi1_clear_tx_buff_size(struct st_ssp_spi *stspi );
Nextern void kl520_api_ssp_spi1_clear_tx_current_buff_size( void );
Nextern void kl520_api_ssp_spi1_clear_tx_done_flag( void );
Nextern UINT8 kl520_api_ssp_spi1_init(enum e_spi edata);
Nextern UINT8 kl520_api_ssp_spi1_receive(struct st_ssp_spi *stspi);
Nextern void kl520_api_ssp_lcd_clock_init(u8 tx);
Nextern void kl520_api_ssp_set_display_size(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1);
Nextern void spi_lcd_write_cmd(u8 cmd, u8 len, ...);
Nextern void spi_lcd_write_cmd_single(u8 cmd, ...);
Nextern void spi_lcd_write_img_buf_data(u32 len, void* buf);
Nextern void kl520_api_ssp_master_read(u8 reg, u8 len, u8* buf);
N
Nextern void font_read_Chinese( struct st_ssp_spi *st_spi, UINT16 raw_word );
Nextern void kl520_api_ssp_spi_master_init(void);
Nextern void font_test_read(void);
Nextern void kdp520_api_ssp_set_DO_dcsr_param(kdp520_gpio_custom_dcsr_param* src_param);
N
N#endif
L 54 "..\..\user\main.c" 2
N#include "kl520_api_device_id.h"
N#include "usr_ddr_img_table.h"
L 1 "..\..\config\usr_ddr_img_table.h" 1
N#ifndef __USR_DDR_IMG_TABLE_H__
N#define __USR_DDR_IMG_TABLE_H__
N
N
N#define USR_DDR_SETTINGS_ADDR                               (KDP_DDR_LAST_ADDR + 0x00000000) // 0x61F84A00, file=flash_bin\usr_settings.bin
N#define USR_DDR_SETTINGS_SIZE                               0x00001000
N#define USR_DDR_LAST_ADDR                                   0x61F85A00
N
N/*
N
N//Copy the content of this annotation to kl520_api_ddr_img_user()
Nkdp_memxfer_flash_to_ddr(USR_DDR_SETTINGS_ADDR, USR_FLASH_SETTINGS_ADDR, USR_FLASH_SETTINGS_SIZE);
N*/ 
N
N#define KDP_DDR_HEAP_HEAD_FOR_MALLOC_END                    (0x61F85A00 - 1)
N#define KDP_DDR_HEAP_HEAD_FOR_MALLOC                        0x63FFFFFF
N
N#endif
L 56 "..\..\user\main.c" 2
N
N#if CFG_SNAPSHOT_ENABLE == 1 || CFG_SNAPSHOT_ENABLE == 2
X#if 0 == 1 || 0 == 2
S#include "kl520_api_snapshot.h"
N#endif
N#if CFG_FMAP_EXTRA_ENABLE == YES
X#if 0 == 1
S#include "kl520_api_extra_fmap.h"
N#endif
N#if CFG_CONSOLE_MODE == YES
X#if CFG_CONSOLE_MODE == 1
S#include "sample_app_console.h"
N#endif
N
N//========================================LWCOM
N#if CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_LWCOM
X#if 0 == 0
N//--------------------UART
N#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
X#if ( (0x04)&0x0000007F )
N#include "kl520_com.h"
N
N#if ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_DEF )
X#if ( 1 == 0 )
S#include "sample_user_com_and_gui_fdr.h"
N#elif ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP )
X#elif ( 1 == 1 )
N#include "kdp_comm_and_gui_fdr.h"
L 1 "..\..\..\..\scpu\middleware\kdp_comm\kdp_comm_and_gui_fdr.h" 1
N#ifndef __KDP_COMM_AND_GUI_FDR_H__
N#define __KDP_COMM_AND_GUI_FDR_H__
N
N#include "board_kl520.h"
N
N//zcy add for default time
N#define VERIFY_DEFAULT_TIME  5
N#define ENROLL_DEFAULT_TIME  9
N
N
N#if CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_LWCOM
X#if 0 == 0
N#if ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP )
X#if ( 1 == 1 )
N#include "kl520_com.h"
N
N#if (CFG_COM_UART_MSG == COM_UART_MSG_KDP)
X#if (1 == 0)
S#include "kdp_comm_msg_define.h"
N#else
N#include "user_comm_msg_define.h"
N#endif
N
N#define COM_DEBUG_LOG_EN        (NO)
N
N#define USER_COM_FLAG_REGISTRATION          (1<<0)
N#define USER_COM_FLAG_RECOGNITION           (1<<1)
N#define USER_COM_FLAG_DELETE_ALL            (1<<2)
N#define USER_COM_FLAG_DELETE_ONE            (1<<3)
N#define USER_COM_FLAG_POWER_OFF             (1<<4)
N#define USER_COM_FLAG_FACE_CLOSE_DONE       (1<<5)
N#define USER_COM_FLAG_SNAP_IMG              (1<<6)
N#define USER_COM_FLAG_FACE_RESET            (1<<7)
N#define USER_COM_FLAG_MP                    (1<<8)
N#define USER_COM_FLAG_OTA_PROCESS           (1<<9)
N#define USER_COM_FLAG_DOWNLIB_PROCESS       (1<<10)
N#define USER_COM_FLAG_ALL                   (USER_COM_FLAG_REGISTRATION|\
N                                             USER_COM_FLAG_RECOGNITION|\
N                                             USER_COM_FLAG_DELETE_ALL|\
N                                             USER_COM_FLAG_DELETE_ONE|\
N                                             USER_COM_FLAG_POWER_OFF|\
N                                             USER_COM_FLAG_SNAP_IMG|\
N                                             USER_COM_FLAG_FACE_RESET|\
N                                             USER_COM_FLAG_MP|\
N                                             USER_COM_FLAG_OTA_PROCESS|\
N                                             USER_COM_FLAG_DOWNLIB_PROCESS)
X#define USER_COM_FLAG_ALL                   (USER_COM_FLAG_REGISTRATION|                                             USER_COM_FLAG_RECOGNITION|                                             USER_COM_FLAG_DELETE_ALL|                                             USER_COM_FLAG_DELETE_ONE|                                             USER_COM_FLAG_POWER_OFF|                                             USER_COM_FLAG_SNAP_IMG|                                             USER_COM_FLAG_FACE_RESET|                                             USER_COM_FLAG_MP|                                             USER_COM_FLAG_OTA_PROCESS|                                             USER_COM_FLAG_DOWNLIB_PROCESS)
N
N#define USER_COM_EVENT_CMD_READY            (1)
N#define USER_COM_EVENT_FDR_OPENED           (2)
N
Nenum USER_COM_THREAD_EVENT
N{
N    USER_COM_THREAD_EVENT_READY             = 0,
N    USER_COM_THREAD_EVENT_OVERWRITABLE      = 1,
N    USER_COM_THREAD_EVENT_NON_OVERWRITABLE  = 2,
N    USER_COM_THREAD_EVENT_OTA_FLASH         = 3,
N    USER_COM_THREAD_EVENT_ENROLL            = 0x80, //overwritable starts from 0x80
N    USER_COM_THREAD_EVENT_VERIFY            = 0x81,
N};
N
Nenum
N{
N    SYS_IDLE = 0,
N    SYS_BUSY = 1,
N    SYS_ERROR = 2,
N    SYS_INVALID = 3,
N};
N
N// Mass data type
Ntypedef enum
N{
N	MASS_DATA_NULL					= 0x00,
N
N	//OTA
N    MASS_DATA_OTA_MASK              = 0x10,
N	MASS_DATA_OTA					= 0x10,
N
N	//EXPORT
N    MASS_DATA_EXP_MASK              = 0x20,
N	MASS_DATA_EXP_DB				= 0x21,
N	MASS_DATA_EXP_FM				= 0x22,
N    MASS_DATA_EXP_IMG               = 0x23, //for recognition
N	MASS_DATA_EXP_ALL_DB			= 0x24,
N    MASS_DATA_EXP_FW                = 0x2A,
N
N	//IMPORT
N    MASS_DATA_IMP_MASK              = 0x30,
N	MASS_DATA_IMP_DB				= 0x31,
N	MASS_DATA_IMP_FM				= 0x32,
N    MASS_DATA_IMP_IMG               = 0x33, //for register
N    MASS_DATA_IMP_ALL_DB            = 0x34,
N    MASS_DATA_IMP_FW                = 0x3A,
N
N	MASS_DATA_MODE_MASK             = 0xF0,
N} mass_data_type;
N
Nenum data_ready_type
N{
N    DATA_READY_TYPE_NULL            = 0x00,
N    DATA_READY_TYPE_EXP_DB          = 0x01,
N    DATA_READY_TYPE_EXP_FM          = 0x02,
N    DATA_READY_TYPE_EXP_IMG         = 0x03,
N	DATA_READY_TYPE_EXP_ALL_DB      = 0x04,
N    DATA_READY_TYPE_EXP_FLASH       = 0x05,
N    DATA_READY_TYPE_IMP_DB          = 0x10,
N    DATA_READY_TYPE_IMP_FM          = 0x20,
N    DATA_READY_TYPE_IMP_IMG         = 0x30,
N	DATA_READY_TYPE_IMP_ALL_DB      = 0x40,
N};
N
N// Module to Host
Nenum kdp_com_m2h
N{
N    KID_REPLY                       = 0x00, // request(command) reply message, success with data or fail with reason
N    KID_NOTE                        = 0x01, // note to host e.g. the position or angle of the face
N    KID_IMAGE                       = 0x02, // send image to host
N    KID_ERROR                       = 0x03
N};
N
Nenum kdp_com_m2h_type
N{
N    NID_READY                       = 0x00, // module ready for handling request (command)
N    NID_FACE_STATE                  = 0x01, // the detected face status description
N    NID_UNKNOWN_ERROR               = 0x02, // unknown error
N    NID_OTA_DONE                    = 0x03, // OTA upgrading processing done
N    NID_MASS_DATA_DONE              = 0x04, // Mass data transmission done
N    NID_CATEYE_RUNNING              = 0xF0,
N};
N
Nenum kdp_face_dir
N{
N    KDP_FACE_DIRECTION_UNDEFINE     = 0x00,
N    KDP_FACE_DIRECTION_MIDDLE       = 0x01,
N    KDP_FACE_DIRECTION_RIGHT        = 0x02,
N    KDP_FACE_DIRECTION_LEFT         = 0x04,
N    KDP_FACE_DIRECTION_DOWN         = 0x08,
N    KDP_FACE_DIRECTION_UP           = 0x10,
N
N    KDP_FACE_DIRECTION_LR           = KDP_FACE_DIRECTION_LEFT|KDP_FACE_DIRECTION_RIGHT,
N    KDP_FACE_DIRECTION_UD           = KDP_FACE_DIRECTION_UP|KDP_FACE_DIRECTION_DOWN,
N    KDP_FACE_DIRECTION_UDLR         = KDP_FACE_DIRECTION_UD|KDP_FACE_DIRECTION_LR,
N    KDP_FACE_DIRECTION_MASK         = 0x1F,
N};
N
Nenum kdp_chk_face_dir
N{
N    KDP_CHK_FACE_DIR_NORMAL         = 0x00,
N    KDP_CHK_FACE_DIR_ERROR          = 0x01,
N    KDP_CHK_FACE_DIR_EXISTED        = 0x02,
N};
N
Nextern u8 user_com_GetOtaStatus(void);
Nextern void user_com_response_data(u8* p_data, u16 size);
Nextern void user_com_init(void);
Nextern void user_com_thread_event_set(enum USER_COM_THREAD_EVENT eState);
Nextern enum USER_COM_THREAD_EVENT user_com_thread_event_get(void);
N
N#if ( CFG_GUI_ENABLE == YES )
X#if ( 0 == 1 )
Sextern void user_com_set_data(u16 type, u16 data, u8 data2);
Sextern int user_com_get_data(void* arg);
N#endif
Nextern void user_com_event_start(u32 event);
Nextern void user_com_event_interrupt(void);
Nextern void user_com_event_power_off(void);
N
Nvoid init_user_com_thread(void);
N
N#endif
N#endif
N#endif    //__KDP_COMM_AND_GUI_FDR_H__
N
L 77 "..\..\user\main.c" 2
N#elif ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP_USR )
X#elif ( 1 == 3 )
S#include "user_comm_and_gui_fdr.h"
S#elif ( CFG_COM_USB_PROT_TYPE == COM_UART_PROT_DEF_USR )
S
N#endif
N#else
Svoid user_com_init(void) {}
N#endif
N
N//--------------------USB
N#if ( CFG_COM_BUS_TYPE&COM_BUS_USB_MASK )
X#if ( (0x04)&0x00000080 )
S#if ( CFG_COM_USB_PROT_TYPE == COM_USB_PROT_DEF )
S#include "host_com.h"
S#elif ( CFG_COM_USB_PROT_TYPE == COM_USB_PROT_KDP )
S#include "kdp_host_com.h"
S#elif ( CFG_COM_USB_PROT_TYPE == COM_USB_PROT_KDP_USR )
S#include "user_host_com.h"
S#elif ( CFG_COM_USB_PROT_TYPE == COM_USB_PROT_DEF_USR )
S
S#endif
N#endif
N
N//--------------------OTG
N#if ( CFG_COM_BUS_TYPE&COM_BUS_OTG_MASK )
X#if ( (0x04)&0x00100000 )
Sextern void otg_init(void);
N#endif
N
N//========================================KCOMM
N#elif CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_KCOMM
X#elif 0 == 1
S#if ( CFG_COM_BUS_TYPE&COM_BUS_USB_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
S#include "kcomm.h"
S#endif
S#else
S#include "kl520_com.h"
N#endif
N
N#if ( CFG_GUI_ENABLE == YES )
X#if ( 0 == 1 )
S#include "sample_gui_main.h"
N#endif
N
N
N
N#define MSG_DBG_LOG
N#define MSG_MEM_BYTE_WRITE     0
N
Nextern void kdp_uart_app_uart0_log(void);
Nextern void GPIO010_IRQHandler(void);
N
N/**
N * @info(), Get kernel information
N */
N
Nint cpu_type = 0;
N
N
Nvoid msgZhian()
N{
N    struct fw_misc_data scpu_version;
N    kl520_api_get_scpu_version(&scpu_version);
N
N    dbg_msg_console_zhian("zhian tec BP3-X-25 (V%d.%d.%d.%d)-%d", scpu_version.version[0],
N                                                       scpu_version.version[1],
N                                                       scpu_version.version[2],
N                                                       scpu_version.version[3],
N                                                       scpu_version.date); 
X    kdp_level_printf(1, "zhian tec BP3-X-25 (V%d.%d.%d.%d)-%d" "\r\n",scpu_version . version[0], scpu_version . version[1], scpu_version . version[2], scpu_version . version[3], scpu_version . date); 
N
N}
Nvoid info(u32 spl_version) {
N    char infobuf[16];
N    osVersion_t osv;
N    osStatus_t status;
N    u32 rom_table;
N
N    rom_table = inw(CPU_ID_STS_ADDR);
X    rom_table = (*(volatile unsigned int *)(0xE00FF01C));
N    if (CPU_ID_SCPU == rom_table) {
X    if (0x53430000 == rom_table) {
N        cpu_type = 0;
N    }
N    else if (CPU_ID_NCPU == rom_table) {
X    else if (0x4e430000 == rom_table) {
N        cpu_type = 1;
N    }
N
N    status = osKernelGetInfo(&osv, infobuf, sizeof(infobuf));
N    if(status == osOK)
N    {
N        //dbg_msg_console("+-------------------Keil RTX5----------------------+");
N        //dbg_msg_console("Kernel Information: %s", infobuf);
N        //dbg_msg_console("Kernel Version    : %d", osv.kernel);
N        //dbg_msg_console("Kernel API Version: %d", osv.api);
N        u32 spl_version = kdp_sys_get_spl_version();
N        struct fw_misc_data scpu_version, ncpu_version;
N        kl520_api_get_scpu_version(&scpu_version);
N        kl520_api_get_ncpu_version(&ncpu_version);
N#ifdef CFG_KL520_VERSION
N        dbg_msg_console("BP3-X-25 version: %s", (CFG_KL520_VERSION==KL520B)?"B":"A");//mod KL520 to ZF-BP1-C
X        kdp_level_printf(1, "BP3-X-25 version: %s" "\r\n",(1==1)?"B":"A");
N#endif
N        dbg_msg_console("SPL fw version: %x", spl_version);
X        kdp_level_printf(1, "SPL fw version: %x" "\r\n",spl_version);
N        dbg_msg_console("SCPU fw version : %d (%d.%d.%d.%d)",   scpu_version.date,
N                                                                scpu_version.version[0],
N                                                                scpu_version.version[1],
N                                                                scpu_version.version[2],
N                                                                scpu_version.version[3]);
X        kdp_level_printf(1, "SCPU fw version : %d (%d.%d.%d.%d)" "\r\n",scpu_version . date, scpu_version . version[0], scpu_version . version[1], scpu_version . version[2], scpu_version . version[3]);
N        dbg_msg_console("NCPU fw version : %d (%d.%d.%d.%d)",   ncpu_version.date,
N                                                                ncpu_version.version[0],
N                                                                ncpu_version.version[1],
N                                                                ncpu_version.version[2],
N                                                                ncpu_version.version[3]);
X        kdp_level_printf(1, "NCPU fw version : %d (%d.%d.%d.%d)" "\r\n",ncpu_version . date, ncpu_version . version[0], ncpu_version . version[1], ncpu_version . version[2], ncpu_version . version[3]);
N        dbg_msg_console("FW compile time:%s %s", __DATE__, __TIME__);
X        kdp_level_printf(1, "FW compile time:%s %s" "\r\n","May 10 2024", "11:21:04");
N    }
N}
N
Nstatic void comm_init(void)
N{
N#if CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_LWCOM
X#if 0 == 0
N
N//--------------------UART/SPI
N#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
X#if ( (0x04)&0x0000007F ) || ( (0x04)&0x00000F00 )
N    kl520_com_bus_init();
N#endif
N//--------------------USB
N#if ( CFG_COM_BUS_TYPE&COM_BUS_USB_MASK )
X#if ( (0x04)&0x00000080 )
S#if ( CFG_COM_USB_PROT_TYPE == COM_USB_PROT_DEF )
S    host_com_init();
S#elif ( CFG_COM_USB_PROT_TYPE == COM_USB_PROT_KDP ) || ( CFG_COM_USB_PROT_TYPE == COM_USB_PROT_KDP_USR )
S    user_host_com_init();
S#elif ( CFG_COM_USB_PROT_TYPE == COM_USB_PROT_DEF_USR )
S
S#endif
S//--------------------OTG
S#if ( CFG_COM_BUS_TYPE&COM_BUS_OTG_MASK )
S    otg_init();
S#endif
N#endif
N
N
N
N#elif CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_KCOMM
X#elif 0 == 1
S
S#else //CFG_COM_BUS_TYPE
S    kl520_com_bus_init();
N#endif
N}
N
Nstatic void user_init(void)
N{
N    user_io_init();
N#if ( CFG_MODELS_LOAD_BY_ORDER == NO )    
X#if ( 1 == 0 )    
S    user_ui_init();
N#endif    
N    user_com_init();
N}
N
Nstatic void nvic_init(void)
N{
N    //register IRQ
N    NVIC_SetVector((IRQn_Type)GPIO_FTGPIO010_IRQ, (uint32_t)GPIO010_IRQHandler);
X    __NVIC_SetVector((IRQn_Type)GPIO_FTGPIO010_IRQ, (uint32_t)GPIO010_IRQHandler);
N
N    //enable IRQ
N    NVIC_EnableIRQ(GPIO_FTGPIO010_IRQ);
X    __NVIC_EnableIRQ(GPIO_FTGPIO010_IRQ);
N
N#if I2C_INTERRUPT_ENABLE
S#if CFG_I2C_0_ENABLE == YES
S    NVIC_EnableIRQ((IRQn_Type)IIC_FTIIC010_0_IRQ);
S#endif
S#if CFG_I2C_1_ENABLE == YES
S    NVIC_EnableIRQ((IRQn_Type)IIC_FTIIC010_1_IRQ);
S#endif
S#if CFG_I2C_2_ENABLE == YES
S    NVIC_EnableIRQ((IRQn_Type)IIC_FTIIC010_2_IRQ);
S#endif
S#if CFG_I2C_3_ENABLE == YES
S    NVIC_EnableIRQ((IRQn_Type)IIC_FTIIC010_3_IRQ);
S#endif
N#endif
N}
N
N/**
N * @brief main, main dispatch function
N */
N
Nint main(void)
N{
N    //u32 spl_version;
N    kl520_measure_init();
N    kl520_measure_stamp(E_MEASURE_MAIN_BOOT);
X    ;
N    //spl_version = kdp_sys_get_spl_version();
N    pinmux_init();
N    system_init();
N    system_init_ncpu();
N
N    kdp_uart_init();
N#if CFG_UART0_ENABLE == YES
X#if 1 == 1
N    kdp_uart_app_uart0_log();   // for log
N#endif
N    //kdp_ipc_init(TRUE);
N    kl520_api_log_set_user_level(CPU_ID_SCPU, LOG_USER);  //scpu
X    kl520_api_log_set_user_level(0x53430000, 1);  
N    kl520_api_log_set_user_level(CPU_ID_NCPU, LOG_USER);  //ncpu
X    kl520_api_log_set_user_level(0x4e430000, 1);  
N    ddr_init(DDR_INIT_ALL);
N    kdp_ddr_init(KDP_DDR_HEAP_HEAD_FOR_MALLOC+1, KDP_DDR_HEAP_HEAD_FOR_MALLOC_END); // will remove in next version
X    kdp_ddr_init(0x63FFFFFF+1, (0x61F85A00 - 1)); 
N
N    kdp_ipc_init(TRUE);
X    kdp_ipc_init(1);
N    #if(OTA_USER_BOOT_CHECK==YES)
X    #if(OTA_USER_BOOT_CHECK==1)
S    ota_update_boot_judge();
N    #endif
N    ota_handle_first_time_boot();
N    load_ncpu_fw(1);
N
N    SystemCoreClockUpdate();            // System Initialization
N    osKernelInitialize();               // Initialize CMSIS-RTOS
N    power_manager_init();
N#if (CFG_PRODUCTION_TEST == 1)
S    if (ota_get_scpu_flag_status() == 1)
S        kl520_api_ota_switch_SCPU();
N#endif
N    kdp_drv_init();
N    kdp_camera_init();
N    #if( OTA_USER_BACKUP == YES )
X    #if( (0) == 1 )
S    ota_user_area_boot_check();
N    #endif
N    kl520_api_tasks_init();
N    comm_init();
N    user_init();
N
N     msgZhian();
N
N#if CFG_CONSOLE_MODE == YES
X#if CFG_CONSOLE_MODE == 1
S    sample_doorlock_entry();
N#endif
N
N#if (CFG_GUI_ENABLE == YES)
X#if (0 == 1)
S    sample_gui_init();
N#endif
N
N    nvic_init();
N#if CFG_SNAPSHOT_ENABLE == 1 || CFG_SNAPSHOT_ENABLE == 2
X#if 0 == 1 || 0 == 2
S    kl520_api_snapshot_init();
N#endif
N
N#if CFG_FMAP_EXTRA_ENABLE == YES
X#if 0 == 1
S    kl520_api_extra_fmap_init();
N#endif
N    info(0);
N
N    kl520_measure_stamp(E_MEASURE_OS_START);
X    ;
N    //application is triggered in host_com.c
N    if (osKernelGetState() == osKernelReady) {
N        osKernelStart();
N    }
N
N    while(1) {
N        osDelay(1000);
N    }
N}
N
N
