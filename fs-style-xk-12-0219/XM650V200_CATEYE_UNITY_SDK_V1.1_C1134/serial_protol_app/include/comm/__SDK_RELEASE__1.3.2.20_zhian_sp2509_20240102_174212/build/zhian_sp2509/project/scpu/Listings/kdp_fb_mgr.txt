; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\kdp_fb_mgr.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\kdp_fb_mgr.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\kdp_fb_mgr.crf ..\..\..\..\scpu\drivers\media\platform\kdp_fb_mgr.c]
                          THUMB

                          AREA ||i._fb_sem_lock||, CODE, READONLY, ALIGN=1

                  _fb_sem_lock PROC
;;;34     
;;;35     static osStatus_t _fb_sem_lock(osSemaphoreId_t sem, uint32_t tm)
000000  f7ffbffe          B.W      osSemaphoreAcquire
;;;36     {
;;;37         return osSemaphoreAcquire(sem, tm);
;;;38     }
;;;39     
                          ENDP


                          AREA ||i.inc_write_next_idx||, CODE, READONLY, ALIGN=1

                  inc_write_next_idx PROC
;;;119    
;;;120    static inline void inc_write_next_idx(struct kdp_fb_mgr_s *fbp)
000000  f8d01084          LDR      r1,[r0,#0x84]
;;;121    {
;;;122        fbp->write_next_idx = (fbp->write_next_idx + 1) % fbp->buf_num;
000004  6842              LDR      r2,[r0,#4]
000006  1c49              ADDS     r1,r1,#1
000008  fb91f3f2          SDIV     r3,r1,r2
00000c  fb021113          MLS      r1,r2,r3,r1
000010  f8c01084          STR      r1,[r0,#0x84]
;;;123    }
000014  4770              BX       lr
;;;124    
                          ENDP


                          AREA ||i.kdp_fb_mgr_buf_addr||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_buf_addr PROC
;;;109    #if CFG_ONE_SHOT_MODE == YES
;;;110    uint32_t kdp_fb_mgr_buf_addr( int cam_idx, uint8_t idx )
000000  b570              PUSH     {r4-r6,lr}
;;;111    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;112        if (cam_idx >= IMGSRC_NUM)
000006  2802              CMP      r0,#2
000008  db01              BLT      |L3.14|
;;;113            return 0; 
00000a  2000              MOVS     r0,#0
;;;114    
;;;115        dbg_msg_console("[%s] idx : %d", __func__, idx);
;;;116        return fb_p[cam_idx]->buf_addr[idx];
;;;117    }
00000c  bd70              POP      {r4-r6,pc}
                  |L3.14|
00000e  460b              MOV      r3,r1                 ;115
000010  4a06              LDR      r2,|L3.44|
000012  a107              ADR      r1,|L3.48|
000014  2001              MOVS     r0,#1                 ;115
000016  f7fffffe          BL       kdp_level_printf
00001a  4809              LDR      r0,|L3.64|
00001c  2108              MOVS     r1,#8                 ;116
00001e  eb010184          ADD      r1,r1,r4,LSL #2       ;116
000022  f8500025          LDR      r0,[r0,r5,LSL #2]     ;116
000026  5840              LDR      r0,[r0,r1]            ;116
000028  bd70              POP      {r4-r6,pc}
;;;118    #endif
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      ||.constdata||
                  |L3.48|
000030  5b25735d          DCB      "[%s] idx : %d\r\n",0
000034  20696478
000038  203a2025
00003c  640d0a00
                  |L3.64|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_buffer_write_next||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_buffer_write_next PROC
;;;275    
;;;276    uint32_t kdp_fb_mgr_buffer_write_next(int cam_idx, int* write_idx, unsigned char *tile_val) //new func
000000  b570              PUSH     {r4-r6,lr}
;;;277    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;278        if (cam_idx >= IMGSRC_NUM)
000006  2802              CMP      r0,#2
000008  da09              BGE      |L4.30|
;;;279            return 0; 
;;;280            
;;;281        if(write_idx == NULL) return 0;
00000a  b145              CBZ      r5,|L4.30|
;;;282        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
00000c  482d              LDR      r0,|L4.196|
;;;283    
;;;284        if(_fb_sem_lock(fbp->_sem_fb, 0) != osOK) return 0; //in case of fb is busy, skip this interrupt
00000e  2100              MOVS     r1,#0
000010  f8504026          LDR      r4,[r0,r6,LSL #2]     ;282
000014  f8d400b0          LDR      r0,[r4,#0xb0]
000018  f7fffffe          BL       _fb_sem_lock
00001c  b108              CBZ      r0,|L4.34|
                  |L4.30|
00001e  2000              MOVS     r0,#0
;;;285        local_irq_disable();
;;;286        
;;;287        if(*write_idx != -1) {
;;;288            fbp->write_count++;
;;;289    
;;;290            fbp->buf_seq_num[*write_idx] = fbp->write_count;
;;;291    
;;;292            fbp->write_done_idx = *write_idx;
;;;293            fbp->write_idx = fbp->write_next_idx;
;;;294    
;;;295            if (fbp->write_done_cb)
;;;296                fbp->write_done_cb(cam_idx, *write_idx);
;;;297        }
;;;298    
;;;299        inc_write_next_idx(fbp);
;;;300    
;;;301        if (fbp->write_idx == -1)
;;;302            fbp->write_idx = fbp->write_next_idx;
;;;303    
;;;304        fb_msg("[%d]%s: %d\n", cam_idx, __func__, fbp->write_next_idx);
;;;305    
;;;306        // skip the buffer currently for inference or being read
;;;307        if (fbp->write_next_idx == fbp->inf_idx) {
;;;308            inc_write_next_idx(fbp);
;;;309            if (fbp->write_next_idx == fbp->read_idx)
;;;310                inc_write_next_idx(fbp);
;;;311        } else if (fbp->write_next_idx == fbp->read_idx) {
;;;312            inc_write_next_idx(fbp);
;;;313            if (fbp->write_next_idx == fbp->inf_idx)
;;;314                inc_write_next_idx(fbp);
;;;315        }
;;;316    
;;;317        *write_idx = fbp->write_next_idx;
;;;318        
;;;319        uint32_t tmp = fbp->buf_addr[fbp->write_next_idx];
;;;320        local_irq_enable();
;;;321        _fb_sem_release(fbp->_sem_fb);
;;;322        
;;;323        return tmp;
;;;324    }
000020  bd70              POP      {r4-r6,pc}
                  |L4.34|
000022  6828              LDR      r0,[r5,#0]            ;287
000024  1c40              ADDS     r0,r0,#1              ;287
000026  d015              BEQ      |L4.84|
000028  f8d4009c          LDR      r0,[r4,#0x9c]         ;288
00002c  1c40              ADDS     r0,r0,#1              ;288
00002e  f8c4009c          STR      r0,[r4,#0x9c]         ;290
000032  6829              LDR      r1,[r5,#0]            ;290
000034  eb040181          ADD      r1,r4,r1,LSL #2       ;290
000038  6248              STR      r0,[r1,#0x24]         ;292
00003a  6828              LDR      r0,[r5,#0]            ;292
00003c  f8c40088          STR      r0,[r4,#0x88]         ;293
000040  f8d40084          LDR      r0,[r4,#0x84]         ;293
000044  f8c40080          STR      r0,[r4,#0x80]         ;295
000048  f8d420ac          LDR      r2,[r4,#0xac]         ;295
00004c  b112              CBZ      r2,|L4.84|
00004e  4630              MOV      r0,r6                 ;296
000050  6829              LDR      r1,[r5,#0]            ;296
000052  4790              BLX      r2                    ;296
                  |L4.84|
000054  4620              MOV      r0,r4                 ;299
000056  f7fffffe          BL       inc_write_next_idx
00005a  f8d40080          LDR      r0,[r4,#0x80]         ;301
00005e  1c40              ADDS     r0,r0,#1              ;301
000060  d103              BNE      |L4.106|
000062  f8d40084          LDR      r0,[r4,#0x84]         ;302
000066  f8c40080          STR      r0,[r4,#0x80]         ;302
                  |L4.106|
00006a  f8d4108c          LDR      r1,[r4,#0x8c]         ;307
00006e  f8d40084          LDR      r0,[r4,#0x84]         ;307
000072  4288              CMP      r0,r1                 ;307
000074  d107              BNE      |L4.134|
000076  4620              MOV      r0,r4                 ;308
000078  f7fffffe          BL       inc_write_next_idx
00007c  f8d41094          LDR      r1,[r4,#0x94]         ;309
000080  f8d40084          LDR      r0,[r4,#0x84]         ;309
000084  e00a              B        |L4.156|
                  |L4.134|
000086  f8d41094          LDR      r1,[r4,#0x94]         ;311
00008a  4288              CMP      r0,r1                 ;311
00008c  d10b              BNE      |L4.166|
00008e  4620              MOV      r0,r4                 ;312
000090  f7fffffe          BL       inc_write_next_idx
000094  f8d4108c          LDR      r1,[r4,#0x8c]         ;313
000098  f8d40084          LDR      r0,[r4,#0x84]         ;313
                  |L4.156|
00009c  4288              CMP      r0,r1                 ;313
00009e  d102              BNE      |L4.166|
0000a0  4620              MOV      r0,r4                 ;314
0000a2  f7fffffe          BL       inc_write_next_idx
                  |L4.166|
0000a6  f8d40084          LDR      r0,[r4,#0x84]         ;317
0000aa  6028              STR      r0,[r5,#0]            ;319
0000ac  f8d40084          LDR      r0,[r4,#0x84]         ;319
0000b0  eb040080          ADD      r0,r4,r0,LSL #2       ;319
0000b4  6885              LDR      r5,[r0,#8]            ;321
0000b6  f8d400b0          LDR      r0,[r4,#0xb0]         ;321
0000ba  f7fffffe          BL       osSemaphoreRelease
0000be  4628              MOV      r0,r5                 ;323
0000c0  bd70              POP      {r4-r6,pc}
;;;325    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L4.196|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_free_aec_buf||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_free_aec_buf PROC
;;;775    
;;;776    void kdp_fb_mgr_free_aec_buf(int cam_idx)
000000  2802              CMP      r0,#2
;;;777    {
000002  da06              BGE      |L5.18|
;;;778        if (cam_idx >= IMGSRC_NUM)
;;;779            return ;
;;;780    
;;;781        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
000004  4903              LDR      r1,|L5.20|
000006  f8510020          LDR      r0,[r1,r0,LSL #2]
;;;782    
;;;783        local_irq_disable();
;;;784    
;;;785        fbp->aec_idx = -1;
00000a  f04f31ff          MOV      r1,#0xffffffff
00000e  f8c01098          STR      r1,[r0,#0x98]
                  |L5.18|
;;;786    
;;;787        fb_msg("[%d]%s\n", cam_idx, __func__);
;;;788    
;;;789        local_irq_enable();
;;;790    }
000012  4770              BX       lr
;;;791    
                          ENDP

                  |L5.20|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_free_inf_buf||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_free_inf_buf PROC
;;;874    
;;;875    void kdp_fb_mgr_free_inf_buf(int cam_idx)
000000  b510              PUSH     {r4,lr}
;;;876    {
;;;877        if (cam_idx >= IMGSRC_NUM)
000002  2802              CMP      r0,#2
000004  da16              BGE      |L6.52|
;;;878            return; 
;;;879        
;;;880        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
000006  490c              LDR      r1,|L6.56|
000008  f8514020          LDR      r4,[r1,r0,LSL #2]
;;;881        
;;;882        osStatus_t sem_rt = _fb_sem_lock(fbp->_sem_fb, 5000);
00000c  f2413188          MOV      r1,#0x1388
000010  f8d400b0          LDR      r0,[r4,#0xb0]
000014  348c              ADDS     r4,r4,#0x8c
000016  f7fffffe          BL       _fb_sem_lock
;;;883    
;;;884        local_irq_disable();
;;;885    
;;;886        fbp->inf_idx = -1;
00001a  f04f31ff          MOV      r1,#0xffffffff
00001e  c402              STM      r4!,{r1}
;;;887        fbp->inf_done_idx = -1;
;;;888    
;;;889        fb_msg("[%d]%s\n", cam_idx, __func__);
;;;890    
;;;891        local_irq_enable();
;;;892        if(sem_rt == osOK) _fb_sem_release(fbp->_sem_fb);
000020  2800              CMP      r0,#0
000022  f8441990          STR      r1,[r4],#-0x90        ;887
000026  d105              BNE      |L6.52|
000028  f8d400b0          LDR      r0,[r4,#0xb0]
00002c  e8bd4010          POP      {r4,lr}
000030  f7ffbffe          B.W      osSemaphoreRelease
                  |L6.52|
;;;893    }
000034  bd10              POP      {r4,pc}
;;;894    
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_free_read_buf||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_free_read_buf PROC
;;;756    
;;;757    void kdp_fb_mgr_free_read_buf(int cam_idx)
000000  b510              PUSH     {r4,lr}
;;;758    {
;;;759        if (cam_idx >= IMGSRC_NUM)
000002  2802              CMP      r0,#2
000004  da14              BGE      |L7.48|
;;;760            return ;
;;;761    
;;;762        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
000006  490b              LDR      r1,|L7.52|
000008  f8514020          LDR      r4,[r1,r0,LSL #2]
;;;763    
;;;764        osStatus_t sem_rt = _fb_sem_lock(fbp->_sem_fb, 5000);
00000c  f2413188          MOV      r1,#0x1388
000010  f8d400b0          LDR      r0,[r4,#0xb0]
000014  f7fffffe          BL       _fb_sem_lock
;;;765        local_irq_disable();
;;;766    
;;;767        fbp->read_idx = -1;
000018  f04f31ff          MOV      r1,#0xffffffff
;;;768    
;;;769        fb_msg("[%d]%s\n", cam_idx, __func__);
;;;770    
;;;771        local_irq_enable();
;;;772        if(sem_rt == osOK) _fb_sem_release(fbp->_sem_fb);
00001c  f8c41094          STR      r1,[r4,#0x94]
000020  2800              CMP      r0,#0
000022  d105              BNE      |L7.48|
000024  f8d400b0          LDR      r0,[r4,#0xb0]
000028  e8bd4010          POP      {r4,lr}
00002c  f7ffbffe          B.W      osSemaphoreRelease
                  |L7.48|
;;;773    }
000030  bd10              POP      {r4,pc}
;;;774    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_free_write_buf||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_free_write_buf PROC
;;;325    
;;;326    void kdp_fb_mgr_free_write_buf(int cam_idx)
000000  b510              PUSH     {r4,lr}
;;;327    {
;;;328        if (cam_idx >= IMGSRC_NUM)
000002  2802              CMP      r0,#2
000004  da23              BGE      |L8.78|
;;;329            return;
;;;330        
;;;331        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
000006  4912              LDR      r1,|L8.80|
000008  f8514020          LDR      r4,[r1,r0,LSL #2]
;;;332        int i;
;;;333    
;;;334        osStatus_t sem_rt = _fb_sem_lock(fbp->_sem_fb, 5000);
00000c  f2413188          MOV      r1,#0x1388
000010  f8d400b0          LDR      r0,[r4,#0xb0]
000014  3480              ADDS     r4,r4,#0x80
000016  f7fffffe          BL       _fb_sem_lock
;;;335        local_irq_disable();
;;;336    
;;;337        fbp->write_idx = -1;
00001a  f04f31ff          MOV      r1,#0xffffffff
00001e  c402              STM      r4!,{r1}
;;;338        fbp->write_next_idx = -1;
;;;339        fbp->write_done_idx = -1;
;;;340        fbp->write_count = 0;
000020  2200              MOVS     r2,#0
000022  c402              STM      r4!,{r1}              ;338
000024  f8441b14          STR      r1,[r4],#0x14         ;339
;;;341    
;;;342    #if FB_CTX_ENABLE == YES
;;;343    #ifdef FB_DEBUG2
;;;344        fbp->write_count = 0;   // for test purposes
;;;345    
;;;346        // memset((void *)fbp->fb_ctx[0].buf_addr, 0, fbp->buf_size);
;;;347        // memset((void *)fbp->fb_ctx[1].buf_addr, 0, fbp->buf_size);
;;;348        // memset((void *)fbp->fb_ctx[2].buf_addr, 0, fbp->buf_size);
;;;349    #else
;;;350        // memset((void *)fbp->fb_ctx[0].buf_addr, 0, fbp->buf_size);
;;;351        // memset((void *)fbp->fb_ctx[1].buf_addr, 0, fbp->buf_size);
;;;352    #endif
;;;353        for (i = 0; i < fbp->buf_num; i++) {
;;;354            fbp->fb_ctx[i].buf_seq_num = 0;
;;;355        }   
;;;356    #else
;;;357    #ifdef FB_DEBUG2
;;;358        fbp->write_count = 0;   // for test purposes
;;;359    
;;;360        // memset((void *)fbp->buf_addr[0], 0, fbp->buf_size);
;;;361        // memset((void *)fbp->buf_addr[1], 0, fbp->buf_size);
;;;362        // memset((void *)fbp->buf_addr[2], 0, fbp->buf_size);
;;;363    #else
;;;364        // memset((void *)fbp->buf_addr[0], 0, fbp->buf_size);
;;;365        // memset((void *)fbp->buf_addr[1], 0, fbp->buf_size);
;;;366    #endif
;;;367        for (i = 0; i < fbp->buf_num; i++) {
000028  4611              MOV      r1,r2
00002a  f844299c          STR      r2,[r4],#-0x9c        ;340
00002e  e003              B        |L8.56|
                  |L8.48|
;;;368            fbp->buf_seq_num[i] = 0;
000030  eb040381          ADD      r3,r4,r1,LSL #2
000034  1c49              ADDS     r1,r1,#1
000036  625a              STR      r2,[r3,#0x24]
                  |L8.56|
000038  6863              LDR      r3,[r4,#4]            ;367
00003a  428b              CMP      r3,r1                 ;367
00003c  dcf8              BGT      |L8.48|
;;;369        }   
;;;370    #endif
;;;371    
;;;372        fb_msg("[%d]%s\n", cam_idx, __func__);
;;;373    
;;;374        local_irq_enable();
;;;375        if(sem_rt == osOK) _fb_sem_release(fbp->_sem_fb);
00003e  2800              CMP      r0,#0
000040  d105              BNE      |L8.78|
000042  f8d400b0          LDR      r0,[r4,#0xb0]
000046  e8bd4010          POP      {r4,lr}
00004a  f7ffbffe          B.W      osSemaphoreRelease
                  |L8.78|
;;;376    }
00004e  bd10              POP      {r4,pc}
;;;377    
                          ENDP

                  |L8.80|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_get_buf||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_get_buf PROC
;;;400    
;;;401    uint32_t kdp_fb_mgr_get_buf(int cam_idx, int idx)
000000  b510              PUSH     {r4,lr}
;;;402    {
;;;403        if (cam_idx >= IMGSRC_NUM)
000002  2802              CMP      r0,#2
000004  db01              BLT      |L9.10|
;;;404            return 0; 
000006  2000              MOVS     r0,#0
;;;405            
;;;406        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
;;;407    
;;;408        local_irq_disable();
;;;409    
;;;410        idx %= fbp->buf_num;
;;;411    #if FB_CTX_ENABLE == YES
;;;412        uint32_t buf_addr = fbp->fb_ctx[idx].buf_addr;
;;;413    #else
;;;414        uint32_t buf_addr = fbp->buf_addr[idx];
;;;415    #endif
;;;416        memset((void *)buf_addr, 0, fbp->buf_size);
;;;417    
;;;418        fb_msg("[%d]%s: %d\n", cam_idx, __func__, idx);
;;;419    
;;;420        local_irq_enable();
;;;421    
;;;422        return buf_addr;
;;;423    }
000008  bd10              POP      {r4,pc}
                  |L9.10|
00000a  4a08              LDR      r2,|L9.44|
00000c  f8522020          LDR      r2,[r2,r0,LSL #2]     ;406
000010  6850              LDR      r0,[r2,#4]            ;410
000012  fb91f3f0          SDIV     r3,r1,r0              ;410
000016  fb001013          MLS      r0,r0,r3,r1           ;410
00001a  eb020080          ADD      r0,r2,r0,LSL #2       ;414
00001e  6811              LDR      r1,[r2,#0]            ;416
000020  6884              LDR      r4,[r0,#8]            ;416
000022  4620              MOV      r0,r4                 ;416
000024  f7fffffe          BL       __aeabi_memclr
000028  4620              MOV      r0,r4                 ;422
00002a  bd10              POP      {r4,pc}
;;;424    
                          ENDP

                  |L9.44|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_get_buf_seq_num||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_get_buf_seq_num PROC
;;;377    
;;;378    uint32_t kdp_fb_mgr_get_buf_seq_num(int cam_idx, int idx)
000000  2802              CMP      r0,#2
;;;379    {
000002  db01              BLT      |L10.8|
;;;380        if (cam_idx >= IMGSRC_NUM)
;;;381            return 0;
000004  2000              MOVS     r0,#0
;;;382        
;;;383        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
;;;384    #if FB_CTX_ENABLE == YES
;;;385        return fbp->fb_ctx[idx].buf_seq_num;
;;;386    #else
;;;387        return fbp->buf_seq_num[idx];
;;;388    #endif
;;;389    }
000006  4770              BX       lr
                  |L10.8|
000008  4a03              LDR      r2,|L10.24|
00000a  f8520020          LDR      r0,[r2,r0,LSL #2]     ;383
00000e  eb000081          ADD      r0,r0,r1,LSL #2       ;387
000012  6a40              LDR      r0,[r0,#0x24]         ;387
000014  4770              BX       lr
;;;390    
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_get_current_buf_seq_num||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_get_current_buf_seq_num PROC
;;;390    
;;;391    uint32_t kdp_fb_mgr_get_current_buf_seq_num(int cam_idx)
000000  2802              CMP      r0,#2
;;;392    {
000002  db01              BLT      |L11.8|
;;;393        if (cam_idx >= IMGSRC_NUM)
;;;394            return 0;
000004  2000              MOVS     r0,#0
;;;395        
;;;396        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
;;;397    
;;;398        return fbp->write_count;
;;;399    }
000006  4770              BX       lr
                  |L11.8|
000008  4902              LDR      r1,|L11.20|
00000a  f8510020          LDR      r0,[r1,r0,LSL #2]     ;396
00000e  f8d0009c          LDR      r0,[r0,#0x9c]         ;398
000012  4770              BX       lr
;;;400    
                          ENDP

                  |L11.20|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_get_latest_frame_info||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_get_latest_frame_info PROC
;;;424    
;;;425    void kdp_fb_mgr_get_latest_frame_info(int cam_idx, struct frame_info *info)
000000  460b              MOV      r3,r1
;;;426    {
;;;427        if (cam_idx >= IMGSRC_NUM)
000002  2802              CMP      r0,#2
000004  da07              BGE      |L12.22|
;;;428            return; 
;;;429            
;;;430        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
000006  4904              LDR      r1,|L12.24|
;;;431    
;;;432        local_irq_disable();
;;;433    
;;;434        memcpy(info, &fbp->latest_info, sizeof(struct frame_info));
000008  223d              MOVS     r2,#0x3d
00000a  f8511020          LDR      r1,[r1,r0,LSL #2]     ;430
00000e  4618              MOV      r0,r3
000010  3140              ADDS     r1,r1,#0x40
000012  f7ffbffe          B.W      __aeabi_memcpy
                  |L12.22|
;;;435    
;;;436        fb_msg("[%d]%s: %d\n", cam_idx, __func__);
;;;437    
;;;438        local_irq_enable();
;;;439    }
000016  4770              BX       lr
;;;440    
                          ENDP

                  |L12.24|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_inf_done||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_inf_done PROC
;;;853    
;;;854    int kdp_fb_mgr_inf_done(int cam_idx, int inf_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;855    {
000002  460d              MOV      r5,r1
;;;856        if (cam_idx >= IMGSRC_NUM)
000004  2802              CMP      r0,#2
000006  da14              BGE      |L13.50|
;;;857            return 0; 
;;;858        
;;;859        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
000008  490b              LDR      r1,|L13.56|
00000a  f8514020          LDR      r4,[r1,r0,LSL #2]
;;;860    
;;;861        osStatus_t sem_rt = _fb_sem_lock(fbp->_sem_fb, 5000);
00000e  f2413188          MOV      r1,#0x1388
000012  f8d400b0          LDR      r0,[r4,#0xb0]
000016  3490              ADDS     r4,r4,#0x90
000018  f7fffffe          BL       _fb_sem_lock
;;;862        local_irq_disable();
;;;863    
;;;864        fbp->inf_done_idx = inf_idx;
00001c  f8445b14          STR      r5,[r4],#0x14
;;;865        fbp->inf_count++;
000020  6821              LDR      r1,[r4,#0]
000022  1c49              ADDS     r1,r1,#1
000024  f84419a4          STR      r1,[r4],#-0xa4
;;;866    
;;;867        fb_msg("[%d]%s: %d\n", cam_idx, __func__, inf_idx);
;;;868    
;;;869        local_irq_enable();
;;;870        if(sem_rt == osOK) _fb_sem_release(fbp->_sem_fb);
000028  b918              CBNZ     r0,|L13.50|
00002a  f8d400b0          LDR      r0,[r4,#0xb0]
00002e  f7fffffe          BL       osSemaphoreRelease
                  |L13.50|
;;;871    
;;;872        return 0;
000032  2000              MOVS     r0,#0
;;;873    }
000034  bd70              POP      {r4-r6,pc}
;;;874    
                          ENDP

000036  0000              DCW      0x0000
                  |L13.56|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_init||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_init PROC
;;;124    
;;;125    int kdp_fb_mgr_init(int cam_idx, uint32_t buf_size, int buf_num)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;126    {
000004  4615              MOV      r5,r2
000006  460f              MOV      r7,r1
;;;127        if (cam_idx >= IMGSRC_NUM)
000008  2802              CMP      r0,#2
00000a  da34              BGE      |L14.118|
;;;128            return 0; 
;;;129            
;;;130        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
00000c  491b              LDR      r1,|L14.124|
;;;131        int i, size;
;;;132    
;;;133    #if USE_GUARDBAND
;;;134        size = buf_size + (2 * buf_size / USE_GUARDBAND);
;;;135    #else
;;;136        size = buf_size;
;;;137    #endif
;;;138    
;;;139        if (buf_num <= 0 || buf_num > MAX_FRAME_BUFFER)
00000e  2d00              CMP      r5,#0
000010  f8514020          LDR      r4,[r1,r0,LSL #2]     ;130
000014  f3c71059          UBFX     r0,r7,#5,#26          ;134
000018  eb070800          ADD      r8,r7,r0              ;134
00001c  dd01              BLE      |L14.34|
00001e  2d07              CMP      r5,#7
000020  dd02              BLE      |L14.40|
                  |L14.34|
;;;140            buf_num = MAX_FRAME_BUFFER;
000022  2507              MOVS     r5,#7
;;;141    
;;;142    #if FB_CTX_ENABLE == YES
;;;143        for (i = 0; i < buf_num; i++) {
;;;144            fbp->fb_ctx[i].buf_addr = kdp_ddr_reserve(size);
;;;145    #if USE_GUARDBAND
;;;146            fbp->fb_ctx[i].buf_addr += (buf_size / USE_GUARDBAND);
;;;147    #endif
;;;148            //fb_msg("  cam %d: frame buf[%d] : 0x%x", cam_idx, i, fbp->buf_addr[i]);
;;;149        }
;;;150    #else
;;;151        for (i = 0; i < buf_num; i++) {
000024  2600              MOVS     r6,#0
000026  e001              B        |L14.44|
                  |L14.40|
000028  2600              MOVS     r6,#0
00002a  e008              B        |L14.62|
                  |L14.44|
;;;152            fbp->buf_addr[i] = kdp_ddr_reserve(size);
00002c  4640              MOV      r0,r8
00002e  f7fffffe          BL       kdp_ddr_reserve
000032  eb040186          ADD      r1,r4,r6,LSL #2
;;;153    #if USE_GUARDBAND
;;;154            fbp->buf_addr[i] += (buf_size / USE_GUARDBAND);
000036  eb001097          ADD      r0,r0,r7,LSR #6
00003a  1c76              ADDS     r6,r6,#1
00003c  6088              STR      r0,[r1,#8]
                  |L14.62|
00003e  42ae              CMP      r6,r5                 ;151
000040  dbf4              BLT      |L14.44|
;;;155    #endif
;;;156            //fb_msg("  cam %d: frame buf[%d] : 0x%x", cam_idx, i, fbp->buf_addr[i]);
;;;157        }
;;;158    #endif
;;;159        fbp->write_idx = fbp->read_idx = fbp->inf_idx = -1;
000042  f04f30ff          MOV      r0,#0xffffffff
000046  f8c4008c          STR      r0,[r4,#0x8c]
00004a  f8c40094          STR      r0,[r4,#0x94]
;;;160        fbp->write_done_idx = fbp->write_next_idx = fbp->inf_done_idx = -1;
00004e  f8c40080          STR      r0,[r4,#0x80]
000052  f8c40090          STR      r0,[r4,#0x90]
000056  f8c40084          STR      r0,[r4,#0x84]
00005a  f8c40088          STR      r0,[r4,#0x88]
00005e  e9c47500          STRD     r7,r5,[r4,#0]
;;;161        fbp->buf_size = buf_size;
;;;162        fbp->buf_num = buf_num;
;;;163    #if (FB_USE_SEM_LOCK == 1)
;;;164        if(fbp->_sem_fb == NULL) fbp->_sem_fb = osSemaphoreNew(1, 1, NULL);
000062  f8d400b0          LDR      r0,[r4,#0xb0]
000066  b930              CBNZ     r0,|L14.118|
000068  2101              MOVS     r1,#1
00006a  2200              MOVS     r2,#0
00006c  4608              MOV      r0,r1
00006e  f7fffffe          BL       osSemaphoreNew
000072  f8c400b0          STR      r0,[r4,#0xb0]
                  |L14.118|
;;;165    #endif
;;;166    
;;;167    
;;;168        return 0;
000076  2000              MOVS     r0,#0
;;;169    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;170    
                          ENDP

                  |L14.124|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_next_aec||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_next_aec PROC
;;;672    
;;;673    uint32_t kdp_fb_mgr_next_aec(int cam_idx, int *aec_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;674    {
000002  460e              MOV      r6,r1
;;;675        if (cam_idx >= IMGSRC_NUM)
000004  2802              CMP      r0,#2
000006  db01              BLT      |L15.12|
;;;676            return 0;
000008  2000              MOVS     r0,#0
;;;677    
;;;678        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
;;;679    #ifndef READ_FROM_ISR
;;;680        int try_max_count = INF_WAIT_MAX_TIME_MS / INF_WAIT_OS_DELAY_MS;
;;;681    
;;;682    next_aec_buf:
;;;683    #endif
;;;684        local_irq_disable();
;;;685    
;;;686    #ifdef FOLLOW_INFERENCE_FIRST
;;;687        if (fbp->inf_done_idx != -1) {
;;;688            // keep displaying the inference done buffer
;;;689            fbp->aec_idx = fbp->inf_done_idx;
;;;690            fb_msg("[%d]%s: %d (inf-done)\n", cam_idx, __func__, fbp->aec_idx);
;;;691        } else if (fbp->write_done_idx != -1) {
;;;692    #else // Just follow write-done
;;;693        if (fbp->write_done_idx != -1) {
;;;694    #endif
;;;695    
;;;696    #if FB_CTX_ENABLE == YES
;;;697            if (fbp->fb_ctx[fbp->write_done_idx].buf_seq_num <= SKIP_FRAME_NUM)
;;;698    #else
;;;699            if (fbp->buf_seq_num[fbp->write_done_idx] <= SKIP_FRAME_NUM)
;;;700    #endif
;;;701            {
;;;702                if(try_max_count-- >= 0)
;;;703                {
;;;704                    local_irq_enable();
;;;705                    osDelay(INF_WAIT_OS_DELAY_TICKS);
;;;706                    goto next_aec_buf;
;;;707                }
;;;708            }
;;;709    
;;;710            fbp->aec_idx = fbp->write_done_idx;
;;;711            fb_msg("[%d]%s: %d (w-done)\n", cam_idx, __func__, fbp->aec_idx);
;;;712    #ifdef FB_DEBUG2
;;;713            if (fbp->write_count < 3) {
;;;714                fb_msg("[%d]%s: %d (w-done)", cam_idx, __func__, fbp->aec_idx);
;;;715            }
;;;716    #endif
;;;717        } else {
;;;718    #ifndef READ_FROM_ISR
;;;719            // let's wait for next available one
;;;720            if (try_max_count-- >= 0) {
;;;721                local_irq_enable();
;;;722                osDelay(INF_WAIT_OS_DELAY_TICKS);
;;;723                goto next_aec_buf;
;;;724            }
;;;725    
;;;726            if (fbp->aec_idx == -1)
;;;727                fbp->aec_idx = 0;
;;;728            fb_msg("[%d]%s: reuse read_idx:%d after waiting %d ms\n",
;;;729                    cam_idx, __func__, fbp->aec_idx, INF_WAIT_MAX_TIME_MS);
;;;730    #else
;;;731            if (fbp->aec_idx == -1)
;;;732                fbp->aec_idx = 0;
;;;733    #endif
;;;734    
;;;735    #ifdef FB_DEBUG2
;;;736            if (fbp->write_count < 3) {
;;;737                //fb_msg("[%d]%s: reuse read_idx:%d after waiting %d ms",
;;;738                //    cam_idx, __func__, fbp->read_idx, INF_WAIT_MAX_TIME_MS);
;;;739            }
;;;740    #endif
;;;741        }
;;;742    
;;;743        if (aec_idx)
;;;744            *aec_idx = fbp->aec_idx;
;;;745    
;;;746        fbp->aec_count++;
;;;747    
;;;748        local_irq_enable();
;;;749    
;;;750    #if FB_CTX_ENABLE == YES
;;;751        return fbp->fb_ctx[fbp->aec_idx].buf_addr;
;;;752    #else
;;;753        return fbp->buf_addr[fbp->aec_idx];
;;;754    #endif
;;;755    }
00000a  bd70              POP      {r4-r6,pc}
                  |L15.12|
00000c  4917              LDR      r1,|L15.108|
00000e  2564              MOVS     r5,#0x64              ;680
000010  f8514020          LDR      r4,[r1,r0,LSL #2]     ;678
                  |L15.20|
000014  f8d40088          LDR      r0,[r4,#0x88]         ;693
000018  1c41              ADDS     r1,r0,#1              ;693
00001a  d00a              BEQ      |L15.50|
00001c  eb040080          ADD      r0,r4,r0,LSL #2       ;699
000020  6a40              LDR      r0,[r0,#0x24]         ;699
000022  b918              CBNZ     r0,|L15.44|
000024  0028              MOVS     r0,r5                 ;702
000026  f1a00501          SUB      r5,r0,#1              ;702
00002a  d506              BPL      |L15.58|
                  |L15.44|
00002c  f8d40088          LDR      r0,[r4,#0x88]         ;710
000030  e00b              B        |L15.74|
                  |L15.50|
000032  0028              MOVS     r0,r5                 ;720
000034  f1a00501          SUB      r5,r0,#1              ;720
000038  d403              BMI      |L15.66|
                  |L15.58|
00003a  200a              MOVS     r0,#0xa               ;722
00003c  f7fffffe          BL       osDelay
000040  e7e8              B        |L15.20|
                  |L15.66|
000042  f8d40098          LDR      r0,[r4,#0x98]         ;726
000046  1c40              ADDS     r0,r0,#1              ;726
000048  d101              BNE      |L15.78|
                  |L15.74|
00004a  f8c40098          STR      r0,[r4,#0x98]         ;727
                  |L15.78|
00004e  b116              CBZ      r6,|L15.86|
000050  f8d40098          LDR      r0,[r4,#0x98]         ;744
000054  6030              STR      r0,[r6,#0]            ;744
                  |L15.86|
000056  f8d400a8          LDR      r0,[r4,#0xa8]         ;746
00005a  1c40              ADDS     r0,r0,#1              ;746
00005c  f8c400a8          STR      r0,[r4,#0xa8]         ;753
000060  f8d40098          LDR      r0,[r4,#0x98]         ;753
000064  eb040080          ADD      r0,r4,r0,LSL #2       ;753
000068  6880              LDR      r0,[r0,#8]            ;753
00006a  bd70              POP      {r4-r6,pc}
;;;756    
                          ENDP

                  |L15.108|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_next_inf||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_next_inf PROC
;;;791    
;;;792    uint32_t kdp_fb_mgr_next_inf(int cam_idx, int *inf_idx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;793    {
000004  460e              MOV      r6,r1
;;;794        if (cam_idx >= IMGSRC_NUM)
000006  2802              CMP      r0,#2
000008  da31              BGE      |L16.110|
;;;795            return 0;
;;;796    
;;;797        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
00000a  491a              LDR      r1,|L16.116|
;;;798    
;;;799    #if (KL520_QUICK_BOOT == YES)
;;;800        int try_max_count = 200;
00000c  25c8              MOVS     r5,#0xc8
;;;801    #else
;;;802        int try_max_count = INF_WAIT_MAX_TIME_MS / INF_WAIT_OS_DELAY_MS;
;;;803    #endif
;;;804    
;;;805    next_inf_buf:
;;;806        local_irq_disable();
;;;807        // inference uses the latest write_done_idx
;;;808        //fb_msg("fbp->write_done_idx=%d fbp->inf_done_idx=%d", fbp->write_done_idx, fbp->inf_done_idx);
;;;809        
;;;810        osStatus_t sem_rt = _fb_sem_lock(fbp->_sem_fb, 5000);
00000e  f2413788          MOV      r7,#0x1388
000012  f8514020          LDR      r4,[r1,r0,LSL #2]     ;797
                  |L16.22|
000016  4639              MOV      r1,r7
000018  f8d400b0          LDR      r0,[r4,#0xb0]
00001c  f7fffffe          BL       _fb_sem_lock
;;;811        if(sem_rt != osOK) return 0; // in case no sem, return 0
000020  bb28              CBNZ     r0,|L16.110|
;;;812    
;;;813        if (fbp->write_done_idx == fbp->inf_done_idx) {
000022  f8d41090          LDR      r1,[r4,#0x90]
000026  f8d40088          LDR      r0,[r4,#0x88]
00002a  4288              CMP      r0,r1
00002c  d10b              BNE      |L16.70|
;;;814            // latest write_done_idx is already used. let's wait for new one
;;;815            if (try_max_count-- >= 0) {
00002e  0028              MOVS     r0,r5
000030  f1a00501          SUB      r5,r0,#1
000034  d407              BMI      |L16.70|
000036  f8d400b0          LDR      r0,[r4,#0xb0]
00003a  f7fffffe          BL       osSemaphoreRelease
;;;816                _fb_sem_release(fbp->_sem_fb);
;;;817                local_irq_enable();
;;;818            #if (KL520_QUICK_BOOT == YES)
;;;819                osDelay(5);//osDelay(1);
00003e  2005              MOVS     r0,#5
000040  f7fffffe          BL       osDelay
;;;820            #else
;;;821                osDelay(INF_WAIT_OS_DELAY_TICKS);
;;;822            #endif
;;;823                goto next_inf_buf;
000044  e7e7              B        |L16.22|
                  |L16.70|
;;;824            }
;;;825            //fb_msg("[%d]%s: reuse w-done:%d after waiting %d ms\n",
;;;826            //        cam_idx, __func__, fbp->write_done_idx, INF_WAIT_MAX_TIME_MS);
;;;827        } else {
;;;828            //fb_msg("[%d]%s: %d\n", cam_idx, __func__, fbp->write_done_idx);
;;;829        }
;;;830    
;;;831        // inference uses the latest write_done_idx
;;;832        fbp->inf_idx = fbp->write_done_idx;
000046  f8d40088          LDR      r0,[r4,#0x88]
;;;833        if (inf_idx)
00004a  f8c4008c          STR      r0,[r4,#0x8c]
00004e  b106              CBZ      r6,|L16.82|
;;;834            *inf_idx = fbp->inf_idx;
000050  6030              STR      r0,[r6,#0]
                  |L16.82|
;;;835        
;;;836        int tmp = fbp->inf_idx;
;;;837        uint32_t ret = fbp->buf_addr[tmp];
000052  f8d4508c          LDR      r5,[r4,#0x8c]
000056  eb040085          ADD      r0,r4,r5,LSL #2
;;;838        local_irq_enable();
;;;839        _fb_sem_release(fbp->_sem_fb);
00005a  6886              LDR      r6,[r0,#8]
00005c  f8d400b0          LDR      r0,[r4,#0xb0]
000060  f7fffffe          BL       osSemaphoreRelease
;;;840        
;;;841        if (tmp >= 0) {
000064  2d00              CMP      r5,#0
000066  db02              BLT      |L16.110|
;;;842        #if FB_CTX_ENABLE == YES
;;;843            return fbp->fb_ctx[fbp->inf_idx].buf_addr;
;;;844        #else
;;;845            return ret;
000068  4630              MOV      r0,r6
                  |L16.106|
;;;846        #endif
;;;847        }
;;;848        else {
;;;849            dbg_msg_algo ("cap frm failed:%d.%d.%d.", cam_idx, fbp->inf_idx, fbp->write_done_idx);
;;;850            return 0x0;
;;;851        }
;;;852    }
00006a  e8bd81f0          POP      {r4-r8,pc}
                  |L16.110|
00006e  2000              MOVS     r0,#0                 ;850
000070  e7fb              B        |L16.106|
;;;853    
                          ENDP

000072  0000              DCW      0x0000
                  |L16.116|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_next_read||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_next_read PROC
;;;582    #endif
;;;583    uint32_t kdp_fb_mgr_next_read(int cam_idx, int *read_idx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;584    {
000004  460e              MOV      r6,r1
;;;585        if (cam_idx >= IMGSRC_NUM)
000006  2802              CMP      r0,#2
000008  da0b              BGE      |L17.34|
;;;586            return 0;
;;;587    
;;;588        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
00000a  4922              LDR      r1,|L17.148|
;;;589    #ifndef READ_FROM_ISR
;;;590        int try_max_count = INF_WAIT_MAX_TIME_MS / INF_WAIT_OS_DELAY_MS;
00000c  2564              MOVS     r5,#0x64
;;;591    
;;;592    next_read_buf:
;;;593    #endif
;;;594        local_irq_disable();
;;;595        osStatus_t sem_rt = _fb_sem_lock(fbp->_sem_fb, 5000);
00000e  f2413788          MOV      r7,#0x1388
000012  f8514020          LDR      r4,[r1,r0,LSL #2]     ;588
                  |L17.22|
000016  4639              MOV      r1,r7
000018  f8d400b0          LDR      r0,[r4,#0xb0]
00001c  f7fffffe          BL       _fb_sem_lock
;;;596        if(sem_rt != osOK) return 0;
000020  b110              CBZ      r0,|L17.40|
                  |L17.34|
000022  2000              MOVS     r0,#0
                  |L17.36|
;;;597    
;;;598    #ifdef FOLLOW_INFERENCE_FIRST
;;;599        if (fbp->inf_done_idx != -1) {
;;;600            // keep displaying the inference done buffer
;;;601            fbp->read_idx = fbp->inf_done_idx;
;;;602            fb_msg("[%d]%s: %d (inf-done)\n", cam_idx, __func__, fbp->read_idx);
;;;603        } else if (fbp->write_done_idx != -1) {
;;;604    #else // Just follow write-done
;;;605        if (fbp->write_done_idx != -1) {
;;;606    #endif
;;;607    
;;;608    #if FB_CTX_ENABLE == YES
;;;609            if (fbp->fb_ctx[fbp->write_done_idx].buf_seq_num <= SKIP_FRAME_NUM)
;;;610    #else
;;;611            if (fbp->buf_seq_num[fbp->write_done_idx] <= SKIP_FRAME_NUM)
;;;612    #endif
;;;613            {
;;;614                if(try_max_count-- >= 0)
;;;615                {
;;;616                    _fb_sem_release(fbp->_sem_fb);
;;;617                    local_irq_enable();
;;;618                    osDelay(INF_WAIT_OS_DELAY_TICKS);
;;;619                    goto next_read_buf;
;;;620                }
;;;621            }
;;;622    
;;;623            fbp->read_idx = fbp->write_done_idx;
;;;624            fb_msg("[%d]%s: %d (w-done)\n", cam_idx, __func__, fbp->read_idx);
;;;625    #ifdef FB_DEBUG2
;;;626            if (fbp->write_count < 3) {
;;;627                fb_msg("[%d]%s: %d (w-done)", cam_idx, __func__, fbp->read_idx);
;;;628            }
;;;629    #endif
;;;630        } else {
;;;631    #ifndef READ_FROM_ISR
;;;632            // let's wait for next available one
;;;633            if (try_max_count-- >= 0) {
;;;634                _fb_sem_release(fbp->_sem_fb);
;;;635                local_irq_enable();
;;;636                osDelay(INF_WAIT_OS_DELAY_TICKS);
;;;637                goto next_read_buf;
;;;638            }
;;;639    
;;;640            if (fbp->read_idx == -1)
;;;641                fbp->read_idx = 0;
;;;642            fb_msg("[%d]%s: reuse read_idx:%d after waiting %d ms\n",
;;;643                    cam_idx, __func__, fbp->read_idx, INF_WAIT_MAX_TIME_MS);
;;;644    #else
;;;645            if (fbp->read_idx == -1)
;;;646                fbp->read_idx = 0;
;;;647    #endif
;;;648    
;;;649    #ifdef FB_DEBUG2
;;;650            if (fbp->write_count < 3) {
;;;651                //fb_msg("[%d]%s: reuse read_idx:%d after waiting %d ms",
;;;652                //    cam_idx, __func__, fbp->read_idx, INF_WAIT_MAX_TIME_MS);
;;;653            }
;;;654    #endif
;;;655        }
;;;656    
;;;657        if (read_idx)
;;;658            *read_idx = fbp->read_idx;
;;;659    
;;;660        fbp->read_count++;
;;;661    
;;;662        uint32_t ret = fbp->buf_addr[fbp->read_idx];
;;;663        local_irq_enable();
;;;664        _fb_sem_release(fbp->_sem_fb);
;;;665    
;;;666    #if FB_CTX_ENABLE == YES
;;;667        return fbp->fb_ctx[fbp->read_idx].buf_addr;
;;;668    #else
;;;669        return ret;
;;;670    #endif
;;;671    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L17.40|
000028  f8d40088          LDR      r0,[r4,#0x88]         ;605
00002c  1c41              ADDS     r1,r0,#1              ;605
00002e  d00a              BEQ      |L17.70|
000030  eb040080          ADD      r0,r4,r0,LSL #2       ;611
000034  6a40              LDR      r0,[r0,#0x24]         ;611
000036  b918              CBNZ     r0,|L17.64|
000038  0028              MOVS     r0,r5                 ;614
00003a  f1a00501          SUB      r5,r0,#1              ;614
00003e  d506              BPL      |L17.78|
                  |L17.64|
000040  f8d40088          LDR      r0,[r4,#0x88]         ;623
000044  e00f              B        |L17.102|
                  |L17.70|
000046  0028              MOVS     r0,r5                 ;633
000048  f1a00501          SUB      r5,r0,#1              ;633
00004c  d407              BMI      |L17.94|
                  |L17.78|
00004e  f8d400b0          LDR      r0,[r4,#0xb0]         ;633
000052  f7fffffe          BL       osSemaphoreRelease
000056  200a              MOVS     r0,#0xa               ;636
000058  f7fffffe          BL       osDelay
00005c  e7db              B        |L17.22|
                  |L17.94|
00005e  f8d40094          LDR      r0,[r4,#0x94]         ;640
000062  1c40              ADDS     r0,r0,#1              ;640
000064  d101              BNE      |L17.106|
                  |L17.102|
000066  f8c40094          STR      r0,[r4,#0x94]         ;641
                  |L17.106|
00006a  b116              CBZ      r6,|L17.114|
00006c  f8d40094          LDR      r0,[r4,#0x94]         ;658
000070  6030              STR      r0,[r6,#0]            ;658
                  |L17.114|
000072  f8d400a0          LDR      r0,[r4,#0xa0]         ;660
000076  1c40              ADDS     r0,r0,#1              ;660
000078  f8c400a0          STR      r0,[r4,#0xa0]         ;662
00007c  f8d40094          LDR      r0,[r4,#0x94]         ;662
000080  eb040080          ADD      r0,r4,r0,LSL #2       ;662
000084  6885              LDR      r5,[r0,#8]            ;664
000086  f8d400b0          LDR      r0,[r4,#0xb0]         ;664
00008a  f7fffffe          BL       osSemaphoreRelease
00008e  4628              MOV      r0,r5                 ;669
000090  e7c8              B        |L17.36|
;;;672    
                          ENDP

000092  0000              DCW      0x0000
                  |L17.148|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_next_write||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_next_write PROC
;;;170    
;;;171    uint32_t kdp_fb_mgr_next_write(int cam_idx, int *write_idx) //used only during init
000000  b570              PUSH     {r4-r6,lr}
;;;172    {
000002  460d              MOV      r5,r1
;;;173        if (cam_idx >= IMGSRC_NUM)
000004  2802              CMP      r0,#2
000006  db01              BLT      |L18.12|
;;;174            return 0; 
000008  2000              MOVS     r0,#0
;;;175            
;;;176        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
;;;177    
;;;178        osStatus_t sem_rt = _fb_sem_lock(fbp->_sem_fb, 5000);
;;;179        local_irq_disable();
;;;180    
;;;181        inc_write_next_idx(fbp);
;;;182    
;;;183        if (fbp->write_idx == -1)
;;;184            fbp->write_idx = fbp->write_next_idx;
;;;185    
;;;186        fb_msg("[%d]%s: %d\n", cam_idx, __func__, fbp->write_next_idx);
;;;187    
;;;188        // skip the buffer currently for inference or being read
;;;189        if (fbp->write_next_idx == fbp->inf_idx) {
;;;190            inc_write_next_idx(fbp);
;;;191            if (fbp->write_next_idx == fbp->read_idx)
;;;192                inc_write_next_idx(fbp);
;;;193        } else if (fbp->write_next_idx == fbp->read_idx) {
;;;194            inc_write_next_idx(fbp);
;;;195            if (fbp->write_next_idx == fbp->inf_idx)
;;;196                inc_write_next_idx(fbp);
;;;197        }
;;;198    
;;;199        if (write_idx)
;;;200            *write_idx = fbp->write_next_idx;
;;;201    
;;;202        local_irq_enable();
;;;203        uint32_t tmp = fbp->buf_addr[fbp->write_next_idx];
;;;204        if(sem_rt == osOK) _fb_sem_release(fbp->_sem_fb);
;;;205    #if FB_CTX_ENABLE == YES
;;;206        return fbp->fb_ctx[fbp->write_next_idx].buf_addr;
;;;207    #else
;;;208        return tmp;
;;;209    #endif
;;;210    }
00000a  bd70              POP      {r4-r6,pc}
                  |L18.12|
00000c  4921              LDR      r1,|L18.148|
00000e  f8514020          LDR      r4,[r1,r0,LSL #2]     ;176
000012  f2413188          MOV      r1,#0x1388            ;178
000016  f8d400b0          LDR      r0,[r4,#0xb0]         ;178
00001a  f7fffffe          BL       _fb_sem_lock
00001e  4606              MOV      r6,r0                 ;178
000020  4620              MOV      r0,r4                 ;181
000022  f7fffffe          BL       inc_write_next_idx
000026  f8d40080          LDR      r0,[r4,#0x80]         ;183
00002a  1c40              ADDS     r0,r0,#1              ;183
00002c  d103              BNE      |L18.54|
00002e  f8d40084          LDR      r0,[r4,#0x84]         ;184
000032  f8c40080          STR      r0,[r4,#0x80]         ;184
                  |L18.54|
000036  f8d4108c          LDR      r1,[r4,#0x8c]         ;189
00003a  f8d40084          LDR      r0,[r4,#0x84]         ;189
00003e  4288              CMP      r0,r1                 ;189
000040  d107              BNE      |L18.82|
000042  4620              MOV      r0,r4                 ;190
000044  f7fffffe          BL       inc_write_next_idx
000048  f8d41094          LDR      r1,[r4,#0x94]         ;191
00004c  f8d40084          LDR      r0,[r4,#0x84]         ;191
000050  e00a              B        |L18.104|
                  |L18.82|
000052  f8d41094          LDR      r1,[r4,#0x94]         ;193
000056  4288              CMP      r0,r1                 ;193
000058  d10b              BNE      |L18.114|
00005a  4620              MOV      r0,r4                 ;194
00005c  f7fffffe          BL       inc_write_next_idx
000060  f8d4108c          LDR      r1,[r4,#0x8c]         ;195
000064  f8d40084          LDR      r0,[r4,#0x84]         ;195
                  |L18.104|
000068  4288              CMP      r0,r1                 ;195
00006a  d102              BNE      |L18.114|
00006c  4620              MOV      r0,r4                 ;196
00006e  f7fffffe          BL       inc_write_next_idx
                  |L18.114|
000072  b115              CBZ      r5,|L18.122|
000074  f8d40084          LDR      r0,[r4,#0x84]         ;200
000078  6028              STR      r0,[r5,#0]            ;200
                  |L18.122|
00007a  f8d40084          LDR      r0,[r4,#0x84]         ;203
00007e  eb040080          ADD      r0,r4,r0,LSL #2       ;203
000082  6885              LDR      r5,[r0,#8]            ;204
000084  b91e              CBNZ     r6,|L18.142|
000086  f8d400b0          LDR      r0,[r4,#0xb0]         ;204
00008a  f7fffffe          BL       osSemaphoreRelease
                  |L18.142|
00008e  4628              MOV      r0,r5                 ;208
000090  bd70              POP      {r4-r6,pc}
;;;211    
                          ENDP

000092  0000              DCW      0x0000
                  |L18.148|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_notifier_register||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_notifier_register PROC
;;;894    
;;;895    int kdp_fb_mgr_notifier_register(int cam_idx, fb_write_done_notify callback)
000000  4a03              LDR      r2,|L19.16|
;;;896    {
;;;897        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
000002  f8520020          LDR      r0,[r2,r0,LSL #2]
;;;898    
;;;899        fbp->write_done_cb = callback;
;;;900        return 0;
000006  f8c010ac          STR      r1,[r0,#0xac]
00000a  2000              MOVS     r0,#0
;;;901    }
00000c  4770              BX       lr
                          ENDP

00000e  0000              DCW      0x0000
                  |L19.16|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_set_frame_info||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_set_frame_info PROC
;;;440    
;;;441    void kdp_fb_mgr_set_frame_info(int cam_idx, struct frame_info *info)
000000  2802              CMP      r0,#2
;;;442    {
000002  da06              BGE      |L20.18|
;;;443        if (cam_idx >= IMGSRC_NUM)
;;;444            return; 
;;;445            
;;;446        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
000004  4a03              LDR      r2,|L20.20|
000006  f8520020          LDR      r0,[r2,r0,LSL #2]
;;;447    
;;;448        local_irq_disable();
;;;449    
;;;450    #if FB_CTX_ENABLE == YES
;;;451        memcpy(&fbp->fb_ctx[fbp->write_done_idx].info, info, sizeof(struct frame_info));
;;;452    #else
;;;453        memcpy(&fbp->latest_info, info, sizeof(struct frame_info));
00000a  223d              MOVS     r2,#0x3d
00000c  3040              ADDS     r0,r0,#0x40
00000e  f7ffbffe          B.W      __aeabi_memcpy
                  |L20.18|
;;;454    #endif
;;;455    
;;;456        fb_msg("[%s] %d idx:%d\n", __func__, cam_idx, fbp->write_done_idx);
;;;457    
;;;458        local_irq_enable();
;;;459    }
000012  4770              BX       lr
;;;460    #if (FB_TILE_RECODE == YES)
                          ENDP

                  |L20.20|
                          DCD      ||.data||

                          AREA ||i.kdp_fb_mgr_write_done||, CODE, READONLY, ALIGN=2

                  kdp_fb_mgr_write_done PROC
;;;211    
;;;212    int kdp_fb_mgr_write_done(int cam_idx, int write_idx, unsigned char *tile_val) //not used any more
000000  b510              PUSH     {r4,lr}
;;;213    {
;;;214        if (cam_idx >= IMGSRC_NUM)
000002  2802              CMP      r0,#2
000004  da13              BGE      |L21.46|
;;;215            return 0; 
;;;216            
;;;217        struct kdp_fb_mgr_s *fbp = fb_p[cam_idx];
000006  4a0b              LDR      r2,|L21.52|
000008  f8522020          LDR      r2,[r2,r0,LSL #2]
;;;218    
;;;219        local_irq_disable();
;;;220    
;;;221        fb_msg("[%d]%s: %d\n", cam_idx, __func__, write_idx);
;;;222    
;;;223        if (fbp->inf_idx != -1 ) {
;;;224            if (fbp->write_next_idx == fbp->read_idx) {
;;;225                fb_msg("\n [%d]%s: [%d done] w-next:%d == read_idx (prev w-done:%d, inf:%d, inf-done:%d) !\n",
;;;226                    cam_idx, __func__, write_idx, fbp->write_next_idx, fbp->write_done_idx,
;;;227                    fbp->inf_idx, fbp->inf_done_idx);
;;;228            } else if (fbp->write_next_idx == fbp->inf_idx) {
;;;229                fb_msg("\n [%d]%s: [%d done] w-next:%d == inf_idx %d !!\n",
;;;230                    cam_idx, __func__, write_idx, fbp->write_next_idx, fbp->inf_idx);
;;;231            }
;;;232        }
;;;233    
;;;234    
;;;235    #ifdef FB_DEBUG2
;;;236        if (fbp->write_count < 3) {
;;;237            uint32_t *addr0, *addr1, *addr2;
;;;238    #if FB_CTX_ENABLE == YES
;;;239            addr0 = (uint32_t *)fbp->fb_ctx[0].buf_addr + 0x100;
;;;240            addr1 = (uint32_t *)fbp->fb_ctx[1].buf_addr + 0x100;
;;;241            addr2 = (uint32_t *)fbp->fb_ctx[2].buf_addr + 0x100;
;;;242    #else
;;;243            addr0 = (uint32_t *)fbp->buf_addr[0] + 0x100;
;;;244            addr1 = (uint32_t *)fbp->buf_addr[1] + 0x100;
;;;245            addr2 = (uint32_t *)fbp->buf_addr[2] + 0x100;
;;;246    #endif
;;;247    
;;;248            fb_msg("[%d] write-done: %d: [0]=0x%x, [1]=0x%x, [2]=0x%x",
;;;249                cam_idx, write_idx, *addr0, *addr1, *addr2);
;;;250            *addr0 = 1;
;;;251            *addr1 = 2;
;;;252            *addr2 = 4;
;;;253        }
;;;254    #endif
;;;255    
;;;256        /* Mark with sequential number */
;;;257        fbp->write_count++;
;;;258    #if FB_CTX_ENABLE == YES
;;;259        fbp->fb_ctx[write_idx].buf_seq_num = fbp->write_count;
;;;260    #else
;;;261        fbp->buf_seq_num[write_idx] = fbp->write_count;
00000c  eb020481          ADD      r4,r2,r1,LSL #2
000010  f8d2309c          LDR      r3,[r2,#0x9c]         ;257
000014  1c5b              ADDS     r3,r3,#1              ;257
000016  f8c2309c          STR      r3,[r2,#0x9c]
;;;262    #endif
;;;263        fbp->write_done_idx = write_idx;
00001a  6263              STR      r3,[r4,#0x24]
;;;264        fbp->write_idx = fbp->write_next_idx;
00001c  f8c21088          STR      r1,[r2,#0x88]
000020  f8d23084          LDR      r3,[r2,#0x84]
000024  f8423f80          STR      r3,[r2,#0x80]!
;;;265    #if FB_CTX_ENABLE == YES
;;;266        memcpy(fbp->fb_ctx[fbp->write_done_idx].info.tile_val, fbp->latest_info.tile_val, 20);
;;;267    #endif
;;;268        if (fbp->write_done_cb)
000028  6ad2              LDR      r2,[r2,#0x2c]
00002a  b102              CBZ      r2,|L21.46|
;;;269            fbp->write_done_cb(cam_idx, write_idx);
00002c  4790              BLX      r2
                  |L21.46|
;;;270    
;;;271        local_irq_enable();
;;;272    
;;;273        return 0;
00002e  2000              MOVS     r0,#0
;;;274    }
000030  bd10              POP      {r4,pc}
;;;275    
                          ENDP

000032  0000              DCW      0x0000
                  |L21.52|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  kdp_frame_buffer
                          %        360

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __func__
000000  6b64705f          DCB      0x6b,0x64,0x70,0x5f
000004  66625f6d          DCB      0x66,0x62,0x5f,0x6d
000008  67725f62          DCB      0x67,0x72,0x5f,0x62
00000c  75665f61          DCB      0x75,0x66,0x5f,0x61
000010  64647200          DCB      0x64,0x64,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  fb_p
                          DCD      kdp_frame_buffer
                          DCD      kdp_frame_buffer+0xb4

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\scpu\\drivers\\media\\platform\\kdp_fb_mgr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp_fb_mgr_c_5d711ab4____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___12_kdp_fb_mgr_c_5d711ab4____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp_fb_mgr_c_5d711ab4____REVSH|
#line 223
|__asm___12_kdp_fb_mgr_c_5d711ab4____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_kdp_fb_mgr_c_5d711ab4____RRX|
#line 410
|__asm___12_kdp_fb_mgr_c_5d711ab4____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
