; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\rtx_mutex.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\rtx_mutex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\rtx_mutex.crf F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_mutex.c]
                          THUMB

                          AREA ||i.IsException||, CODE, READONLY, ALIGN=1

                  IsException PROC
;;;122    /// \return     true=exception, false=thread
;;;123    __STATIC_INLINE bool_t IsException (void) {
000000  f3ef8005          MRS      r0,IPSR
000004  2800              CMP      r0,#0
000006  d000              BEQ      |L1.10|
;;;124      return (__get_IPSR() != 0U);
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;125    }
00000a  4770              BX       lr
;;;126    
                          ENDP


                          AREA ||i.IsIrqMasked||, CODE, READONLY, ALIGN=1

                  IsIrqMasked PROC
;;;128    /// \return     true=masked, false=not masked
;;;129    __STATIC_INLINE bool_t IsIrqMasked (void) {
000000  f3ef8010          MRS      r0,PRIMASK
000004  b918              CBNZ     r0,|L2.14|
000006  f3ef8011          MRS      r0,BASEPRI
;;;130    #if   ((defined(__ARM_ARCH_7M__)        && (__ARM_ARCH_7M__        != 0)) || \
;;;131           (defined(__ARM_ARCH_7EM__)       && (__ARM_ARCH_7EM__       != 0)) || \
;;;132           (defined(__ARM_ARCH_8M_MAIN__)   && (__ARM_ARCH_8M_MAIN__   != 0)) || \
;;;133           (defined(__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ != 0)))
;;;134      return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L2.16|
                  |L2.14|
00000e  2001              MOVS     r0,#1
                  |L2.16|
;;;135    #else
;;;136      return  (__get_PRIMASK() != 0U);
;;;137    #endif
;;;138    }
000010  4770              BX       lr
;;;139    
                          ENDP


                          AREA ||i.osMutexAcquire||, CODE, READONLY, ALIGN=2

                  osMutexAcquire PROC
;;;519    /// Acquire a Mutex or timeout if it is locked.
;;;520    osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;521      osStatus_t status;
;;;522    
;;;523      EvrRtxMutexAcquire(mutex_id, timeout);
000006  f7fffffe          BL       EvrRtxMutexAcquire
;;;524      if (IsException() || IsIrqMasked()) {
00000a  f7fffffe          BL       IsException
00000e  b910              CBNZ     r0,|L3.22|
000010  f7fffffe          BL       IsIrqMasked
000014  b138              CBZ      r0,|L3.38|
                  |L3.22|
;;;525        EvrRtxMutexError(mutex_id, (int32_t)osErrorISR);
000016  f06f0405          MVN      r4,#5
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       EvrRtxMutexError
;;;526        status = osErrorISR;
000022  4620              MOV      r0,r4
;;;527      } else {
;;;528        status = __svcMutexAcquire(mutex_id, timeout);
;;;529      }
;;;530      return status;
;;;531    }
000024  bd70              POP      {r4-r6,pc}
                  |L3.38|
000026  4628              MOV      r0,r5                 ;528
000028  4621              MOV      r1,r4                 ;528
00002a  f8dfc008          LDR      r12,|L3.52|
00002e  df00              SVC      #0x0                  ;528
000030  bd70              POP      {r4-r6,pc}
;;;532    
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      svcRtxMutexAcquire

                          AREA ||i.osMutexDelete||, CODE, READONLY, ALIGN=2

                  osMutexDelete PROC
;;;560    /// Delete a Mutex object.
;;;561    osStatus_t osMutexDelete (osMutexId_t mutex_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;562      osStatus_t status;
;;;563    
;;;564      EvrRtxMutexDelete(mutex_id);
000004  f7fffffe          BL       EvrRtxMutexDelete
;;;565      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L4.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L4.36|
                  |L4.20|
;;;566        EvrRtxMutexError(mutex_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxMutexError
;;;567        status = osErrorISR;
000020  4628              MOV      r0,r5
;;;568      } else {
;;;569        status = __svcMutexDelete(mutex_id);
;;;570      }
;;;571      return status;
;;;572    }
000022  bd70              POP      {r4-r6,pc}
                  |L4.36|
000024  4620              MOV      r0,r4                 ;569
000026  f8dfc008          LDR      r12,|L4.48|
00002a  df00              SVC      #0x0                  ;569
00002c  bd70              POP      {r4-r6,pc}
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      svcRtxMutexDelete

                          AREA ||i.osMutexGetName||, CODE, READONLY, ALIGN=2

                  osMutexGetName PROC
;;;506    /// Get name of a Mutex object.
;;;507    const char *osMutexGetName (osMutexId_t mutex_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;508      const char *name;
;;;509    
;;;510      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L5.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b128              CBZ      r0,|L5.28|
                  |L5.16|
;;;511        EvrRtxMutexGetName(mutex_id, NULL);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxMutexGetName
;;;512        name = NULL;
000018  2000              MOVS     r0,#0
;;;513      } else {
;;;514        name = __svcMutexGetName(mutex_id);
;;;515      }
;;;516      return name;
;;;517    }
00001a  bd10              POP      {r4,pc}
                  |L5.28|
00001c  4620              MOV      r0,r4                 ;514
00001e  f8dfc008          LDR      r12,|L5.40|
000022  df00              SVC      #0x0                  ;514
000024  bd10              POP      {r4,pc}
;;;518    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      svcRtxMutexGetName

                          AREA ||i.osMutexGetOwner||, CODE, READONLY, ALIGN=2

                  osMutexGetOwner PROC
;;;547    /// Get Thread which owns a Mutex object.
;;;548    osThreadId_t osMutexGetOwner (osMutexId_t mutex_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;549      osThreadId_t thread;
;;;550    
;;;551      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L6.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b128              CBZ      r0,|L6.28|
                  |L6.16|
;;;552        EvrRtxMutexGetOwner(mutex_id, NULL);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxMutexGetOwner
;;;553        thread = NULL;
000018  2000              MOVS     r0,#0
;;;554      } else {
;;;555        thread = __svcMutexGetOwner(mutex_id);
;;;556      }
;;;557      return thread;
;;;558    }
00001a  bd10              POP      {r4,pc}
                  |L6.28|
00001c  4620              MOV      r0,r4                 ;555
00001e  f8dfc008          LDR      r12,|L6.40|
000022  df00              SVC      #0x0                  ;555
000024  bd10              POP      {r4,pc}
;;;559    
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      svcRtxMutexGetOwner

                          AREA ||i.osMutexNew||, CODE, READONLY, ALIGN=2

                  osMutexNew PROC
;;;492    /// Create and Initialize a Mutex object.
;;;493    osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;494      osMutexId_t mutex_id;
;;;495    
;;;496      EvrRtxMutexNew(attr);
000004  f7fffffe          BL       EvrRtxMutexNew
;;;497      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L7.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b130              CBZ      r0,|L7.34|
                  |L7.20|
;;;498        EvrRtxMutexError(NULL, (int32_t)osErrorISR);
000014  f06f0105          MVN      r1,#5
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       EvrRtxMutexError
;;;499        mutex_id = NULL;
00001e  2000              MOVS     r0,#0
;;;500      } else {
;;;501        mutex_id = __svcMutexNew(attr);
;;;502      }
;;;503      return mutex_id;
;;;504    }
000020  bd10              POP      {r4,pc}
                  |L7.34|
000022  4620              MOV      r0,r4                 ;501
000024  f8dfc004          LDR      r12,|L7.44|
000028  df00              SVC      #0x0                  ;501
00002a  bd10              POP      {r4,pc}
;;;505    
                          ENDP

                  |L7.44|
                          DCD      svcRtxMutexNew

                          AREA ||i.osMutexRelease||, CODE, READONLY, ALIGN=2

                  osMutexRelease PROC
;;;533    /// Release a Mutex that was acquired by \ref osMutexAcquire.
;;;534    osStatus_t osMutexRelease (osMutexId_t mutex_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;535      osStatus_t status;
;;;536    
;;;537      EvrRtxMutexRelease(mutex_id);
000004  f7fffffe          BL       EvrRtxMutexRelease
;;;538      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L8.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L8.36|
                  |L8.20|
;;;539        EvrRtxMutexError(mutex_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxMutexError
;;;540        status = osErrorISR;
000020  4628              MOV      r0,r5
;;;541      } else {
;;;542        status = __svcMutexRelease(mutex_id);
;;;543      }
;;;544      return status;
;;;545    }
000022  bd70              POP      {r4-r6,pc}
                  |L8.36|
000024  4620              MOV      r0,r4                 ;542
000026  f8dfc008          LDR      r12,|L8.48|
00002a  df00              SVC      #0x0                  ;542
00002c  bd70              POP      {r4-r6,pc}
;;;546    
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      svcRtxMutexRelease

                          AREA ||i.osRtxMutexOwnerRelease||, CODE, READONLY, ALIGN=1

                  osRtxMutexOwnerRelease PROC
;;;40     /// \param[in]  mutex_list      mutex list.
;;;41     void osRtxMutexOwnerRelease (os_mutex_t *mutex_list) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  2700              MOVS     r7,#0
000008  e021              B        |L9.78|
                  |L9.10|
;;;42       os_mutex_t  *mutex;
;;;43       os_mutex_t  *mutex_next;
;;;44       os_thread_t *thread;
;;;45     
;;;46       mutex = mutex_list;
;;;47       while (mutex != NULL) {
;;;48         mutex_next = mutex->owner_next;
;;;49         // Check if Mutex is Robust
;;;50         if ((mutex->attr & osMutexRobust) != 0U) {
00000a  78e0              LDRB     r0,[r4,#3]
00000c  6966              LDR      r6,[r4,#0x14]
00000e  0700              LSLS     r0,r0,#28
000010  d51c              BPL      |L9.76|
;;;51           // Clear Lock counter
;;;52           mutex->lock = 0U;
000012  7627              STRB     r7,[r4,#0x18]
;;;53           EvrRtxMutexReleased(mutex, 0U);
000014  2100              MOVS     r1,#0
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       EvrRtxMutexReleased
;;;54           // Check if Thread is waiting for a Mutex
;;;55           if (mutex->thread_list != NULL) {
00001c  68a0              LDR      r0,[r4,#8]
00001e  b1a8              CBZ      r0,|L9.76|
;;;56             // Wakeup waiting Thread with highest Priority
;;;57             thread = osRtxThreadListGet(osRtxObject(mutex));
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       osRtxThreadListGet
;;;58             osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
000026  2200              MOVS     r2,#0
000028  4605              MOV      r5,r0                 ;57
00002a  4611              MOV      r1,r2
00002c  f7fffffe          BL       osRtxThreadWaitExit
000030  e9c45703          STRD     r5,r7,[r4,#0xc]
;;;59             // Thread is the new Mutex owner
;;;60             mutex->owner_thread = thread;
;;;61             mutex->owner_prev   = NULL;
;;;62             mutex->owner_next   = thread->mutex_list;
000034  6ae8              LDR      r0,[r5,#0x2c]
;;;63             if (thread->mutex_list != NULL) {
000036  6160              STR      r0,[r4,#0x14]
000038  6ae8              LDR      r0,[r5,#0x2c]
00003a  b100              CBZ      r0,|L9.62|
;;;64               thread->mutex_list->owner_prev = mutex;
00003c  6104              STR      r4,[r0,#0x10]
                  |L9.62|
;;;65             }
;;;66             thread->mutex_list = mutex;
;;;67             mutex->lock = 1U;
00003e  2001              MOVS     r0,#1
000040  62ec              STR      r4,[r5,#0x2c]
000042  7620              STRB     r0,[r4,#0x18]
;;;68             EvrRtxMutexAcquired(mutex, 1U);
000044  4601              MOV      r1,r0
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       EvrRtxMutexAcquired
                  |L9.76|
;;;69           }
;;;70         }
;;;71         mutex = mutex_next;
00004c  4634              MOV      r4,r6
                  |L9.78|
00004e  2c00              CMP      r4,#0                 ;47
000050  d1db              BNE      |L9.10|
;;;72       }
;;;73     }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;74     
                          ENDP


                          AREA ||i.osRtxMutexOwnerRestore||, CODE, READONLY, ALIGN=1

                  osRtxMutexOwnerRestore PROC
;;;77     /// \param[in]  thread_wakeup   thread wakeup object.
;;;78     void osRtxMutexOwnerRestore (const os_mutex_t *mutex, const os_thread_t *thread_wakeup) {
000000  b430              PUSH     {r4,r5}
;;;79       const os_mutex_t  *mutex0;
;;;80             os_thread_t *thread;
;;;81       const os_thread_t *thread0;
;;;82             int8_t       priority;
;;;83     
;;;84       // Restore owner Thread priority
;;;85       if ((mutex->attr & osMutexPrioInherit) != 0U) {
000002  78c2              LDRB     r2,[r0,#3]
000004  0792              LSLS     r2,r2,#30
000006  d51c              BPL      |L10.66|
;;;86         thread   = mutex->owner_thread;
000008  68c0              LDR      r0,[r0,#0xc]
;;;87         priority = thread->priority_base;
00000a  f9902021          LDRSB    r2,[r0,#0x21]
;;;88         mutex0   = thread->mutex_list;
00000e  6ac3              LDR      r3,[r0,#0x2c]
                  |L10.16|
;;;89         // Check Mutexes owned by Thread
;;;90         do {
;;;91           if ((mutex0->attr & osMutexPrioInherit) != 0U) {
000010  78dc              LDRB     r4,[r3,#3]
000012  07a4              LSLS     r4,r4,#30
000014  d509              BPL      |L10.42|
;;;92             // Check Threads waiting for Mutex
;;;93             thread0 = mutex0->thread_list;
;;;94             if (thread0 == thread_wakeup) {
000016  689c              LDR      r4,[r3,#8]
000018  428c              CMP      r4,r1
00001a  d100              BNE      |L10.30|
;;;95               // Skip thread that is waken-up
;;;96               thread0 = thread0->thread_next;
00001c  68a4              LDR      r4,[r4,#8]
                  |L10.30|
;;;97             }
;;;98             if ((thread0 != NULL) && (thread0->priority > priority)) {
00001e  b124              CBZ      r4,|L10.42|
000020  f9944020          LDRSB    r4,[r4,#0x20]
000024  4294              CMP      r4,r2
000026  dd00              BLE      |L10.42|
000028  4622              MOV      r2,r4
                  |L10.42|
;;;99               // Higher priority Thread is waiting for Mutex
;;;100              priority = thread0->priority;
;;;101            }
;;;102          }
;;;103          mutex0 = mutex0->owner_next;
00002a  695b              LDR      r3,[r3,#0x14]
;;;104        } while (mutex0 != NULL);
00002c  2b00              CMP      r3,#0
00002e  d1ef              BNE      |L10.16|
;;;105        if (thread->priority != priority) {
000030  f9901020          LDRSB    r1,[r0,#0x20]
000034  4291              CMP      r1,r2
000036  d004              BEQ      |L10.66|
;;;106          thread->priority = priority;
000038  f8802020          STRB     r2,[r0,#0x20]
;;;107          osRtxThreadListSort(thread);
00003c  bc30              POP      {r4,r5}
00003e  f7ffbffe          B.W      osRtxThreadListSort
                  |L10.66|
;;;108        }
;;;109      }
;;;110    }
000042  bc30              POP      {r4,r5}
000044  4770              BX       lr
;;;111    
                          ENDP


                          AREA ||i.svcRtxMutexAcquire||, CODE, READONLY, ALIGN=2

                  svcRtxMutexAcquire PROC
;;;211    /// \note API identical to osMutexAcquire
;;;212    static osStatus_t svcRtxMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;213      os_mutex_t  *mutex = osRtxMutexId(mutex_id);
000004  4604              MOV      r4,r0
000006  4833              LDR      r0,|L11.212|
000008  460e              MOV      r6,r1                 ;212
00000a  6945              LDR      r5,[r0,#0x14]         ;212  ; osRtxInfo
00000c  b165              CBZ      r5,|L11.40|
;;;214      os_thread_t *thread;
;;;215      osStatus_t   status;
;;;216    
;;;217      // Check running thread
;;;218      thread = osRtxThreadGetRunning();
;;;219      if (thread == NULL) {
;;;220        EvrRtxMutexError(mutex, osRtxErrorKernelNotRunning);
;;;221        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;222        return osError;
;;;223      }
;;;224    
;;;225      // Check parameters
;;;226      if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
00000e  b114              CBZ      r4,|L11.22|
000010  7820              LDRB     r0,[r4,#0]
000012  28f5              CMP      r0,#0xf5
000014  d010              BEQ      |L11.56|
                  |L11.22|
;;;227        EvrRtxMutexError(mutex, (int32_t)osErrorParameter);
000016  f06f0503          MVN      r5,#3
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       EvrRtxMutexError
;;;228        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;229        return osErrorParameter;
000022  4628              MOV      r0,r5
                  |L11.36|
;;;230      }
;;;231    
;;;232      // Check if Mutex is not locked
;;;233      if (mutex->lock == 0U) {
;;;234        // Acquire Mutex
;;;235        mutex->owner_thread = thread;
;;;236        mutex->owner_prev   = NULL;
;;;237        mutex->owner_next   = thread->mutex_list;
;;;238        if (thread->mutex_list != NULL) {
;;;239          thread->mutex_list->owner_prev = mutex;
;;;240        }
;;;241        thread->mutex_list = mutex;
;;;242        mutex->lock = 1U;
;;;243        EvrRtxMutexAcquired(mutex, mutex->lock);
;;;244        status = osOK;
;;;245      } else {
;;;246        // Check if Mutex is recursive and running Thread is the owner
;;;247        if (((mutex->attr & osMutexRecursive) != 0U) && (mutex->owner_thread == thread)) {
;;;248          // Try to increment lock counter
;;;249          if (mutex->lock == osRtxMutexLockLimit) {
;;;250            EvrRtxMutexError(mutex, osRtxErrorMutexLockLimit);
;;;251            status = osErrorResource;
;;;252          } else {
;;;253            mutex->lock++;
;;;254            EvrRtxMutexAcquired(mutex, mutex->lock);
;;;255            status = osOK;
;;;256          }
;;;257        } else {
;;;258          // Check if timeout is specified
;;;259          if (timeout != 0U) {
;;;260            // Check if Priority inheritance protocol is enabled
;;;261            if ((mutex->attr & osMutexPrioInherit) != 0U) {
;;;262              // Raise priority of owner Thread if lower than priority of running Thread
;;;263              if (mutex->owner_thread->priority < thread->priority) {
;;;264                mutex->owner_thread->priority = thread->priority;
;;;265                osRtxThreadListSort(mutex->owner_thread);
;;;266              }
;;;267            }
;;;268            EvrRtxMutexAcquirePending(mutex, timeout);
;;;269            // Suspend current Thread
;;;270            if (osRtxThreadWaitEnter(osRtxThreadWaitingMutex, timeout)) {
;;;271              osRtxThreadListPut(osRtxObject(mutex), thread);
;;;272            } else {
;;;273              EvrRtxMutexAcquireTimeout(mutex);
;;;274            }
;;;275            status = osErrorTimeout;
;;;276          } else {
;;;277            EvrRtxMutexNotAcquired(mutex);
;;;278            status = osErrorResource;
;;;279          }
;;;280        }
;;;281      }
;;;282    
;;;283      return status;
;;;284    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L11.40|
000028  f06f0107          MVN      r1,#7                 ;220
00002c  4620              MOV      r0,r4                 ;220
00002e  f7fffffe          BL       EvrRtxMutexError
000032  f04f30ff          MOV      r0,#0xffffffff        ;222
000036  e7f5              B        |L11.36|
                  |L11.56|
000038  7e20              LDRB     r0,[r4,#0x18]         ;233
00003a  b188              CBZ      r0,|L11.96|
00003c  78e1              LDRB     r1,[r4,#3]            ;247
00003e  f06f0702          MVN      r7,#2                 ;251
000042  07ca              LSLS     r2,r1,#31             ;247
000044  d01d              BEQ      |L11.130|
000046  68e2              LDR      r2,[r4,#0xc]          ;247
000048  42aa              CMP      r2,r5                 ;247
00004a  d11a              BNE      |L11.130|
00004c  28ff              CMP      r0,#0xff              ;249
00004e  d012              BEQ      |L11.118|
000050  1c40              ADDS     r0,r0,#1              ;249
000052  b2c1              UXTB     r1,r0                 ;253
                  |L11.84|
000054  7621              STRB     r1,[r4,#0x18]         ;242
000056  4620              MOV      r0,r4                 ;243
000058  f7fffffe          BL       EvrRtxMutexAcquired
00005c  2000              MOVS     r0,#0                 ;244
00005e  e7e1              B        |L11.36|
                  |L11.96|
000060  2000              MOVS     r0,#0                 ;236
000062  e9c45003          STRD     r5,r0,[r4,#0xc]       ;236
000066  6ae8              LDR      r0,[r5,#0x2c]         ;237
000068  6160              STR      r0,[r4,#0x14]         ;238
00006a  6ae8              LDR      r0,[r5,#0x2c]         ;238
00006c  b100              CBZ      r0,|L11.112|
00006e  6104              STR      r4,[r0,#0x10]         ;239
                  |L11.112|
000070  2101              MOVS     r1,#1                 ;242
000072  62ec              STR      r4,[r5,#0x2c]         ;244
000074  e7ee              B        |L11.84|
                  |L11.118|
000076  f06f010f          MVN      r1,#0xf               ;250
00007a  4620              MOV      r0,r4                 ;250
00007c  f7fffffe          BL       EvrRtxMutexError
000080  e025              B        |L11.206|
                  |L11.130|
000082  b30e              CBZ      r6,|L11.200|
000084  0788              LSLS     r0,r1,#30             ;261
000086  d50b              BPL      |L11.160|
000088  68e0              LDR      r0,[r4,#0xc]          ;263
00008a  f9951020          LDRSB    r1,[r5,#0x20]         ;263
00008e  f9902020          LDRSB    r2,[r0,#0x20]         ;263
000092  428a              CMP      r2,r1                 ;263
000094  da04              BGE      |L11.160|
000096  f8801020          STRB     r1,[r0,#0x20]         ;264
00009a  68e0              LDR      r0,[r4,#0xc]          ;265
00009c  f7fffffe          BL       osRtxThreadListSort
                  |L11.160|
0000a0  4631              MOV      r1,r6                 ;268
0000a2  4620              MOV      r0,r4                 ;268
0000a4  f7fffffe          BL       EvrRtxMutexAcquirePending
0000a8  4631              MOV      r1,r6                 ;270
0000aa  2053              MOVS     r0,#0x53              ;270
0000ac  f7fffffe          BL       osRtxThreadWaitEnter
0000b0  2800              CMP      r0,#0                 ;270
0000b2  4620              MOV      r0,r4                 ;273
0000b4  d003              BEQ      |L11.190|
0000b6  4629              MOV      r1,r5                 ;271
0000b8  f7fffffe          BL       osRtxThreadListPut
0000bc  e001              B        |L11.194|
                  |L11.190|
0000be  f7fffffe          BL       EvrRtxMutexAcquireTimeout
                  |L11.194|
0000c2  f06f0001          MVN      r0,#1                 ;275
0000c6  e7ad              B        |L11.36|
                  |L11.200|
0000c8  4620              MOV      r0,r4                 ;277
0000ca  f7fffffe          BL       EvrRtxMutexNotAcquired
                  |L11.206|
0000ce  4638              MOV      r0,r7                 ;251
0000d0  e7a8              B        |L11.36|
;;;285    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L11.212|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxMutexDelete||, CODE, READONLY, ALIGN=2

                  svcRtxMutexDelete PROC
;;;403    /// \note API identical to osMutexDelete
;;;404    static osStatus_t svcRtxMutexDelete (osMutexId_t mutex_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;405            os_mutex_t  *mutex = osRtxMutexId(mutex_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L12.12|
;;;406      const os_mutex_t  *mutex0;
;;;407            os_thread_t *thread;
;;;408            int8_t       priority;
;;;409    
;;;410      // Check parameters
;;;411      if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f5              CMP      r0,#0xf5
00000a  d007              BEQ      |L12.28|
                  |L12.12|
;;;412        EvrRtxMutexError(mutex, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxMutexError
;;;413        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;414        return osErrorParameter;
000018  4628              MOV      r0,r5
;;;415      }
;;;416    
;;;417      // Check if Mutex is locked
;;;418      if (mutex->lock != 0U) {
;;;419    
;;;420        thread = mutex->owner_thread;
;;;421    
;;;422        // Remove Mutex from Thread owner list
;;;423        if (mutex->owner_next != NULL) {
;;;424          mutex->owner_next->owner_prev = mutex->owner_prev;
;;;425        }
;;;426        if (mutex->owner_prev != NULL) {
;;;427          mutex->owner_prev->owner_next = mutex->owner_next;
;;;428        } else {
;;;429          thread->mutex_list = mutex->owner_next;
;;;430        }
;;;431    
;;;432        // Restore owner Thread priority
;;;433        priority = thread->priority_base;
;;;434        mutex0   = thread->mutex_list;
;;;435        // Check Mutexes owned by Thread
;;;436        while (mutex0 != NULL) {
;;;437          if ((mutex0->attr & osMutexPrioInherit) != 0U) {
;;;438            if ((mutex0->thread_list != NULL) && (mutex0->thread_list->priority > priority)) {
;;;439              // Higher priority Thread is waiting for Mutex
;;;440              priority = mutex0->thread_list->priority;
;;;441            }
;;;442          }
;;;443          mutex0 = mutex0->owner_next;
;;;444        }
;;;445        if (thread->priority != priority) {
;;;446          thread->priority = priority;
;;;447          osRtxThreadListSort(thread);
;;;448        }
;;;449    
;;;450        // Unblock waiting threads
;;;451        while (mutex->thread_list != NULL) {
;;;452          thread = osRtxThreadListGet(osRtxObject(mutex));
;;;453          osRtxThreadWaitExit(thread, (uint32_t)osErrorResource, FALSE);
;;;454        }
;;;455    
;;;456        osRtxThreadDispatch(NULL);
;;;457      }
;;;458    
;;;459      // Mark object as invalid
;;;460      mutex->id = osRtxIdInvalid;
;;;461    
;;;462      // Free object memory
;;;463      if ((mutex->flags & osRtxFlagSystemObject) != 0U) {
;;;464        if (osRtxInfo.mpi.mutex != NULL) {
;;;465          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.mutex, mutex);
;;;466        } else {
;;;467          (void)osRtxMemoryFree(osRtxInfo.mem.common, mutex);
;;;468        }
;;;469    #ifdef RTX_OBJ_MEM_USAGE
;;;470        osRtxMutexMemUsage.cnt_free++;
;;;471    #endif
;;;472      }
;;;473    
;;;474      EvrRtxMutexDestroyed(mutex);
;;;475    
;;;476      return osOK;
;;;477    }
00001a  bd70              POP      {r4-r6,pc}
                  |L12.28|
00001c  7e20              LDRB     r0,[r4,#0x18]         ;418
00001e  b380              CBZ      r0,|L12.130|
000020  6961              LDR      r1,[r4,#0x14]         ;423
000022  68e0              LDR      r0,[r4,#0xc]          ;423
000024  b109              CBZ      r1,|L12.42|
000026  6922              LDR      r2,[r4,#0x10]         ;424
000028  610a              STR      r2,[r1,#0x10]         ;424
                  |L12.42|
00002a  6921              LDR      r1,[r4,#0x10]         ;426
00002c  b111              CBZ      r1,|L12.52|
00002e  6962              LDR      r2,[r4,#0x14]         ;427
000030  614a              STR      r2,[r1,#0x14]         ;427
000032  e001              B        |L12.56|
                  |L12.52|
000034  6961              LDR      r1,[r4,#0x14]         ;429
000036  62c1              STR      r1,[r0,#0x2c]         ;429
                  |L12.56|
000038  f9901021          LDRSB    r1,[r0,#0x21]         ;433
00003c  6ac2              LDR      r2,[r0,#0x2c]         ;436
00003e  e00a              B        |L12.86|
                  |L12.64|
000040  78d3              LDRB     r3,[r2,#3]            ;437
000042  079b              LSLS     r3,r3,#30             ;437
000044  d506              BPL      |L12.84|
000046  6893              LDR      r3,[r2,#8]            ;438
000048  b123              CBZ      r3,|L12.84|
00004a  f9933020          LDRSB    r3,[r3,#0x20]         ;438
00004e  428b              CMP      r3,r1                 ;438
000050  dd00              BLE      |L12.84|
000052  4619              MOV      r1,r3                 ;438
                  |L12.84|
000054  6952              LDR      r2,[r2,#0x14]         ;443
                  |L12.86|
000056  2a00              CMP      r2,#0                 ;436
000058  d1f2              BNE      |L12.64|
00005a  f9902020          LDRSB    r2,[r0,#0x20]         ;445
00005e  428a              CMP      r2,r1                 ;445
000060  d003              BEQ      |L12.106|
000062  f8801020          STRB     r1,[r0,#0x20]         ;446
000066  f7fffffe          BL       osRtxThreadListSort
                  |L12.106|
00006a  f06f0502          MVN      r5,#2                 ;453
                  |L12.110|
00006e  68a0              LDR      r0,[r4,#8]            ;451
000070  b140              CBZ      r0,|L12.132|
000072  4620              MOV      r0,r4                 ;452
000074  f7fffffe          BL       osRtxThreadListGet
000078  2200              MOVS     r2,#0                 ;453
00007a  4629              MOV      r1,r5                 ;453
00007c  f7fffffe          BL       osRtxThreadWaitExit
000080  e7f5              B        |L12.110|
                  |L12.130|
000082  e002              B        |L12.138|
                  |L12.132|
000084  2000              MOVS     r0,#0                 ;456
000086  f7fffffe          BL       osRtxThreadDispatch
                  |L12.138|
00008a  2000              MOVS     r0,#0                 ;460
00008c  7020              STRB     r0,[r4,#0]            ;460
00008e  78a0              LDRB     r0,[r4,#2]            ;463
000090  07c0              LSLS     r0,r0,#31             ;463
000092  d010              BEQ      |L12.182|
000094  490a              LDR      r1,|L12.192|
000096  f8d10094          LDR      r0,[r1,#0x94]         ;464  ; osRtxInfo
00009a  b118              CBZ      r0,|L12.164|
00009c  4621              MOV      r1,r4                 ;465
00009e  f7fffffe          BL       osRtxMemoryPoolFree
0000a2  e004              B        |L12.174|
                  |L12.164|
0000a4  f8d10080          LDR      r0,[r1,#0x80]         ;467  ; osRtxInfo
0000a8  4621              MOV      r1,r4                 ;467
0000aa  f7fffffe          BL       osRtxMemoryFree
                  |L12.174|
0000ae  4805              LDR      r0,|L12.196|
0000b0  6841              LDR      r1,[r0,#4]            ;470  ; osRtxMutexMemUsage
0000b2  1c49              ADDS     r1,r1,#1              ;470
0000b4  6041              STR      r1,[r0,#4]            ;470  ; osRtxMutexMemUsage
                  |L12.182|
0000b6  4620              MOV      r0,r4                 ;474
0000b8  f7fffffe          BL       EvrRtxMutexDestroyed
0000bc  2000              MOVS     r0,#0                 ;476
0000be  bd70              POP      {r4-r6,pc}
;;;478    
                          ENDP

                  |L12.192|
                          DCD      osRtxInfo
                  |L12.196|
                          DCD      ||.data.os.mutex.obj||

                          AREA ||i.svcRtxMutexGetName||, CODE, READONLY, ALIGN=1

                  svcRtxMutexGetName PROC
;;;194    /// \note API identical to osMutexGetName
;;;195    static const char *svcRtxMutexGetName (osMutexId_t mutex_id) {
000000  b510              PUSH     {r4,lr}
;;;196      os_mutex_t *mutex = osRtxMutexId(mutex_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L13.12|
;;;197    
;;;198      // Check parameters
;;;199      if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f5              CMP      r0,#0xf5
00000a  d005              BEQ      |L13.24|
                  |L13.12|
;;;200        EvrRtxMutexGetName(mutex, NULL);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxMutexGetName
;;;201        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;202        return NULL;
000014  2000              MOVS     r0,#0
;;;203      }
;;;204    
;;;205      EvrRtxMutexGetName(mutex, mutex->name);
;;;206    
;;;207      return mutex->name;
;;;208    }
000016  bd10              POP      {r4,pc}
                  |L13.24|
000018  4620              MOV      r0,r4                 ;205
00001a  6861              LDR      r1,[r4,#4]            ;205
00001c  f7fffffe          BL       EvrRtxMutexGetName
000020  6860              LDR      r0,[r4,#4]            ;207
000022  bd10              POP      {r4,pc}
;;;209    
                          ENDP


                          AREA ||i.svcRtxMutexGetOwner||, CODE, READONLY, ALIGN=1

                  svcRtxMutexGetOwner PROC
;;;379    /// \note API identical to osMutexGetOwner
;;;380    static osThreadId_t svcRtxMutexGetOwner (osMutexId_t mutex_id) {
000000  b510              PUSH     {r4,lr}
;;;381      os_mutex_t *mutex = osRtxMutexId(mutex_id);
000002  0004              MOVS     r4,r0
000004  d00a              BEQ      |L14.28|
;;;382    
;;;383      // Check parameters
;;;384      if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f5              CMP      r0,#0xf5
00000a  d107              BNE      |L14.28|
;;;385        EvrRtxMutexGetOwner(mutex, NULL);
;;;386        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;387        return NULL;
;;;388      }
;;;389    
;;;390      // Check if Mutex is not locked
;;;391      if (mutex->lock == 0U) {
00000c  7e20              LDRB     r0,[r4,#0x18]
00000e  b128              CBZ      r0,|L14.28|
;;;392        EvrRtxMutexGetOwner(mutex, NULL);
;;;393        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;394        return NULL;
;;;395      }
;;;396    
;;;397      EvrRtxMutexGetOwner(mutex, mutex->owner_thread);
000010  4620              MOV      r0,r4
000012  68e1              LDR      r1,[r4,#0xc]
000014  f7fffffe          BL       EvrRtxMutexGetOwner
;;;398    
;;;399      return mutex->owner_thread;
000018  68e0              LDR      r0,[r4,#0xc]
;;;400    }
00001a  bd10              POP      {r4,pc}
                  |L14.28|
00001c  2100              MOVS     r1,#0                 ;392
00001e  4620              MOV      r0,r4                 ;392
000020  f7fffffe          BL       EvrRtxMutexGetOwner
000024  2000              MOVS     r0,#0                 ;394
000026  bd10              POP      {r4,pc}
;;;401    
                          ENDP


                          AREA ||i.svcRtxMutexNew||, CODE, READONLY, ALIGN=2

                  svcRtxMutexNew PROC
;;;116    /// \note API identical to osMutexNew
;;;117    static osMutexId_t svcRtxMutexNew (const osMutexAttr_t *attr) {
000000  b570              PUSH     {r4-r6,lr}
000002  b190              CBZ      r0,|L15.42|
;;;118      os_mutex_t *mutex;
;;;119      uint32_t    attr_bits;
;;;120      uint8_t     flags;
;;;121      const char *name;
;;;122    
;;;123      // Process attributes
;;;124      if (attr != NULL) {
;;;125        name      = attr->name;
;;;126        attr_bits = attr->attr_bits;
;;;127        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
;;;128        mutex     = attr->cb_mem;
;;;129        if (mutex != NULL) {
;;;130          //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
;;;131          if ((((uint32_t)mutex & 3U) != 0U) || (attr->cb_size < sizeof(os_mutex_t))) {
;;;132            EvrRtxMutexError(NULL, osRtxErrorInvalidControlBlock);
000004  e9d06401          LDRD     r6,r4,[r0,#4]
000008  6805              LDR      r5,[r0,#0]            ;129
00000a  f06f0108          MVN      r1,#8
00000e  b12c              CBZ      r4,|L15.28|
000010  07a2              LSLS     r2,r4,#30             ;131
000012  d105              BNE      |L15.32|
000014  68c0              LDR      r0,[r0,#0xc]          ;131
000016  281c              CMP      r0,#0x1c              ;131
000018  d302              BCC      |L15.32|
00001a  e029              B        |L15.112|
                  |L15.28|
;;;133            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;134            return NULL;
;;;135          }
;;;136        } else {
;;;137          if (attr->cb_size != 0U) {
00001c  68c0              LDR      r0,[r0,#0xc]
00001e  b130              CBZ      r0,|L15.46|
                  |L15.32|
;;;138            EvrRtxMutexError(NULL, osRtxErrorInvalidControlBlock);
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       EvrRtxMutexError
;;;139            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;140            return NULL;
000026  2000              MOVS     r0,#0
;;;141          }
;;;142        }
;;;143      } else {
;;;144        name      = NULL;
;;;145        attr_bits = 0U;
;;;146        mutex     = NULL;
;;;147      }
;;;148    
;;;149      // Allocate object memory if not provided
;;;150      if (mutex == NULL) {
;;;151        if (osRtxInfo.mpi.mutex != NULL) {
;;;152          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;153          mutex = osRtxMemoryPoolAlloc(osRtxInfo.mpi.mutex);
;;;154        } else {
;;;155          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;156          mutex = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_mutex_t), 1U);
;;;157        }
;;;158    #ifdef RTX_OBJ_MEM_USAGE
;;;159        if (mutex != NULL) {
;;;160          uint32_t used;
;;;161          osRtxMutexMemUsage.cnt_alloc++;
;;;162          used = osRtxMutexMemUsage.cnt_alloc - osRtxMutexMemUsage.cnt_free;
;;;163          if (osRtxMutexMemUsage.max_used < used) {
;;;164            osRtxMutexMemUsage.max_used = used;
;;;165          }
;;;166        }
;;;167    #endif
;;;168        flags = osRtxFlagSystemObject;
;;;169      } else {
;;;170        flags = 0U;
;;;171      }
;;;172    
;;;173      if (mutex != NULL) {
;;;174        // Initialize control block
;;;175        mutex->id           = osRtxIdMutex;
;;;176        mutex->flags        = flags;
;;;177        mutex->attr         = (uint8_t)attr_bits;
;;;178        mutex->name         = name;
;;;179        mutex->thread_list  = NULL;
;;;180        mutex->owner_thread = NULL;
;;;181        mutex->owner_prev   = NULL;
;;;182        mutex->owner_next   = NULL;
;;;183        mutex->lock         = 0U;
;;;184    
;;;185        EvrRtxMutexCreated(mutex, mutex->name);
;;;186      } else {
;;;187        EvrRtxMutexError(NULL, (int32_t)osErrorNoMemory);
;;;188      }
;;;189    
;;;190      return mutex;
;;;191    }
000028  bd70              POP      {r4-r6,pc}
                  |L15.42|
00002a  2500              MOVS     r5,#0                 ;144
00002c  462e              MOV      r6,r5                 ;145
                  |L15.46|
00002e  4919              LDR      r1,|L15.148|
000030  f8d10094          LDR      r0,[r1,#0x94]         ;151  ; osRtxInfo
000034  b110              CBZ      r0,|L15.60|
000036  f7fffffe          BL       osRtxMemoryPoolAlloc
00003a  e005              B        |L15.72|
                  |L15.60|
00003c  f8d10080          LDR      r0,[r1,#0x80]         ;156  ; osRtxInfo
000040  2201              MOVS     r2,#1                 ;156
000042  211c              MOVS     r1,#0x1c              ;156
000044  f7fffffe          BL       osRtxMemoryAlloc
                  |L15.72|
000048  0004              MOVS     r4,r0                 ;156
00004a  d00b              BEQ      |L15.100|
00004c  4812              LDR      r0,|L15.152|
00004e  6801              LDR      r1,[r0,#0]            ;161  ; osRtxMutexMemUsage
000050  1c49              ADDS     r1,r1,#1              ;161
000052  6001              STR      r1,[r0,#0]            ;162  ; osRtxMutexMemUsage
000054  6842              LDR      r2,[r0,#4]            ;162  ; osRtxMutexMemUsage
000056  1a89              SUBS     r1,r1,r2              ;162
000058  6882              LDR      r2,[r0,#8]            ;163  ; osRtxMutexMemUsage
00005a  428a              CMP      r2,r1                 ;163
00005c  d200              BCS      |L15.96|
00005e  6081              STR      r1,[r0,#8]            ;164  ; osRtxMutexMemUsage
                  |L15.96|
000060  2001              MOVS     r0,#1                 ;168
000062  e006              B        |L15.114|
                  |L15.100|
000064  f06f0104          MVN      r1,#4                 ;187
000068  2000              MOVS     r0,#0                 ;187
00006a  f7fffffe          BL       EvrRtxMutexError
00006e  e00f              B        |L15.144|
                  |L15.112|
000070  2000              MOVS     r0,#0                 ;170
                  |L15.114|
000072  21f5              MOVS     r1,#0xf5              ;175
000074  7021              STRB     r1,[r4,#0]            ;175
000076  70a0              STRB     r0,[r4,#2]            ;176
000078  70e6              STRB     r6,[r4,#3]            ;177
00007a  2000              MOVS     r0,#0                 ;179
00007c  e9c45001          STRD     r5,r0,[r4,#4]         ;179
000080  60e0              STR      r0,[r4,#0xc]          ;181
000082  6120              STR      r0,[r4,#0x10]         ;182
000084  6160              STR      r0,[r4,#0x14]         ;183
000086  7620              STRB     r0,[r4,#0x18]         ;183
000088  4629              MOV      r1,r5                 ;178
00008a  4620              MOV      r0,r4                 ;185
00008c  f7fffffe          BL       EvrRtxMutexCreated
                  |L15.144|
000090  4620              MOV      r0,r4                 ;190
000092  bd70              POP      {r4-r6,pc}
;;;192    
                          ENDP

                  |L15.148|
                          DCD      osRtxInfo
                  |L15.152|
                          DCD      ||.data.os.mutex.obj||

                          AREA ||i.svcRtxMutexRelease||, CODE, READONLY, ALIGN=2

                  svcRtxMutexRelease PROC
;;;287    /// \note API identical to osMutexRelease
;;;288    static osStatus_t svcRtxMutexRelease (osMutexId_t mutex_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;289            os_mutex_t  *mutex = osRtxMutexId(mutex_id);
000002  4604              MOV      r4,r0
000004  4835              LDR      r0,|L16.220|
000006  6945              LDR      r5,[r0,#0x14]         ;288  ; osRtxInfo
000008  b15d              CBZ      r5,|L16.34|
;;;290      const os_mutex_t  *mutex0;
;;;291            os_thread_t *thread;
;;;292            int8_t       priority;
;;;293    
;;;294      // Check running thread
;;;295      thread = osRtxThreadGetRunning();
;;;296      if (thread == NULL) {
;;;297        EvrRtxMutexError(mutex, osRtxErrorKernelNotRunning);
;;;298        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;299        return osError;
;;;300      }
;;;301    
;;;302      // Check parameters
;;;303      if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
00000a  b114              CBZ      r4,|L16.18|
00000c  7820              LDRB     r0,[r4,#0]
00000e  28f5              CMP      r0,#0xf5
000010  d00f              BEQ      |L16.50|
                  |L16.18|
;;;304        EvrRtxMutexError(mutex, (int32_t)osErrorParameter);
000012  f06f0503          MVN      r5,#3
000016  4629              MOV      r1,r5
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       EvrRtxMutexError
;;;305        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;306        return osErrorParameter;
00001e  4628              MOV      r0,r5
;;;307      }
;;;308    
;;;309      // Check if Mutex is not locked
;;;310      if (mutex->lock == 0U) {
;;;311        EvrRtxMutexError(mutex, osRtxErrorMutexNotLocked);
;;;312        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;313        return osErrorResource;
;;;314      }
;;;315    
;;;316      // Check if running Thread is not the owner
;;;317      if (mutex->owner_thread != thread) {
;;;318        EvrRtxMutexError(mutex, osRtxErrorMutexNotOwned);
;;;319        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;320        return osErrorResource;
;;;321      }
;;;322    
;;;323      // Decrement Lock counter
;;;324      mutex->lock--;
;;;325      EvrRtxMutexReleased(mutex, mutex->lock);
;;;326    
;;;327      // Check Lock counter
;;;328      if (mutex->lock == 0U) {
;;;329    
;;;330        // Remove Mutex from Thread owner list
;;;331        if (mutex->owner_next != NULL) {
;;;332          mutex->owner_next->owner_prev = mutex->owner_prev;
;;;333        }
;;;334        if (mutex->owner_prev != NULL) {
;;;335          mutex->owner_prev->owner_next = mutex->owner_next;
;;;336        } else {
;;;337          thread->mutex_list = mutex->owner_next;
;;;338        }
;;;339    
;;;340        // Restore running Thread priority
;;;341        priority = thread->priority_base;
;;;342        mutex0   = thread->mutex_list;
;;;343        // Check mutexes owned by running Thread
;;;344        while (mutex0 != NULL) {
;;;345          if ((mutex0->attr & osMutexPrioInherit) != 0U) {
;;;346            if ((mutex0->thread_list != NULL) && (mutex0->thread_list->priority > priority)) {
;;;347              // Higher priority Thread is waiting for Mutex
;;;348              priority = mutex0->thread_list->priority;
;;;349            }
;;;350          }
;;;351          mutex0 = mutex0->owner_next;
;;;352        }
;;;353        thread->priority = priority;
;;;354    
;;;355        // Check if Thread is waiting for a Mutex
;;;356        if (mutex->thread_list != NULL) {
;;;357          // Wakeup waiting Thread with highest Priority
;;;358          thread = osRtxThreadListGet(osRtxObject(mutex));
;;;359          osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
;;;360          // Thread is the new Mutex owner
;;;361          mutex->owner_thread = thread;
;;;362          mutex->owner_prev   = NULL;
;;;363          mutex->owner_next   = thread->mutex_list;
;;;364          if (thread->mutex_list != NULL) {
;;;365            thread->mutex_list->owner_prev = mutex;
;;;366          }
;;;367          thread->mutex_list = mutex;
;;;368          mutex->lock = 1U;
;;;369          EvrRtxMutexAcquired(mutex, 1U);
;;;370        }
;;;371    
;;;372        osRtxThreadDispatch(NULL);
;;;373      }
;;;374    
;;;375      return osOK;
;;;376    }
000020  bd70              POP      {r4-r6,pc}
                  |L16.34|
000022  f06f0107          MVN      r1,#7                 ;297
000026  4620              MOV      r0,r4                 ;297
000028  f7fffffe          BL       EvrRtxMutexError
00002c  f04f30ff          MOV      r0,#0xffffffff        ;299
000030  bd70              POP      {r4-r6,pc}
                  |L16.50|
000032  7e20              LDRB     r0,[r4,#0x18]         ;310
000034  f06f0602          MVN      r6,#2                 ;313
000038  b148              CBZ      r0,|L16.78|
00003a  68e1              LDR      r1,[r4,#0xc]          ;317
00003c  42a9              CMP      r1,r5                 ;317
00003e  d009              BEQ      |L16.84|
000040  f06f010d          MVN      r1,#0xd               ;318
                  |L16.68|
000044  4620              MOV      r0,r4                 ;318
000046  f7fffffe          BL       EvrRtxMutexError
00004a  4630              MOV      r0,r6                 ;320
00004c  bd70              POP      {r4-r6,pc}
                  |L16.78|
00004e  f06f010e          MVN      r1,#0xe               ;311
000052  e7f7              B        |L16.68|
                  |L16.84|
000054  1e40              SUBS     r0,r0,#1              ;313
000056  b2c1              UXTB     r1,r0                 ;324
000058  7621              STRB     r1,[r4,#0x18]         ;324
00005a  4620              MOV      r0,r4                 ;325
00005c  f7fffffe          BL       EvrRtxMutexReleased
000060  7e20              LDRB     r0,[r4,#0x18]         ;328
000062  bbc8              CBNZ     r0,|L16.216|
000064  6960              LDR      r0,[r4,#0x14]         ;331
000066  b108              CBZ      r0,|L16.108|
000068  6921              LDR      r1,[r4,#0x10]         ;332
00006a  6101              STR      r1,[r0,#0x10]         ;332
                  |L16.108|
00006c  6920              LDR      r0,[r4,#0x10]         ;334
00006e  b110              CBZ      r0,|L16.118|
000070  6961              LDR      r1,[r4,#0x14]         ;335
000072  6141              STR      r1,[r0,#0x14]         ;335
000074  e001              B        |L16.122|
                  |L16.118|
000076  6960              LDR      r0,[r4,#0x14]         ;337
000078  62e8              STR      r0,[r5,#0x2c]         ;337
                  |L16.122|
00007a  f9951021          LDRSB    r1,[r5,#0x21]         ;341
00007e  6ae8              LDR      r0,[r5,#0x2c]         ;344
000080  e00a              B        |L16.152|
                  |L16.130|
000082  78c2              LDRB     r2,[r0,#3]            ;345
000084  0792              LSLS     r2,r2,#30             ;345
000086  d506              BPL      |L16.150|
000088  6882              LDR      r2,[r0,#8]            ;346
00008a  b122              CBZ      r2,|L16.150|
00008c  f9922020          LDRSB    r2,[r2,#0x20]         ;346
000090  428a              CMP      r2,r1                 ;346
000092  dd00              BLE      |L16.150|
000094  4611              MOV      r1,r2                 ;346
                  |L16.150|
000096  6940              LDR      r0,[r0,#0x14]         ;351
                  |L16.152|
000098  2800              CMP      r0,#0                 ;344
00009a  d1f2              BNE      |L16.130|
00009c  f8851020          STRB     r1,[r5,#0x20]         ;353
0000a0  68a0              LDR      r0,[r4,#8]            ;356
0000a2  b1b0              CBZ      r0,|L16.210|
0000a4  4620              MOV      r0,r4                 ;358
0000a6  f7fffffe          BL       osRtxThreadListGet
0000aa  2200              MOVS     r2,#0                 ;359
0000ac  4605              MOV      r5,r0                 ;358
0000ae  4611              MOV      r1,r2                 ;359
0000b0  f7fffffe          BL       osRtxThreadWaitExit
0000b4  2000              MOVS     r0,#0                 ;362
0000b6  e9c45003          STRD     r5,r0,[r4,#0xc]       ;362
0000ba  6ae8              LDR      r0,[r5,#0x2c]         ;363
0000bc  6160              STR      r0,[r4,#0x14]         ;364
0000be  6ae8              LDR      r0,[r5,#0x2c]         ;364
0000c0  b100              CBZ      r0,|L16.196|
0000c2  6104              STR      r4,[r0,#0x10]         ;365
                  |L16.196|
0000c4  2001              MOVS     r0,#1                 ;368
0000c6  62ec              STR      r4,[r5,#0x2c]         ;368
0000c8  7620              STRB     r0,[r4,#0x18]         ;368
0000ca  4601              MOV      r1,r0                 ;369
0000cc  4620              MOV      r0,r4                 ;369
0000ce  f7fffffe          BL       EvrRtxMutexAcquired
                  |L16.210|
0000d2  2000              MOVS     r0,#0                 ;372
0000d4  f7fffffe          BL       osRtxThreadDispatch
                  |L16.216|
0000d8  2000              MOVS     r0,#0                 ;375
0000da  bd70              POP      {r4-r6,pc}
;;;377    
                          ENDP

                  |L16.220|
                          DCD      osRtxInfo

                          AREA ||.data.os.mutex.obj||, DATA, ALIGN=2

                  osRtxMutexMemUsage
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_mutex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___11_rtx_mutex_c_271c6f13____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13____REVSH|
#line 223
|__asm___11_rtx_mutex_c_271c6f13____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13____RRX|
#line 410
|__asm___11_rtx_mutex_c_271c6f13____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_wr8|
#line 464 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_core_cm.h"
|__asm___11_rtx_mutex_c_271c6f13__atomic_wr8| PROC
#line 464

 mov r2,r0
1
 ldrexb r0,[r2]
 strexb r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_set32|
#line 511
|__asm___11_rtx_mutex_c_271c6f13__atomic_set32| PROC
#line 511

 mov r2,r0
1
 ldrex r0,[r2]
 orr r0,r0,r1
 strex r3,r0,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_clr32|
#line 570
|__asm___11_rtx_mutex_c_271c6f13__atomic_clr32| PROC
#line 570

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F2
 b %B1
2
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_chk32_all|
#line 630
|__asm___11_rtx_mutex_c_271c6f13__atomic_chk32_all| PROC
#line 630

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 and r4,r0,r1
 cmp r4,r1
 beq %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_chk32_any|
#line 705
|__asm___11_rtx_mutex_c_271c6f13__atomic_chk32_any| PROC
#line 705

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 tst r0,r1
 bne %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_inc32|
#line 772
|__asm___11_rtx_mutex_c_271c6f13__atomic_inc32| PROC
#line 772

 mov r2,r0
1
 ldrex r0,[r2]
 adds r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_inc16_lt|
#line 821
|__asm___11_rtx_mutex_c_271c6f13__atomic_inc16_lt| PROC
#line 821

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 cmp r1,r0
 bhi %F2
 clrex
 pop {r4,pc}
2
 adds r4,r0,#1
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_inc16_lim|
#line 882
|__asm___11_rtx_mutex_c_271c6f13__atomic_inc16_lim| PROC
#line 882

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 adds r4,r0,#1
 cmp r1,r4
 bhi %F2
 movs r4,#0
2
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_dec32|
#line 940
|__asm___11_rtx_mutex_c_271c6f13__atomic_dec32| PROC
#line 940

 mov r2,r0
1
 ldrex r0,[r2]
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_dec32_nz|
#line 988
|__asm___11_rtx_mutex_c_271c6f13__atomic_dec32_nz| PROC
#line 988

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_dec16_nz|
#line 1044
|__asm___11_rtx_mutex_c_271c6f13__atomic_dec16_nz| PROC
#line 1044

 mov r2,r0
1
 ldrexh r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strexh r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_link_get|
#line 1100
|__asm___11_rtx_mutex_c_271c6f13__atomic_link_get| PROC
#line 1100

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 ldr r1,[r0]
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_mutex_c_271c6f13__atomic_link_put|
#line 1156
|__asm___11_rtx_mutex_c_271c6f13__atomic_link_put| PROC
#line 1156

1
 ldr r2,[r0]
 str r2,[r1]
 dmb
 ldrex r2,[r0]
 ldr r3,[r1]
 cmp r3,r2
 bne %B1
 strex r3,r1,[r0]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP

;*** End   embedded assembler ***
