; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\rtx_thread.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\rtx_thread.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\rtx_thread.crf F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_thread.c]
                          THUMB

                          AREA ||i.IsException||, CODE, READONLY, ALIGN=1

                  IsException PROC
;;;122    /// \return     true=exception, false=thread
;;;123    __STATIC_INLINE bool_t IsException (void) {
000000  f3ef8005          MRS      r0,IPSR
000004  2800              CMP      r0,#0
000006  d000              BEQ      |L1.10|
;;;124      return (__get_IPSR() != 0U);
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;125    }
00000a  4770              BX       lr
;;;126    
                          ENDP


                          AREA ||i.IsIrqMasked||, CODE, READONLY, ALIGN=1

                  IsIrqMasked PROC
;;;128    /// \return     true=masked, false=not masked
;;;129    __STATIC_INLINE bool_t IsIrqMasked (void) {
000000  f3ef8010          MRS      r0,PRIMASK
000004  b918              CBNZ     r0,|L2.14|
000006  f3ef8011          MRS      r0,BASEPRI
;;;130    #if   ((defined(__ARM_ARCH_7M__)        && (__ARM_ARCH_7M__        != 0)) || \
;;;131           (defined(__ARM_ARCH_7EM__)       && (__ARM_ARCH_7EM__       != 0)) || \
;;;132           (defined(__ARM_ARCH_8M_MAIN__)   && (__ARM_ARCH_8M_MAIN__   != 0)) || \
;;;133           (defined(__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ != 0)))
;;;134      return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L2.16|
                  |L2.14|
00000e  2001              MOVS     r0,#1
                  |L2.16|
;;;135    #else
;;;136      return  (__get_PRIMASK() != 0U);
;;;137    #endif
;;;138    }
000010  4770              BX       lr
;;;139    
                          ENDP


                          AREA ||i.ThreadFlagsCheck||, CODE, READONLY, ALIGN=1

                  ThreadFlagsCheck PROC
;;;95     /// \return thread flags before clearing or 0 if specified flags have not been set.
;;;96     static uint32_t ThreadFlagsCheck (os_thread_t *thread, uint32_t flags, uint32_t options) {
000000  0793              LSLS     r3,r2,#30
000002  d407              BMI      |L3.20|
;;;97     #if (EXCLUSIVE_ACCESS == 0)
;;;98       uint32_t primask;
;;;99     #endif
;;;100      uint32_t thread_flags;
;;;101    
;;;102      if ((options & osFlagsNoClear) == 0U) {
;;;103    #if (EXCLUSIVE_ACCESS == 0)
;;;104        primask = __get_PRIMASK();
;;;105        __disable_irq();
;;;106    
;;;107        thread_flags = thread->thread_flags;
;;;108        if ((((options & osFlagsWaitAll) != 0U) && ((thread_flags & flags) != flags)) ||
;;;109            (((options & osFlagsWaitAll) == 0U) && ((thread_flags & flags) == 0U))) {
;;;110          thread_flags = 0U;
;;;111        } else {
;;;112          thread->thread_flags &= ~flags;
;;;113        }
;;;114    
;;;115        if (primask == 0U) {
;;;116          __enable_irq();
;;;117        }
;;;118    #else
;;;119        if ((options & osFlagsWaitAll) != 0U) {
000004  07d2              LSLS     r2,r2,#31
000006  f1000028          ADD      r0,r0,#0x28
00000a  d001              BEQ      |L3.16|
;;;120          thread_flags = atomic_chk32_all(&thread->thread_flags, flags);
00000c  f7ffbffe          B.W      __asm___12_rtx_thread_c_3927f09d__atomic_chk32_all
                  |L3.16|
;;;121        } else {
;;;122          thread_flags = atomic_chk32_any(&thread->thread_flags, flags);
000010  f7ffbffe          B.W      __asm___12_rtx_thread_c_3927f09d__atomic_chk32_any
                  |L3.20|
;;;123        }
;;;124    #endif
;;;125      } else {
;;;126        thread_flags = thread->thread_flags;
000014  6a80              LDR      r0,[r0,#0x28]
;;;127        if ((((options & osFlagsWaitAll) != 0U) && ((thread_flags & flags) != flags)) ||
000016  07d3              LSLS     r3,r2,#31
000018  d002              BEQ      |L3.32|
00001a  ea310300          BICS     r3,r1,r0
00001e  d104              BNE      |L3.42|
                  |L3.32|
;;;128            (((options & osFlagsWaitAll) == 0U) && ((thread_flags & flags) == 0U))) {
000020  f0020201          AND      r2,r2,#1
000024  4001              ANDS     r1,r1,r0
000026  430a              ORRS     r2,r2,r1
000028  d100              BNE      |L3.44|
                  |L3.42|
;;;129          thread_flags = 0U;
00002a  2000              MOVS     r0,#0
                  |L3.44|
;;;130        }
;;;131      }
;;;132    
;;;133      return thread_flags;
;;;134    }
00002c  4770              BX       lr
;;;135    
                          ENDP


                          AREA ||i.ThreadFlagsSet||, CODE, READONLY, ALIGN=1

                  ThreadFlagsSet PROC
;;;42     /// \return thread flags after setting.
;;;43     static uint32_t ThreadFlagsSet (os_thread_t *thread, uint32_t flags) {
000000  3028              ADDS     r0,r0,#0x28
;;;44     #if (EXCLUSIVE_ACCESS == 0)
;;;45       uint32_t primask = __get_PRIMASK();
;;;46     #endif
;;;47       uint32_t thread_flags;
;;;48     
;;;49     #if (EXCLUSIVE_ACCESS == 0)
;;;50       __disable_irq();
;;;51     
;;;52       thread->thread_flags |= flags;
;;;53       thread_flags = thread->thread_flags;
;;;54     
;;;55       if (primask == 0U) {
;;;56         __enable_irq();
;;;57       }
;;;58     #else
;;;59       thread_flags = atomic_set32(&thread->thread_flags, flags);
000002  f7ffbffe          B.W      __asm___12_rtx_thread_c_3927f09d__atomic_set32
;;;60     #endif
;;;61     
;;;62       return thread_flags;
;;;63     }
;;;64     
                          ENDP


                          AREA ||i.osRtxThreadBlock||, CODE, READONLY, ALIGN=2

                  osRtxThreadBlock PROC
;;;387    /// \param[in]  thread          running thread object.
;;;388    static void osRtxThreadBlock (os_thread_t *thread) {
000000  b430              PUSH     {r4,r5}
;;;389      os_thread_t *prev, *next;
;;;390      int32_t      priority;
;;;391    
;;;392      thread->state = osRtxThreadReady;
000002  2101              MOVS     r1,#1
;;;393    
;;;394      priority = thread->priority;
;;;395    
;;;396      prev = osRtxThreadObject(&osRtxInfo.thread.ready);
000004  4a0a              LDR      r2,|L5.48|
000006  7041              STRB     r1,[r0,#1]            ;392
000008  f9903020          LDRSB    r3,[r0,#0x20]         ;394
;;;397      next = prev->thread_next;
00000c  6a51              LDR      r1,[r2,#0x24]
00000e  321c              ADDS     r2,r2,#0x1c
000010  e001              B        |L5.22|
                  |L5.18|
;;;398    
;;;399      while ((next != NULL) && (next->priority > priority)) {
;;;400        prev = next;
000012  460a              MOV      r2,r1
;;;401        next = next->thread_next;
000014  6889              LDR      r1,[r1,#8]
                  |L5.22|
000016  b119              CBZ      r1,|L5.32|
000018  f9914020          LDRSB    r4,[r1,#0x20]         ;399
00001c  429c              CMP      r4,r3                 ;399
00001e  dcf8              BGT      |L5.18|
                  |L5.32|
000020  e9c01202          STRD     r1,r2,[r0,#8]         ;399
;;;402      }
;;;403      thread->thread_prev = prev;
;;;404      thread->thread_next = next;
;;;405      prev->thread_next = thread;
;;;406      if (next != NULL) {
000024  6090              STR      r0,[r2,#8]
000026  b101              CBZ      r1,|L5.42|
;;;407        next->thread_prev = thread;
000028  60c8              STR      r0,[r1,#0xc]
                  |L5.42|
;;;408      }
;;;409    
;;;410      EvrRtxThreadPreempted(thread);
00002a  bc30              POP      {r4,r5}
00002c  f7ffbffe          B.W      EvrRtxThreadPreempted
;;;411    }
;;;412    
                          ENDP

                  |L5.48|
                          DCD      osRtxInfo

                          AREA ||i.osRtxThreadDelayInsert||, CODE, READONLY, ALIGN=2

                  osRtxThreadDelayInsert PROC
;;;248    /// \param[in]  delay           delay value.
;;;249    static void osRtxThreadDelayInsert (os_thread_t *thread, uint32_t delay) {
000000  b530              PUSH     {r4,r5,lr}
;;;250      os_thread_t *prev, *next;
;;;251    
;;;252      if (delay == osWaitForever) {
;;;253        prev = NULL;
;;;254        next = osRtxInfo.thread.wait_list;
000002  4c15              LDR      r4,|L6.88|
000004  1c4a              ADDS     r2,r1,#1              ;252
000006  d002              BEQ      |L6.14|
;;;255        while (next != NULL)  {
;;;256          prev = next;
;;;257          next = next->delay_next;
;;;258        }
;;;259        thread->delay = delay;
;;;260        thread->delay_prev = prev;
;;;261        thread->delay_next = NULL;
;;;262        if (prev != NULL) {
;;;263          prev->delay_next = thread;
;;;264        } else {
;;;265          osRtxInfo.thread.wait_list = thread;
;;;266        }
;;;267      } else {
;;;268        prev = NULL;
000008  2300              MOVS     r3,#0
;;;269        next = osRtxInfo.thread.delay_list;
;;;270        while ((next != NULL) && (next->delay <= delay)) {
00000a  6ae2              LDR      r2,[r4,#0x2c]  ; osRtxInfo
00000c  e012              B        |L6.52|
                  |L6.14|
00000e  2200              MOVS     r2,#0                 ;253
000010  6b23              LDR      r3,[r4,#0x30]         ;255  ; osRtxInfo
000012  e001              B        |L6.24|
                  |L6.20|
000014  461a              MOV      r2,r3                 ;256
000016  691b              LDR      r3,[r3,#0x10]         ;257
                  |L6.24|
000018  2b00              CMP      r3,#0                 ;255
00001a  d1fb              BNE      |L6.20|
00001c  61c1              STR      r1,[r0,#0x1c]         ;261
00001e  2100              MOVS     r1,#0                 ;261
000020  e9c01204          STRD     r1,r2,[r0,#0x10]      ;261
000024  b10a              CBZ      r2,|L6.42|
000026  6110              STR      r0,[r2,#0x10]         ;263
;;;271          delay -= next->delay;
;;;272          prev = next;
;;;273          next = next->delay_next;
;;;274        }
;;;275        thread->delay = delay;
;;;276        thread->delay_prev = prev;
;;;277        thread->delay_next = next;
;;;278        if (prev != NULL) {
;;;279          prev->delay_next = thread;
;;;280        } else {
;;;281          osRtxInfo.thread.delay_list = thread;
;;;282        }
;;;283        if (next != NULL) {
;;;284          next->delay -= delay;
;;;285          next->delay_prev = thread;
;;;286        }
;;;287      }
;;;288    }
000028  bd30              POP      {r4,r5,pc}
                  |L6.42|
00002a  6320              STR      r0,[r4,#0x30]         ;265  ; osRtxInfo
                  |L6.44|
00002c  bd30              POP      {r4,r5,pc}
                  |L6.46|
00002e  4613              MOV      r3,r2                 ;272
000030  6912              LDR      r2,[r2,#0x10]         ;273
000032  1b49              SUBS     r1,r1,r5              ;271
                  |L6.52|
000034  b112              CBZ      r2,|L6.60|
000036  69d5              LDR      r5,[r2,#0x1c]         ;270
000038  428d              CMP      r5,r1                 ;270
00003a  d9f8              BLS      |L6.46|
                  |L6.60|
00003c  61c1              STR      r1,[r0,#0x1c]         ;275
00003e  e9c02304          STRD     r2,r3,[r0,#0x10]      ;275
000042  b10b              CBZ      r3,|L6.72|
000044  6118              STR      r0,[r3,#0x10]         ;279
000046  e000              B        |L6.74|
                  |L6.72|
000048  62e0              STR      r0,[r4,#0x2c]         ;281  ; osRtxInfo
                  |L6.74|
00004a  2a00              CMP      r2,#0                 ;283
00004c  d0ee              BEQ      |L6.44|
00004e  69d3              LDR      r3,[r2,#0x1c]         ;284
000050  1a59              SUBS     r1,r3,r1              ;284
000052  61d1              STR      r1,[r2,#0x1c]         ;285
000054  6150              STR      r0,[r2,#0x14]         ;285
000056  bd30              POP      {r4,r5,pc}
;;;289    
                          ENDP

                  |L6.88|
                          DCD      osRtxInfo

                          AREA ||i.osRtxThreadDelayRemove||, CODE, READONLY, ALIGN=2

                  osRtxThreadDelayRemove PROC
;;;291    /// \param[in]  thread          thread object.
;;;292    static void osRtxThreadDelayRemove (os_thread_t *thread) {
000000  b530              PUSH     {r4,r5,lr}
;;;293    
;;;294      if (thread->delay == osWaitForever) {
000002  69c3              LDR      r3,[r0,#0x1c]
;;;295        if (thread->delay_next != NULL) {
;;;296          thread->delay_next->delay_prev = thread->delay_prev;
;;;297        }
;;;298        if (thread->delay_prev != NULL) {
;;;299          thread->delay_prev->delay_next = thread->delay_next;
;;;300          thread->delay_prev = NULL;
;;;301        } else {
;;;302          osRtxInfo.thread.wait_list = thread->delay_next;
000004  4c0f              LDR      r4,|L7.68|
000006  6901              LDR      r1,[r0,#0x10]         ;292
000008  1c5d              ADDS     r5,r3,#1              ;294
00000a  f04f0200          MOV      r2,#0
00000e  d00c              BEQ      |L7.42|
;;;303        }
;;;304      } else {
;;;305        if (thread->delay_next != NULL) {
000010  b129              CBZ      r1,|L7.30|
;;;306          thread->delay_next->delay += thread->delay;
000012  69cd              LDR      r5,[r1,#0x1c]
000014  442b              ADD      r3,r3,r5
000016  61cb              STR      r3,[r1,#0x1c]
000018  e9d01304          LDRD     r1,r3,[r0,#0x10]
;;;307          thread->delay_next->delay_prev = thread->delay_prev;
00001c  614b              STR      r3,[r1,#0x14]
                  |L7.30|
;;;308        }
;;;309        if (thread->delay_prev != NULL) {
00001e  6941              LDR      r1,[r0,#0x14]
000020  b161              CBZ      r1,|L7.60|
                  |L7.34|
;;;310          thread->delay_prev->delay_next = thread->delay_next;
000022  6903              LDR      r3,[r0,#0x10]
;;;311          thread->delay_prev = NULL;
000024  610b              STR      r3,[r1,#0x10]
000026  6142              STR      r2,[r0,#0x14]
000028  e00a              B        |L7.64|
                  |L7.42|
00002a  b109              CBZ      r1,|L7.48|
00002c  6943              LDR      r3,[r0,#0x14]         ;296
00002e  614b              STR      r3,[r1,#0x14]         ;296
                  |L7.48|
000030  6941              LDR      r1,[r0,#0x14]         ;298
000032  2900              CMP      r1,#0                 ;298
000034  d1f5              BNE      |L7.34|
000036  6901              LDR      r1,[r0,#0x10]         ;302
000038  6321              STR      r1,[r4,#0x30]         ;302  ; osRtxInfo
00003a  e001              B        |L7.64|
                  |L7.60|
;;;312        } else {
;;;313          osRtxInfo.thread.delay_list = thread->delay_next;
00003c  6901              LDR      r1,[r0,#0x10]
00003e  62e1              STR      r1,[r4,#0x2c]  ; osRtxInfo
                  |L7.64|
;;;314        }
;;;315      }
;;;316      thread->delay = 0U;
000040  61c2              STR      r2,[r0,#0x1c]
;;;317    }
000042  bd30              POP      {r4,r5,pc}
;;;318    
                          ENDP

                  |L7.68|
                          DCD      osRtxInfo

                          AREA ||i.osRtxThreadDelayTick||, CODE, READONLY, ALIGN=2

                  osRtxThreadDelayTick PROC
;;;319    /// Process Thread Delay Tick (executed each System Tick).
;;;320    void osRtxThreadDelayTick (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;321      os_thread_t *thread;
;;;322      os_object_t *object;
;;;323    
;;;324      thread = osRtxInfo.thread.delay_list;
000002  4d31              LDR      r5,|L8.200|
000004  6aec              LDR      r4,[r5,#0x2c]         ;320  ; osRtxInfo
000006  2c00              CMP      r4,#0                 ;320
000008  d05c              BEQ      |L8.196|
;;;325      if (thread == NULL) {
;;;326        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;327        return;
;;;328      }
;;;329    
;;;330      thread->delay--;
00000a  69e0              LDR      r0,[r4,#0x1c]
00000c  1e40              SUBS     r0,r0,#1
;;;331    
;;;332      if (thread->delay == 0U) {
00000e  61e0              STR      r0,[r4,#0x1c]
000010  d158              BNE      |L8.196|
                  |L8.18|
;;;333        do {
;;;334          switch (thread->state) {
000012  7860              LDRB     r0,[r4,#1]
000014  2863              CMP      r0,#0x63
000016  d029              BEQ      |L8.108|
000018  dc08              BGT      |L8.44|
00001a  2813              CMP      r0,#0x13
00001c  d00d              BEQ      |L8.58|
00001e  2833              CMP      r0,#0x33
000020  d00f              BEQ      |L8.66|
000022  2843              CMP      r0,#0x43
000024  d011              BEQ      |L8.74|
000026  2853              CMP      r0,#0x53
000028  d137              BNE      |L8.154|
00002a  e014              B        |L8.86|
                  |L8.44|
00002c  2873              CMP      r0,#0x73
00002e  d023              BEQ      |L8.120|
000030  2883              CMP      r0,#0x83
000032  d027              BEQ      |L8.132|
000034  2893              CMP      r0,#0x93
000036  d130              BNE      |L8.154|
000038  e02a              B        |L8.144|
                  |L8.58|
;;;335            case osRtxThreadWaitingDelay:
;;;336              EvrRtxDelayCompleted(thread);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       EvrRtxDelayCompleted
;;;337              break;
000040  e02b              B        |L8.154|
                  |L8.66|
;;;338            case osRtxThreadWaitingThreadFlags:
;;;339              EvrRtxThreadFlagsWaitTimeout(thread);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       EvrRtxThreadFlagsWaitTimeout
;;;340              break;
000048  e027              B        |L8.154|
                  |L8.74|
;;;341            case osRtxThreadWaitingEventFlags:
;;;342              EvrRtxEventFlagsWaitTimeout((osEventFlagsId_t)osRtxThreadListRoot(thread));
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       osRtxThreadListRoot
000050  f7fffffe          BL       EvrRtxEventFlagsWaitTimeout
;;;343              break;
000054  e021              B        |L8.154|
                  |L8.86|
;;;344            case osRtxThreadWaitingMutex:
;;;345              object = osRtxObject(osRtxThreadListRoot(thread));
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       osRtxThreadListRoot
00005c  4606              MOV      r6,r0
;;;346              osRtxMutexOwnerRestore(osRtxMutexObject(object), thread);
00005e  4621              MOV      r1,r4
000060  f7fffffe          BL       osRtxMutexOwnerRestore
;;;347              EvrRtxMutexAcquireTimeout(osRtxMutexObject(object));
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       EvrRtxMutexAcquireTimeout
;;;348              break;
00006a  e016              B        |L8.154|
                  |L8.108|
;;;349            case osRtxThreadWaitingSemaphore:
;;;350              EvrRtxSemaphoreAcquireTimeout((osSemaphoreId_t)osRtxThreadListRoot(thread));
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       osRtxThreadListRoot
000072  f7fffffe          BL       EvrRtxSemaphoreAcquireTimeout
;;;351              break;
000076  e010              B        |L8.154|
                  |L8.120|
;;;352            case osRtxThreadWaitingMemoryPool:
;;;353              EvrRtxMemoryPoolAllocTimeout((osMemoryPoolId_t)osRtxThreadListRoot(thread));
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       osRtxThreadListRoot
00007e  f7fffffe          BL       EvrRtxMemoryPoolAllocTimeout
;;;354              break;
000082  e00a              B        |L8.154|
                  |L8.132|
;;;355            case osRtxThreadWaitingMessageGet:
;;;356              EvrRtxMessageQueueGetTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       osRtxThreadListRoot
00008a  f7fffffe          BL       EvrRtxMessageQueueGetTimeout
;;;357              break;
00008e  e004              B        |L8.154|
                  |L8.144|
;;;358            case osRtxThreadWaitingMessagePut:
;;;359              EvrRtxMessageQueuePutTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       osRtxThreadListRoot
000096  f7fffffe          BL       EvrRtxMessageQueuePutTimeout
                  |L8.154|
;;;360              break;
;;;361            default:
;;;362              // Invalid
;;;363              break;
;;;364          }
;;;365          EvrRtxThreadUnblocked(thread, (osRtxThreadRegPtr(thread))[0]);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       osRtxThreadRegPtr
0000a0  6801              LDR      r1,[r0,#0]
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       EvrRtxThreadUnblocked
;;;366          osRtxThreadListRemove(thread);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       osRtxThreadListRemove
;;;367          osRtxThreadReadyPut(thread);
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       osRtxThreadReadyPut
;;;368          thread = thread->delay_next;
0000b4  6924              LDR      r4,[r4,#0x10]
;;;369        } while ((thread != NULL) && (thread->delay == 0U));
0000b6  b124              CBZ      r4,|L8.194|
0000b8  69e0              LDR      r0,[r4,#0x1c]
0000ba  2800              CMP      r0,#0
0000bc  d0a9              BEQ      |L8.18|
;;;370        if (thread != NULL) {
;;;371          thread->delay_prev = NULL;
0000be  2000              MOVS     r0,#0
0000c0  6160              STR      r0,[r4,#0x14]
                  |L8.194|
;;;372        }
;;;373        osRtxInfo.thread.delay_list = thread;
0000c2  62ec              STR      r4,[r5,#0x2c]  ; osRtxInfo
                  |L8.196|
;;;374      }
;;;375    }
0000c4  bd70              POP      {r4-r6,pc}
;;;376    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L8.200|
                          DCD      osRtxInfo

                          AREA ||i.osRtxThreadDestroy||, CODE, READONLY, ALIGN=2

                  osRtxThreadDestroy PROC
;;;1131   /// \param[in]  thread          thread object.
;;;1132   static void osRtxThreadDestroy (os_thread_t *thread) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1133   
;;;1134     if ((thread->attr & osThreadJoinable) == 0U) {
000004  78c0              LDRB     r0,[r0,#3]
000006  07c0              LSLS     r0,r0,#31
000008  d00f              BEQ      |L9.42|
;;;1135       osRtxThreadFree(thread);
;;;1136     } else {
;;;1137       // Update Thread State and put it into Terminate Thread list
;;;1138       thread->state = osRtxThreadTerminated;
00000a  2004              MOVS     r0,#4
00000c  7060              STRB     r0,[r4,#1]
;;;1139       thread->thread_prev = NULL;
00000e  2000              MOVS     r0,#0
;;;1140       thread->thread_next = osRtxInfo.thread.terminate_list;
000010  60e0              STR      r0,[r4,#0xc]
000012  4808              LDR      r0,|L9.52|
000014  6b41              LDR      r1,[r0,#0x34]  ; osRtxInfo
;;;1141       if (osRtxInfo.thread.terminate_list != NULL) {
000016  60a1              STR      r1,[r4,#8]
000018  6b41              LDR      r1,[r0,#0x34]  ; osRtxInfo
00001a  b101              CBZ      r1,|L9.30|
;;;1142         osRtxInfo.thread.terminate_list->thread_prev = thread;
00001c  60cc              STR      r4,[r1,#0xc]
                  |L9.30|
;;;1143       }
;;;1144       osRtxInfo.thread.terminate_list = thread;
00001e  6344              STR      r4,[r0,#0x34]  ; osRtxInfo
                  |L9.32|
;;;1145     }
;;;1146     EvrRtxThreadDestroyed(thread);
000020  4620              MOV      r0,r4
000022  e8bd4010          POP      {r4,lr}
000026  f7ffbffe          B.W      EvrRtxThreadDestroyed
                  |L9.42|
00002a  4620              MOV      r0,r4                 ;1135
00002c  f7fffffe          BL       osRtxThreadFree
000030  e7f6              B        |L9.32|
;;;1147   }
;;;1148   
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      osRtxInfo

                          AREA ||i.osRtxThreadDispatch||, CODE, READONLY, ALIGN=2

                  osRtxThreadDispatch PROC
;;;423    /// \param[in]  thread          thread object or NULL.
;;;424    void osRtxThreadDispatch (os_thread_t *thread) {
000000  b510              PUSH     {r4,lr}
000002  4915              LDR      r1,|L10.88|
000004  0004              MOVS     r4,r0
000006  7a08              LDRB     r0,[r1,#8]  ; osRtxInfo
000008  694b              LDR      r3,[r1,#0x14]  ; osRtxInfo
00000a  d002              BEQ      |L10.18|
;;;425      uint8_t      kernel_state;
;;;426      os_thread_t *thread_running;
;;;427      os_thread_t *thread_ready;
;;;428    
;;;429      kernel_state   = osRtxKernelGetState();
;;;430      thread_running = osRtxThreadGetRunning();
;;;431    
;;;432      if (thread == NULL) {
;;;433        thread_ready = osRtxInfo.thread.ready.thread_list;
;;;434        if ((kernel_state == osRtxKernelRunning) &&
;;;435            (thread_ready != NULL) &&
;;;436            (thread_ready->priority > thread_running->priority)) {
;;;437          // Preempt running Thread
;;;438          osRtxThreadListRemove(thread_ready);
;;;439          osRtxThreadBlock(thread_running);
;;;440          osRtxThreadSwitch(thread_ready);
;;;441        }
;;;442      } else {
;;;443        if ((kernel_state == osRtxKernelRunning) &&
00000c  2802              CMP      r0,#2
00000e  d00f              BEQ      |L10.48|
000010  e01c              B        |L10.76|
                  |L10.18|
000012  6a4c              LDR      r4,[r1,#0x24]         ;434  ; osRtxInfo
000014  2802              CMP      r0,#2                 ;434
000016  d11e              BNE      |L10.86|
000018  2c00              CMP      r4,#0                 ;435
00001a  d01c              BEQ      |L10.86|
00001c  f9940020          LDRSB    r0,[r4,#0x20]         ;436
000020  f9931020          LDRSB    r1,[r3,#0x20]         ;436
000024  4288              CMP      r0,r1                 ;436
000026  dd16              BLE      |L10.86|
000028  4620              MOV      r0,r4                 ;438
00002a  f7fffffe          BL       osRtxThreadListRemove
00002e  e005              B        |L10.60|
                  |L10.48|
;;;444            (thread->priority > thread_running->priority)) {
000030  f9940020          LDRSB    r0,[r4,#0x20]
000034  f9931020          LDRSB    r1,[r3,#0x20]
000038  4288              CMP      r0,r1
00003a  dd07              BLE      |L10.76|
                  |L10.60|
;;;445          // Preempt running Thread
;;;446          osRtxThreadBlock(thread_running);
00003c  4618              MOV      r0,r3
00003e  f7fffffe          BL       osRtxThreadBlock
;;;447          osRtxThreadSwitch(thread);
000042  4620              MOV      r0,r4
000044  e8bd4010          POP      {r4,lr}
000048  f7ffbffe          B.W      osRtxThreadSwitch
                  |L10.76|
;;;448        } else {
;;;449          // Put Thread into Ready list
;;;450          osRtxThreadReadyPut(thread);
00004c  4620              MOV      r0,r4
00004e  e8bd4010          POP      {r4,lr}
000052  f7ffbffe          B.W      osRtxThreadReadyPut
                  |L10.86|
;;;451        }
;;;452      }
;;;453    }
000056  bd10              POP      {r4,pc}
;;;454    
                          ENDP

                  |L10.88|
                          DCD      osRtxInfo

                          AREA ||i.osRtxThreadFree||, CODE, READONLY, ALIGN=2

                  osRtxThreadFree PROC
;;;1094   /// \param[in]  thread          thread object.
;;;1095   static void osRtxThreadFree (os_thread_t *thread) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1096   
;;;1097     // Mark object as inactive and invalid
;;;1098     thread->state = osRtxThreadInactive;
000004  2000              MOVS     r0,#0
000006  7060              STRB     r0,[r4,#1]
;;;1099     thread->id    = osRtxIdInvalid;
000008  7020              STRB     r0,[r4,#0]
;;;1100   
;;;1101   #if (DOMAIN_NS == 1)
;;;1102     // Free secure process stack
;;;1103     if (thread->tz_memory != 0U) {
;;;1104       (void)TZ_FreeModuleContext_S(thread->tz_memory);
;;;1105     }
;;;1106   #endif
;;;1107   
;;;1108     // Free stack memory
;;;1109     if ((thread->flags & osRtxFlagSystemMemory) != 0U) {
00000a  78a0              LDRB     r0,[r4,#2]
;;;1110       if ((thread->flags & osRtxThreadFlagDefStack) != 0U) {
;;;1111         (void)osRtxMemoryPoolFree(osRtxInfo.mpi.stack, thread->stack_mem);
00000c  4d10              LDR      r5,|L11.80|
00000e  0781              LSLS     r1,r0,#30             ;1109
000010  d50a              BPL      |L11.40|
000012  6b21              LDR      r1,[r4,#0x30]         ;1110
000014  06c0              LSLS     r0,r0,#27             ;1110
000016  d504              BPL      |L11.34|
000018  f8d50084          LDR      r0,[r5,#0x84]  ; osRtxInfo
00001c  f7fffffe          BL       osRtxMemoryPoolFree
000020  e002              B        |L11.40|
                  |L11.34|
;;;1112       } else {
;;;1113         (void)osRtxMemoryFree(osRtxInfo.mem.stack, thread->stack_mem);
000022  6f68              LDR      r0,[r5,#0x74]  ; osRtxInfo
000024  f7fffffe          BL       osRtxMemoryFree
                  |L11.40|
;;;1114       }
;;;1115     }
;;;1116   
;;;1117     // Free object memory
;;;1118     if ((thread->flags & osRtxFlagSystemObject) != 0U) {
000028  78a0              LDRB     r0,[r4,#2]
00002a  07c0              LSLS     r0,r0,#31
00002c  d00f              BEQ      |L11.78|
;;;1119       if (osRtxInfo.mpi.thread != NULL) {
00002e  f8d50088          LDR      r0,[r5,#0x88]  ; osRtxInfo
000032  b118              CBZ      r0,|L11.60|
;;;1120         (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
000034  4621              MOV      r1,r4
000036  f7fffffe          BL       osRtxMemoryPoolFree
00003a  e004              B        |L11.70|
                  |L11.60|
;;;1121       } else {
;;;1122         (void)osRtxMemoryFree(osRtxInfo.mem.common, thread);
00003c  4621              MOV      r1,r4
00003e  f8d50080          LDR      r0,[r5,#0x80]  ; osRtxInfo
000042  f7fffffe          BL       osRtxMemoryFree
                  |L11.70|
;;;1123       }
;;;1124   #ifdef RTX_OBJ_MEM_USAGE
;;;1125       osRtxThreadMemUsage.cnt_free++;
000046  4803              LDR      r0,|L11.84|
000048  6841              LDR      r1,[r0,#4]  ; osRtxThreadMemUsage
00004a  1c49              ADDS     r1,r1,#1
00004c  6041              STR      r1,[r0,#4]  ; osRtxThreadMemUsage
                  |L11.78|
;;;1126   #endif
;;;1127     }
;;;1128   }
00004e  bd70              POP      {r4-r6,pc}
;;;1129   
                          ENDP

                  |L11.80|
                          DCD      osRtxInfo
                  |L11.84|
                          DCD      ||.data.os.thread.obj||

                          AREA ||i.osRtxThreadJoinWakeup||, CODE, READONLY, ALIGN=1

                  osRtxThreadJoinWakeup PROC
;;;1081   /// \param[in]  thread          thread object.
;;;1082   static void osRtxThreadJoinWakeup (os_thread_t *thread) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1083   
;;;1084     if (thread->thread_join != NULL) {
000004  6980              LDR      r0,[r0,#0x18]
000006  b130              CBZ      r0,|L12.22|
;;;1085       osRtxThreadWaitExit(thread->thread_join, (uint32_t)osOK, FALSE);
000008  2200              MOVS     r2,#0
00000a  4611              MOV      r1,r2
00000c  f7fffffe          BL       osRtxThreadWaitExit
;;;1086       EvrRtxThreadJoined(thread->thread_join);
000010  69a0              LDR      r0,[r4,#0x18]
000012  f7fffffe          BL       EvrRtxThreadJoined
                  |L12.22|
;;;1087     }
;;;1088     if (thread->state == osRtxThreadWaitingJoin) {
000016  7860              LDRB     r0,[r4,#1]
000018  2823              CMP      r0,#0x23
00001a  d102              BNE      |L12.34|
;;;1089       thread->thread_next->thread_join = NULL;
00001c  68a1              LDR      r1,[r4,#8]
00001e  2000              MOVS     r0,#0
000020  6188              STR      r0,[r1,#0x18]
                  |L12.34|
;;;1090     }
;;;1091   }
000022  bd10              POP      {r4,pc}
;;;1092   
                          ENDP


                          AREA ||i.osRtxThreadListGet||, CODE, READONLY, ALIGN=1

                  osRtxThreadListGet PROC
;;;164    /// \return thread object.
;;;165    os_thread_t *osRtxThreadListGet (os_object_t *object) {
000000  6881              LDR      r1,[r0,#8]
;;;166      os_thread_t *thread;
;;;167    
;;;168      thread = object->thread_list;
;;;169      object->thread_list = thread->thread_next;
000002  688a              LDR      r2,[r1,#8]
;;;170      if (thread->thread_next != NULL) {
000004  6082              STR      r2,[r0,#8]
000006  688a              LDR      r2,[r1,#8]            ;165
000008  b102              CBZ      r2,|L13.12|
;;;171        thread->thread_next->thread_prev = osRtxThreadObject(object);
00000a  60d0              STR      r0,[r2,#0xc]
                  |L13.12|
;;;172      }
;;;173      thread->thread_prev = NULL;
00000c  2000              MOVS     r0,#0
;;;174    
;;;175      return thread;
00000e  60c8              STR      r0,[r1,#0xc]
000010  4608              MOV      r0,r1
;;;176    }
000012  4770              BX       lr
;;;177    
                          ENDP


                          AREA ||i.osRtxThreadListPut||, CODE, READONLY, ALIGN=1

                  osRtxThreadListPut PROC
;;;141    /// \param[in]  thread          thread object.
;;;142    void osRtxThreadListPut (os_object_t *object, os_thread_t *thread) {
000000  b510              PUSH     {r4,lr}
;;;143      os_thread_t *prev, *next;
;;;144      int32_t      priority;
;;;145    
;;;146      priority = thread->priority;
000002  f9913020          LDRSB    r3,[r1,#0x20]
                  |L14.6|
;;;147    
;;;148      prev = osRtxThreadObject(object);
;;;149      next = prev->thread_next;
000006  6882              LDR      r2,[r0,#8]
000008  b12a              CBZ      r2,|L14.22|
;;;150      while ((next != NULL) && (next->priority >= priority)) {
00000a  f9924020          LDRSB    r4,[r2,#0x20]
00000e  429c              CMP      r4,r3
000010  db01              BLT      |L14.22|
;;;151        prev = next;
000012  4610              MOV      r0,r2
;;;152        next = next->thread_next;
000014  e7f7              B        |L14.6|
                  |L14.22|
000016  e9c12002          STRD     r2,r0,[r1,#8]
;;;153      }
;;;154      thread->thread_prev = prev;
;;;155      thread->thread_next = next;
;;;156      prev->thread_next = thread;
;;;157      if (next != NULL) {
00001a  6081              STR      r1,[r0,#8]
00001c  2a00              CMP      r2,#0
00001e  d000              BEQ      |L14.34|
;;;158        next->thread_prev = thread;
000020  60d1              STR      r1,[r2,#0xc]
                  |L14.34|
;;;159      }
;;;160    }
000022  bd10              POP      {r4,pc}
;;;161    
                          ENDP


                          AREA ||i.osRtxThreadListRemove||, CODE, READONLY, ALIGN=1

                  osRtxThreadListRemove PROC
;;;211    /// \param[in]  thread          thread object.
;;;212    void osRtxThreadListRemove (os_thread_t *thread) {
000000  68c1              LDR      r1,[r0,#0xc]
000002  2900              CMP      r1,#0
000004  d007              BEQ      |L15.22|
;;;213    
;;;214      if (thread->thread_prev != NULL) {
;;;215        thread->thread_prev->thread_next = thread->thread_next;
000006  6882              LDR      r2,[r0,#8]
;;;216        if (thread->thread_next != NULL) {
000008  608a              STR      r2,[r1,#8]
00000a  6881              LDR      r1,[r0,#8]
00000c  b109              CBZ      r1,|L15.18|
;;;217          thread->thread_next->thread_prev = thread->thread_prev;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  60ca              STR      r2,[r1,#0xc]
                  |L15.18|
;;;218        }
;;;219        thread->thread_prev = NULL;
000012  2100              MOVS     r1,#0
000014  60c1              STR      r1,[r0,#0xc]
                  |L15.22|
;;;220      }
;;;221    }
000016  4770              BX       lr
;;;222    
                          ENDP


                          AREA ||i.osRtxThreadListRoot||, CODE, READONLY, ALIGN=1

                  osRtxThreadListRoot PROC
;;;180    /// \return root object.
;;;181    static void *osRtxThreadListRoot (os_thread_t *thread) {
000000  e000              B        |L16.4|
                  |L16.2|
;;;182      os_thread_t *thread0;
;;;183    
;;;184      thread0 = thread;
;;;185      while (thread0->id == osRtxIdThread) {
;;;186        thread0 = thread0->thread_prev;
000002  68c0              LDR      r0,[r0,#0xc]
                  |L16.4|
000004  7801              LDRB     r1,[r0,#0]            ;185
000006  29f1              CMP      r1,#0xf1              ;185
000008  d0fb              BEQ      |L16.2|
;;;187      }
;;;188      return thread0;
;;;189    }
00000a  4770              BX       lr
;;;190    
                          ENDP


                          AREA ||i.osRtxThreadListSort||, CODE, READONLY, ALIGN=1

                  osRtxThreadListSort PROC
;;;192    /// \param[in]  thread          thread object.
;;;193    void osRtxThreadListSort (os_thread_t *thread) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;194      os_object_t *object;
;;;195      os_thread_t *thread0;
;;;196    
;;;197      // Search for object
;;;198      thread0 = thread;
;;;199      while ((thread0 != NULL) && (thread0->id == osRtxIdThread)) {
;;;200        thread0 = thread0->thread_prev;
000004  e000              B        |L17.8|
                  |L17.6|
000006  68c0              LDR      r0,[r0,#0xc]
                  |L17.8|
000008  2800              CMP      r0,#0                 ;199
00000a  d00c              BEQ      |L17.38|
00000c  7801              LDRB     r1,[r0,#0]            ;199
00000e  29f1              CMP      r1,#0xf1              ;199
000010  d0f9              BEQ      |L17.6|
;;;201      }
;;;202      object = osRtxObject(thread0);
000012  4603              MOV      r3,r0
;;;203    
;;;204      if (object != NULL) {
;;;205        osRtxThreadListRemove(thread);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       osRtxThreadListRemove
;;;206        osRtxThreadListPut(object, thread);
00001a  4621              MOV      r1,r4
00001c  e8bd4010          POP      {r4,lr}
000020  4618              MOV      r0,r3
000022  f7ffbffe          B.W      osRtxThreadListPut
                  |L17.38|
;;;207      }
;;;208    }
000026  bd10              POP      {r4,pc}
;;;209    
                          ENDP


                          AREA ||i.osRtxThreadListUnlink||, CODE, READONLY, ALIGN=1

                  osRtxThreadListUnlink PROC
;;;224    /// \param[in]  thread          thread object.
;;;225    static void osRtxThreadListUnlink (os_thread_t **thread_list, os_thread_t *thread) {
000000  688a              LDR      r2,[r1,#8]
000002  b10a              CBZ      r2,|L18.8|
;;;226    
;;;227      if (thread->thread_next != NULL) {
;;;228        thread->thread_next->thread_prev = thread->thread_prev;
000004  68cb              LDR      r3,[r1,#0xc]
000006  60d3              STR      r3,[r2,#0xc]
                  |L18.8|
;;;229      }
;;;230      if (thread->thread_prev != NULL) {
000008  68ca              LDR      r2,[r1,#0xc]
00000a  b122              CBZ      r2,|L18.22|
;;;231        thread->thread_prev->thread_next = thread->thread_next;
00000c  6888              LDR      r0,[r1,#8]
;;;232        thread->thread_prev = NULL;
00000e  6090              STR      r0,[r2,#8]
000010  2000              MOVS     r0,#0
000012  60c8              STR      r0,[r1,#0xc]
;;;233      } else {
;;;234        *thread_list = thread->thread_next;
;;;235      }
;;;236    }
000014  4770              BX       lr
                  |L18.22|
000016  6889              LDR      r1,[r1,#8]            ;234
000018  6001              STR      r1,[r0,#0]            ;234
00001a  4770              BX       lr
;;;237    
                          ENDP


                          AREA ||i.osRtxThreadPostProcess||, CODE, READONLY, ALIGN=1

                  osRtxThreadPostProcess PROC
;;;549    /// \param[in]  thread          thread object.
;;;550    static void osRtxThreadPostProcess (os_thread_t *thread) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;551      uint32_t thread_flags;
;;;552    
;;;553      // Check if Thread is waiting for Thread Flags
;;;554      if (thread->state == osRtxThreadWaitingThreadFlags) {
000004  7840              LDRB     r0,[r0,#1]
000006  2833              CMP      r0,#0x33
000008  d115              BNE      |L19.54|
;;;555        thread_flags = ThreadFlagsCheck(thread, thread->wait_flags, thread->flags_options);
00000a  f8942023          LDRB     r2,[r4,#0x23]
00000e  4620              MOV      r0,r4
000010  6a61              LDR      r1,[r4,#0x24]
000012  f7fffffe          BL       ThreadFlagsCheck
000016  0005              MOVS     r5,r0
;;;556        if (thread_flags != 0U) {
000018  d00d              BEQ      |L19.54|
;;;557          osRtxThreadWaitExit(thread, thread_flags, FALSE);
00001a  4601              MOV      r1,r0
00001c  2200              MOVS     r2,#0
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       osRtxThreadWaitExit
;;;558          EvrRtxThreadFlagsWaitCompleted(thread->wait_flags, thread->flags_options, thread_flags, thread);
000024  f8941023          LDRB     r1,[r4,#0x23]
000028  4623              MOV      r3,r4
00002a  462a              MOV      r2,r5
00002c  6a60              LDR      r0,[r4,#0x24]
00002e  e8bd4070          POP      {r4-r6,lr}
000032  f7ffbffe          B.W      EvrRtxThreadFlagsWaitCompleted
                  |L19.54|
;;;559        }
;;;560      }
;;;561    }
000036  bd70              POP      {r4-r6,pc}
;;;562    
                          ENDP


                          AREA ||i.osRtxThreadReadyPut||, CODE, READONLY, ALIGN=2

                  osRtxThreadReadyPut PROC
;;;239    /// \param[in]  thread          thread object.
;;;240    void osRtxThreadReadyPut (os_thread_t *thread) {
000000  2101              MOVS     r1,#1
;;;241    
;;;242      thread->state = osRtxThreadReady;
000002  7041              STRB     r1,[r0,#1]
;;;243      osRtxThreadListPut(&osRtxInfo.thread.ready, thread);
000004  4601              MOV      r1,r0
000006  4801              LDR      r0,|L20.12|
000008  f7ffbffe          B.W      osRtxThreadListPut
;;;244    }
;;;245    
                          ENDP

                  |L20.12|
                          DCD      osRtxInfo+0x1c

                          AREA ||i.osRtxThreadRegPtr||, CODE, READONLY, ALIGN=1

                  osRtxThreadRegPtr PROC
;;;379    /// \return pointer to registers R0-R3.
;;;380    uint32_t *osRtxThreadRegPtr (const os_thread_t *thread) {
000000  6b81              LDR      r1,[r0,#0x38]
;;;381      uint32_t addr = thread->sp + StackOffsetR0(thread->stack_frame);
000002  f8900022          LDRB     r0,[r0,#0x22]
000006  06c0              LSLS     r0,r0,#27
000008  d401              BMI      |L21.14|
00000a  2060              MOVS     r0,#0x60
00000c  e000              B        |L21.16|
                  |L21.14|
00000e  2020              MOVS     r0,#0x20
                  |L21.16|
000010  4408              ADD      r0,r0,r1
;;;382      //lint -e{923} -e{9078} "cast from unsigned int to pointer"
;;;383      return ((uint32_t *)addr);
;;;384    }
000012  4770              BX       lr
;;;385    
                          ENDP


                          AREA ||i.osRtxThreadStackCheck||, CODE, READONLY, ALIGN=2

                  osRtxThreadStackCheck PROC
;;;513    //lint -esym(765,osRtxThreadStackCheck) "Global scope"
;;;514    bool_t osRtxThreadStackCheck (const os_thread_t *thread) {
000000  6b81              LDR      r1,[r0,#0x38]
;;;515    
;;;516      //lint -e{923} "cast from pointer to unsigned int"
;;;517      //lint -e{9079} -e{9087} "cast between pointers to different object types"
;;;518      if ((thread->sp <= (uint32_t)thread->stack_mem) ||
000002  6b00              LDR      r0,[r0,#0x30]
000004  4281              CMP      r1,r0
000006  d903              BLS      |L22.16|
;;;519          (*((uint32_t *)thread->stack_mem) != osRtxStackMagicWord)) {
000008  6800              LDR      r0,[r0,#0]
00000a  4903              LDR      r1,|L22.24|
00000c  4288              CMP      r0,r1
00000e  d001              BEQ      |L22.20|
                  |L22.16|
;;;520        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;521        return FALSE;
000010  2000              MOVS     r0,#0
;;;522      }
;;;523      return TRUE;
;;;524    }
000012  4770              BX       lr
                  |L22.20|
000014  2001              MOVS     r0,#1                 ;523
000016  4770              BX       lr
;;;525    #endif
                          ENDP

                  |L22.24|
                          DCD      0xe25a2ea5

                          AREA ||i.osRtxThreadStartup||, CODE, READONLY, ALIGN=2

                  osRtxThreadStartup PROC
;;;1624   /// \return true - success, false - failure.
;;;1625   bool_t osRtxThreadStartup (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;1626     bool_t ret = FALSE;
;;;1627   
;;;1628     // Create Idle Thread
;;;1629     osRtxInfo.thread.idle = osRtxThreadId(
000002  4c0b              LDR      r4,|L23.48|
000004  2500              MOVS     r5,#0                 ;1626
000006  4629              MOV      r1,r5
000008  480a              LDR      r0,|L23.52|
00000a  6da2              LDR      r2,[r4,#0x58]  ; osRtxConfig
00000c  f7fffffe          BL       svcRtxThreadNew
000010  4e09              LDR      r6,|L23.56|
;;;1630       svcRtxThreadNew(osRtxIdleThread, NULL, osRtxConfig.idle_thread_attr)
;;;1631     );
;;;1632   
;;;1633     // Create Timer Thread
;;;1634     if (osRtxConfig.timer_setup != NULL) {
000012  62b0              STR      r0,[r6,#0x28]  ; osRtxInfo
000014  6e60              LDR      r0,[r4,#0x64]  ; osRtxConfig
000016  b140              CBZ      r0,|L23.42|
;;;1635       if (osRtxConfig.timer_setup() == 0) {
000018  4780              BLX      r0
00001a  b938              CBNZ     r0,|L23.44|
;;;1636         osRtxInfo.timer.thread = osRtxThreadId(
00001c  6de2              LDR      r2,[r4,#0x5c]  ; osRtxConfig
00001e  6cf1              LDR      r1,[r6,#0x4c]  ; osRtxInfo
000020  6e20              LDR      r0,[r4,#0x60]  ; osRtxConfig
000022  f7fffffe          BL       svcRtxThreadNew
;;;1637           svcRtxThreadNew(osRtxConfig.timer_thread, osRtxInfo.timer.mq, osRtxConfig.timer_thread_attr)
;;;1638         );
;;;1639         if (osRtxInfo.timer.thread != NULL) {
000026  64b0              STR      r0,[r6,#0x48]  ; osRtxInfo
000028  b100              CBZ      r0,|L23.44|
                  |L23.42|
;;;1640           ret = TRUE;
00002a  2501              MOVS     r5,#1
                  |L23.44|
;;;1641         }
;;;1642       }
;;;1643     } else {
;;;1644       ret = TRUE;
;;;1645     }
;;;1646   
;;;1647     return ret;
00002c  4628              MOV      r0,r5
;;;1648   }
00002e  bd70              POP      {r4-r6,pc}
;;;1649   
                          ENDP

                  |L23.48|
                          DCD      osRtxConfig
                  |L23.52|
                          DCD      osRtxIdleThread
                  |L23.56|
                          DCD      osRtxInfo

                          AREA ||i.osRtxThreadSwitch||, CODE, READONLY, ALIGN=2

                  osRtxThreadSwitch PROC
;;;414    /// \param[in]  thread          thread object.
;;;415    void osRtxThreadSwitch (os_thread_t *thread) {
000000  2102              MOVS     r1,#2
;;;416    
;;;417      thread->state = osRtxThreadRunning;
000002  7041              STRB     r1,[r0,#1]
;;;418      osRtxInfo.thread.run.next = thread;
000004  4901              LDR      r1,|L24.12|
;;;419      EvrRtxThreadSwitched(thread);
000006  6188              STR      r0,[r1,#0x18]  ; osRtxInfo
000008  f7ffbffe          B.W      EvrRtxThreadSwitched
;;;420    }
;;;421    
                          ENDP

                  |L24.12|
                          DCD      osRtxInfo

                          AREA ||i.osRtxThreadWaitEnter||, CODE, READONLY, ALIGN=2

                  osRtxThreadWaitEnter PROC
;;;478    /// \return true - success, false - failure.
;;;479    bool_t osRtxThreadWaitEnter (uint8_t state, uint32_t timeout) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  480d              LDR      r0,|L25.60|
000006  460e              MOV      r6,r1
000008  7a01              LDRB     r1,[r0,#8]  ; osRtxInfo
;;;480      os_thread_t *thread;
;;;481    
;;;482      // Check if Kernel is running
;;;483      if (osRtxKernelGetState() != osRtxKernelRunning) {
00000a  2902              CMP      r1,#2
00000c  d113              BNE      |L25.54|
;;;484        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;485        return FALSE;
;;;486      }
;;;487    
;;;488      // Check if any thread is ready
;;;489      if (osRtxInfo.thread.ready.thread_list == NULL) {
00000e  6a41              LDR      r1,[r0,#0x24]  ; osRtxInfo
000010  b189              CBZ      r1,|L25.54|
;;;490        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;491        return FALSE;
;;;492      }
;;;493    
;;;494      // Get running thread
;;;495      thread = osRtxThreadGetRunning();
;;;496    
;;;497      EvrRtxThreadBlocked(thread, timeout);
000012  6944              LDR      r4,[r0,#0x14]  ; osRtxInfo
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       EvrRtxThreadBlocked
;;;498    
;;;499      thread->state = state;
00001c  7065              STRB     r5,[r4,#1]
;;;500      osRtxThreadDelayInsert(thread, timeout);
00001e  4631              MOV      r1,r6
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       osRtxThreadDelayInsert
;;;501      thread = osRtxThreadListGet(&osRtxInfo.thread.ready);
000026  4805              LDR      r0,|L25.60|
000028  301c              ADDS     r0,r0,#0x1c
00002a  f7fffffe          BL       osRtxThreadListGet
;;;502      osRtxThreadSwitch(thread);
00002e  f7fffffe          BL       osRtxThreadSwitch
;;;503    
;;;504      return TRUE;
000032  2001              MOVS     r0,#1
;;;505    }
000034  bd70              POP      {r4-r6,pc}
                  |L25.54|
000036  2000              MOVS     r0,#0                 ;491
000038  bd70              POP      {r4-r6,pc}
;;;506    
                          ENDP

00003a  0000              DCW      0x0000
                  |L25.60|
                          DCD      osRtxInfo

                          AREA ||i.osRtxThreadWaitExit||, CODE, READONLY, ALIGN=1

                  osRtxThreadWaitExit PROC
;;;458    /// \param[in]  dispatch        dispatch flag.
;;;459    void osRtxThreadWaitExit (os_thread_t *thread, uint32_t ret_val, bool_t dispatch) {
000000  b570              PUSH     {r4-r6,lr}
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;460      uint32_t *reg;
;;;461    
;;;462      EvrRtxThreadUnblocked(thread, ret_val);
000008  f7fffffe          BL       EvrRtxThreadUnblocked
;;;463    
;;;464      reg = osRtxThreadRegPtr(thread);
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       osRtxThreadRegPtr
;;;465      reg[0] = ret_val;
;;;466    
;;;467      osRtxThreadDelayRemove(thread);
000012  6005              STR      r5,[r0,#0]
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       osRtxThreadDelayRemove
;;;468      if (dispatch) {
;;;469        osRtxThreadDispatch(thread);
;;;470      } else {
;;;471        osRtxThreadReadyPut(thread);
00001a  4630              MOV      r0,r6
00001c  b11c              CBZ      r4,|L26.38|
00001e  e8bd4070          POP      {r4-r6,lr}            ;469
000022  f7ffbffe          B.W      osRtxThreadDispatch
                  |L26.38|
000026  e8bd4070          POP      {r4-r6,lr}
00002a  f7ffbffe          B.W      osRtxThreadReadyPut
;;;472      }
;;;473    }
;;;474    
                          ENDP


                          AREA ||i.osThreadDetach||, CODE, READONLY, ALIGN=2

                  osThreadDetach PROC
;;;1800   /// Detach a thread (thread storage can be reclaimed when thread terminates).
;;;1801   osStatus_t osThreadDetach (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1802     osStatus_t status;
;;;1803   
;;;1804     EvrRtxThreadDetach(thread_id);
000004  f7fffffe          BL       EvrRtxThreadDetach
;;;1805     if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L27.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L27.36|
                  |L27.20|
;;;1806       EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxThreadError
;;;1807       status = osErrorISR;
000020  4628              MOV      r0,r5
;;;1808     } else {
;;;1809       status = __svcThreadDetach(thread_id);
;;;1810     }
;;;1811     return status;
;;;1812   }
000022  bd70              POP      {r4-r6,pc}
                  |L27.36|
000024  4620              MOV      r0,r4                 ;1809
000026  f8dfc008          LDR      r12,|L27.48|
00002a  df00              SVC      #0x0                  ;1809
00002c  bd70              POP      {r4-r6,pc}
;;;1813   
                          ENDP

00002e  0000              DCW      0x0000
                  |L27.48|
                          DCD      svcRtxThreadDetach

                          AREA ||i.osThreadEnumerate||, CODE, READONLY, ALIGN=2

                  osThreadEnumerate PROC
;;;1863   /// Enumerate active threads.
;;;1864   uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;1865     uint32_t count;
;;;1866   
;;;1867     if (IsException() || IsIrqMasked()) {
000006  f7fffffe          BL       IsException
00000a  b910              CBNZ     r0,|L28.18|
00000c  f7fffffe          BL       IsIrqMasked
000010  b130              CBZ      r0,|L28.32|
                  |L28.18|
;;;1868       EvrRtxThreadEnumerate(thread_array, array_items, 0U);
000012  2200              MOVS     r2,#0
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       EvrRtxThreadEnumerate
;;;1869       count = 0U;
00001c  2000              MOVS     r0,#0
;;;1870     } else {
;;;1871       count = __svcThreadEnumerate(thread_array, array_items);
;;;1872     }
;;;1873     return count;
;;;1874   }
00001e  bd70              POP      {r4-r6,pc}
                  |L28.32|
000020  4628              MOV      r0,r5                 ;1871
000022  4621              MOV      r1,r4                 ;1871
000024  f8dfc004          LDR      r12,|L28.44|
000028  df00              SVC      #0x0                  ;1871
00002a  bd70              POP      {r4-r6,pc}
;;;1875   
                          ENDP

                  |L28.44|
                          DCD      svcRtxThreadEnumerate

                          AREA ||i.osThreadExit||, CODE, READONLY, ALIGN=2

                  osThreadExit PROC
;;;1828   /// Terminate execution of current running thread.
;;;1829   __NO_RETURN void osThreadExit (void) {
000000  f7fffffe          BL       EvrRtxThreadExit
;;;1830     EvrRtxThreadExit();
000004  f8dfc010          LDR      r12,|L29.24|
000008  df00              SVC      #0x0
;;;1831     __svcThreadExit();
;;;1832     EvrRtxThreadError(NULL, (int32_t)osError);
00000a  f04f31ff          MOV      r1,#0xffffffff
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       EvrRtxThreadError
                  |L29.20|
;;;1833     for (;;) {}
000014  e7fe              B        |L29.20|
;;;1834   }
;;;1835   
                          ENDP

000016  0000              DCW      0x0000
                  |L29.24|
                          DCD      svcRtxThreadExit

                          AREA ||i.osThreadFlagsClear||, CODE, READONLY, ALIGN=2

                  osThreadFlagsClear PROC
;;;1889   /// Clear the specified Thread Flags of current running thread.
;;;1890   uint32_t osThreadFlagsClear (uint32_t flags) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1891     uint32_t thread_flags;
;;;1892   
;;;1893     EvrRtxThreadFlagsClear(flags);
000004  f7fffffe          BL       EvrRtxThreadFlagsClear
;;;1894     if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L30.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L30.36|
                  |L30.20|
;;;1895       EvrRtxThreadFlagsError(NULL, (int32_t)osErrorISR);
000014  f06f0405          MVN      r4,#5
000018  4621              MOV      r1,r4
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       EvrRtxThreadFlagsError
;;;1896       thread_flags = (uint32_t)osErrorISR;
000020  4620              MOV      r0,r4
;;;1897     } else {
;;;1898       thread_flags = __svcThreadFlagsClear(flags);
;;;1899     }
;;;1900     return thread_flags;
;;;1901   }
000022  bd10              POP      {r4,pc}
                  |L30.36|
000024  4620              MOV      r0,r4                 ;1898
000026  f8dfc008          LDR      r12,|L30.48|
00002a  df00              SVC      #0x0                  ;1898
00002c  bd10              POP      {r4,pc}
;;;1902   
                          ENDP

00002e  0000              DCW      0x0000
                  |L30.48|
                          DCD      svcRtxThreadFlagsClear

                          AREA ||i.osThreadFlagsGet||, CODE, READONLY, ALIGN=2

                  osThreadFlagsGet PROC
;;;1903   /// Get the current Thread Flags of current running thread.
;;;1904   uint32_t osThreadFlagsGet (void) {
000000  b510              PUSH     {r4,lr}
;;;1905     uint32_t thread_flags;
;;;1906   
;;;1907     if (IsException() || IsIrqMasked()) {
000002  f7fffffe          BL       IsException
000006  b910              CBNZ     r0,|L31.14|
000008  f7fffffe          BL       IsIrqMasked
00000c  b120              CBZ      r0,|L31.24|
                  |L31.14|
;;;1908       EvrRtxThreadFlagsGet(0U);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       EvrRtxThreadFlagsGet
;;;1909       thread_flags = 0U;
000014  2000              MOVS     r0,#0
;;;1910     } else {
;;;1911       thread_flags = __svcThreadFlagsGet();
;;;1912     }
;;;1913     return thread_flags;
;;;1914   }
000016  bd10              POP      {r4,pc}
                  |L31.24|
000018  f8dfc004          LDR      r12,|L31.32|
00001c  df00              SVC      #0x0
00001e  bd10              POP      {r4,pc}
;;;1915   
                          ENDP

                  |L31.32|
                          DCD      svcRtxThreadFlagsGet

                          AREA ||i.osThreadFlagsSet||, CODE, READONLY, ALIGN=2

                  osThreadFlagsSet PROC
;;;1876   /// Set the specified Thread Flags of a thread.
;;;1877   uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1878     uint32_t thread_flags;
;;;1879   
;;;1880     EvrRtxThreadFlagsSet(thread_id, flags);
000006  f7fffffe          BL       EvrRtxThreadFlagsSet
;;;1881     if (IsException() || IsIrqMasked()) {
00000a  f7fffffe          BL       IsException
00000e  b910              CBNZ     r0,|L32.22|
000010  f7fffffe          BL       IsIrqMasked
000014  b300              CBZ      r0,|L32.88|
                  |L32.22|
;;;1882       thread_flags = isrRtxThreadFlagsSet(thread_id, flags);
000016  4629              MOV      r1,r5
000018  b124              CBZ      r4,|L32.36|
00001a  7820              LDRB     r0,[r4,#0]
00001c  28f1              CMP      r0,#0xf1
00001e  d101              BNE      |L32.36|
000020  2900              CMP      r1,#0
000022  da02              BGE      |L32.42|
                  |L32.36|
000024  f06f0503          MVN      r5,#3
000028  e011              B        |L32.78|
                  |L32.42|
00002a  7860              LDRB     r0,[r4,#1]
00002c  2804              CMP      r0,#4
00002e  d00c              BEQ      |L32.74|
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       ThreadFlagsSet
000036  4605              MOV      r5,r0
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       osRtxPostProcess
00003e  4629              MOV      r1,r5
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       EvrRtxThreadFlagsSetDone
                  |L32.70|
000046  4628              MOV      r0,r5
;;;1883     } else {
;;;1884       thread_flags =  __svcThreadFlagsSet(thread_id, flags);
;;;1885     }
;;;1886     return thread_flags;
;;;1887   }
000048  bd70              POP      {r4-r6,pc}
                  |L32.74|
00004a  f06f0502          MVN      r5,#2
                  |L32.78|
00004e  4629              MOV      r1,r5
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       EvrRtxThreadFlagsError
000056  e7f6              B        |L32.70|
                  |L32.88|
000058  4620              MOV      r0,r4                 ;1884
00005a  4629              MOV      r1,r5                 ;1884
00005c  f8dfc004          LDR      r12,|L32.100|
000060  df00              SVC      #0x0                  ;1884
000062  bd70              POP      {r4-r6,pc}
;;;1888   
                          ENDP

                  |L32.100|
                          DCD      svcRtxThreadFlagsSet

                          AREA ||i.osThreadFlagsWait||, CODE, READONLY, ALIGN=2

                  osThreadFlagsWait PROC
;;;1916   /// Wait for one or more Thread Flags of the current running thread to become signaled.
;;;1917   uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
000000  b570              PUSH     {r4-r6,lr}
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;1918     uint32_t thread_flags;
;;;1919   
;;;1920     EvrRtxThreadFlagsWait(flags, options, timeout);
000008  f7fffffe          BL       EvrRtxThreadFlagsWait
;;;1921     if (IsException() || IsIrqMasked()) {
00000c  f7fffffe          BL       IsException
000010  b910              CBNZ     r0,|L33.24|
000012  f7fffffe          BL       IsIrqMasked
000016  b138              CBZ      r0,|L33.40|
                  |L33.24|
;;;1922       EvrRtxThreadFlagsError(NULL, (int32_t)osErrorISR);
000018  f06f0405          MVN      r4,#5
00001c  4621              MOV      r1,r4
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       EvrRtxThreadFlagsError
;;;1923       thread_flags = (uint32_t)osErrorISR;
000024  4620              MOV      r0,r4
;;;1924     } else {
;;;1925       thread_flags = __svcThreadFlagsWait(flags, options, timeout);
;;;1926     }
;;;1927     return thread_flags;
;;;1928   }
000026  bd70              POP      {r4-r6,pc}
                  |L33.40|
000028  4630              MOV      r0,r6                 ;1925
00002a  4629              MOV      r1,r5                 ;1925
00002c  4622              MOV      r2,r4                 ;1925
00002e  f8dfc008          LDR      r12,|L33.56|
000032  df00              SVC      #0x0                  ;1925
000034  bd70              POP      {r4-r6,pc}
                          ENDP

000036  0000              DCW      0x0000
                  |L33.56|
                          DCD      svcRtxThreadFlagsWait

                          AREA ||i.osThreadGetCount||, CODE, READONLY, ALIGN=2

                  osThreadGetCount PROC
;;;1850   /// Get number of active threads.
;;;1851   uint32_t osThreadGetCount (void) {
000000  b510              PUSH     {r4,lr}
;;;1852     uint32_t count;
;;;1853   
;;;1854     if (IsException() || IsIrqMasked()) {
000002  f7fffffe          BL       IsException
000006  b910              CBNZ     r0,|L34.14|
000008  f7fffffe          BL       IsIrqMasked
00000c  b120              CBZ      r0,|L34.24|
                  |L34.14|
;;;1855       EvrRtxThreadGetCount(0U);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       EvrRtxThreadGetCount
;;;1856       count = 0U;
000014  2000              MOVS     r0,#0
;;;1857     } else {
;;;1858       count = __svcThreadGetCount();
;;;1859     }
;;;1860     return count;
;;;1861   }
000016  bd10              POP      {r4,pc}
                  |L34.24|
000018  f8dfc004          LDR      r12,|L34.32|
00001c  df00              SVC      #0x0
00001e  bd10              POP      {r4,pc}
;;;1862   
                          ENDP

                  |L34.32|
                          DCD      svcRtxThreadGetCount

                          AREA ||i.osThreadGetId||, CODE, READONLY, ALIGN=2

                  osThreadGetId PROC
;;;1680   /// Return the thread ID of the current running thread.
;;;1681   osThreadId_t osThreadGetId (void) {
000000  b510              PUSH     {r4,lr}
;;;1682     osThreadId_t thread_id;
;;;1683   
;;;1684     if (IsException() || IsIrqMasked()) {
000002  f7fffffe          BL       IsException
000006  b910              CBNZ     r0,|L35.14|
000008  f7fffffe          BL       IsIrqMasked
00000c  b118              CBZ      r0,|L35.22|
                  |L35.14|
;;;1685       thread_id = svcRtxThreadGetId();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      svcRtxThreadGetId
                  |L35.22|
000016  f8dfc008          LDR      r12,|L35.32|
00001a  df00              SVC      #0x0
;;;1686     } else {
;;;1687       thread_id =  __svcThreadGetId();
;;;1688     }
;;;1689     return thread_id;
;;;1690   }
00001c  bd10              POP      {r4,pc}
;;;1691   
                          ENDP

00001e  0000              DCW      0x0000
                  |L35.32|
                          DCD      svcRtxThreadGetId

                          AREA ||i.osThreadGetName||, CODE, READONLY, ALIGN=2

                  osThreadGetName PROC
;;;1667   /// Get name of a thread.
;;;1668   const char *osThreadGetName (osThreadId_t thread_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1669     const char *name;
;;;1670   
;;;1671     if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L36.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b128              CBZ      r0,|L36.28|
                  |L36.16|
;;;1672       EvrRtxThreadGetName(thread_id, NULL);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxThreadGetName
;;;1673       name = NULL;
000018  2000              MOVS     r0,#0
;;;1674     } else {
;;;1675       name = __svcThreadGetName(thread_id);
;;;1676     }
;;;1677     return name;
;;;1678   }
00001a  bd10              POP      {r4,pc}
                  |L36.28|
00001c  4620              MOV      r0,r4                 ;1675
00001e  f8dfc008          LDR      r12,|L36.40|
000022  df00              SVC      #0x0                  ;1675
000024  bd10              POP      {r4,pc}
;;;1679   
                          ENDP

000026  0000              DCW      0x0000
                  |L36.40|
                          DCD      svcRtxThreadGetName

                          AREA ||i.osThreadGetPriority||, CODE, READONLY, ALIGN=2

                  osThreadGetPriority PROC
;;;1745   /// Get current priority of a thread.
;;;1746   osPriority_t osThreadGetPriority (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1747     osPriority_t priority;
;;;1748   
;;;1749     if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L37.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b138              CBZ      r0,|L37.32|
                  |L37.16|
;;;1750       EvrRtxThreadGetPriority(thread_id, osPriorityError);
000010  f04f35ff          MOV      r5,#0xffffffff
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       EvrRtxThreadGetPriority
;;;1751       priority = osPriorityError;
00001c  4628              MOV      r0,r5
;;;1752     } else {
;;;1753       priority = __svcThreadGetPriority(thread_id);
;;;1754     }
;;;1755     return priority;
;;;1756   }
00001e  bd70              POP      {r4-r6,pc}
                  |L37.32|
000020  4620              MOV      r0,r4                 ;1753
000022  f8dfc008          LDR      r12,|L37.44|
000026  df00              SVC      #0x0                  ;1753
000028  bd70              POP      {r4-r6,pc}
;;;1757   
                          ENDP

00002a  0000              DCW      0x0000
                  |L37.44|
                          DCD      svcRtxThreadGetPriority

                          AREA ||i.osThreadGetStackSize||, CODE, READONLY, ALIGN=2

                  osThreadGetStackSize PROC
;;;1705   /// Get stack size of a thread.
;;;1706   uint32_t osThreadGetStackSize (osThreadId_t thread_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1707     uint32_t stack_size;
;;;1708   
;;;1709     if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L38.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b128              CBZ      r0,|L38.28|
                  |L38.16|
;;;1710       EvrRtxThreadGetStackSize(thread_id, 0U);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxThreadGetStackSize
;;;1711       stack_size = 0U;
000018  2000              MOVS     r0,#0
;;;1712     } else {
;;;1713       stack_size = __svcThreadGetStackSize(thread_id);
;;;1714     }
;;;1715     return stack_size;
;;;1716   }
00001a  bd10              POP      {r4,pc}
                  |L38.28|
00001c  4620              MOV      r0,r4                 ;1713
00001e  f8dfc008          LDR      r12,|L38.40|
000022  df00              SVC      #0x0                  ;1713
000024  bd10              POP      {r4,pc}
;;;1717   
                          ENDP

000026  0000              DCW      0x0000
                  |L38.40|
                          DCD      svcRtxThreadGetStackSize

                          AREA ||i.osThreadGetStackSpace||, CODE, READONLY, ALIGN=2

                  osThreadGetStackSpace PROC
;;;1718   /// Get available stack space of a thread based on stack watermark recording during execution.
;;;1719   uint32_t osThreadGetStackSpace (osThreadId_t thread_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1720     uint32_t stack_space;
;;;1721   
;;;1722     if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L39.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b128              CBZ      r0,|L39.28|
                  |L39.16|
;;;1723       EvrRtxThreadGetStackSpace(thread_id, 0U);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxThreadGetStackSpace
;;;1724       stack_space = 0U;
000018  2000              MOVS     r0,#0
;;;1725     } else {
;;;1726       stack_space = __svcThreadGetStackSpace(thread_id);
;;;1727     }
;;;1728     return stack_space;
;;;1729   }
00001a  bd10              POP      {r4,pc}
                  |L39.28|
00001c  4620              MOV      r0,r4                 ;1726
00001e  f8dfc008          LDR      r12,|L39.40|
000022  df00              SVC      #0x0                  ;1726
000024  bd10              POP      {r4,pc}
;;;1730   
                          ENDP

000026  0000              DCW      0x0000
                  |L39.40|
                          DCD      svcRtxThreadGetStackSpace

                          AREA ||i.osThreadGetState||, CODE, READONLY, ALIGN=2

                  osThreadGetState PROC
;;;1692   /// Get current thread state of a thread.
;;;1693   osThreadState_t osThreadGetState (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1694     osThreadState_t state;
;;;1695   
;;;1696     if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L40.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b138              CBZ      r0,|L40.32|
                  |L40.16|
;;;1697       EvrRtxThreadGetState(thread_id, osThreadError);
000010  f04f35ff          MOV      r5,#0xffffffff
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       EvrRtxThreadGetState
;;;1698       state = osThreadError;
00001c  4628              MOV      r0,r5
;;;1699     } else {
;;;1700       state = __svcThreadGetState(thread_id);
;;;1701     }
;;;1702     return state;
;;;1703   }
00001e  bd70              POP      {r4-r6,pc}
                  |L40.32|
000020  4620              MOV      r0,r4                 ;1700
000022  f8dfc008          LDR      r12,|L40.44|
000026  df00              SVC      #0x0                  ;1700
000028  bd70              POP      {r4-r6,pc}
;;;1704   
                          ENDP

00002a  0000              DCW      0x0000
                  |L40.44|
                          DCD      svcRtxThreadGetState

                          AREA ||i.osThreadJoin||, CODE, READONLY, ALIGN=2

                  osThreadJoin PROC
;;;1814   /// Wait for specified thread to terminate.
;;;1815   osStatus_t osThreadJoin (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1816     osStatus_t status;
;;;1817   
;;;1818     EvrRtxThreadJoin(thread_id);
000004  f7fffffe          BL       EvrRtxThreadJoin
;;;1819     if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L41.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L41.36|
                  |L41.20|
;;;1820       EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxThreadError
;;;1821       status = osErrorISR;
000020  4628              MOV      r0,r5
;;;1822     } else {
;;;1823       status = __svcThreadJoin(thread_id);
;;;1824     }
;;;1825     return status;
;;;1826   }
000022  bd70              POP      {r4-r6,pc}
                  |L41.36|
000024  4620              MOV      r0,r4                 ;1823
000026  f8dfc008          LDR      r12,|L41.48|
00002a  df00              SVC      #0x0                  ;1823
00002c  bd70              POP      {r4-r6,pc}
;;;1827   
                          ENDP

00002e  0000              DCW      0x0000
                  |L41.48|
                          DCD      svcRtxThreadJoin

                          AREA ||i.osThreadNew||, CODE, READONLY, ALIGN=2

                  osThreadNew PROC
;;;1653   /// Create a thread and add it to Active Threads.
;;;1654   osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
000000  b570              PUSH     {r4-r6,lr}
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;1655     osThreadId_t thread_id;
;;;1656   
;;;1657     EvrRtxThreadNew(func, argument, attr);
000008  f7fffffe          BL       EvrRtxThreadNew
;;;1658     if (IsException() || IsIrqMasked()) {
00000c  f7fffffe          BL       IsException
000010  b910              CBNZ     r0,|L42.24|
000012  f7fffffe          BL       IsIrqMasked
000016  b130              CBZ      r0,|L42.38|
                  |L42.24|
;;;1659       EvrRtxThreadError(NULL, (int32_t)osErrorISR);
000018  f06f0105          MVN      r1,#5
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       EvrRtxThreadError
;;;1660       thread_id = NULL;
000022  2000              MOVS     r0,#0
;;;1661     } else {
;;;1662       thread_id = __svcThreadNew(func, argument, attr);
;;;1663     }
;;;1664     return thread_id;
;;;1665   }
000024  bd70              POP      {r4-r6,pc}
                  |L42.38|
000026  4630              MOV      r0,r6                 ;1662
000028  4629              MOV      r1,r5                 ;1662
00002a  4622              MOV      r2,r4                 ;1662
00002c  f8dfc004          LDR      r12,|L42.52|
000030  df00              SVC      #0x0                  ;1662
000032  bd70              POP      {r4-r6,pc}
;;;1666   
                          ENDP

                  |L42.52|
                          DCD      svcRtxThreadNew

                          AREA ||i.osThreadResume||, CODE, READONLY, ALIGN=2

                  osThreadResume PROC
;;;1786   /// Resume execution of a thread.
;;;1787   osStatus_t osThreadResume (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1788     osStatus_t status;
;;;1789   
;;;1790     EvrRtxThreadResume(thread_id);
000004  f7fffffe          BL       EvrRtxThreadResume
;;;1791     if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L43.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L43.36|
                  |L43.20|
;;;1792       EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxThreadError
;;;1793       status = osErrorISR;
000020  4628              MOV      r0,r5
;;;1794     } else {
;;;1795       status = __svcThreadResume(thread_id);
;;;1796     }
;;;1797     return status;
;;;1798   }
000022  bd70              POP      {r4-r6,pc}
                  |L43.36|
000024  4620              MOV      r0,r4                 ;1795
000026  f8dfc008          LDR      r12,|L43.48|
00002a  df00              SVC      #0x0                  ;1795
00002c  bd70              POP      {r4-r6,pc}
;;;1799   
                          ENDP

00002e  0000              DCW      0x0000
                  |L43.48|
                          DCD      svcRtxThreadResume

                          AREA ||i.osThreadSetPriority||, CODE, READONLY, ALIGN=2

                  osThreadSetPriority PROC
;;;1731   /// Change priority of a thread.
;;;1732   osStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;1733     osStatus_t status;
;;;1734   
;;;1735     EvrRtxThreadSetPriority(thread_id, priority);
000006  f7fffffe          BL       EvrRtxThreadSetPriority
;;;1736     if (IsException() || IsIrqMasked()) {
00000a  f7fffffe          BL       IsException
00000e  b910              CBNZ     r0,|L44.22|
000010  f7fffffe          BL       IsIrqMasked
000014  b138              CBZ      r0,|L44.38|
                  |L44.22|
;;;1737       EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
000016  f06f0405          MVN      r4,#5
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       EvrRtxThreadError
;;;1738       status = osErrorISR;
000022  4620              MOV      r0,r4
;;;1739     } else {
;;;1740       status = __svcThreadSetPriority(thread_id, priority);
;;;1741     }
;;;1742     return status;
;;;1743   }
000024  bd70              POP      {r4-r6,pc}
                  |L44.38|
000026  4628              MOV      r0,r5                 ;1740
000028  4621              MOV      r1,r4                 ;1740
00002a  f8dfc008          LDR      r12,|L44.52|
00002e  df00              SVC      #0x0                  ;1740
000030  bd70              POP      {r4-r6,pc}
;;;1744   
                          ENDP

000032  0000              DCW      0x0000
                  |L44.52|
                          DCD      svcRtxThreadSetPriority

                          AREA ||i.osThreadSuspend||, CODE, READONLY, ALIGN=2

                  osThreadSuspend PROC
;;;1772   /// Suspend execution of a thread.
;;;1773   osStatus_t osThreadSuspend (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1774     osStatus_t status;
;;;1775   
;;;1776     EvrRtxThreadSuspend(thread_id);
000004  f7fffffe          BL       EvrRtxThreadSuspend
;;;1777     if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L45.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L45.36|
                  |L45.20|
;;;1778       EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxThreadError
;;;1779       status = osErrorISR;
000020  4628              MOV      r0,r5
;;;1780     } else {
;;;1781       status = __svcThreadSuspend(thread_id);
;;;1782     }
;;;1783     return status;
;;;1784   }
000022  bd70              POP      {r4-r6,pc}
                  |L45.36|
000024  4620              MOV      r0,r4                 ;1781
000026  f8dfc008          LDR      r12,|L45.48|
00002a  df00              SVC      #0x0                  ;1781
00002c  bd70              POP      {r4-r6,pc}
;;;1785   
                          ENDP

00002e  0000              DCW      0x0000
                  |L45.48|
                          DCD      svcRtxThreadSuspend

                          AREA ||i.osThreadTerminate||, CODE, READONLY, ALIGN=2

                  osThreadTerminate PROC
;;;1836   /// Terminate execution of a thread.
;;;1837   osStatus_t osThreadTerminate (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1838     osStatus_t status;
;;;1839   
;;;1840     EvrRtxThreadTerminate(thread_id);
000004  f7fffffe          BL       EvrRtxThreadTerminate
;;;1841     if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L46.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L46.36|
                  |L46.20|
;;;1842       EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxThreadError
;;;1843       status = osErrorISR;
000020  4628              MOV      r0,r5
;;;1844     } else {
;;;1845       status = __svcThreadTerminate(thread_id);
;;;1846     }
;;;1847     return status;
;;;1848   }
000022  bd70              POP      {r4-r6,pc}
                  |L46.36|
000024  4620              MOV      r0,r4                 ;1845
000026  f8dfc008          LDR      r12,|L46.48|
00002a  df00              SVC      #0x0                  ;1845
00002c  bd70              POP      {r4-r6,pc}
;;;1849   
                          ENDP

00002e  0000              DCW      0x0000
                  |L46.48|
                          DCD      svcRtxThreadTerminate

                          AREA ||i.osThreadYield||, CODE, READONLY, ALIGN=2

                  osThreadYield PROC
;;;1758   /// Pass control to next thread that is in state READY.
;;;1759   osStatus_t osThreadYield (void) {
000000  b510              PUSH     {r4,lr}
;;;1760     osStatus_t status;
;;;1761   
;;;1762     EvrRtxThreadYield();
000002  f7fffffe          BL       EvrRtxThreadYield
;;;1763     if (IsException() || IsIrqMasked()) {
000006  f7fffffe          BL       IsException
00000a  b910              CBNZ     r0,|L47.18|
00000c  f7fffffe          BL       IsIrqMasked
000010  b138              CBZ      r0,|L47.34|
                  |L47.18|
;;;1764       EvrRtxThreadError(NULL, (int32_t)osErrorISR);
000012  f06f0405          MVN      r4,#5
000016  4621              MOV      r1,r4
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       EvrRtxThreadError
;;;1765       status = osErrorISR;
00001e  4620              MOV      r0,r4
;;;1766     } else {
;;;1767       status = __svcThreadYield();
;;;1768     }
;;;1769     return status;
;;;1770   }
000020  bd10              POP      {r4,pc}
                  |L47.34|
000022  f8dfc008          LDR      r12,|L47.44|
000026  df00              SVC      #0x0
000028  bd10              POP      {r4,pc}
;;;1771   
                          ENDP

00002a  0000              DCW      0x0000
                  |L47.44|
                          DCD      svcRtxThreadYield

                          AREA ||i.svcRtxThreadDetach||, CODE, READONLY, ALIGN=2

                  svcRtxThreadDetach PROC
;;;1150   /// \note API identical to osThreadDetach
;;;1151   static osStatus_t svcRtxThreadDetach (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;1152     os_thread_t *thread = osRtxThreadId(thread_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L48.12|
;;;1153   
;;;1154     // Check parameters
;;;1155     if ((thread == NULL) || (thread->id != osRtxIdThread)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f1              CMP      r0,#0xf1
00000a  d007              BEQ      |L48.28|
                  |L48.12|
;;;1156       EvrRtxThreadError(thread, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxThreadError
;;;1157       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1158       return osErrorParameter;
000018  4628              MOV      r0,r5
;;;1159     }
;;;1160   
;;;1161     // Check object attributes
;;;1162     if ((thread->attr & osThreadJoinable) == 0U) {
;;;1163       EvrRtxThreadError(thread, osRtxErrorThreadNotJoinable);
;;;1164       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1165       return osErrorResource;
;;;1166     }
;;;1167   
;;;1168     if (thread->state == osRtxThreadTerminated) {
;;;1169       osRtxThreadListUnlink(&osRtxInfo.thread.terminate_list, thread);
;;;1170       osRtxThreadFree(thread);
;;;1171     } else {
;;;1172       thread->attr &= ~osThreadJoinable;
;;;1173     }
;;;1174   
;;;1175     EvrRtxThreadDetached(thread);
;;;1176   
;;;1177     return osOK;
;;;1178   }
00001a  bd70              POP      {r4-r6,pc}
                  |L48.28|
00001c  78e0              LDRB     r0,[r4,#3]            ;1162
00001e  07c1              LSLS     r1,r0,#31             ;1162
000020  d00a              BEQ      |L48.56|
000022  7861              LDRB     r1,[r4,#1]            ;1168
000024  2904              CMP      r1,#4                 ;1168
000026  d00f              BEQ      |L48.72|
000028  f0200001          BIC      r0,r0,#1              ;1172
00002c  70e0              STRB     r0,[r4,#3]            ;1172
                  |L48.46|
00002e  4620              MOV      r0,r4                 ;1175
000030  f7fffffe          BL       EvrRtxThreadDetached
000034  2000              MOVS     r0,#0                 ;1177
000036  bd70              POP      {r4-r6,pc}
                  |L48.56|
000038  f06f010c          MVN      r1,#0xc               ;1163
00003c  4620              MOV      r0,r4                 ;1163
00003e  f7fffffe          BL       EvrRtxThreadError
000042  f06f0002          MVN      r0,#2                 ;1165
000046  bd70              POP      {r4-r6,pc}
                  |L48.72|
000048  4621              MOV      r1,r4                 ;1169
00004a  4803              LDR      r0,|L48.88|
00004c  f7fffffe          BL       osRtxThreadListUnlink
000050  4620              MOV      r0,r4                 ;1170
000052  f7fffffe          BL       osRtxThreadFree
000056  e7ea              B        |L48.46|
;;;1179   
                          ENDP

                  |L48.88|
                          DCD      osRtxInfo+0x34

                          AREA ||i.svcRtxThreadEnumerate||, CODE, READONLY, ALIGN=2

                  svcRtxThreadEnumerate PROC
;;;1377   /// \note API identical to osThreadEnumerate
;;;1378   static uint32_t svcRtxThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
000000  b510              PUSH     {r4,lr}
000002  b130              CBZ      r0,|L49.18|
;;;1379     os_thread_t *thread;
;;;1380     uint32_t     count;
;;;1381   
;;;1382     // Check parameters
;;;1383     if ((thread_array == NULL) || (array_items == 0U)) {
000004  b129              CBZ      r1,|L49.18|
000006  4b14              LDR      r3,|L49.88|
;;;1384       EvrRtxThreadEnumerate(thread_array, array_items, 0U);
;;;1385       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1386       return 0U;
;;;1387     }
;;;1388   
;;;1389     // Running Thread
;;;1390     *thread_array = osRtxThreadGetRunning();
;;;1391      thread_array++;
;;;1392      count = 1U;
000008  2401              MOVS     r4,#1
00000a  695a              LDR      r2,[r3,#0x14]         ;1390  ; osRtxInfo
00000c  c004              STM      r0!,{r2}              ;1390
;;;1393   
;;;1394     // Ready List
;;;1395     for (thread = osRtxInfo.thread.ready.thread_list;
00000e  6a5a              LDR      r2,[r3,#0x24]  ; osRtxInfo
000010  e007              B        |L49.34|
                  |L49.18|
000012  2200              MOVS     r2,#0                 ;1384
000014  f7fffffe          BL       EvrRtxThreadEnumerate
000018  2000              MOVS     r0,#0                 ;1386
;;;1396          (thread != NULL) && (count < array_items); thread = thread->thread_next) {
;;;1397       *thread_array = thread;
;;;1398        thread_array++;
;;;1399        count++;
;;;1400     }
;;;1401   
;;;1402     // Delay List
;;;1403     for (thread = osRtxInfo.thread.delay_list;
;;;1404          (thread != NULL) && (count < array_items); thread = thread->delay_next) {
;;;1405       *thread_array = thread;
;;;1406        thread_array++;
;;;1407        count++;
;;;1408     }
;;;1409   
;;;1410     // Wait List
;;;1411     for (thread = osRtxInfo.thread.wait_list;
;;;1412          (thread != NULL) && (count < array_items); thread = thread->delay_next) {
;;;1413       *thread_array = thread;
;;;1414        thread_array++;
;;;1415        count++;
;;;1416     }
;;;1417   
;;;1418     EvrRtxThreadEnumerate(thread_array - count, array_items, count);
;;;1419   
;;;1420     return count;
;;;1421   }
00001a  bd10              POP      {r4,pc}
                  |L49.28|
00001c  c004              STM      r0!,{r2}              ;1397
00001e  6892              LDR      r2,[r2,#8]            ;1396
000020  1c64              ADDS     r4,r4,#1              ;1396
                  |L49.34|
000022  b10a              CBZ      r2,|L49.40|
000024  428c              CMP      r4,r1                 ;1396
000026  d3f9              BCC      |L49.28|
                  |L49.40|
000028  6ada              LDR      r2,[r3,#0x2c]         ;1403  ; osRtxInfo
00002a  e002              B        |L49.50|
                  |L49.44|
00002c  c004              STM      r0!,{r2}              ;1405
00002e  6912              LDR      r2,[r2,#0x10]         ;1404
000030  1c64              ADDS     r4,r4,#1              ;1404
                  |L49.50|
000032  b10a              CBZ      r2,|L49.56|
000034  428c              CMP      r4,r1                 ;1404
000036  d3f9              BCC      |L49.44|
                  |L49.56|
000038  6b1a              LDR      r2,[r3,#0x30]         ;1411  ; osRtxInfo
00003a  e002              B        |L49.66|
                  |L49.60|
00003c  c004              STM      r0!,{r2}              ;1413
00003e  6912              LDR      r2,[r2,#0x10]         ;1412
000040  1c64              ADDS     r4,r4,#1              ;1412
                  |L49.66|
000042  b10a              CBZ      r2,|L49.72|
000044  428c              CMP      r4,r1                 ;1412
000046  d3f9              BCC      |L49.60|
                  |L49.72|
000048  eba00084          SUB      r0,r0,r4,LSL #2       ;1418
00004c  4622              MOV      r2,r4                 ;1418
00004e  f7fffffe          BL       EvrRtxThreadEnumerate
000052  4620              MOV      r0,r4                 ;1420
000054  bd10              POP      {r4,pc}
;;;1422   
                          ENDP

000056  0000              DCW      0x0000
                  |L49.88|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxThreadExit||, CODE, READONLY, ALIGN=2

                  svcRtxThreadExit PROC
;;;1231   /// \note API identical to osThreadExit
;;;1232   static void svcRtxThreadExit (void) {
000000  b570              PUSH     {r4-r6,lr}
000002  4c14              LDR      r4,|L50.84|
000004  7a20              LDRB     r0,[r4,#8]  ; osRtxInfo
;;;1233     os_thread_t *thread;
;;;1234   
;;;1235     // Check if switch to next Ready Thread is possible
;;;1236     if ((osRtxKernelGetState() != osRtxKernelRunning) ||
000006  2802              CMP      r0,#2
000008  d123              BNE      |L50.82|
;;;1237         (osRtxInfo.thread.ready.thread_list == NULL)) {
00000a  6a60              LDR      r0,[r4,#0x24]  ; osRtxInfo
00000c  2800              CMP      r0,#0
00000e  d020              BEQ      |L50.82|
;;;1238       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1239       return;
;;;1240     }
;;;1241   
;;;1242     // Get running thread
;;;1243     thread = osRtxThreadGetRunning();
;;;1244   
;;;1245     // Release owned Mutexes
;;;1246     osRtxMutexOwnerRelease(thread->mutex_list);
000010  6965              LDR      r5,[r4,#0x14]  ; osRtxInfo
000012  6ae8              LDR      r0,[r5,#0x2c]
000014  f7fffffe          BL       osRtxMutexOwnerRelease
;;;1247   
;;;1248     // Wakeup Thread waiting to Join
;;;1249     osRtxThreadJoinWakeup(thread);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       osRtxThreadJoinWakeup
;;;1250   
;;;1251     // Switch to next Ready Thread
;;;1252     osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
00001e  f104001c          ADD      r0,r4,#0x1c
000022  f7fffffe          BL       osRtxThreadListGet
000026  f7fffffe          BL       osRtxThreadSwitch
00002a  f3ef8009          MRS      r0,PSP
;;;1253   
;;;1254     // Update Stack Pointer
;;;1255     thread->sp = __get_PSP();
;;;1256   #ifdef RTX_STACK_CHECK
;;;1257     // Check Stack usage
;;;1258     if (!osRtxThreadStackCheck(thread)) {
00002e  63a8              STR      r0,[r5,#0x38]
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       osRtxThreadStackCheck
000036  b928              CBNZ     r0,|L50.68|
000038  69a0              LDR      r0,[r4,#0x18]  ; osRtxInfo
;;;1259       osRtxThreadSetRunning(osRtxInfo.thread.run.next);
;;;1260       (void)osRtxKernelErrorNotify(osRtxErrorStackOverflow, thread);
00003a  6160              STR      r0,[r4,#0x14]  ; osRtxInfo
00003c  4629              MOV      r1,r5
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       osRtxKernelErrorNotify
                  |L50.68|
;;;1261     }
;;;1262   #endif
;;;1263   
;;;1264     // Mark running thread as deleted
;;;1265     osRtxThreadSetRunning(NULL);
000044  2000              MOVS     r0,#0
;;;1266   
;;;1267     // Destroy Thread
;;;1268     osRtxThreadDestroy(thread);
000046  6160              STR      r0,[r4,#0x14]  ; osRtxInfo
000048  4628              MOV      r0,r5
00004a  e8bd4070          POP      {r4-r6,lr}
00004e  f7ffbffe          B.W      osRtxThreadDestroy
                  |L50.82|
;;;1269   }
000052  bd70              POP      {r4-r6,pc}
;;;1270   
                          ENDP

                  |L50.84|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxThreadFlagsClear||, CODE, READONLY, ALIGN=2

                  svcRtxThreadFlagsClear PROC
;;;1468   /// \note API identical to osThreadFlagsClear
;;;1469   static uint32_t svcRtxThreadFlagsClear (uint32_t flags) {
000000  4601              MOV      r1,r0
000002  480e              LDR      r0,|L51.60|
000004  b510              PUSH     {r4,lr}
000006  6940              LDR      r0,[r0,#0x14]  ; osRtxInfo
000008  b138              CBZ      r0,|L51.26|
;;;1470     os_thread_t *thread;
;;;1471     uint32_t     thread_flags;
;;;1472   
;;;1473     // Check running thread
;;;1474     thread = osRtxThreadGetRunning();
;;;1475     if (thread == NULL) {
;;;1476       EvrRtxThreadFlagsError(NULL, osRtxErrorKernelNotRunning);
;;;1477       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1478       return ((uint32_t)osError);
;;;1479     }
;;;1480   
;;;1481     // Check parameters
;;;1482     if ((flags & ~(((uint32_t)1U << osRtxThreadFlagsLimit) - 1U)) != 0U) {
00000a  2900              CMP      r1,#0
00000c  da0d              BGE      |L51.42|
;;;1483       EvrRtxThreadFlagsError(thread, (int32_t)osErrorParameter);
00000e  f06f0403          MVN      r4,#3
000012  4621              MOV      r1,r4
000014  f7fffffe          BL       EvrRtxThreadFlagsError
;;;1484       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1485       return ((uint32_t)osErrorParameter);
000018  e00d              B        |L51.54|
                  |L51.26|
00001a  f06f0107          MVN      r1,#7                 ;1476
00001e  2000              MOVS     r0,#0                 ;1476
000020  f7fffffe          BL       EvrRtxThreadFlagsError
000024  f04f30ff          MOV      r0,#0xffffffff        ;1478
;;;1486     }
;;;1487   
;;;1488     // Clear Thread Flags
;;;1489     thread_flags = ThreadFlagsClear(thread, flags);
;;;1490   
;;;1491     EvrRtxThreadFlagsClearDone(thread_flags);
;;;1492   
;;;1493     return thread_flags;
;;;1494   }
000028  bd10              POP      {r4,pc}
                  |L51.42|
00002a  3028              ADDS     r0,r0,#0x28
00002c  f7fffffe          BL       __asm___12_rtx_thread_c_3927f09d__atomic_clr32
000030  4604              MOV      r4,r0                 ;1489
000032  f7fffffe          BL       EvrRtxThreadFlagsClearDone
                  |L51.54|
000036  4620              MOV      r0,r4                 ;1493
000038  bd10              POP      {r4,pc}
;;;1495   
                          ENDP

00003a  0000              DCW      0x0000
                  |L51.60|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxThreadFlagsGet||, CODE, READONLY, ALIGN=2

                  svcRtxThreadFlagsGet PROC
;;;1497   /// \note API identical to osThreadFlagsGet
;;;1498   static uint32_t svcRtxThreadFlagsGet (void) {
000000  4806              LDR      r0,|L52.28|
000002  b510              PUSH     {r4,lr}
000004  6944              LDR      r4,[r0,#0x14]  ; osRtxInfo
000006  b124              CBZ      r4,|L52.18|
;;;1499     const os_thread_t *thread;
;;;1500   
;;;1501     // Check running thread
;;;1502     thread = osRtxThreadGetRunning();
;;;1503     if (thread == NULL) {
;;;1504       EvrRtxThreadFlagsGet(0U);
;;;1505       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1506       return 0U;
;;;1507     }
;;;1508   
;;;1509     EvrRtxThreadFlagsGet(thread->thread_flags);
000008  6aa0              LDR      r0,[r4,#0x28]
00000a  f7fffffe          BL       EvrRtxThreadFlagsGet
;;;1510   
;;;1511     return thread->thread_flags;
00000e  6aa0              LDR      r0,[r4,#0x28]
;;;1512   }
000010  bd10              POP      {r4,pc}
                  |L52.18|
000012  2000              MOVS     r0,#0                 ;1504
000014  f7fffffe          BL       EvrRtxThreadFlagsGet
000018  2000              MOVS     r0,#0                 ;1506
00001a  bd10              POP      {r4,pc}
;;;1513   
                          ENDP

                  |L52.28|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxThreadFlagsSet||, CODE, READONLY, ALIGN=1

                  svcRtxThreadFlagsSet PROC
;;;1424   /// \note API identical to osThreadFlagsSet
;;;1425   static uint32_t svcRtxThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
000000  b570              PUSH     {r4-r6,lr}
;;;1426     os_thread_t *thread = osRtxThreadId(thread_id);
000002  0004              MOVS     r4,r0
000004  d004              BEQ      |L53.16|
;;;1427     uint32_t     thread_flags;
;;;1428     uint32_t     thread_flags0;
;;;1429   
;;;1430     // Check parameters
;;;1431     if ((thread == NULL) || (thread->id != osRtxIdThread) ||
000006  7820              LDRB     r0,[r4,#0]
000008  28f1              CMP      r0,#0xf1
00000a  d101              BNE      |L53.16|
;;;1432         ((flags & ~(((uint32_t)1U << osRtxThreadFlagsLimit) - 1U)) != 0U)) {
00000c  2900              CMP      r1,#0
00000e  da02              BGE      |L53.22|
                  |L53.16|
;;;1433       EvrRtxThreadFlagsError(thread, (int32_t)osErrorParameter);
000010  f06f0503          MVN      r5,#3
;;;1434       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1435       return ((uint32_t)osErrorParameter);
000014  e00c              B        |L53.48|
                  |L53.22|
;;;1436     }
;;;1437   
;;;1438     // Check object state
;;;1439     if (thread->state == osRtxThreadTerminated) {
000016  7860              LDRB     r0,[r4,#1]
000018  2804              CMP      r0,#4
00001a  d007              BEQ      |L53.44|
;;;1440       EvrRtxThreadFlagsError(thread, (int32_t)osErrorResource);
;;;1441       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1442       return ((uint32_t)osErrorResource);
;;;1443     }
;;;1444   
;;;1445     // Set Thread Flags
;;;1446     thread_flags = ThreadFlagsSet(thread, flags);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       ThreadFlagsSet
000022  4606              MOV      r6,r0
;;;1447   
;;;1448     // Check if Thread is waiting for Thread Flags
;;;1449     if (thread->state == osRtxThreadWaitingThreadFlags) {
000024  7860              LDRB     r0,[r4,#1]
000026  2833              CMP      r0,#0x33
000028  d008              BEQ      |L53.60|
00002a  e024              B        |L53.118|
                  |L53.44|
00002c  f06f0502          MVN      r5,#2                 ;1440
                  |L53.48|
000030  4629              MOV      r1,r5                 ;1440
000032  4620              MOV      r0,r4                 ;1440
000034  f7fffffe          BL       EvrRtxThreadFlagsError
000038  4628              MOV      r0,r5                 ;1442
;;;1450       thread_flags0 = ThreadFlagsCheck(thread, thread->wait_flags, thread->flags_options);
;;;1451       if (thread_flags0 != 0U) {
;;;1452         if ((thread->flags_options & osFlagsNoClear) == 0U) {
;;;1453           thread_flags = thread_flags0 & ~thread->wait_flags;
;;;1454         } else {
;;;1455           thread_flags = thread_flags0;
;;;1456         }
;;;1457         osRtxThreadWaitExit(thread, thread_flags0, TRUE);
;;;1458         EvrRtxThreadFlagsWaitCompleted(thread->wait_flags, thread->flags_options, thread_flags0, thread);
;;;1459       }
;;;1460     }
;;;1461   
;;;1462     EvrRtxThreadFlagsSetDone(thread, thread_flags);
;;;1463   
;;;1464     return thread_flags;
;;;1465   }
00003a  bd70              POP      {r4-r6,pc}
                  |L53.60|
00003c  f8942023          LDRB     r2,[r4,#0x23]         ;1450
000040  4620              MOV      r0,r4                 ;1450
000042  6a61              LDR      r1,[r4,#0x24]         ;1450
000044  f7fffffe          BL       ThreadFlagsCheck
000048  0005              MOVS     r5,r0                 ;1450
00004a  d014              BEQ      |L53.118|
00004c  f8940023          LDRB     r0,[r4,#0x23]         ;1452
000050  0780              LSLS     r0,r0,#30             ;1452
000052  d403              BMI      |L53.92|
000054  6a60              LDR      r0,[r4,#0x24]         ;1453
000056  ea250600          BIC      r6,r5,r0              ;1453
00005a  e000              B        |L53.94|
                  |L53.92|
00005c  462e              MOV      r6,r5                 ;1455
                  |L53.94|
00005e  2201              MOVS     r2,#1                 ;1457
000060  4629              MOV      r1,r5                 ;1457
000062  4620              MOV      r0,r4                 ;1457
000064  f7fffffe          BL       osRtxThreadWaitExit
000068  f8941023          LDRB     r1,[r4,#0x23]         ;1458
00006c  4623              MOV      r3,r4                 ;1458
00006e  462a              MOV      r2,r5                 ;1458
000070  6a60              LDR      r0,[r4,#0x24]         ;1458
000072  f7fffffe          BL       EvrRtxThreadFlagsWaitCompleted
                  |L53.118|
000076  4631              MOV      r1,r6                 ;1462
000078  4620              MOV      r0,r4                 ;1462
00007a  f7fffffe          BL       EvrRtxThreadFlagsSetDone
00007e  4630              MOV      r0,r6                 ;1464
000080  bd70              POP      {r4-r6,pc}
;;;1466   
                          ENDP


                          AREA ||i.svcRtxThreadFlagsWait||, CODE, READONLY, ALIGN=2

                  svcRtxThreadFlagsWait PROC
;;;1515   /// \note API identical to osThreadFlagsWait
;;;1516   static uint32_t svcRtxThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  4821              LDR      r0,|L54.140|
000008  4690              MOV      r8,r2
00000a  460f              MOV      r7,r1
00000c  6944              LDR      r4,[r0,#0x14]  ; osRtxInfo
00000e  b144              CBZ      r4,|L54.34|
;;;1517     os_thread_t *thread;
;;;1518     uint32_t     thread_flags;
;;;1519   
;;;1520     // Check running thread
;;;1521     thread = osRtxThreadGetRunning();
;;;1522     if (thread == NULL) {
;;;1523       EvrRtxThreadFlagsError(NULL, osRtxErrorKernelNotRunning);
;;;1524       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1525       return ((uint32_t)osError);
;;;1526     }
;;;1527   
;;;1528     // Check parameters
;;;1529     if ((flags & ~(((uint32_t)1U << osRtxThreadFlagsLimit) - 1U)) != 0U) {
000010  2e00              CMP      r6,#0
000012  da0f              BGE      |L54.52|
;;;1530       EvrRtxThreadFlagsError(thread, (int32_t)osErrorParameter);
000014  f06f0503          MVN      r5,#3
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxThreadFlagsError
;;;1531       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1532       return ((uint32_t)osErrorParameter);
000020  e032              B        |L54.136|
                  |L54.34|
000022  f06f0107          MVN      r1,#7                 ;1523
000026  2000              MOVS     r0,#0                 ;1523
000028  f7fffffe          BL       EvrRtxThreadFlagsError
00002c  f04f30ff          MOV      r0,#0xffffffff        ;1525
                  |L54.48|
;;;1533     }
;;;1534   
;;;1535     // Check Thread Flags
;;;1536     thread_flags = ThreadFlagsCheck(thread, flags, options);
;;;1537     if (thread_flags != 0U) {
;;;1538       EvrRtxThreadFlagsWaitCompleted(flags, options, thread_flags, thread);
;;;1539     } else {
;;;1540       // Check if timeout is specified
;;;1541       if (timeout != 0U) {
;;;1542         // Store waiting flags and options
;;;1543         EvrRtxThreadFlagsWaitPending(flags, options, timeout);
;;;1544         thread->wait_flags = flags;
;;;1545         thread->flags_options = (uint8_t)options;
;;;1546         // Suspend current Thread
;;;1547         if (!osRtxThreadWaitEnter(osRtxThreadWaitingThreadFlags, timeout)) {
;;;1548           EvrRtxThreadFlagsWaitTimeout(thread);
;;;1549         }
;;;1550         thread_flags = (uint32_t)osErrorTimeout;
;;;1551       } else {
;;;1552         EvrRtxThreadFlagsWaitNotCompleted(flags, options);
;;;1553         thread_flags = (uint32_t)osErrorResource;
;;;1554       }
;;;1555     }
;;;1556     return thread_flags;
;;;1557   }
000030  e8bd81f0          POP      {r4-r8,pc}
                  |L54.52|
000034  460a              MOV      r2,r1                 ;1536
000036  4631              MOV      r1,r6                 ;1536
000038  4620              MOV      r0,r4                 ;1536
00003a  f7fffffe          BL       ThreadFlagsCheck
00003e  0005              MOVS     r5,r0                 ;1536
000040  d006              BEQ      |L54.80|
000042  4602              MOV      r2,r0                 ;1538
000044  4623              MOV      r3,r4                 ;1538
000046  4639              MOV      r1,r7                 ;1538
000048  4630              MOV      r0,r6                 ;1538
00004a  f7fffffe          BL       EvrRtxThreadFlagsWaitCompleted
00004e  e01b              B        |L54.136|
                  |L54.80|
000050  f1b80000          SUBS     r0,r8,#0              ;1541
000054  d012              BEQ      |L54.124|
000056  4602              MOV      r2,r0                 ;1543
000058  4639              MOV      r1,r7                 ;1543
00005a  4630              MOV      r0,r6                 ;1543
00005c  f7fffffe          BL       EvrRtxThreadFlagsWaitPending
000060  6266              STR      r6,[r4,#0x24]         ;1545
000062  f8847023          STRB     r7,[r4,#0x23]         ;1545
000066  4641              MOV      r1,r8                 ;1547
000068  2033              MOVS     r0,#0x33              ;1547
00006a  f7fffffe          BL       osRtxThreadWaitEnter
00006e  b910              CBNZ     r0,|L54.118|
000070  4620              MOV      r0,r4                 ;1548
000072  f7fffffe          BL       EvrRtxThreadFlagsWaitTimeout
                  |L54.118|
000076  f06f0501          MVN      r5,#1                 ;1550
00007a  e005              B        |L54.136|
                  |L54.124|
00007c  4639              MOV      r1,r7                 ;1552
00007e  4630              MOV      r0,r6                 ;1552
000080  f7fffffe          BL       EvrRtxThreadFlagsWaitNotCompleted
000084  f06f0502          MVN      r5,#2                 ;1553
                  |L54.136|
000088  4628              MOV      r0,r5                 ;1556
00008a  e7d1              B        |L54.48|
;;;1558   
                          ENDP

                  |L54.140|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxThreadGetCount||, CODE, READONLY, ALIGN=2

                  svcRtxThreadGetCount PROC
;;;1345   /// \note API identical to osThreadGetCount
;;;1346   static uint32_t svcRtxThreadGetCount (void) {
000000  b510              PUSH     {r4,lr}
;;;1347     const os_thread_t *thread;
;;;1348           uint32_t     count;
;;;1349   
;;;1350     // Running Thread
;;;1351     count = 1U;
;;;1352   
;;;1353     // Ready List
;;;1354     for (thread = osRtxInfo.thread.ready.thread_list;
000002  490c              LDR      r1,|L55.52|
000004  2401              MOVS     r4,#1                 ;1351
000006  6a48              LDR      r0,[r1,#0x24]         ;1346  ; osRtxInfo
000008  e001              B        |L55.14|
                  |L55.10|
;;;1355          thread != NULL; thread = thread->thread_next) {
00000a  6880              LDR      r0,[r0,#8]
00000c  1c64              ADDS     r4,r4,#1
                  |L55.14|
00000e  2800              CMP      r0,#0
000010  d1fb              BNE      |L55.10|
;;;1356       count++;
;;;1357     }
;;;1358   
;;;1359     // Delay List
;;;1360     for (thread = osRtxInfo.thread.delay_list;
000012  6ac8              LDR      r0,[r1,#0x2c]  ; osRtxInfo
000014  e001              B        |L55.26|
                  |L55.22|
;;;1361          thread != NULL; thread = thread->delay_next) {
000016  6900              LDR      r0,[r0,#0x10]
000018  1c64              ADDS     r4,r4,#1
                  |L55.26|
00001a  2800              CMP      r0,#0
00001c  d1fb              BNE      |L55.22|
;;;1362       count++;
;;;1363     }
;;;1364   
;;;1365     // Wait List
;;;1366     for (thread = osRtxInfo.thread.wait_list;
00001e  6b08              LDR      r0,[r1,#0x30]  ; osRtxInfo
000020  e001              B        |L55.38|
                  |L55.34|
;;;1367          thread != NULL; thread = thread->delay_next) {
000022  6900              LDR      r0,[r0,#0x10]
000024  1c64              ADDS     r4,r4,#1
                  |L55.38|
000026  2800              CMP      r0,#0
000028  d1fb              BNE      |L55.34|
;;;1368       count++;
;;;1369     }
;;;1370   
;;;1371     EvrRtxThreadGetCount(count);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       EvrRtxThreadGetCount
;;;1372   
;;;1373     return count;
000030  4620              MOV      r0,r4
;;;1374   }
000032  bd10              POP      {r4,pc}
;;;1375   
                          ENDP

                  |L55.52|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxThreadGetId||, CODE, READONLY, ALIGN=2

                  svcRtxThreadGetId PROC
;;;832    /// \note API identical to osThreadGetId
;;;833    static osThreadId_t svcRtxThreadGetId (void) {
000000  4803              LDR      r0,|L56.16|
000002  b510              PUSH     {r4,lr}
;;;834      os_thread_t *thread;
;;;835    
;;;836      thread = osRtxThreadGetRunning();
;;;837      EvrRtxThreadGetId(thread);
000004  6944              LDR      r4,[r0,#0x14]  ; osRtxInfo
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       EvrRtxThreadGetId
;;;838      return thread;
00000c  4620              MOV      r0,r4
;;;839    }
00000e  bd10              POP      {r4,pc}
;;;840    
                          ENDP

                  |L56.16|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxThreadGetName||, CODE, READONLY, ALIGN=1

                  svcRtxThreadGetName PROC
;;;815    /// \note API identical to osThreadGetName
;;;816    static const char *svcRtxThreadGetName (osThreadId_t thread_id) {
000000  b510              PUSH     {r4,lr}
;;;817      os_thread_t *thread = osRtxThreadId(thread_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L57.12|
;;;818    
;;;819      // Check parameters
;;;820      if ((thread == NULL) || (thread->id != osRtxIdThread)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f1              CMP      r0,#0xf1
00000a  d005              BEQ      |L57.24|
                  |L57.12|
;;;821        EvrRtxThreadGetName(thread, NULL);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxThreadGetName
;;;822        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;823        return NULL;
000014  2000              MOVS     r0,#0
;;;824      }
;;;825    
;;;826      EvrRtxThreadGetName(thread, thread->name);
;;;827    
;;;828      return thread->name;
;;;829    }
000016  bd10              POP      {r4,pc}
                  |L57.24|
000018  4620              MOV      r0,r4                 ;826
00001a  6861              LDR      r1,[r4,#4]            ;826
00001c  f7fffffe          BL       EvrRtxThreadGetName
000020  6860              LDR      r0,[r4,#4]            ;828
000022  bd10              POP      {r4,pc}
;;;830    
                          ENDP


                          AREA ||i.svcRtxThreadGetPriority||, CODE, READONLY, ALIGN=1

                  svcRtxThreadGetPriority PROC
;;;948    /// \note API identical to osThreadGetPriority
;;;949    static osPriority_t svcRtxThreadGetPriority (osThreadId_t thread_id) {
000000  b510              PUSH     {r4,lr}
;;;950      os_thread_t *thread = osRtxThreadId(thread_id);
;;;951      osPriority_t priority;
;;;952    
;;;953      // Check parameters
;;;954      if ((thread == NULL) || (thread->id != osRtxIdThread)) {
;;;955        EvrRtxThreadGetPriority(thread, osPriorityError);
000002  f04f34ff          MOV      r4,#0xffffffff
000006  b138              CBZ      r0,|L58.24|
000008  7801              LDRB     r1,[r0,#0]            ;954
00000a  29f1              CMP      r1,#0xf1              ;954
00000c  d104              BNE      |L58.24|
;;;956        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;957        return osPriorityError;
;;;958      }
;;;959    
;;;960      // Check object state
;;;961      if (thread->state == osRtxThreadTerminated) {
00000e  7841              LDRB     r1,[r0,#1]
000010  2904              CMP      r1,#4
000012  d001              BEQ      |L58.24|
;;;962        EvrRtxThreadGetPriority(thread, osPriorityError);
;;;963        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;964        return osPriorityError;
;;;965      }
;;;966    
;;;967      priority = osRtxThreadPriority(thread);
000014  f9904020          LDRSB    r4,[r0,#0x20]
                  |L58.24|
000018  4621              MOV      r1,r4                 ;962
00001a  f7fffffe          BL       EvrRtxThreadGetPriority
00001e  4620              MOV      r0,r4                 ;964
;;;968    
;;;969      EvrRtxThreadGetPriority(thread, priority);
;;;970    
;;;971      return priority;
;;;972    }
000020  bd10              POP      {r4,pc}
;;;973    
                          ENDP


                          AREA ||i.svcRtxThreadGetStackSize||, CODE, READONLY, ALIGN=1

                  svcRtxThreadGetStackSize PROC
;;;862    /// \note API identical to osThreadGetStackSize
;;;863    static uint32_t svcRtxThreadGetStackSize (osThreadId_t thread_id) {
000000  b510              PUSH     {r4,lr}
;;;864      os_thread_t *thread = osRtxThreadId(thread_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L59.12|
;;;865    
;;;866      // Check parameters
;;;867      if ((thread == NULL) || (thread->id != osRtxIdThread)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f1              CMP      r0,#0xf1
00000a  d005              BEQ      |L59.24|
                  |L59.12|
;;;868        EvrRtxThreadGetStackSize(thread, 0U);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxThreadGetStackSize
;;;869        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;870        return 0U;
000014  2000              MOVS     r0,#0
;;;871      }
;;;872    
;;;873      EvrRtxThreadGetStackSize(thread, thread->stack_size);
;;;874    
;;;875      return thread->stack_size;
;;;876    }
000016  bd10              POP      {r4,pc}
                  |L59.24|
000018  4620              MOV      r0,r4                 ;873
00001a  6b61              LDR      r1,[r4,#0x34]         ;873
00001c  f7fffffe          BL       EvrRtxThreadGetStackSize
000020  6b60              LDR      r0,[r4,#0x34]         ;875
000022  bd10              POP      {r4,pc}
;;;877    
                          ENDP


                          AREA ||i.svcRtxThreadGetStackSpace||, CODE, READONLY, ALIGN=2

                  svcRtxThreadGetStackSpace PROC
;;;879    /// \note API identical to osThreadGetStackSpace
;;;880    static uint32_t svcRtxThreadGetStackSpace (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  b130              CBZ      r0,|L60.18|
;;;881      os_thread_t    *thread = osRtxThreadId(thread_id);
;;;882      const uint32_t *stack;
;;;883            uint32_t  space;
;;;884    
;;;885      // Check parameters
;;;886      if ((thread == NULL) || (thread->id != osRtxIdThread)) {
000004  7801              LDRB     r1,[r0,#0]
000006  29f1              CMP      r1,#0xf1
000008  d103              BNE      |L60.18|
;;;887        EvrRtxThreadGetStackSpace(thread, 0U);
;;;888        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;889        return 0U;
;;;890      }
;;;891    
;;;892      // Check if stack watermark is not enabled
;;;893      if ((osRtxConfig.flags & osRtxConfigStackWatermark) == 0U) {
00000a  4910              LDR      r1,|L60.76|
00000c  7809              LDRB     r1,[r1,#0]  ; osRtxConfig
00000e  0749              LSLS     r1,r1,#29
000010  d404              BMI      |L60.28|
                  |L60.18|
;;;894        EvrRtxThreadGetStackSpace(thread, 0U);
000012  2100              MOVS     r1,#0
000014  f7fffffe          BL       EvrRtxThreadGetStackSpace
;;;895        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;896        return 0U;
000018  2000              MOVS     r0,#0
;;;897      }
;;;898    
;;;899      //lint -e{9079} "conversion from pointer to void to pointer to other type"
;;;900      stack = thread->stack_mem;
;;;901      if (*stack++ == osRtxStackMagicWord) {
;;;902        for (space = 4U; space < thread->stack_size; space += 4U) {
;;;903          if (*stack++ != osRtxStackFillPattern) {
;;;904            break;
;;;905          }
;;;906        }
;;;907      } else {
;;;908        space = 0U;
;;;909      }
;;;910    
;;;911      EvrRtxThreadGetStackSpace(thread, space);
;;;912    
;;;913      return space;
;;;914    }
00001a  bd70              POP      {r4-r6,pc}
                  |L60.28|
00001c  6b02              LDR      r2,[r0,#0x30]         ;901
00001e  4b0c              LDR      r3,|L60.80|
000020  ca02              LDM      r2!,{r1}              ;901
000022  4299              CMP      r1,r3                 ;901
000024  d10b              BNE      |L60.62|
000026  2404              MOVS     r4,#4                 ;902
000028  f04f33cc          MOV      r3,#0xcccccccc        ;903
00002c  6b41              LDR      r1,[r0,#0x34]         ;902
00002e  e003              B        |L60.56|
                  |L60.48|
000030  ca20              LDM      r2!,{r5}              ;903
000032  429d              CMP      r5,r3                 ;903
000034  d104              BNE      |L60.64|
000036  1d24              ADDS     r4,r4,#4              ;903
                  |L60.56|
000038  42a1              CMP      r1,r4                 ;902
00003a  d8f9              BHI      |L60.48|
00003c  e000              B        |L60.64|
                  |L60.62|
00003e  2400              MOVS     r4,#0                 ;908
                  |L60.64|
000040  4621              MOV      r1,r4                 ;911
000042  f7fffffe          BL       EvrRtxThreadGetStackSpace
000046  4620              MOV      r0,r4                 ;913
000048  bd70              POP      {r4-r6,pc}
;;;915    
                          ENDP

00004a  0000              DCW      0x0000
                  |L60.76|
                          DCD      osRtxConfig
                  |L60.80|
                          DCD      0xe25a2ea5

                          AREA ||i.svcRtxThreadGetState||, CODE, READONLY, ALIGN=1

                  svcRtxThreadGetState PROC
;;;842    /// \note API identical to osThreadGetState
;;;843    static osThreadState_t svcRtxThreadGetState (osThreadId_t thread_id) {
000000  b510              PUSH     {r4,lr}
000002  b110              CBZ      r0,|L61.10|
;;;844      os_thread_t    *thread = osRtxThreadId(thread_id);
;;;845      osThreadState_t state;
;;;846    
;;;847      // Check parameters
;;;848      if ((thread == NULL) || (thread->id != osRtxIdThread)) {
000004  7801              LDRB     r1,[r0,#0]
000006  29f1              CMP      r1,#0xf1
000008  d002              BEQ      |L61.16|
                  |L61.10|
;;;849        EvrRtxThreadGetState(thread, osThreadError);
00000a  f04f34ff          MOV      r4,#0xffffffff
;;;850        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;851        return osThreadError;
00000e  e002              B        |L61.22|
                  |L61.16|
000010  7841              LDRB     r1,[r0,#1]
000012  f001040f          AND      r4,r1,#0xf
                  |L61.22|
;;;852      }
;;;853    
;;;854      state = osRtxThreadState(thread);
;;;855    
;;;856      EvrRtxThreadGetState(thread, state);
000016  4621              MOV      r1,r4
000018  f7fffffe          BL       EvrRtxThreadGetState
;;;857    
;;;858      return state;
00001c  4620              MOV      r0,r4
;;;859    }
00001e  bd10              POP      {r4,pc}
;;;860    
                          ENDP


                          AREA ||i.svcRtxThreadJoin||, CODE, READONLY, ALIGN=2

                  svcRtxThreadJoin PROC
;;;1181   /// \note API identical to osThreadJoin
;;;1182   static osStatus_t svcRtxThreadJoin (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;1183     os_thread_t *thread = osRtxThreadId(thread_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L62.12|
;;;1184     os_thread_t *thread_running;
;;;1185     osStatus_t   status;
;;;1186   
;;;1187     // Check parameters
;;;1188     if ((thread == NULL) || (thread->id != osRtxIdThread)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f1              CMP      r0,#0xf1
00000a  d002              BEQ      |L62.18|
                  |L62.12|
;;;1189       EvrRtxThreadError(thread, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
;;;1190       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1191       return osErrorParameter;
000010  e02e              B        |L62.112|
                  |L62.18|
;;;1192     }
;;;1193   
;;;1194     // Check object attributes
;;;1195     if ((thread->attr & osThreadJoinable) == 0U) {
000012  78e0              LDRB     r0,[r4,#3]
;;;1196       EvrRtxThreadError(thread, osRtxErrorThreadNotJoinable);
;;;1197       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1198       return osErrorResource;
000014  f06f0502          MVN      r5,#2
000018  07c0              LSLS     r0,r0,#31             ;1195
00001a  d015              BEQ      |L62.72|
;;;1199     }
;;;1200   
;;;1201     // Check object state
;;;1202     if (thread->state == osRtxThreadRunning) {
00001c  7860              LDRB     r0,[r4,#1]
00001e  2802              CMP      r0,#2
000020  d026              BEQ      |L62.112|
;;;1203       EvrRtxThreadError(thread, (int32_t)osErrorResource);
;;;1204       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1205       return osErrorResource;
;;;1206     }
;;;1207   
;;;1208     if (thread->state == osRtxThreadTerminated) {
000022  2804              CMP      r0,#4
000024  d017              BEQ      |L62.86|
;;;1209       osRtxThreadListUnlink(&osRtxInfo.thread.terminate_list, thread);
;;;1210       osRtxThreadFree(thread);
;;;1211       EvrRtxThreadJoined(thread);
;;;1212       status = osOK;
;;;1213     } else {
;;;1214       // Suspend current Thread
;;;1215       if (osRtxThreadWaitEnter(osRtxThreadWaitingJoin, osWaitForever)) {
000026  10a9              ASRS     r1,r5,#2
000028  2023              MOVS     r0,#0x23
00002a  f7fffffe          BL       osRtxThreadWaitEnter
00002e  b1f8              CBZ      r0,|L62.112|
000030  4810              LDR      r0,|L62.116|
000032  6940              LDR      r0,[r0,#0x14]  ; osRtxInfo
;;;1216         thread_running = osRtxThreadGetRunning();
;;;1217         thread_running->thread_next = thread;
;;;1218         thread->thread_join = thread_running;
000034  6084              STR      r4,[r0,#8]
;;;1219         thread->attr &= ~osThreadJoinable;
000036  61a0              STR      r0,[r4,#0x18]
000038  78e0              LDRB     r0,[r4,#3]
00003a  f0200001          BIC      r0,r0,#1
00003e  70e0              STRB     r0,[r4,#3]
;;;1220         EvrRtxThreadJoinPending(thread);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       EvrRtxThreadJoinPending
000046  e004              B        |L62.82|
                  |L62.72|
000048  f06f010c          MVN      r1,#0xc               ;1196
                  |L62.76|
00004c  4620              MOV      r0,r4                 ;1189
00004e  f7fffffe          BL       EvrRtxThreadError
                  |L62.82|
;;;1221       } else {
;;;1222         EvrRtxThreadError(thread, (int32_t)osErrorResource);
;;;1223       }
;;;1224       status = osErrorResource;
000052  4628              MOV      r0,r5
;;;1225     }
;;;1226   
;;;1227     return status;
;;;1228   }
000054  bd70              POP      {r4-r6,pc}
                  |L62.86|
000056  4807              LDR      r0,|L62.116|
000058  4621              MOV      r1,r4                 ;1209
00005a  3034              ADDS     r0,r0,#0x34           ;1209
00005c  f7fffffe          BL       osRtxThreadListUnlink
000060  4620              MOV      r0,r4                 ;1210
000062  f7fffffe          BL       osRtxThreadFree
000066  4620              MOV      r0,r4                 ;1211
000068  f7fffffe          BL       EvrRtxThreadJoined
00006c  2000              MOVS     r0,#0                 ;1212
00006e  bd70              POP      {r4-r6,pc}
                  |L62.112|
000070  4629              MOV      r1,r5                 ;1222
000072  e7eb              B        |L62.76|
;;;1229   
                          ENDP

                  |L62.116|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxThreadNew||, CODE, READONLY, ALIGN=2

                  svcRtxThreadNew PROC
;;;567    /// \note API identical to osThreadNew
;;;568    static osThreadId_t svcRtxThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  b082              SUB      sp,sp,#8
000006  ea5f0b00          MOVS     r11,r0
00000a  d010              BEQ      |L63.46|
;;;569      os_thread_t  *thread;
;;;570      uint32_t      attr_bits;
;;;571      void         *stack_mem;
;;;572      uint32_t      stack_size;
;;;573      osPriority_t  priority;
;;;574      uint8_t       flags;
;;;575      const char   *name;
;;;576      uint32_t     *ptr;
;;;577      uint32_t      n;
;;;578    #if (DOMAIN_NS == 1)
;;;579      TZ_ModuleId_t tz_module;
;;;580      TZ_MemoryId_t tz_memory;
;;;581    #endif
;;;582    
;;;583      // Check parameters
;;;584      if (func == NULL) {
;;;585        EvrRtxThreadError(NULL, (int32_t)osErrorParameter);
;;;586        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;587        return NULL;
;;;588      }
;;;589    
;;;590      // Process attributes
;;;591      if (attr != NULL) {
;;;592        name       = attr->name;
;;;593        attr_bits  = attr->attr_bits;
;;;594        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
;;;595        thread     = attr->cb_mem;
;;;596        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
;;;597        stack_mem  = attr->stack_mem;
;;;598        stack_size = attr->stack_size;
;;;599        priority   = attr->priority;
;;;600    #if (DOMAIN_NS == 1)
;;;601        tz_module  = attr->tz_module;
;;;602    #endif
;;;603        if (thread != NULL) {
;;;604          //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
;;;605          if ((((uint32_t)thread & 3U) != 0U) || (attr->cb_size < sizeof(os_thread_t))) {
;;;606            EvrRtxThreadError(NULL, osRtxErrorInvalidControlBlock);
;;;607            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;608            return NULL;
;;;609          }
;;;610        } else {
;;;611          if (attr->cb_size != 0U) {
;;;612            EvrRtxThreadError(NULL, osRtxErrorInvalidControlBlock);
;;;613            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;614            return NULL;
;;;615          }
;;;616        }
;;;617        if (stack_mem != NULL) {
;;;618          //lint -e{923} "cast from pointer to unsigned int" [MISRA Note 7]
;;;619          if ((((uint32_t)stack_mem & 7U) != 0U) || (stack_size == 0U)) {
;;;620            EvrRtxThreadError(NULL, osRtxErrorInvalidThreadStack);
;;;621            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;622            return NULL;
;;;623          }
;;;624        }
;;;625        if (priority == osPriorityNone) {
;;;626          priority = osPriorityNormal;
;;;627        } else {
;;;628          if ((priority < osPriorityIdle) || (priority > osPriorityISR)) {
;;;629            EvrRtxThreadError(NULL, osRtxErrorInvalidPriority);
;;;630            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;631            return NULL;
;;;632          }
;;;633        }
;;;634      } else {
;;;635        name       = NULL;
;;;636        attr_bits  = 0U;
;;;637        thread     = NULL;
;;;638        stack_mem  = NULL;
;;;639        stack_size = 0U;
;;;640        priority   = osPriorityNormal;
;;;641    #if (DOMAIN_NS == 1)
;;;642        tz_module  = 0U;
;;;643    #endif
;;;644      }
;;;645    
;;;646      // Check stack size
;;;647      if (stack_size != 0U) {
;;;648        if (((stack_size & 7U) != 0U) || (stack_size < (64U + 8U)) || (stack_size > 0x7FFFFFFFU)) {
;;;649          EvrRtxThreadError(NULL, osRtxErrorInvalidThreadStack);
;;;650          //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;651          return NULL;
;;;652        }
;;;653      }
;;;654    
;;;655      // Allocate object memory if not provided
;;;656      if (thread == NULL) {
;;;657        if (osRtxInfo.mpi.thread != NULL) {
00000c  f8df91c8          LDR      r9,|L63.472|
000010  b35a              CBZ      r2,|L63.106|
000012  6810              LDR      r0,[r2,#0]            ;592
000014  9000              STR      r0,[sp,#0]            ;593
000016  e9d26005          LDRD     r6,r0,[r2,#0x14]      ;597
00001a  e9d2a401          LDRD     r10,r4,[r2,#4]        ;603
00001e  6915              LDR      r5,[r2,#0x10]         ;603
000020  4680              MOV      r8,r0                 ;599
000022  f06f0108          MVN      r1,#8                 ;606
000026  b14c              CBZ      r4,|L63.60|
000028  07a0              LSLS     r0,r4,#30             ;605
00002a  d12b              BNE      |L63.132|
00002c  e002              B        |L63.52|
                  |L63.46|
00002e  f06f0103          MVN      r1,#3                 ;585
000032  e027              B        |L63.132|
                  |L63.52|
000034  68d0              LDR      r0,[r2,#0xc]          ;605
000036  2844              CMP      r0,#0x44              ;605
000038  d324              BCC      |L63.132|
00003a  e001              B        |L63.64|
                  |L63.60|
00003c  68d0              LDR      r0,[r2,#0xc]          ;611
00003e  bb08              CBNZ     r0,|L63.132|
                  |L63.64|
000040  f06f010a          MVN      r1,#0xa               ;620
000044  b115              CBZ      r5,|L63.76|
000046  0768              LSLS     r0,r5,#29             ;619
000048  d11c              BNE      |L63.132|
00004a  b1de              CBZ      r6,|L63.132|
                  |L63.76|
00004c  ea5f0008          MOVS     r0,r8                 ;625
000050  d005              BEQ      |L63.94|
000052  1e40              SUBS     r0,r0,#1              ;625
000054  2838              CMP      r0,#0x38              ;628
000056  d304              BCC      |L63.98|
000058  f06f010b          MVN      r1,#0xb               ;629
00005c  e012              B        |L63.132|
                  |L63.94|
00005e  f04f0818          MOV      r8,#0x18              ;626
                  |L63.98|
000062  b1b6              CBZ      r6,|L63.146|
000064  0770              LSLS     r0,r6,#29             ;648
000066  d10d              BNE      |L63.132|
000068  e007              B        |L63.122|
                  |L63.106|
00006a  2000              MOVS     r0,#0                 ;635
00006c  4682              MOV      r10,r0                ;636
00006e  4605              MOV      r5,r0                 ;638
000070  4606              MOV      r6,r0                 ;639
000072  f04f0818          MOV      r8,#0x18              ;640
000076  9000              STR      r0,[sp,#0]            ;640
000078  e00f              B        |L63.154|
                  |L63.122|
00007a  2e48              CMP      r6,#0x48              ;648
00007c  d302              BCC      |L63.132|
00007e  f1b64f00          CMP      r6,#0x80000000        ;648
000082  d306              BCC      |L63.146|
                  |L63.132|
000084  2000              MOVS     r0,#0                 ;649
000086  f7fffffe          BL       EvrRtxThreadError
00008a  2000              MOVS     r0,#0                 ;651
                  |L63.140|
;;;658          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;659          thread = osRtxMemoryPoolAlloc(osRtxInfo.mpi.thread);
;;;660        } else {
;;;661          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;662          thread = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_thread_t), 1U);
;;;663        }
;;;664    #ifdef RTX_OBJ_MEM_USAGE
;;;665        if (thread != NULL) {
;;;666          uint32_t used;
;;;667          osRtxThreadMemUsage.cnt_alloc++;
;;;668          used = osRtxThreadMemUsage.cnt_alloc - osRtxThreadMemUsage.cnt_free;
;;;669          if (osRtxThreadMemUsage.max_used < used) {
;;;670            osRtxThreadMemUsage.max_used = used;
;;;671          }
;;;672        }
;;;673    #endif
;;;674        flags = osRtxFlagSystemObject;
;;;675      } else {
;;;676        flags = 0U;
;;;677      }
;;;678    
;;;679      // Allocate stack memory if not provided
;;;680      if ((thread != NULL) && (stack_mem == NULL)) {
;;;681        if (stack_size == 0U) {
;;;682          stack_size = osRtxConfig.thread_stack_size;
;;;683          if (osRtxInfo.mpi.stack != NULL) {
;;;684            //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;685            stack_mem = osRtxMemoryPoolAlloc(osRtxInfo.mpi.stack);
;;;686            if (stack_mem != NULL) {
;;;687              flags |= osRtxThreadFlagDefStack;
;;;688            }
;;;689          } else {
;;;690            //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;691            stack_mem = osRtxMemoryAlloc(osRtxInfo.mem.stack, stack_size, 0U);
;;;692          }
;;;693        } else {
;;;694          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;695          stack_mem = osRtxMemoryAlloc(osRtxInfo.mem.stack, stack_size, 0U);
;;;696        }
;;;697        if (stack_mem == NULL) {
;;;698          if ((flags & osRtxFlagSystemObject) != 0U) {
;;;699            if (osRtxInfo.mpi.thread != NULL) {
;;;700              (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
;;;701            } else {
;;;702              (void)osRtxMemoryFree(osRtxInfo.mem.common, thread);
;;;703            }
;;;704    #ifdef RTX_OBJ_MEM_USAGE
;;;705            osRtxThreadMemUsage.cnt_free++;
;;;706    #endif
;;;707          }
;;;708          thread = NULL;
;;;709        }
;;;710        flags |= osRtxFlagSystemMemory;
;;;711      }
;;;712    
;;;713    #if (DOMAIN_NS == 1)
;;;714      // Allocate secure process stack
;;;715      if ((thread != NULL) && (tz_module != 0U)) {
;;;716        tz_memory = TZ_AllocModuleContext_S(tz_module);
;;;717        if (tz_memory == 0U) {
;;;718          EvrRtxThreadError(NULL, osRtxErrorTZ_AllocContext_S);
;;;719          if ((flags & osRtxFlagSystemMemory) != 0U) {
;;;720            if ((flags & osRtxThreadFlagDefStack) != 0U) {
;;;721              (void)osRtxMemoryPoolFree(osRtxInfo.mpi.stack, thread->stack_mem);
;;;722            } else {
;;;723              (void)osRtxMemoryFree(osRtxInfo.mem.stack, thread->stack_mem);
;;;724            }
;;;725          }
;;;726          if ((flags & osRtxFlagSystemObject) != 0U) {
;;;727            if (osRtxInfo.mpi.thread != NULL) {
;;;728              (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
;;;729            } else {
;;;730              (void)osRtxMemoryFree(osRtxInfo.mem.common, thread);
;;;731            }
;;;732    #ifdef RTX_OBJ_MEM_USAGE
;;;733            osRtxThreadMemUsage.cnt_free++;
;;;734    #endif
;;;735          }
;;;736          thread = NULL;
;;;737        }
;;;738      } else {
;;;739        tz_memory = 0U;
;;;740      }
;;;741    #endif
;;;742    
;;;743      if (thread != NULL) {
;;;744        // Initialize control block
;;;745        //lint --e{923}  --e{9078} "cast between pointers and unsigned int"
;;;746        //lint --e{9079} --e{9087} "cast between pointers to different object types"
;;;747        //lint --e{9074} "conversion between a pointer to function and another type"
;;;748        thread->id            = osRtxIdThread;
;;;749        thread->state         = osRtxThreadReady;
;;;750        thread->flags         = flags;
;;;751        thread->attr          = (uint8_t)attr_bits;
;;;752        thread->name          = name;
;;;753        thread->thread_next   = NULL;
;;;754        thread->thread_prev   = NULL;
;;;755        thread->delay_next    = NULL;
;;;756        thread->delay_prev    = NULL;
;;;757        thread->thread_join   = NULL;
;;;758        thread->delay         = 0U;
;;;759        thread->priority      = (int8_t)priority;
;;;760        thread->priority_base = (int8_t)priority;
;;;761        thread->stack_frame   = STACK_FRAME_INIT_VAL;
;;;762        thread->flags_options = 0U;
;;;763        thread->wait_flags    = 0U;
;;;764        thread->thread_flags  = 0U;
;;;765        thread->mutex_list    = NULL;
;;;766        thread->stack_mem     = stack_mem;
;;;767        thread->stack_size    = stack_size;
;;;768        thread->sp            = (uint32_t)stack_mem + stack_size - 64U;
;;;769        thread->thread_addr   = (uint32_t)func;
;;;770      #if (DOMAIN_NS == 1)
;;;771        thread->tz_memory     = tz_memory;
;;;772      #ifdef RTX_TF_M_EXTENSION
;;;773        thread->tz_module     = tz_module;
;;;774      #endif
;;;775      #endif
;;;776    
;;;777        // Initialize stack
;;;778        //lint --e{613} false detection: "Possible use of null pointer"
;;;779        ptr = (uint32_t *)stack_mem;
;;;780        ptr[0] = osRtxStackMagicWord;
;;;781        if ((osRtxConfig.flags & osRtxConfigStackWatermark) != 0U) {
;;;782          for (n = (stack_size/4U) - (16U + 1U); n != 0U; n--) {
;;;783             ptr++;
;;;784            *ptr = osRtxStackFillPattern;
;;;785          }
;;;786        }
;;;787        ptr = (uint32_t *)thread->sp;
;;;788        for (n = 0U; n != 13U; n++) {
;;;789          ptr[n] = 0U;                      // R4..R11, R0..R3, R12
;;;790        }
;;;791        ptr[13] = (uint32_t)osThreadExit;   // LR
;;;792        ptr[14] = (uint32_t)func;           // PC
;;;793        ptr[15] = xPSR_InitVal(
;;;794                    (bool_t)((osRtxConfig.flags & osRtxConfigPrivilegedMode) != 0U),
;;;795                    (bool_t)(((uint32_t)func & 1U) != 0U)
;;;796                  );                        // xPSR
;;;797        ptr[8]  = (uint32_t)argument;       // R0
;;;798    
;;;799        // Register post ISR processing function
;;;800        osRtxInfo.post_process.thread = osRtxThreadPostProcess;
;;;801    
;;;802        EvrRtxThreadCreated(thread, thread->thread_addr, thread->name);
;;;803      } else {
;;;804        EvrRtxThreadError(NULL, (int32_t)osErrorNoMemory);
;;;805      }
;;;806    
;;;807      if (thread != NULL) {
;;;808        osRtxThreadDispatch(thread);
;;;809      }
;;;810    
;;;811      return thread;
;;;812    }
00008c  b005              ADD      sp,sp,#0x14
00008e  e8bd8ff0          POP      {r4-r11,pc}
                  |L63.146|
000092  b114              CBZ      r4,|L63.154|
000094  2700              MOVS     r7,#0                 ;676
                  |L63.150|
000096  b1dd              CBZ      r5,|L63.208|
000098  e032              B        |L63.256|
                  |L63.154|
00009a  f8d91088          LDR      r1,[r9,#0x88]         ;657  ; osRtxInfo
00009e  b119              CBZ      r1,|L63.168|
0000a0  4608              MOV      r0,r1                 ;657
0000a2  f7fffffe          BL       osRtxMemoryPoolAlloc
0000a6  e005              B        |L63.180|
                  |L63.168|
0000a8  2201              MOVS     r2,#1                 ;662
0000aa  2144              MOVS     r1,#0x44              ;662
0000ac  f8d90080          LDR      r0,[r9,#0x80]         ;662  ; osRtxInfo
0000b0  f7fffffe          BL       osRtxMemoryAlloc
                  |L63.180|
0000b4  0004              MOVS     r4,r0                 ;662
0000b6  d074              BEQ      |L63.418|
0000b8  4848              LDR      r0,|L63.476|
0000ba  6801              LDR      r1,[r0,#0]            ;667  ; osRtxThreadMemUsage
0000bc  1c49              ADDS     r1,r1,#1              ;667
0000be  6001              STR      r1,[r0,#0]            ;668  ; osRtxThreadMemUsage
0000c0  6842              LDR      r2,[r0,#4]            ;668  ; osRtxThreadMemUsage
0000c2  1a89              SUBS     r1,r1,r2              ;668
0000c4  6882              LDR      r2,[r0,#8]            ;669  ; osRtxThreadMemUsage
0000c6  428a              CMP      r2,r1                 ;669
0000c8  d200              BCS      |L63.204|
0000ca  6081              STR      r1,[r0,#8]            ;670  ; osRtxThreadMemUsage
                  |L63.204|
0000cc  2701              MOVS     r7,#1                 ;674
0000ce  e7e2              B        |L63.150|
                  |L63.208|
0000d0  b966              CBNZ     r6,|L63.236|
0000d2  4843              LDR      r0,|L63.480|
0000d4  f8d91084          LDR      r1,[r9,#0x84]         ;683  ; osRtxInfo
0000d8  6d46              LDR      r6,[r0,#0x54]         ;683  ; osRtxConfig
0000da  b139              CBZ      r1,|L63.236|
0000dc  4608              MOV      r0,r1                 ;683
0000de  f7fffffe          BL       osRtxMemoryPoolAlloc
0000e2  0005              MOVS     r5,r0                 ;685
0000e4  d05e              BEQ      |L63.420|
0000e6  f0470710          ORR      r7,r7,#0x10           ;687
0000ea  e007              B        |L63.252|
                  |L63.236|
0000ec  2200              MOVS     r2,#0                 ;691
0000ee  4631              MOV      r1,r6                 ;691
0000f0  f8d90074          LDR      r0,[r9,#0x74]         ;691  ; osRtxInfo
0000f4  f7fffffe          BL       osRtxMemoryAlloc
0000f8  1e05              SUBS     r5,r0,#0              ;691
0000fa  d053              BEQ      |L63.420|
                  |L63.252|
0000fc  f0470702          ORR      r7,r7,#2              ;710
                  |L63.256|
000100  20f1              MOVS     r0,#0xf1              ;748
000102  7020              STRB     r0,[r4,#0]            ;748
000104  2001              MOVS     r0,#1                 ;749
000106  7060              STRB     r0,[r4,#1]            ;749
000108  70a7              STRB     r7,[r4,#2]            ;750
00010a  f884a003          STRB     r10,[r4,#3]           ;751
00010e  9800              LDR      r0,[sp,#0]            ;752
000110  6060              STR      r0,[r4,#4]            ;753
000112  2000              MOVS     r0,#0                 ;753
000114  60a0              STR      r0,[r4,#8]            ;754
000116  60e0              STR      r0,[r4,#0xc]          ;755
000118  6120              STR      r0,[r4,#0x10]         ;756
00011a  6160              STR      r0,[r4,#0x14]         ;757
00011c  61a0              STR      r0,[r4,#0x18]         ;758
00011e  61e0              STR      r0,[r4,#0x1c]         ;759
000120  f8848020          STRB     r8,[r4,#0x20]         ;759
000124  f8848021          STRB     r8,[r4,#0x21]         ;760
000128  21fd              MOVS     r1,#0xfd              ;761
00012a  f8841022          STRB     r1,[r4,#0x22]         ;761
00012e  f8840023          STRB     r0,[r4,#0x23]         ;762
000132  6260              STR      r0,[r4,#0x24]         ;764
000134  19a9              ADDS     r1,r5,r6              ;768
000136  f8c4b03c          STR      r11,[r4,#0x3c]        ;769
00013a  3940              SUBS     r1,r1,#0x40           ;769
00013c  62a0              STR      r0,[r4,#0x28]         ;769
00013e  e9c4610d          STRD     r6,r1,[r4,#0x34]      ;769
000142  e9c4050b          STRD     r0,r5,[r4,#0x2c]      ;780
000146  4927              LDR      r1,|L63.484|
000148  6029              STR      r1,[r5,#0]            ;781
00014a  4925              LDR      r1,|L63.480|
00014c  7809              LDRB     r1,[r1,#0]            ;781  ; osRtxConfig
00014e  0749              LSLS     r1,r1,#29             ;781
000150  d50a              BPL      |L63.360|
000152  f06f0110          MVN      r1,#0x10              ;782
000156  eb110196          ADDS     r1,r1,r6,LSR #2       ;782
00015a  d005              BEQ      |L63.360|
00015c  f04f32cc          MOV      r2,#0xcccccccc        ;784
                  |L63.352|
000160  f8452f04          STR      r2,[r5,#4]!           ;784
000164  1e49              SUBS     r1,r1,#1              ;784
000166  d1fb              BNE      |L63.352|
                  |L63.360|
000168  6ba1              LDR      r1,[r4,#0x38]         ;788
00016a  2200              MOVS     r2,#0                 ;788
                  |L63.364|
00016c  f8410022          STR      r0,[r1,r2,LSL #2]     ;789
000170  1c52              ADDS     r2,r2,#1              ;789
000172  2a0d              CMP      r2,#0xd               ;788
000174  d1fa              BNE      |L63.364|
000176  481c              LDR      r0,|L63.488|
000178  e9c10b0d          STRD     r0,r11,[r1,#0x34]     ;791
00017c  f04f7080          MOV      r0,#0x1000000         ;791
000180  63c8              STR      r0,[r1,#0x3c]         ;797
000182  9803              LDR      r0,[sp,#0xc]          ;797
000184  6208              STR      r0,[r1,#0x20]         ;800
000186  4919              LDR      r1,|L63.492|
000188  f8c91060          STR      r1,[r9,#0x60]         ;802  ; osRtxInfo
00018c  4620              MOV      r0,r4                 ;802
00018e  6862              LDR      r2,[r4,#4]            ;802
000190  6be1              LDR      r1,[r4,#0x3c]         ;802
000192  f7fffffe          BL       EvrRtxThreadCreated
000196  b114              CBZ      r4,|L63.414|
000198  4620              MOV      r0,r4                 ;808
00019a  f7fffffe          BL       osRtxThreadDispatch
                  |L63.414|
00019e  4620              MOV      r0,r4                 ;811
0001a0  e774              B        |L63.140|
                  |L63.418|
0001a2  e013              B        |L63.460|
                  |L63.420|
0001a4  07f8              LSLS     r0,r7,#31             ;698
0001a6  d010              BEQ      |L63.458|
0001a8  f8d92088          LDR      r2,[r9,#0x88]         ;699  ; osRtxInfo
0001ac  b122              CBZ      r2,|L63.440|
0001ae  4621              MOV      r1,r4                 ;700
0001b0  4610              MOV      r0,r2                 ;700
0001b2  f7fffffe          BL       osRtxMemoryPoolFree
0001b6  e004              B        |L63.450|
                  |L63.440|
0001b8  4621              MOV      r1,r4                 ;702
0001ba  f8d90080          LDR      r0,[r9,#0x80]         ;702  ; osRtxInfo
0001be  f7fffffe          BL       osRtxMemoryFree
                  |L63.450|
0001c2  4806              LDR      r0,|L63.476|
0001c4  6841              LDR      r1,[r0,#4]            ;705  ; osRtxThreadMemUsage
0001c6  1c49              ADDS     r1,r1,#1              ;705
0001c8  6041              STR      r1,[r0,#4]            ;705  ; osRtxThreadMemUsage
                  |L63.458|
0001ca  2400              MOVS     r4,#0                 ;708
                  |L63.460|
0001cc  f06f0104          MVN      r1,#4                 ;804
0001d0  2000              MOVS     r0,#0                 ;804
0001d2  f7fffffe          BL       EvrRtxThreadError
0001d6  e7e2              B        |L63.414|
;;;813    
                          ENDP

                  |L63.472|
                          DCD      osRtxInfo
                  |L63.476|
                          DCD      ||.data.os.thread.obj||
                  |L63.480|
                          DCD      osRtxConfig
                  |L63.484|
                          DCD      0xe25a2ea5
                  |L63.488|
                          DCD      osThreadExit
                  |L63.492|
                          DCD      osRtxThreadPostProcess

                          AREA ||i.svcRtxThreadResume||, CODE, READONLY, ALIGN=1

                  svcRtxThreadResume PROC
;;;1052   /// \note API identical to osThreadResume
;;;1053   static osStatus_t svcRtxThreadResume (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;1054     os_thread_t *thread = osRtxThreadId(thread_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L64.12|
;;;1055   
;;;1056     // Check parameters
;;;1057     if ((thread == NULL) || (thread->id != osRtxIdThread)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f1              CMP      r0,#0xf1
00000a  d002              BEQ      |L64.18|
                  |L64.12|
;;;1058       EvrRtxThreadError(thread, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
;;;1059       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1060       return osErrorParameter;
000010  e006              B        |L64.32|
                  |L64.18|
;;;1061     }
;;;1062   
;;;1063     // Check object state
;;;1064     if ((thread->state & osRtxThreadStateMask) != osRtxThreadBlocked) {
000012  7860              LDRB     r0,[r4,#1]
000014  f000000f          AND      r0,r0,#0xf
000018  2803              CMP      r0,#3
00001a  d007              BEQ      |L64.44|
;;;1065       EvrRtxThreadError(thread, (int32_t)osErrorResource);
00001c  f06f0502          MVN      r5,#2
                  |L64.32|
000020  4629              MOV      r1,r5
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       EvrRtxThreadError
;;;1066       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1067       return osErrorResource;
000028  4628              MOV      r0,r5
;;;1068     }
;;;1069   
;;;1070     EvrRtxThreadResumed(thread);
;;;1071   
;;;1072     // Wakeup Thread
;;;1073     osRtxThreadListRemove(thread);
;;;1074     osRtxThreadDelayRemove(thread);
;;;1075     osRtxThreadDispatch(thread);
;;;1076   
;;;1077     return osOK;
;;;1078   }
00002a  bd70              POP      {r4-r6,pc}
                  |L64.44|
00002c  4620              MOV      r0,r4                 ;1070
00002e  f7fffffe          BL       EvrRtxThreadResumed
000032  4620              MOV      r0,r4                 ;1073
000034  f7fffffe          BL       osRtxThreadListRemove
000038  4620              MOV      r0,r4                 ;1074
00003a  f7fffffe          BL       osRtxThreadDelayRemove
00003e  4620              MOV      r0,r4                 ;1075
000040  f7fffffe          BL       osRtxThreadDispatch
000044  2000              MOVS     r0,#0                 ;1077
000046  bd70              POP      {r4-r6,pc}
;;;1079   
                          ENDP


                          AREA ||i.svcRtxThreadSetPriority||, CODE, READONLY, ALIGN=1

                  svcRtxThreadSetPriority PROC
;;;917    /// \note API identical to osThreadSetPriority
;;;918    static osStatus_t svcRtxThreadSetPriority (osThreadId_t thread_id, osPriority_t priority) {
000000  b570              PUSH     {r4-r6,lr}
;;;919      os_thread_t *thread = osRtxThreadId(thread_id);
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L65.20|
;;;920    
;;;921      // Check parameters
;;;922      if ((thread == NULL) || (thread->id != osRtxIdThread) ||
000006  7820              LDRB     r0,[r4,#0]
000008  28f1              CMP      r0,#0xf1
00000a  d103              BNE      |L65.20|
;;;923          (priority < osPriorityIdle) || (priority > osPriorityISR)) {
00000c  2901              CMP      r1,#1
00000e  db01              BLT      |L65.20|
000010  2938              CMP      r1,#0x38
000012  dd02              BLE      |L65.26|
                  |L65.20|
;;;924        EvrRtxThreadError(thread, (int32_t)osErrorParameter);
000014  f06f0503          MVN      r5,#3
;;;925        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;926        return osErrorParameter;
000018  e018              B        |L65.76|
                  |L65.26|
;;;927      }
;;;928    
;;;929      // Check object state
;;;930      if (thread->state == osRtxThreadTerminated) {
00001a  7860              LDRB     r0,[r4,#1]
00001c  2804              CMP      r0,#4
00001e  d013              BEQ      |L65.72|
;;;931        EvrRtxThreadError(thread, (int32_t)osErrorResource);
;;;932        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;933        return osErrorResource;
;;;934      }
;;;935    
;;;936      if (thread->priority   != (int8_t)priority) {
000020  f9942020          LDRSB    r2,[r4,#0x20]
000024  b248              SXTB     r0,r1
000026  4282              CMP      r2,r0
000028  d00c              BEQ      |L65.68|
;;;937        thread->priority      = (int8_t)priority;
00002a  f8840020          STRB     r0,[r4,#0x20]
;;;938        thread->priority_base = (int8_t)priority;
00002e  f8840021          STRB     r0,[r4,#0x21]
;;;939        EvrRtxThreadPriorityUpdated(thread, priority);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       EvrRtxThreadPriorityUpdated
;;;940        osRtxThreadListSort(thread);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       osRtxThreadListSort
;;;941        osRtxThreadDispatch(NULL);
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       osRtxThreadDispatch
                  |L65.68|
;;;942      }
;;;943    
;;;944      return osOK;
000044  2000              MOVS     r0,#0
;;;945    }
000046  bd70              POP      {r4-r6,pc}
                  |L65.72|
000048  f06f0502          MVN      r5,#2                 ;931
                  |L65.76|
00004c  4629              MOV      r1,r5                 ;931
00004e  4620              MOV      r0,r4                 ;931
000050  f7fffffe          BL       EvrRtxThreadError
000054  4628              MOV      r0,r5                 ;933
000056  bd70              POP      {r4-r6,pc}
;;;946    
                          ENDP


                          AREA ||i.svcRtxThreadSuspend||, CODE, READONLY, ALIGN=2

                  svcRtxThreadSuspend PROC
;;;996    /// \note API identical to osThreadSuspend
;;;997    static osStatus_t svcRtxThreadSuspend (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L66.12|
;;;998      os_thread_t *thread = osRtxThreadId(thread_id);
;;;999      osStatus_t   status;
;;;1000   
;;;1001     // Check parameters
;;;1002     if ((thread == NULL) || (thread->id != osRtxIdThread)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f1              CMP      r0,#0xf1
00000a  d002              BEQ      |L66.18|
                  |L66.12|
;;;1003       EvrRtxThreadError(thread, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
;;;1004       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1005       return osErrorParameter;
000010  e024              B        |L66.92|
                  |L66.18|
;;;1006     }
;;;1007   
;;;1008     // Check object state
;;;1009     switch (thread->state & osRtxThreadStateMask) {
000012  7860              LDRB     r0,[r4,#1]
000014  f000000f          AND      r0,r0,#0xf
000018  2801              CMP      r0,#1
00001a  d00d              BEQ      |L66.56|
;;;1010       case osRtxThreadRunning:
;;;1011         if ((osRtxKernelGetState() != osRtxKernelRunning) ||
;;;1012             (osRtxInfo.thread.ready.thread_list == NULL)) {
;;;1013           EvrRtxThreadError(thread, (int32_t)osErrorResource);
00001c  f06f0502          MVN      r5,#2
000020  2802              CMP      r0,#2                 ;1009
000022  d002              BEQ      |L66.42|
000024  2803              CMP      r0,#3                 ;1009
000026  d119              BNE      |L66.92|
000028  e00a              B        |L66.64|
                  |L66.42|
00002a  4816              LDR      r0,|L66.132|
00002c  7a01              LDRB     r1,[r0,#8]            ;1009  ; osRtxInfo
00002e  2902              CMP      r1,#2                 ;1011
000030  d114              BNE      |L66.92|
000032  6a40              LDR      r0,[r0,#0x24]         ;1012  ; osRtxInfo
000034  b190              CBZ      r0,|L66.92|
000036  e009              B        |L66.76|
                  |L66.56|
;;;1014           status = osErrorResource;
;;;1015         } else {
;;;1016           status = osOK;
;;;1017         }
;;;1018         break;
;;;1019       case osRtxThreadReady:
;;;1020         osRtxThreadListRemove(thread);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       osRtxThreadListRemove
;;;1021         status = osOK;
;;;1022         break;
00003e  e005              B        |L66.76|
                  |L66.64|
;;;1023       case osRtxThreadBlocked:
;;;1024         osRtxThreadListRemove(thread);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       osRtxThreadListRemove
;;;1025         osRtxThreadDelayRemove(thread);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       osRtxThreadDelayRemove
                  |L66.76|
;;;1026         status = osOK;
00004c  2500              MOVS     r5,#0
;;;1027         break;
;;;1028       case osRtxThreadInactive:
;;;1029       case osRtxThreadTerminated:
;;;1030       default:
;;;1031         EvrRtxThreadError(thread, (int32_t)osErrorResource);
;;;1032         status = osErrorResource;
;;;1033         break;
;;;1034     }
;;;1035   
;;;1036     if (status == osOK) {
;;;1037       EvrRtxThreadSuspended(thread);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       EvrRtxThreadSuspended
;;;1038   
;;;1039       if (thread->state == osRtxThreadRunning) {
000054  7860              LDRB     r0,[r4,#1]
000056  2802              CMP      r0,#2
000058  d005              BEQ      |L66.102|
00005a  e00a              B        |L66.114|
                  |L66.92|
00005c  4629              MOV      r1,r5                 ;1031
00005e  4620              MOV      r0,r4                 ;1031
000060  f7fffffe          BL       EvrRtxThreadError
000064  e00b              B        |L66.126|
                  |L66.102|
;;;1040         osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
000066  4807              LDR      r0,|L66.132|
000068  301c              ADDS     r0,r0,#0x1c
00006a  f7fffffe          BL       osRtxThreadListGet
00006e  f7fffffe          BL       osRtxThreadSwitch
                  |L66.114|
;;;1041       }
;;;1042   
;;;1043       // Update Thread State and put it into Delay list
;;;1044       thread->state = osRtxThreadBlocked;
000072  2003              MOVS     r0,#3
000074  7060              STRB     r0,[r4,#1]
;;;1045       osRtxThreadDelayInsert(thread, osWaitForever);
000076  1f01              SUBS     r1,r0,#4
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       osRtxThreadDelayInsert
                  |L66.126|
;;;1046     }
;;;1047   
;;;1048     return status;
00007e  4628              MOV      r0,r5
;;;1049   }
000080  bd70              POP      {r4-r6,pc}
;;;1050   
                          ENDP

000082  0000              DCW      0x0000
                  |L66.132|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxThreadTerminate||, CODE, READONLY, ALIGN=2

                  svcRtxThreadTerminate PROC
;;;1272   /// \note API identical to osThreadTerminate
;;;1273   static osStatus_t svcRtxThreadTerminate (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;1274     os_thread_t *thread = osRtxThreadId(thread_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L67.12|
;;;1275     osStatus_t   status;
;;;1276   
;;;1277     // Check parameters
;;;1278     if ((thread == NULL) || (thread->id != osRtxIdThread)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f1              CMP      r0,#0xf1
00000a  d002              BEQ      |L67.18|
                  |L67.12|
;;;1279       EvrRtxThreadError(thread, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
;;;1280       //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;1281       return osErrorParameter;
000010  e02e              B        |L67.112|
                  |L67.18|
;;;1282     }
;;;1283   
;;;1284     // Check object state
;;;1285     switch (thread->state & osRtxThreadStateMask) {
000012  7860              LDRB     r0,[r4,#1]
000014  4e24              LDR      r6,|L67.168|
000016  f000000f          AND      r0,r0,#0xf
00001a  2801              CMP      r0,#1
00001c  d00c              BEQ      |L67.56|
;;;1286       case osRtxThreadRunning:
;;;1287         if ((osRtxKernelGetState() != osRtxKernelRunning) ||
;;;1288             (osRtxInfo.thread.ready.thread_list == NULL)) {
;;;1289           EvrRtxThreadError(thread, (int32_t)osErrorResource);
00001e  f06f0502          MVN      r5,#2
000022  2802              CMP      r0,#2                 ;1285
000024  d002              BEQ      |L67.44|
000026  2803              CMP      r0,#3                 ;1285
000028  d122              BNE      |L67.112|
00002a  e009              B        |L67.64|
                  |L67.44|
00002c  7a30              LDRB     r0,[r6,#8]            ;1285  ; osRtxInfo
00002e  2802              CMP      r0,#2                 ;1287
000030  d11e              BNE      |L67.112|
000032  6a70              LDR      r0,[r6,#0x24]         ;1288  ; osRtxInfo
000034  b1e0              CBZ      r0,|L67.112|
000036  e009              B        |L67.76|
                  |L67.56|
;;;1290           status = osErrorResource;
;;;1291         } else {
;;;1292           status = osOK;
;;;1293         }
;;;1294         break;
;;;1295       case osRtxThreadReady:
;;;1296         osRtxThreadListRemove(thread);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       osRtxThreadListRemove
;;;1297         status = osOK;
;;;1298         break;
00003e  e005              B        |L67.76|
                  |L67.64|
;;;1299       case osRtxThreadBlocked:
;;;1300         osRtxThreadListRemove(thread);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       osRtxThreadListRemove
;;;1301         osRtxThreadDelayRemove(thread);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       osRtxThreadDelayRemove
                  |L67.76|
;;;1302         status = osOK;
00004c  2500              MOVS     r5,#0
;;;1303         break;
;;;1304       case osRtxThreadInactive:
;;;1305       case osRtxThreadTerminated:
;;;1306       default:
;;;1307         EvrRtxThreadError(thread, (int32_t)osErrorResource);
;;;1308         status = osErrorResource;
;;;1309         break;
;;;1310     }
;;;1311   
;;;1312     if (status == osOK) {
;;;1313       // Release owned Mutexes
;;;1314       osRtxMutexOwnerRelease(thread->mutex_list);
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  f7fffffe          BL       osRtxMutexOwnerRelease
;;;1315   
;;;1316       // Wakeup Thread waiting to Join
;;;1317       osRtxThreadJoinWakeup(thread);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       osRtxThreadJoinWakeup
;;;1318   
;;;1319       // Switch to next Ready Thread when terminating running Thread
;;;1320       if (thread->state == osRtxThreadRunning) {
00005a  7860              LDRB     r0,[r4,#1]
00005c  2802              CMP      r0,#2
00005e  d00c              BEQ      |L67.122|
;;;1321         osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
;;;1322         // Update Stack Pointer
;;;1323         thread->sp = __get_PSP();
;;;1324   #ifdef RTX_STACK_CHECK
;;;1325         // Check Stack usage
;;;1326         if (!osRtxThreadStackCheck(thread)) {
;;;1327           osRtxThreadSetRunning(osRtxInfo.thread.run.next);
;;;1328           (void)osRtxKernelErrorNotify(osRtxErrorStackOverflow, thread);
;;;1329         }
;;;1330   #endif
;;;1331         // Mark running thread as deleted
;;;1332         osRtxThreadSetRunning(NULL);
;;;1333       } else {
;;;1334         osRtxThreadDispatch(NULL);
000060  2000              MOVS     r0,#0
000062  f7fffffe          BL       osRtxThreadDispatch
                  |L67.102|
;;;1335       }
;;;1336   
;;;1337       // Destroy Thread
;;;1338       osRtxThreadDestroy(thread);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       osRtxThreadDestroy
                  |L67.108|
;;;1339     }
;;;1340   
;;;1341     return status;
00006c  4628              MOV      r0,r5
;;;1342   }
00006e  bd70              POP      {r4-r6,pc}
                  |L67.112|
000070  4629              MOV      r1,r5                 ;1307
000072  4620              MOV      r0,r4                 ;1307
000074  f7fffffe          BL       EvrRtxThreadError
000078  e7f8              B        |L67.108|
                  |L67.122|
00007a  480b              LDR      r0,|L67.168|
00007c  301c              ADDS     r0,r0,#0x1c           ;1321
00007e  f7fffffe          BL       osRtxThreadListGet
000082  f7fffffe          BL       osRtxThreadSwitch
000086  f3ef8009          MRS      r0,PSP                ;1321
00008a  63a0              STR      r0,[r4,#0x38]         ;1326
00008c  4620              MOV      r0,r4                 ;1326
00008e  f7fffffe          BL       osRtxThreadStackCheck
000092  b928              CBNZ     r0,|L67.160|
000094  69b0              LDR      r0,[r6,#0x18]         ;1326  ; osRtxInfo
000096  6170              STR      r0,[r6,#0x14]         ;1328  ; osRtxInfo
000098  4621              MOV      r1,r4                 ;1328
00009a  2001              MOVS     r0,#1                 ;1328
00009c  f7fffffe          BL       osRtxKernelErrorNotify
                  |L67.160|
0000a0  2000              MOVS     r0,#0                 ;1332
0000a2  6170              STR      r0,[r6,#0x14]         ;1332  ; osRtxInfo
0000a4  e7df              B        |L67.102|
;;;1343   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L67.168|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxThreadYield||, CODE, READONLY, ALIGN=2

                  svcRtxThreadYield PROC
;;;975    /// \note API identical to osThreadYield
;;;976    static osStatus_t svcRtxThreadYield (void) {
000000  b570              PUSH     {r4-r6,lr}
000002  480d              LDR      r0,|L68.56|
000004  7a01              LDRB     r1,[r0,#8]  ; osRtxInfo
;;;977      os_thread_t *thread_running;
;;;978      os_thread_t *thread_ready;
;;;979    
;;;980      if (osRtxKernelGetState() == osRtxKernelRunning) {
000006  2902              CMP      r1,#2
000008  d114              BNE      |L68.52|
;;;981        thread_running = osRtxThreadGetRunning();
;;;982        thread_ready   = osRtxInfo.thread.ready.thread_list;
;;;983        if ((thread_ready != NULL) &&
00000a  6a45              LDR      r5,[r0,#0x24]  ; osRtxInfo
00000c  6944              LDR      r4,[r0,#0x14]  ; osRtxInfo
00000e  b18d              CBZ      r5,|L68.52|
;;;984            (thread_ready->priority == thread_running->priority)) {
000010  f9950020          LDRSB    r0,[r5,#0x20]
000014  f9941020          LDRSB    r1,[r4,#0x20]
000018  4288              CMP      r0,r1
00001a  d10b              BNE      |L68.52|
;;;985          osRtxThreadListRemove(thread_ready);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       osRtxThreadListRemove
;;;986          osRtxThreadReadyPut(thread_running);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       osRtxThreadReadyPut
;;;987          EvrRtxThreadPreempted(thread_running);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       EvrRtxThreadPreempted
;;;988          osRtxThreadSwitch(thread_ready);
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       osRtxThreadSwitch
                  |L68.52|
;;;989        }
;;;990      }
;;;991    
;;;992      return osOK;
000034  2000              MOVS     r0,#0
;;;993    }
000036  bd70              POP      {r4-r6,pc}
;;;994    
                          ENDP

                  |L68.56|
                          DCD      osRtxInfo

                          AREA ||.data.os.thread.obj||, DATA, ALIGN=2

                  osRtxThreadMemUsage
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_thread.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___12_rtx_thread_c_3927f09d____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d____REVSH|
#line 223
|__asm___12_rtx_thread_c_3927f09d____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d____RRX|
#line 410
|__asm___12_rtx_thread_c_3927f09d____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_wr8|
#line 464 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_core_cm.h"
|__asm___12_rtx_thread_c_3927f09d__atomic_wr8| PROC
#line 464

 mov r2,r0
1
 ldrexb r0,[r2]
 strexb r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_set32|
#line 511
|__asm___12_rtx_thread_c_3927f09d__atomic_set32| PROC
#line 511

 mov r2,r0
1
 ldrex r0,[r2]
 orr r0,r0,r1
 strex r3,r0,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_clr32|
#line 570
|__asm___12_rtx_thread_c_3927f09d__atomic_clr32| PROC
#line 570

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F2
 b %B1
2
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_chk32_all|
#line 630
|__asm___12_rtx_thread_c_3927f09d__atomic_chk32_all| PROC
#line 630

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 and r4,r0,r1
 cmp r4,r1
 beq %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_chk32_any|
#line 705
|__asm___12_rtx_thread_c_3927f09d__atomic_chk32_any| PROC
#line 705

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 tst r0,r1
 bne %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_inc32|
#line 772
|__asm___12_rtx_thread_c_3927f09d__atomic_inc32| PROC
#line 772

 mov r2,r0
1
 ldrex r0,[r2]
 adds r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_inc16_lt|
#line 821
|__asm___12_rtx_thread_c_3927f09d__atomic_inc16_lt| PROC
#line 821

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 cmp r1,r0
 bhi %F2
 clrex
 pop {r4,pc}
2
 adds r4,r0,#1
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_inc16_lim|
#line 882
|__asm___12_rtx_thread_c_3927f09d__atomic_inc16_lim| PROC
#line 882

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 adds r4,r0,#1
 cmp r1,r4
 bhi %F2
 movs r4,#0
2
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_dec32|
#line 940
|__asm___12_rtx_thread_c_3927f09d__atomic_dec32| PROC
#line 940

 mov r2,r0
1
 ldrex r0,[r2]
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_dec32_nz|
#line 988
|__asm___12_rtx_thread_c_3927f09d__atomic_dec32_nz| PROC
#line 988

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_dec16_nz|
#line 1044
|__asm___12_rtx_thread_c_3927f09d__atomic_dec16_nz| PROC
#line 1044

 mov r2,r0
1
 ldrexh r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strexh r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_link_get|
#line 1100
|__asm___12_rtx_thread_c_3927f09d__atomic_link_get| PROC
#line 1100

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 ldr r1,[r0]
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_rtx_thread_c_3927f09d__atomic_link_put|
#line 1156
|__asm___12_rtx_thread_c_3927f09d__atomic_link_put| PROC
#line 1156

1
 ldr r2,[r0]
 str r2,[r1]
 dmb
 ldrex r2,[r0]
 ldr r3,[r1]
 cmp r3,r2
 bne %B1
 strex r3,r1,[r0]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP

;*** End   embedded assembler ***
