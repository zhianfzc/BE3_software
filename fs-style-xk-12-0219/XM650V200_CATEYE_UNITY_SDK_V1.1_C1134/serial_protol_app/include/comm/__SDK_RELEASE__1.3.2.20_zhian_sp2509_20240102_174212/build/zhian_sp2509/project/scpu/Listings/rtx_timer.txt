; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\rtx_timer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\rtx_timer.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\rtx_timer.crf F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_timer.c]
                          THUMB

                          AREA ||i.IsException||, CODE, READONLY, ALIGN=1

                  IsException PROC
;;;122    /// \return     true=exception, false=thread
;;;123    __STATIC_INLINE bool_t IsException (void) {
000000  f3ef8005          MRS      r0,IPSR
000004  2800              CMP      r0,#0
000006  d000              BEQ      |L1.10|
;;;124      return (__get_IPSR() != 0U);
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;125    }
00000a  4770              BX       lr
;;;126    
                          ENDP


                          AREA ||i.IsIrqMasked||, CODE, READONLY, ALIGN=1

                  IsIrqMasked PROC
;;;128    /// \return     true=masked, false=not masked
;;;129    __STATIC_INLINE bool_t IsIrqMasked (void) {
000000  f3ef8010          MRS      r0,PRIMASK
000004  b918              CBNZ     r0,|L2.14|
000006  f3ef8011          MRS      r0,BASEPRI
;;;130    #if   ((defined(__ARM_ARCH_7M__)        && (__ARM_ARCH_7M__        != 0)) || \
;;;131           (defined(__ARM_ARCH_7EM__)       && (__ARM_ARCH_7EM__       != 0)) || \
;;;132           (defined(__ARM_ARCH_8M_MAIN__)   && (__ARM_ARCH_8M_MAIN__   != 0)) || \
;;;133           (defined(__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ != 0)))
;;;134      return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L2.16|
                  |L2.14|
00000e  2001              MOVS     r0,#1
                  |L2.16|
;;;135    #else
;;;136      return  (__get_PRIMASK() != 0U);
;;;137    #endif
;;;138    }
000010  4770              BX       lr
;;;139    
                          ENDP


                          AREA ||i.TimerInsert||, CODE, READONLY, ALIGN=2

                  TimerInsert PROC
;;;41     /// \param[in]  tick            timer tick.
;;;42     static void TimerInsert (os_timer_t *timer, uint32_t tick) {
000000  b530              PUSH     {r4,r5,lr}
;;;43       os_timer_t *prev, *next;
;;;44     
;;;45       prev = NULL;
;;;46       next = osRtxInfo.timer.list;
000002  4c0c              LDR      r4,|L3.52|
000004  2300              MOVS     r3,#0                 ;45
000006  6c62              LDR      r2,[r4,#0x44]         ;42  ; osRtxInfo
000008  e002              B        |L3.16|
                  |L3.10|
;;;47       while ((next != NULL) && (next->tick <= tick)) {
;;;48         tick -= next->tick;
;;;49         prev  = next;
00000a  4613              MOV      r3,r2
;;;50         next  = next->next;
00000c  68d2              LDR      r2,[r2,#0xc]
00000e  1b49              SUBS     r1,r1,r5              ;48
                  |L3.16|
000010  b112              CBZ      r2,|L3.24|
000012  6915              LDR      r5,[r2,#0x10]         ;47
000014  428d              CMP      r5,r1                 ;47
000016  d9f8              BLS      |L3.10|
                  |L3.24|
;;;51       }
;;;52       timer->tick = tick;
;;;53       timer->prev = prev;
000018  6083              STR      r3,[r0,#8]
00001a  e9c02103          STRD     r2,r1,[r0,#0xc]
;;;54       timer->next = next;
;;;55       if (next != NULL) {
00001e  b11a              CBZ      r2,|L3.40|
;;;56         next->tick -= timer->tick;
000020  6915              LDR      r5,[r2,#0x10]
000022  1a69              SUBS     r1,r5,r1
;;;57         next->prev  = timer;
000024  6111              STR      r1,[r2,#0x10]
000026  6090              STR      r0,[r2,#8]
                  |L3.40|
;;;58       }
;;;59       if (prev != NULL) {
000028  b10b              CBZ      r3,|L3.46|
;;;60         prev->next = timer;
00002a  60d8              STR      r0,[r3,#0xc]
;;;61       } else {
;;;62         osRtxInfo.timer.list = timer;
;;;63       }
;;;64     }
00002c  bd30              POP      {r4,r5,pc}
                  |L3.46|
00002e  6460              STR      r0,[r4,#0x44]         ;62  ; osRtxInfo
000030  bd30              POP      {r4,r5,pc}
;;;65     
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      osRtxInfo

                          AREA ||i.TimerRemove||, CODE, READONLY, ALIGN=2

                  TimerRemove PROC
;;;67     /// \param[in]  timer           timer object.
;;;68     static void TimerRemove (const os_timer_t *timer) {
000000  68c1              LDR      r1,[r0,#0xc]
000002  b131              CBZ      r1,|L4.18|
;;;69     
;;;70       if (timer->next != NULL) {
;;;71         timer->next->tick += timer->tick;
000004  690a              LDR      r2,[r1,#0x10]
000006  6903              LDR      r3,[r0,#0x10]
000008  441a              ADD      r2,r2,r3
00000a  610a              STR      r2,[r1,#0x10]
00000c  e9d01202          LDRD     r1,r2,[r0,#8]
;;;72         timer->next->prev  = timer->prev;
000010  6091              STR      r1,[r2,#8]
                  |L4.18|
;;;73       }
;;;74       if (timer->prev != NULL) {
;;;75         timer->prev->next  = timer->next;
;;;76       } else {
;;;77         osRtxInfo.timer.list = timer->next;
000012  e9d01002          LDRD     r1,r0,[r0,#8]
000016  b109              CBZ      r1,|L4.28|
000018  60c8              STR      r0,[r1,#0xc]          ;75
;;;78       }
;;;79     }
00001a  4770              BX       lr
                  |L4.28|
00001c  4901              LDR      r1,|L4.36|
00001e  6448              STR      r0,[r1,#0x44]         ;77  ; osRtxInfo
000020  4770              BX       lr
;;;80     
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      osRtxInfo

                          AREA ||i.osRtxTimerSetup||, CODE, READONLY, ALIGN=2

                  osRtxTimerSetup PROC
;;;136    //lint -esym(765,osRtxTimerSetup) "Global scope"
;;;137    int32_t osRtxTimerSetup (void) {
000000  b510              PUSH     {r4,lr}
;;;138      int32_t ret = -1;
000002  f04f34ff          MOV      r4,#0xffffffff
;;;139    
;;;140      if (osRtxMessageQueueTimerSetup() == 0) {
000006  f7fffffe          BL       osRtxMessageQueueTimerSetup
00000a  b918              CBNZ     r0,|L5.20|
;;;141        osRtxInfo.timer.tick = osRtxTimerTick;
00000c  4903              LDR      r1,|L5.28|
00000e  4802              LDR      r0,|L5.24|
;;;142        ret = 0;
000010  2400              MOVS     r4,#0
000012  6508              STR      r0,[r1,#0x50]  ; osRtxInfo
                  |L5.20|
;;;143      }
;;;144    
;;;145      return ret;
000014  4620              MOV      r0,r4
;;;146    }
000016  bd10              POP      {r4,pc}
;;;147    
                          ENDP

                  |L5.24|
                          DCD      osRtxTimerTick
                  |L5.28|
                          DCD      osRtxInfo

                          AREA ||i.osRtxTimerThread||, CODE, READONLY, ALIGN=1

                  osRtxTimerThread PROC
;;;151    //lint -esym(765,osRtxTimerThread) "Global scope"
;;;152    __NO_RETURN void osRtxTimerThread (void *argument) {
000000  b51c              PUSH     {r2-r4,lr}
;;;153      os_timer_finfo_t   finfo;
;;;154      osStatus_t         status;
;;;155      osMessageQueueId_t mq = (osMessageQueueId_t)argument;
000002  4604              MOV      r4,r0
;;;156    
;;;157      for (;;) {
;;;158        //lint -e{934} "Taking address of near auto variable"
;;;159        status = osMessageQueueGet(mq, &finfo, NULL, osWaitForever);
000004  f04f35ff          MOV      r5,#0xffffffff
                  |L6.8|
000008  462b              MOV      r3,r5
00000a  2200              MOVS     r2,#0
00000c  4669              MOV      r1,sp
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       osMessageQueueGet
;;;160        if (status == osOK) {
000014  2800              CMP      r0,#0
000016  d1f7              BNE      |L6.8|
000018  e9dd0100          LDRD     r0,r1,[sp,#0]
;;;161          EvrRtxTimerCallback(finfo.func, finfo.arg);
00001c  f7fffffe          BL       EvrRtxTimerCallback
000020  e9dd1000          LDRD     r1,r0,[sp,#0]
;;;162          (finfo.func)(finfo.arg);
000024  4788              BLX      r1
000026  e7ef              B        |L6.8|
;;;163        }
;;;164      }
;;;165    }
;;;166    
                          ENDP


                          AREA ||i.osRtxTimerTick||, CODE, READONLY, ALIGN=2

                  osRtxTimerTick PROC
;;;94     /// Timer Tick (called each SysTick).
;;;95     static void osRtxTimerTick (void) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;96       os_thread_t *thread_running;
;;;97       os_timer_t  *timer;
;;;98       osStatus_t   status;
;;;99     
;;;100      timer = osRtxInfo.timer.list;
000004  4d1a              LDR      r5,|L7.112|
000006  6c6c              LDR      r4,[r5,#0x44]         ;95  ; osRtxInfo
000008  2c00              CMP      r4,#0                 ;95
00000a  d029              BEQ      |L7.96|
;;;101      if (timer == NULL) {
;;;102        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;103        return;
;;;104      }
;;;105    
;;;106      thread_running = osRtxThreadGetRunning();
;;;107    
;;;108      timer->tick--;
00000c  6920              LDR      r0,[r4,#0x10]
00000e  696e              LDR      r6,[r5,#0x14]  ; osRtxInfo
000010  1e40              SUBS     r0,r0,#1
;;;109      while ((timer != NULL) && (timer->tick == 0U)) {
000012  6120              STR      r0,[r4,#0x10]
000014  e021              B        |L7.90|
                  |L7.22|
000016  68e0              LDR      r0,[r4,#0xc]
000018  b108              CBZ      r0,|L7.30|
00001a  68a1              LDR      r1,[r4,#8]
00001c  6081              STR      r1,[r0,#8]
                  |L7.30|
00001e  68e0              LDR      r0,[r4,#0xc]
;;;110        TimerUnlink(timer);
;;;111        status = osMessageQueuePut(osRtxInfo.timer.mq, &timer->finfo, 0U, 0U);
000020  6468              STR      r0,[r5,#0x44]  ; osRtxInfo
000022  2300              MOVS     r3,#0
000024  461a              MOV      r2,r3
000026  f1040118          ADD      r1,r4,#0x18
00002a  6ce8              LDR      r0,[r5,#0x4c]  ; osRtxInfo
00002c  f7fffffe          BL       osMessageQueuePut
;;;112        if (status != osOK) {
000030  b158              CBZ      r0,|L7.74|
000032  e9d57005          LDRD     r7,r0,[r5,#0x14]
;;;113          const os_thread_t *thread = osRtxThreadGetRunning();
;;;114          osRtxThreadSetRunning(osRtxInfo.thread.run.next);
;;;115          (void)osRtxKernelErrorNotify(osRtxErrorTimerQueueOverflow, timer);
000036  6168              STR      r0,[r5,#0x14]  ; osRtxInfo
000038  4621              MOV      r1,r4
00003a  2003              MOVS     r0,#3
00003c  f7fffffe          BL       osRtxKernelErrorNotify
;;;116          if (osRtxThreadGetRunning() == NULL) {
000040  6968              LDR      r0,[r5,#0x14]  ; osRtxInfo
000042  b910              CBNZ     r0,|L7.74|
;;;117            if (thread_running == thread) {
000044  42be              CMP      r6,r7
000046  d100              BNE      |L7.74|
;;;118              thread_running = NULL;
000048  2600              MOVS     r6,#0
                  |L7.74|
;;;119            }
;;;120          }
;;;121        }
;;;122        if (timer->type == osRtxTimerPeriodic) {
00004a  78e0              LDRB     r0,[r4,#3]
00004c  2801              CMP      r0,#1
00004e  d009              BEQ      |L7.100|
;;;123          TimerInsert(timer, timer->load);
;;;124        } else {
;;;125          timer->state = osRtxTimerStopped;
000050  2001              MOVS     r0,#1
000052  7060              STRB     r0,[r4,#1]
                  |L7.84|
;;;126        }
;;;127        timer = osRtxInfo.timer.list;
000054  6c6c              LDR      r4,[r5,#0x44]  ; osRtxInfo
000056  b114              CBZ      r4,|L7.94|
000058  6920              LDR      r0,[r4,#0x10]         ;109
                  |L7.90|
00005a  2800              CMP      r0,#0                 ;109
00005c  d0db              BEQ      |L7.22|
                  |L7.94|
;;;128      }
;;;129    
;;;130      osRtxThreadSetRunning(thread_running);
;;;131    }
00005e  616e              STR      r6,[r5,#0x14]  ; osRtxInfo
                  |L7.96|
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L7.100|
000064  4620              MOV      r0,r4                 ;123
000066  6961              LDR      r1,[r4,#0x14]         ;123
000068  f7fffffe          BL       TimerInsert
00006c  e7f2              B        |L7.84|
;;;132    
                          ENDP

00006e  0000              DCW      0x0000
                  |L7.112|
                          DCD      osRtxInfo

                          AREA ||i.osTimerDelete||, CODE, READONLY, ALIGN=2

                  osTimerDelete PROC
;;;473    /// Delete a timer.
;;;474    osStatus_t osTimerDelete (osTimerId_t timer_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;475      osStatus_t status;
;;;476    
;;;477      EvrRtxTimerDelete(timer_id);
000004  f7fffffe          BL       EvrRtxTimerDelete
;;;478      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L8.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L8.36|
                  |L8.20|
;;;479        EvrRtxTimerError(timer_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxTimerError
;;;480        status = osErrorISR;
000020  4628              MOV      r0,r5
;;;481      } else {
;;;482        status = __svcTimerDelete(timer_id);
;;;483      }
;;;484      return status;
;;;485    }
000022  bd70              POP      {r4-r6,pc}
                  |L8.36|
000024  4620              MOV      r0,r4                 ;482
000026  f8dfc008          LDR      r12,|L8.48|
00002a  df00              SVC      #0x0                  ;482
00002c  bd70              POP      {r4-r6,pc}
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      svcRtxTimerDelete

                          AREA ||i.osTimerGetName||, CODE, READONLY, ALIGN=2

                  osTimerGetName PROC
;;;419    /// Get name of a timer.
;;;420    const char *osTimerGetName (osTimerId_t timer_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;421      const char *name;
;;;422    
;;;423      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L9.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b128              CBZ      r0,|L9.28|
                  |L9.16|
;;;424        EvrRtxTimerGetName(timer_id, NULL);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxTimerGetName
;;;425        name = NULL;
000018  2000              MOVS     r0,#0
;;;426      } else {
;;;427        name = __svcTimerGetName(timer_id);
;;;428      }
;;;429      return name;
;;;430    }
00001a  bd10              POP      {r4,pc}
                  |L9.28|
00001c  4620              MOV      r0,r4                 ;427
00001e  f8dfc008          LDR      r12,|L9.40|
000022  df00              SVC      #0x0                  ;427
000024  bd10              POP      {r4,pc}
;;;431    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      svcRtxTimerGetName

                          AREA ||i.osTimerIsRunning||, CODE, READONLY, ALIGN=2

                  osTimerIsRunning PROC
;;;460    /// Check if a timer is running.
;;;461    uint32_t osTimerIsRunning (osTimerId_t timer_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;462      uint32_t is_running;
;;;463    
;;;464      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L10.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b128              CBZ      r0,|L10.28|
                  |L10.16|
;;;465        EvrRtxTimerIsRunning(timer_id, 0U);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxTimerIsRunning
;;;466        is_running = 0U;
000018  2000              MOVS     r0,#0
;;;467      } else {
;;;468        is_running = __svcTimerIsRunning(timer_id);
;;;469      }
;;;470      return is_running;
;;;471    }
00001a  bd10              POP      {r4,pc}
                  |L10.28|
00001c  4620              MOV      r0,r4                 ;468
00001e  f8dfc008          LDR      r12,|L10.40|
000022  df00              SVC      #0x0                  ;468
000024  bd10              POP      {r4,pc}
;;;472    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      svcRtxTimerIsRunning

                          AREA ||i.osTimerNew||, CODE, READONLY, ALIGN=2

                  osTimerNew PROC
;;;405    /// Create and Initialize a timer.
;;;406    osTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461c              MOV      r4,r3
000006  4615              MOV      r5,r2
000008  460e              MOV      r6,r1
00000a  4607              MOV      r7,r0
;;;407      osTimerId_t timer_id;
;;;408    
;;;409      EvrRtxTimerNew(func, type, argument, attr);
00000c  f7fffffe          BL       EvrRtxTimerNew
;;;410      if (IsException() || IsIrqMasked()) {
000010  f7fffffe          BL       IsException
000014  b910              CBNZ     r0,|L11.28|
000016  f7fffffe          BL       IsIrqMasked
00001a  b138              CBZ      r0,|L11.44|
                  |L11.28|
;;;411        EvrRtxTimerError(NULL, (int32_t)osErrorISR);
00001c  f06f0105          MVN      r1,#5
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       EvrRtxTimerError
;;;412        timer_id = NULL;
000026  2000              MOVS     r0,#0
                  |L11.40|
;;;413      } else {
;;;414        timer_id = __svcTimerNew(func, type, argument, attr);
;;;415      }
;;;416      return timer_id;
;;;417    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L11.44|
00002c  4638              MOV      r0,r7                 ;414
00002e  4631              MOV      r1,r6                 ;414
000030  462a              MOV      r2,r5                 ;414
000032  4623              MOV      r3,r4                 ;414
000034  f8dfc004          LDR      r12,|L11.60|
000038  df00              SVC      #0x0                  ;414
00003a  e7f5              B        |L11.40|
;;;418    
                          ENDP

                  |L11.60|
                          DCD      svcRtxTimerNew

                          AREA ||i.osTimerStart||, CODE, READONLY, ALIGN=2

                  osTimerStart PROC
;;;432    /// Start or restart a timer.
;;;433    osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;434      osStatus_t status;
;;;435    
;;;436      EvrRtxTimerStart(timer_id, ticks);
000006  f7fffffe          BL       EvrRtxTimerStart
;;;437      if (IsException() || IsIrqMasked()) {
00000a  f7fffffe          BL       IsException
00000e  b910              CBNZ     r0,|L12.22|
000010  f7fffffe          BL       IsIrqMasked
000014  b138              CBZ      r0,|L12.38|
                  |L12.22|
;;;438        EvrRtxTimerError(timer_id, (int32_t)osErrorISR);
000016  f06f0405          MVN      r4,#5
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       EvrRtxTimerError
;;;439        status = osErrorISR;
000022  4620              MOV      r0,r4
;;;440      } else {
;;;441        status = __svcTimerStart(timer_id, ticks);
;;;442      }
;;;443      return status;
;;;444    }
000024  bd70              POP      {r4-r6,pc}
                  |L12.38|
000026  4628              MOV      r0,r5                 ;441
000028  4621              MOV      r1,r4                 ;441
00002a  f8dfc008          LDR      r12,|L12.52|
00002e  df00              SVC      #0x0                  ;441
000030  bd70              POP      {r4-r6,pc}
;;;445    
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      svcRtxTimerStart

                          AREA ||i.osTimerStop||, CODE, READONLY, ALIGN=2

                  osTimerStop PROC
;;;446    /// Stop a timer.
;;;447    osStatus_t osTimerStop (osTimerId_t timer_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;448      osStatus_t status;
;;;449    
;;;450      EvrRtxTimerStop(timer_id);
000004  f7fffffe          BL       EvrRtxTimerStop
;;;451      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L13.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L13.36|
                  |L13.20|
;;;452        EvrRtxTimerError(timer_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxTimerError
;;;453        status = osErrorISR;
000020  4628              MOV      r0,r5
;;;454      } else {
;;;455        status = __svcTimerStop(timer_id);
;;;456      }
;;;457      return status;
;;;458    }
000022  bd70              POP      {r4-r6,pc}
                  |L13.36|
000024  4620              MOV      r0,r4                 ;455
000026  f8dfc008          LDR      r12,|L13.48|
00002a  df00              SVC      #0x0                  ;455
00002c  bd70              POP      {r4-r6,pc}
;;;459    
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      svcRtxTimerStop

                          AREA ||i.svcRtxTimerDelete||, CODE, READONLY, ALIGN=2

                  svcRtxTimerDelete PROC
;;;356    /// \note API identical to osTimerDelete
;;;357    static osStatus_t svcRtxTimerDelete (osTimerId_t timer_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;358      os_timer_t *timer = osRtxTimerId(timer_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L14.12|
;;;359    
;;;360      // Check parameters
;;;361      if ((timer == NULL) || (timer->id != osRtxIdTimer)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f2              CMP      r0,#0xf2
00000a  d007              BEQ      |L14.28|
                  |L14.12|
;;;362        EvrRtxTimerError(timer, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxTimerError
;;;363        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;364        return osErrorParameter;
000018  4628              MOV      r0,r5
;;;365      }
;;;366    
;;;367      if (timer->state == osRtxTimerRunning) {
;;;368        TimerRemove(timer);
;;;369      }
;;;370    
;;;371      // Mark object as inactive and invalid
;;;372      timer->state = osRtxTimerInactive;
;;;373      timer->id    = osRtxIdInvalid;
;;;374    
;;;375      // Free object memory
;;;376      if ((timer->flags & osRtxFlagSystemObject) != 0U) {
;;;377        if (osRtxInfo.mpi.timer != NULL) {
;;;378          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.timer, timer);
;;;379        } else {
;;;380          (void)osRtxMemoryFree(osRtxInfo.mem.common, timer);
;;;381        }
;;;382    #ifdef RTX_OBJ_MEM_USAGE
;;;383        osRtxTimerMemUsage.cnt_free++;
;;;384    #endif
;;;385      }
;;;386    
;;;387      EvrRtxTimerDestroyed(timer);
;;;388    
;;;389      return osOK;
;;;390    }
00001a  bd70              POP      {r4-r6,pc}
                  |L14.28|
00001c  7860              LDRB     r0,[r4,#1]            ;367
00001e  2802              CMP      r0,#2                 ;367
000020  d102              BNE      |L14.40|
000022  4620              MOV      r0,r4                 ;368
000024  f7fffffe          BL       TimerRemove
                  |L14.40|
000028  2000              MOVS     r0,#0                 ;372
00002a  7060              STRB     r0,[r4,#1]            ;372
00002c  7020              STRB     r0,[r4,#0]            ;373
00002e  78a0              LDRB     r0,[r4,#2]            ;376
000030  07c0              LSLS     r0,r0,#31             ;376
000032  d010              BEQ      |L14.86|
000034  490a              LDR      r1,|L14.96|
000036  f8d1008c          LDR      r0,[r1,#0x8c]         ;377  ; osRtxInfo
00003a  b118              CBZ      r0,|L14.68|
00003c  4621              MOV      r1,r4                 ;378
00003e  f7fffffe          BL       osRtxMemoryPoolFree
000042  e004              B        |L14.78|
                  |L14.68|
000044  f8d10080          LDR      r0,[r1,#0x80]         ;380  ; osRtxInfo
000048  4621              MOV      r1,r4                 ;380
00004a  f7fffffe          BL       osRtxMemoryFree
                  |L14.78|
00004e  4805              LDR      r0,|L14.100|
000050  6841              LDR      r1,[r0,#4]            ;383  ; osRtxTimerMemUsage
000052  1c49              ADDS     r1,r1,#1              ;383
000054  6041              STR      r1,[r0,#4]            ;383  ; osRtxTimerMemUsage
                  |L14.86|
000056  4620              MOV      r0,r4                 ;387
000058  f7fffffe          BL       EvrRtxTimerDestroyed
00005c  2000              MOVS     r0,#0                 ;389
00005e  bd70              POP      {r4-r6,pc}
;;;391    
                          ENDP

                  |L14.96|
                          DCD      osRtxInfo
                  |L14.100|
                          DCD      ||.data.os.timer.obj||

                          AREA ||i.svcRtxTimerGetName||, CODE, READONLY, ALIGN=1

                  svcRtxTimerGetName PROC
;;;254    /// \note API identical to osTimerGetName
;;;255    static const char *svcRtxTimerGetName (osTimerId_t timer_id) {
000000  b510              PUSH     {r4,lr}
;;;256      os_timer_t *timer = osRtxTimerId(timer_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L15.12|
;;;257    
;;;258      // Check parameters
;;;259      if ((timer == NULL) || (timer->id != osRtxIdTimer)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f2              CMP      r0,#0xf2
00000a  d005              BEQ      |L15.24|
                  |L15.12|
;;;260        EvrRtxTimerGetName(timer, NULL);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxTimerGetName
;;;261        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;262        return NULL;
000014  2000              MOVS     r0,#0
;;;263      }
;;;264    
;;;265      EvrRtxTimerGetName(timer, timer->name);
;;;266    
;;;267      return timer->name;
;;;268    }
000016  bd10              POP      {r4,pc}
                  |L15.24|
000018  4620              MOV      r0,r4                 ;265
00001a  6861              LDR      r1,[r4,#4]            ;265
00001c  f7fffffe          BL       EvrRtxTimerGetName
000020  6860              LDR      r0,[r4,#4]            ;267
000022  bd10              POP      {r4,pc}
;;;269    
                          ENDP


                          AREA ||i.svcRtxTimerIsRunning||, CODE, READONLY, ALIGN=1

                  svcRtxTimerIsRunning PROC
;;;332    /// \note API identical to osTimerIsRunning
;;;333    static uint32_t svcRtxTimerIsRunning (osTimerId_t timer_id) {
000000  b510              PUSH     {r4,lr}
000002  b128              CBZ      r0,|L16.16|
;;;334      os_timer_t *timer = osRtxTimerId(timer_id);
;;;335      uint32_t    is_running;
;;;336    
;;;337      // Check parameters
;;;338      if ((timer == NULL) || (timer->id != osRtxIdTimer)) {
000004  7801              LDRB     r1,[r0,#0]
000006  29f2              CMP      r1,#0xf2
000008  d102              BNE      |L16.16|
;;;339        EvrRtxTimerIsRunning(timer, 0U);
;;;340        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;341        return 0U;
;;;342      }
;;;343    
;;;344      if (timer->state == osRtxTimerRunning) {
00000a  7841              LDRB     r1,[r0,#1]
00000c  2902              CMP      r1,#2
00000e  d004              BEQ      |L16.26|
                  |L16.16|
;;;345        EvrRtxTimerIsRunning(timer, 1U);
;;;346        is_running = 1U;
;;;347      } else {
;;;348        EvrRtxTimerIsRunning(timer, 0U);
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       EvrRtxTimerIsRunning
;;;349        is_running = 0;
000016  2000              MOVS     r0,#0
;;;350      }
;;;351    
;;;352      return is_running;
;;;353    }
000018  bd10              POP      {r4,pc}
                  |L16.26|
00001a  2101              MOVS     r1,#1                 ;345
00001c  f7fffffe          BL       EvrRtxTimerIsRunning
000020  2001              MOVS     r0,#1                 ;346
000022  bd10              POP      {r4,pc}
;;;354    
                          ENDP


                          AREA ||i.svcRtxTimerNew||, CODE, READONLY, ALIGN=2

                  svcRtxTimerNew PROC
;;;170    /// \note API identical to osTimerNew
;;;171    static osTimerId_t svcRtxTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4690              MOV      r8,r2
000006  460e              MOV      r6,r1
000008  0007              MOVS     r7,r0
00000a  d002              BEQ      |L17.18|
;;;172      os_timer_t *timer;
;;;173      uint8_t     flags;
;;;174      const char *name;
;;;175    
;;;176      // Check parameters
;;;177      if ((func == NULL) || ((type != osTimerOnce) && (type != osTimerPeriodic))) {
00000c  b126              CBZ      r6,|L17.24|
00000e  2e01              CMP      r6,#1
000010  d002              BEQ      |L17.24|
                  |L17.18|
;;;178        EvrRtxTimerError(NULL, (int32_t)osErrorParameter);
000012  f06f0103          MVN      r1,#3
;;;179        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;180        return NULL;
000016  e00d              B        |L17.52|
                  |L17.24|
;;;181      }
;;;182    
;;;183      // Process attributes
;;;184      if (attr != NULL) {
000018  b193              CBZ      r3,|L17.64|
;;;185        name  = attr->name;
;;;186        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
;;;187        timer = attr->cb_mem;
;;;188        if (timer != NULL) {
00001a  681d              LDR      r5,[r3,#0]
00001c  689c              LDR      r4,[r3,#8]
;;;189          //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
;;;190          if ((((uint32_t)timer & 3U) != 0U) || (attr->cb_size < sizeof(os_timer_t))) {
;;;191            EvrRtxTimerError(NULL, osRtxErrorInvalidControlBlock);
00001e  f06f0108          MVN      r1,#8
000022  b12c              CBZ      r4,|L17.48|
000024  07a0              LSLS     r0,r4,#30             ;190
000026  d105              BNE      |L17.52|
000028  68d8              LDR      r0,[r3,#0xc]          ;190
00002a  2820              CMP      r0,#0x20              ;190
00002c  d302              BCC      |L17.52|
00002e  e029              B        |L17.132|
                  |L17.48|
;;;192            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;193            return NULL;
;;;194          }
;;;195        } else {
;;;196          if (attr->cb_size != 0U) {
000030  68d8              LDR      r0,[r3,#0xc]
000032  b130              CBZ      r0,|L17.66|
                  |L17.52|
;;;197            EvrRtxTimerError(NULL, osRtxErrorInvalidControlBlock);
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       EvrRtxTimerError
;;;198            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;199            return NULL;
00003a  2000              MOVS     r0,#0
                  |L17.60|
;;;200          }
;;;201        }
;;;202      } else {
;;;203        name  = NULL;
;;;204        timer = NULL;
;;;205      }
;;;206    
;;;207      // Allocate object memory if not provided
;;;208      if (timer == NULL) {
;;;209        if (osRtxInfo.mpi.timer != NULL) {
;;;210          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;211          timer = osRtxMemoryPoolAlloc(osRtxInfo.mpi.timer);
;;;212        } else {
;;;213          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;214          timer = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_timer_t), 1U);
;;;215        }
;;;216    #ifdef RTX_OBJ_MEM_USAGE
;;;217        if (timer != NULL) {
;;;218          uint32_t used;
;;;219          osRtxTimerMemUsage.cnt_alloc++;
;;;220          used = osRtxTimerMemUsage.cnt_alloc - osRtxTimerMemUsage.cnt_free;
;;;221          if (osRtxTimerMemUsage.max_used < used) {
;;;222            osRtxTimerMemUsage.max_used = used;
;;;223          }
;;;224        }
;;;225    #endif
;;;226        flags = osRtxFlagSystemObject;
;;;227      } else {
;;;228        flags = 0U;
;;;229      }
;;;230    
;;;231      if (timer != NULL) {
;;;232        // Initialize control block
;;;233        timer->id         = osRtxIdTimer;
;;;234        timer->state      = osRtxTimerStopped;
;;;235        timer->flags      = flags;
;;;236        timer->type       = (uint8_t)type;
;;;237        timer->name       = name;
;;;238        timer->prev       = NULL;
;;;239        timer->next       = NULL;
;;;240        timer->tick       = 0U;
;;;241        timer->load       = 0U;
;;;242        timer->finfo.func = func;
;;;243        timer->finfo.arg  = argument;
;;;244    
;;;245        EvrRtxTimerCreated(timer, timer->name);
;;;246      } else {
;;;247        EvrRtxTimerError(NULL, (int32_t)osErrorNoMemory);
;;;248      }
;;;249    
;;;250      return timer;
;;;251    }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L17.64|
000040  2500              MOVS     r5,#0                 ;203
                  |L17.66|
000042  491b              LDR      r1,|L17.176|
000044  f8d1008c          LDR      r0,[r1,#0x8c]         ;209  ; osRtxInfo
000048  b110              CBZ      r0,|L17.80|
00004a  f7fffffe          BL       osRtxMemoryPoolAlloc
00004e  e005              B        |L17.92|
                  |L17.80|
000050  f8d10080          LDR      r0,[r1,#0x80]         ;214  ; osRtxInfo
000054  2201              MOVS     r2,#1                 ;214
000056  2120              MOVS     r1,#0x20              ;214
000058  f7fffffe          BL       osRtxMemoryAlloc
                  |L17.92|
00005c  0004              MOVS     r4,r0                 ;214
00005e  d00b              BEQ      |L17.120|
000060  4814              LDR      r0,|L17.180|
000062  6801              LDR      r1,[r0,#0]            ;219  ; osRtxTimerMemUsage
000064  1c49              ADDS     r1,r1,#1              ;219
000066  6001              STR      r1,[r0,#0]            ;220  ; osRtxTimerMemUsage
000068  6842              LDR      r2,[r0,#4]            ;220  ; osRtxTimerMemUsage
00006a  1a89              SUBS     r1,r1,r2              ;220
00006c  6882              LDR      r2,[r0,#8]            ;221  ; osRtxTimerMemUsage
00006e  428a              CMP      r2,r1                 ;221
000070  d200              BCS      |L17.116|
000072  6081              STR      r1,[r0,#8]            ;222  ; osRtxTimerMemUsage
                  |L17.116|
000074  2001              MOVS     r0,#1                 ;226
000076  e006              B        |L17.134|
                  |L17.120|
000078  f06f0104          MVN      r1,#4                 ;247
00007c  2000              MOVS     r0,#0                 ;247
00007e  f7fffffe          BL       EvrRtxTimerError
000082  e013              B        |L17.172|
                  |L17.132|
000084  2000              MOVS     r0,#0                 ;228
                  |L17.134|
000086  21f2              MOVS     r1,#0xf2              ;233
000088  7021              STRB     r1,[r4,#0]            ;233
00008a  2101              MOVS     r1,#1                 ;234
00008c  7061              STRB     r1,[r4,#1]            ;234
00008e  70a0              STRB     r0,[r4,#2]            ;235
000090  70e6              STRB     r6,[r4,#3]            ;236
000092  2000              MOVS     r0,#0                 ;238
000094  e9c45001          STRD     r5,r0,[r4,#4]         ;238
000098  60e0              STR      r0,[r4,#0xc]          ;240
00009a  f1040214          ADD      r2,r4,#0x14           ;240
00009e  6120              STR      r0,[r4,#0x10]         ;240
0000a0  e8820181          STM      r2,{r0,r7,r8}         ;240
0000a4  4629              MOV      r1,r5                 ;237
0000a6  4620              MOV      r0,r4                 ;245
0000a8  f7fffffe          BL       EvrRtxTimerCreated
                  |L17.172|
0000ac  4620              MOV      r0,r4                 ;250
0000ae  e7c5              B        |L17.60|
;;;252    
                          ENDP

                  |L17.176|
                          DCD      osRtxInfo
                  |L17.180|
                          DCD      ||.data.os.timer.obj||

                          AREA ||i.svcRtxTimerStart||, CODE, READONLY, ALIGN=2

                  svcRtxTimerStart PROC
;;;271    /// \note API identical to osTimerStart
;;;272    static osStatus_t svcRtxTimerStart (osTimerId_t timer_id, uint32_t ticks) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
;;;273      os_timer_t *timer = osRtxTimerId(timer_id);
000004  0004              MOVS     r4,r0
000006  d015              BEQ      |L18.52|
;;;274    
;;;275      // Check parameters
;;;276      if ((timer == NULL) || (timer->id != osRtxIdTimer) || (ticks == 0U)) {
000008  7820              LDRB     r0,[r4,#0]
00000a  28f2              CMP      r0,#0xf2
00000c  d112              BNE      |L18.52|
00000e  b18d              CBZ      r5,|L18.52|
;;;277        EvrRtxTimerError(timer, (int32_t)osErrorParameter);
;;;278        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;279        return osErrorParameter;
;;;280      }
;;;281    
;;;282      if (timer->state == osRtxTimerRunning) {
000010  7860              LDRB     r0,[r4,#1]
000012  2802              CMP      r0,#2
000014  d011              BEQ      |L18.58|
;;;283        timer->load = ticks;
;;;284        TimerRemove(timer);
;;;285      } else {
;;;286        if (osRtxInfo.timer.tick == NULL) {
000016  480f              LDR      r0,|L18.84|
000018  6d00              LDR      r0,[r0,#0x50]  ; osRtxInfo
00001a  b198              CBZ      r0,|L18.68|
;;;287          EvrRtxTimerError(timer, (int32_t)osErrorResource);
;;;288          //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;289          return osErrorResource;
;;;290        } else {
;;;291          timer->state = osRtxTimerRunning;
00001c  2002              MOVS     r0,#2
00001e  7060              STRB     r0,[r4,#1]
;;;292          timer->load  = ticks;
000020  6165              STR      r5,[r4,#0x14]
                  |L18.34|
;;;293        }
;;;294      }
;;;295    
;;;296      TimerInsert(timer, ticks);
000022  4629              MOV      r1,r5
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TimerInsert
;;;297    
;;;298      EvrRtxTimerStarted(timer);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       EvrRtxTimerStarted
;;;299    
;;;300      return osOK;
000030  2000              MOVS     r0,#0
;;;301    }
000032  bd70              POP      {r4-r6,pc}
                  |L18.52|
000034  f06f0503          MVN      r5,#3                 ;277
000038  e006              B        |L18.72|
                  |L18.58|
00003a  4620              MOV      r0,r4                 ;284
00003c  6165              STR      r5,[r4,#0x14]         ;284
00003e  f7fffffe          BL       TimerRemove
000042  e7ee              B        |L18.34|
                  |L18.68|
000044  f06f0502          MVN      r5,#2                 ;287
                  |L18.72|
000048  4629              MOV      r1,r5                 ;287
00004a  4620              MOV      r0,r4                 ;287
00004c  f7fffffe          BL       EvrRtxTimerError
000050  4628              MOV      r0,r5                 ;289
000052  bd70              POP      {r4-r6,pc}
;;;302    
                          ENDP

                  |L18.84|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxTimerStop||, CODE, READONLY, ALIGN=1

                  svcRtxTimerStop PROC
;;;304    /// \note API identical to osTimerStop
;;;305    static osStatus_t svcRtxTimerStop (osTimerId_t timer_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;306      os_timer_t *timer = osRtxTimerId(timer_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L19.12|
;;;307    
;;;308      // Check parameters
;;;309      if ((timer == NULL) || (timer->id != osRtxIdTimer)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f2              CMP      r0,#0xf2
00000a  d002              BEQ      |L19.18|
                  |L19.12|
;;;310        EvrRtxTimerError(timer, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
;;;311        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;312        return osErrorParameter;
000010  e004              B        |L19.28|
                  |L19.18|
;;;313      }
;;;314    
;;;315      // Check object state
;;;316      if (timer->state != osRtxTimerRunning) {
000012  7860              LDRB     r0,[r4,#1]
000014  2802              CMP      r0,#2
000016  d007              BEQ      |L19.40|
;;;317        EvrRtxTimerError(timer, (int32_t)osErrorResource);
000018  f06f0502          MVN      r5,#2
                  |L19.28|
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       EvrRtxTimerError
;;;318        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;319        return osErrorResource;
000024  4628              MOV      r0,r5
;;;320      }
;;;321    
;;;322      timer->state = osRtxTimerStopped;
;;;323    
;;;324      TimerRemove(timer);
;;;325    
;;;326      EvrRtxTimerStopped(timer);
;;;327    
;;;328      return osOK;
;;;329    }
000026  bd70              POP      {r4-r6,pc}
                  |L19.40|
000028  2001              MOVS     r0,#1                 ;322
00002a  7060              STRB     r0,[r4,#1]            ;322
00002c  4620              MOV      r0,r4                 ;324
00002e  f7fffffe          BL       TimerRemove
000032  4620              MOV      r0,r4                 ;326
000034  f7fffffe          BL       EvrRtxTimerStopped
000038  2000              MOVS     r0,#0                 ;328
00003a  bd70              POP      {r4-r6,pc}
;;;330    
                          ENDP


                          AREA ||.data.os.timer.obj||, DATA, ALIGN=2

                  osRtxTimerMemUsage
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___11_rtx_timer_c_5d09138c____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c____REVSH|
#line 223
|__asm___11_rtx_timer_c_5d09138c____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c____RRX|
#line 410
|__asm___11_rtx_timer_c_5d09138c____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_wr8|
#line 464 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_core_cm.h"
|__asm___11_rtx_timer_c_5d09138c__atomic_wr8| PROC
#line 464

 mov r2,r0
1
 ldrexb r0,[r2]
 strexb r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_set32|
#line 511
|__asm___11_rtx_timer_c_5d09138c__atomic_set32| PROC
#line 511

 mov r2,r0
1
 ldrex r0,[r2]
 orr r0,r0,r1
 strex r3,r0,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_clr32|
#line 570
|__asm___11_rtx_timer_c_5d09138c__atomic_clr32| PROC
#line 570

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F2
 b %B1
2
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_chk32_all|
#line 630
|__asm___11_rtx_timer_c_5d09138c__atomic_chk32_all| PROC
#line 630

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 and r4,r0,r1
 cmp r4,r1
 beq %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_chk32_any|
#line 705
|__asm___11_rtx_timer_c_5d09138c__atomic_chk32_any| PROC
#line 705

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 tst r0,r1
 bne %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_inc32|
#line 772
|__asm___11_rtx_timer_c_5d09138c__atomic_inc32| PROC
#line 772

 mov r2,r0
1
 ldrex r0,[r2]
 adds r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_inc16_lt|
#line 821
|__asm___11_rtx_timer_c_5d09138c__atomic_inc16_lt| PROC
#line 821

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 cmp r1,r0
 bhi %F2
 clrex
 pop {r4,pc}
2
 adds r4,r0,#1
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_inc16_lim|
#line 882
|__asm___11_rtx_timer_c_5d09138c__atomic_inc16_lim| PROC
#line 882

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 adds r4,r0,#1
 cmp r1,r4
 bhi %F2
 movs r4,#0
2
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_dec32|
#line 940
|__asm___11_rtx_timer_c_5d09138c__atomic_dec32| PROC
#line 940

 mov r2,r0
1
 ldrex r0,[r2]
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_dec32_nz|
#line 988
|__asm___11_rtx_timer_c_5d09138c__atomic_dec32_nz| PROC
#line 988

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_dec16_nz|
#line 1044
|__asm___11_rtx_timer_c_5d09138c__atomic_dec16_nz| PROC
#line 1044

 mov r2,r0
1
 ldrexh r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strexh r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_link_get|
#line 1100
|__asm___11_rtx_timer_c_5d09138c__atomic_link_get| PROC
#line 1100

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 ldr r1,[r0]
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_rtx_timer_c_5d09138c__atomic_link_put|
#line 1156
|__asm___11_rtx_timer_c_5d09138c__atomic_link_put| PROC
#line 1156

1
 ldr r2,[r0]
 str r2,[r1]
 dmb
 ldrex r2,[r0]
 ldr r3,[r1]
 cmp r3,r2
 bne %B1
 strex r3,r1,[r0]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP

;*** End   embedded assembler ***
