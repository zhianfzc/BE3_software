L 1 "..\..\..\..\scpu\middleware\comm\kl520_com.c"
N#include "kl520_com.h"
L 1 "..\..\..\..\scpu\middleware\comm\kl520_com.h" 1
N#ifndef __KL520_COM_H__
N#define __KL520_COM_H__
N#include "board_kl520.h"
L 1 "..\..\..\..\board\board_kl520.h" 1
N#ifndef __BOARD_KL520_H__
N#define __BOARD_KL520_H__
N#include <stdio.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 4 "..\..\..\..\board\board_kl520.h" 2
N#include <string.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 5 "..\..\..\..\board\board_kl520.h" 2
N#include "string.h"
N#include <cmsis_os2.h>
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include\cmsis_os2.h" 1
N/*
N * Copyright (c) 2013-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * ----------------------------------------------------------------------
N *
N * $Date:        12. June 2020
N * $Revision:    V2.1.3
N *
N * Project:      CMSIS-RTOS2 API
N * Title:        cmsis_os2.h header file
N *
N * Version 2.1.3
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osThreadGetId
N * Version 2.1.2
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osKernelGetInfo, osKernelGetState
N * Version 2.1.1
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osKernelGetTickCount, osKernelGetTickFreq
N *    Changed Kernel Tick type to uint32_t:
N *    - updated: osKernelGetTickCount, osDelayUntil
N * Version 2.1.0
N *    Support for critical and uncritical sections (nesting safe):
N *    - updated: osKernelLock, osKernelUnlock
N *    - added: osKernelRestoreLock
N *    Updated Thread and Event Flags:
N *    - changed flags parameter and return type from int32_t to uint32_t
N * Version 2.0.0
N *    Initial Release
N *---------------------------------------------------------------------------*/
N 
N#ifndef CMSIS_OS2_H_
N#define CMSIS_OS2_H_
N 
N#ifndef __NO_RETURN
N#if   defined(__CC_ARM)
X#if   1L
N#define __NO_RETURN __declspec(noreturn)
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S#define __NO_RETURN __attribute__((__noreturn__))
S#elif defined(__GNUC__)
S#define __NO_RETURN __attribute__((__noreturn__))
S#elif defined(__ICCARM__)
S#define __NO_RETURN __noreturn
S#else
S#define __NO_RETURN
N#endif
N#endif
N 
N#include <stdint.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 65 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include\cmsis_os2.h" 2
N#include <stddef.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
X  #elif !0L
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 66 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include\cmsis_os2.h" 2
N 
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N 
N 
N//  ==== Enumerations, structures, defines ====
N 
N/// Version information.
Ntypedef struct {
N  uint32_t                       api;   ///< API version (major.minor.rev: mmnnnrrrr dec).
N  uint32_t                    kernel;   ///< Kernel version (major.minor.rev: mmnnnrrrr dec).
N} osVersion_t;
N 
N/// Kernel state.
Ntypedef enum {
N  osKernelInactive        =  0,         ///< Inactive.
N  osKernelReady           =  1,         ///< Ready.
N  osKernelRunning         =  2,         ///< Running.
N  osKernelLocked          =  3,         ///< Locked.
N  osKernelSuspended       =  4,         ///< Suspended.
N  osKernelError           = -1,         ///< Error.
N  osKernelReserved        = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osKernelState_t;
N 
N/// Thread state.
Ntypedef enum {
N  osThreadInactive        =  0,         ///< Inactive.
N  osThreadReady           =  1,         ///< Ready.
N  osThreadRunning         =  2,         ///< Running.
N  osThreadBlocked         =  3,         ///< Blocked.
N  osThreadTerminated      =  4,         ///< Terminated.
N  osThreadError           = -1,         ///< Error.
N  osThreadReserved        = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osThreadState_t;
N 
N/// Priority values.
Ntypedef enum {
N  osPriorityNone          =  0,         ///< No priority (not initialized).
N  osPriorityIdle          =  1,         ///< Reserved for Idle thread.
N  osPriorityLow           =  8,         ///< Priority: low
N  osPriorityLow1          =  8+1,       ///< Priority: low + 1
N  osPriorityLow2          =  8+2,       ///< Priority: low + 2
N  osPriorityLow3          =  8+3,       ///< Priority: low + 3
N  osPriorityLow4          =  8+4,       ///< Priority: low + 4
N  osPriorityLow5          =  8+5,       ///< Priority: low + 5
N  osPriorityLow6          =  8+6,       ///< Priority: low + 6
N  osPriorityLow7          =  8+7,       ///< Priority: low + 7
N  osPriorityBelowNormal   = 16,         ///< Priority: below normal
N  osPriorityBelowNormal1  = 16+1,       ///< Priority: below normal + 1
N  osPriorityBelowNormal2  = 16+2,       ///< Priority: below normal + 2
N  osPriorityBelowNormal3  = 16+3,       ///< Priority: below normal + 3
N  osPriorityBelowNormal4  = 16+4,       ///< Priority: below normal + 4
N  osPriorityBelowNormal5  = 16+5,       ///< Priority: below normal + 5
N  osPriorityBelowNormal6  = 16+6,       ///< Priority: below normal + 6
N  osPriorityBelowNormal7  = 16+7,       ///< Priority: below normal + 7
N  osPriorityNormal        = 24,         ///< Priority: normal
N  osPriorityNormal1       = 24+1,       ///< Priority: normal + 1
N  osPriorityNormal2       = 24+2,       ///< Priority: normal + 2
N  osPriorityNormal3       = 24+3,       ///< Priority: normal + 3
N  osPriorityNormal4       = 24+4,       ///< Priority: normal + 4
N  osPriorityNormal5       = 24+5,       ///< Priority: normal + 5
N  osPriorityNormal6       = 24+6,       ///< Priority: normal + 6
N  osPriorityNormal7       = 24+7,       ///< Priority: normal + 7
N  osPriorityAboveNormal   = 32,         ///< Priority: above normal
N  osPriorityAboveNormal1  = 32+1,       ///< Priority: above normal + 1
N  osPriorityAboveNormal2  = 32+2,       ///< Priority: above normal + 2
N  osPriorityAboveNormal3  = 32+3,       ///< Priority: above normal + 3
N  osPriorityAboveNormal4  = 32+4,       ///< Priority: above normal + 4
N  osPriorityAboveNormal5  = 32+5,       ///< Priority: above normal + 5
N  osPriorityAboveNormal6  = 32+6,       ///< Priority: above normal + 6
N  osPriorityAboveNormal7  = 32+7,       ///< Priority: above normal + 7
N  osPriorityHigh          = 40,         ///< Priority: high
N  osPriorityHigh1         = 40+1,       ///< Priority: high + 1
N  osPriorityHigh2         = 40+2,       ///< Priority: high + 2
N  osPriorityHigh3         = 40+3,       ///< Priority: high + 3
N  osPriorityHigh4         = 40+4,       ///< Priority: high + 4
N  osPriorityHigh5         = 40+5,       ///< Priority: high + 5
N  osPriorityHigh6         = 40+6,       ///< Priority: high + 6
N  osPriorityHigh7         = 40+7,       ///< Priority: high + 7
N  osPriorityRealtime      = 48,         ///< Priority: realtime
N  osPriorityRealtime1     = 48+1,       ///< Priority: realtime + 1
N  osPriorityRealtime2     = 48+2,       ///< Priority: realtime + 2
N  osPriorityRealtime3     = 48+3,       ///< Priority: realtime + 3
N  osPriorityRealtime4     = 48+4,       ///< Priority: realtime + 4
N  osPriorityRealtime5     = 48+5,       ///< Priority: realtime + 5
N  osPriorityRealtime6     = 48+6,       ///< Priority: realtime + 6
N  osPriorityRealtime7     = 48+7,       ///< Priority: realtime + 7
N  osPriorityISR           = 56,         ///< Reserved for ISR deferred thread.
N  osPriorityError         = -1,         ///< System cannot determine priority or illegal priority.
N  osPriorityReserved      = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osPriority_t;
N 
N/// Entry point of a thread.
Ntypedef void (*osThreadFunc_t) (void *argument);
N 
N/// Timer callback function.
Ntypedef void (*osTimerFunc_t) (void *argument);
N 
N/// Timer type.
Ntypedef enum {
N  osTimerOnce               = 0,          ///< One-shot timer.
N  osTimerPeriodic           = 1           ///< Repeating timer.
N} osTimerType_t;
N 
N// Timeout value.
N#define osWaitForever         0xFFFFFFFFU ///< Wait forever timeout value.
N 
N// Flags options (\ref osThreadFlagsWait and \ref osEventFlagsWait).
N#define osFlagsWaitAny        0x00000000U ///< Wait for any flag (default).
N#define osFlagsWaitAll        0x00000001U ///< Wait for all flags.
N#define osFlagsNoClear        0x00000002U ///< Do not clear flags which have been specified to wait for.
N 
N// Flags errors (returned by osThreadFlagsXxxx and osEventFlagsXxxx).
N#define osFlagsError          0x80000000U ///< Error indicator.
N#define osFlagsErrorUnknown   0xFFFFFFFFU ///< osError (-1).
N#define osFlagsErrorTimeout   0xFFFFFFFEU ///< osErrorTimeout (-2).
N#define osFlagsErrorResource  0xFFFFFFFDU ///< osErrorResource (-3).
N#define osFlagsErrorParameter 0xFFFFFFFCU ///< osErrorParameter (-4).
N#define osFlagsErrorISR       0xFFFFFFFAU ///< osErrorISR (-6).
N 
N// Thread attributes (attr_bits in \ref osThreadAttr_t).
N#define osThreadDetached      0x00000000U ///< Thread created in detached mode (default)
N#define osThreadJoinable      0x00000001U ///< Thread created in joinable mode
N 
N// Mutex attributes (attr_bits in \ref osMutexAttr_t).
N#define osMutexRecursive      0x00000001U ///< Recursive mutex.
N#define osMutexPrioInherit    0x00000002U ///< Priority inherit protocol.
N#define osMutexRobust         0x00000008U ///< Robust mutex.
N 
N/// Status code values returned by CMSIS-RTOS functions.
Ntypedef enum {
N  osOK                      =  0,         ///< Operation completed successfully.
N  osError                   = -1,         ///< Unspecified RTOS error: run-time error but no other error message fits.
N  osErrorTimeout            = -2,         ///< Operation not completed within the timeout period.
N  osErrorResource           = -3,         ///< Resource not available.
N  osErrorParameter          = -4,         ///< Parameter error.
N  osErrorNoMemory           = -5,         ///< System is out of memory: it was impossible to allocate or reserve memory for the operation.
N  osErrorISR                = -6,         ///< Not allowed in ISR context: the function cannot be called from interrupt service routines.
N  osStatusReserved          = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osStatus_t;
N 
N 
N/// \details Thread ID identifies the thread.
Ntypedef void *osThreadId_t;
N 
N/// \details Timer ID identifies the timer.
Ntypedef void *osTimerId_t;
N 
N/// \details Event Flags ID identifies the event flags.
Ntypedef void *osEventFlagsId_t;
N 
N/// \details Mutex ID identifies the mutex.
Ntypedef void *osMutexId_t;
N 
N/// \details Semaphore ID identifies the semaphore.
Ntypedef void *osSemaphoreId_t;
N 
N/// \details Memory Pool ID identifies the memory pool.
Ntypedef void *osMemoryPoolId_t;
N 
N/// \details Message Queue ID identifies the message queue.
Ntypedef void *osMessageQueueId_t;
N 
N 
N#ifndef TZ_MODULEID_T
N#define TZ_MODULEID_T
N/// \details Data type that identifies secure software modules called by a process.
Ntypedef uint32_t TZ_ModuleId_t;
N#endif
N 
N 
N/// Attributes structure for thread.
Ntypedef struct {
N  const char                   *name;   ///< name of the thread
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                   *stack_mem;    ///< memory for stack
N  uint32_t                stack_size;   ///< size of stack
N  osPriority_t              priority;   ///< initial thread priority (default: osPriorityNormal)
N  TZ_ModuleId_t            tz_module;   ///< TrustZone module identifier
N  uint32_t                  reserved;   ///< reserved (must be 0)
N} osThreadAttr_t;
N 
N/// Attributes structure for timer.
Ntypedef struct {
N  const char                   *name;   ///< name of the timer
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osTimerAttr_t;
N 
N/// Attributes structure for event flags.
Ntypedef struct {
N  const char                   *name;   ///< name of the event flags
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osEventFlagsAttr_t;
N 
N/// Attributes structure for mutex.
Ntypedef struct {
N  const char                   *name;   ///< name of the mutex
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osMutexAttr_t;
N 
N/// Attributes structure for semaphore.
Ntypedef struct {
N  const char                   *name;   ///< name of the semaphore
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osSemaphoreAttr_t;
N 
N/// Attributes structure for memory pool.
Ntypedef struct {
N  const char                   *name;   ///< name of the memory pool
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                      *mp_mem;    ///< memory for data storage
N  uint32_t                   mp_size;   ///< size of provided memory for data storage 
N} osMemoryPoolAttr_t;
N 
N/// Attributes structure for message queue.
Ntypedef struct {
N  const char                   *name;   ///< name of the message queue
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                      *mq_mem;    ///< memory for data storage
N  uint32_t                   mq_size;   ///< size of provided memory for data storage 
N} osMessageQueueAttr_t;
N 
N 
N//  ==== Kernel Management Functions ====
N 
N/// Initialize the RTOS Kernel.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelInitialize (void);
N 
N///  Get RTOS Kernel Information.
N/// \param[out]    version       pointer to buffer for retrieving version information.
N/// \param[out]    id_buf        pointer to buffer for retrieving kernel identification string.
N/// \param[in]     id_size       size of buffer for kernel identification string.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size);
N 
N/// Get the current RTOS Kernel state.
N/// \return current RTOS Kernel state.
NosKernelState_t osKernelGetState (void);
N 
N/// Start the RTOS Kernel scheduler.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelStart (void);
N 
N/// Lock the RTOS Kernel scheduler.
N/// \return previous lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelLock (void);
N 
N/// Unlock the RTOS Kernel scheduler.
N/// \return previous lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelUnlock (void);
N 
N/// Restore the RTOS Kernel scheduler lock state.
N/// \param[in]     lock          lock state obtained by \ref osKernelLock or \ref osKernelUnlock.
N/// \return new lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelRestoreLock (int32_t lock);
N 
N/// Suspend the RTOS Kernel scheduler.
N/// \return time in ticks, for how long the system can sleep or power-down.
Nuint32_t osKernelSuspend (void);
N 
N/// Resume the RTOS Kernel scheduler.
N/// \param[in]     sleep_ticks   time in ticks for how long the system was in sleep or power-down mode.
Nvoid osKernelResume (uint32_t sleep_ticks);
N 
N/// Get the RTOS kernel tick count.
N/// \return RTOS kernel current tick count.
Nuint32_t osKernelGetTickCount (void);
N 
N/// Get the RTOS kernel tick frequency.
N/// \return frequency of the kernel tick in hertz, i.e. kernel ticks per second.
Nuint32_t osKernelGetTickFreq (void);
N 
N/// Get the RTOS kernel system timer count.
N/// \return RTOS kernel current system timer count as 32-bit value.
Nuint32_t osKernelGetSysTimerCount (void);
N 
N/// Get the RTOS kernel system timer frequency.
N/// \return frequency of the system timer in hertz, i.e. timer ticks per second.
Nuint32_t osKernelGetSysTimerFreq (void);
N 
N 
N//  ==== Thread Management Functions ====
N 
N/// Create a thread and add it to Active Threads.
N/// \param[in]     func          thread function.
N/// \param[in]     argument      pointer that is passed to the thread function as start argument.
N/// \param[in]     attr          thread attributes; NULL: default values.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr);
N 
N/// Get name of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return name as null-terminated string.
Nconst char *osThreadGetName (osThreadId_t thread_id);
N 
N/// Return the thread ID of the current running thread.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId_t osThreadGetId (void);
N 
N/// Get current thread state of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return current thread state of the specified thread.
NosThreadState_t osThreadGetState (osThreadId_t thread_id);
N 
N/// Get stack size of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return stack size in bytes.
Nuint32_t osThreadGetStackSize (osThreadId_t thread_id);
N 
N/// Get available stack space of a thread based on stack watermark recording during execution.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return remaining stack space in bytes.
Nuint32_t osThreadGetStackSpace (osThreadId_t thread_id);
N 
N/// Change priority of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \param[in]     priority      new priority value for the thread function.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority);
N 
N/// Get current priority of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return current priority value of the specified thread.
NosPriority_t osThreadGetPriority (osThreadId_t thread_id);
N 
N/// Pass control to next thread that is in state \b READY.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadYield (void);
N 
N/// Suspend execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadSuspend (osThreadId_t thread_id);
N 
N/// Resume execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadResume (osThreadId_t thread_id);
N 
N/// Detach a thread (thread storage can be reclaimed when thread terminates).
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadDetach (osThreadId_t thread_id);
N 
N/// Wait for specified thread to terminate.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadJoin (osThreadId_t thread_id);
N 
N/// Terminate execution of current running thread.
N__NO_RETURN void osThreadExit (void);
X__declspec(noreturn) void osThreadExit (void);
N 
N/// Terminate execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadTerminate (osThreadId_t thread_id);
N 
N/// Get number of active threads.
N/// \return number of active threads.
Nuint32_t osThreadGetCount (void);
N 
N/// Enumerate active threads.
N/// \param[out]    thread_array  pointer to array for retrieving thread IDs.
N/// \param[in]     array_items   maximum number of items in array for retrieving thread IDs.
N/// \return number of enumerated threads.
Nuint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items);
N 
N 
N//  ==== Thread Flags Functions ====
N 
N/// Set the specified Thread Flags of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \param[in]     flags         specifies the flags of the thread that shall be set.
N/// \return thread flags after setting or error code if highest bit set.
Nuint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags);
N 
N/// Clear the specified Thread Flags of current running thread.
N/// \param[in]     flags         specifies the flags of the thread that shall be cleared.
N/// \return thread flags before clearing or error code if highest bit set.
Nuint32_t osThreadFlagsClear (uint32_t flags);
N 
N/// Get the current Thread Flags of current running thread.
N/// \return current thread flags.
Nuint32_t osThreadFlagsGet (void);
N 
N/// Wait for one or more Thread Flags of the current running thread to become signaled.
N/// \param[in]     flags         specifies the flags to wait for.
N/// \param[in]     options       specifies flags options (osFlagsXxxx).
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return thread flags before clearing or error code if highest bit set.
Nuint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout);
N 
N 
N//  ==== Generic Wait Functions ====
N 
N/// Wait for Timeout (Time Delay).
N/// \param[in]     ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value
N/// \return status code that indicates the execution status of the function.
NosStatus_t osDelay (uint32_t ticks);
N 
N/// Wait until specified time.
N/// \param[in]     ticks         absolute time in ticks
N/// \return status code that indicates the execution status of the function.
NosStatus_t osDelayUntil (uint32_t ticks);
N 
N 
N//  ==== Timer Management Functions ====
N 
N/// Create and Initialize a timer.
N/// \param[in]     func          function pointer to callback function.
N/// \param[in]     type          \ref osTimerOnce for one-shot or \ref osTimerPeriodic for periodic behavior.
N/// \param[in]     argument      argument to the timer callback function.
N/// \param[in]     attr          timer attributes; NULL: default values.
N/// \return timer ID for reference by other functions or NULL in case of error.
NosTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr);
N 
N/// Get name of a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return name as null-terminated string.
Nconst char *osTimerGetName (osTimerId_t timer_id);
N 
N/// Start or restart a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \param[in]     ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value of the timer.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks);
N 
N/// Stop a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerStop (osTimerId_t timer_id);
N 
N/// Check if a timer is running.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return 0 not running, 1 running.
Nuint32_t osTimerIsRunning (osTimerId_t timer_id);
N 
N/// Delete a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerDelete (osTimerId_t timer_id);
N 
N 
N//  ==== Event Flags Management Functions ====
N 
N/// Create and Initialize an Event Flags object.
N/// \param[in]     attr          event flags attributes; NULL: default values.
N/// \return event flags ID for reference by other functions or NULL in case of error.
NosEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr);
N 
N/// Get name of an Event Flags object.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return name as null-terminated string.
Nconst char *osEventFlagsGetName (osEventFlagsId_t ef_id);
N 
N/// Set the specified Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags that shall be set.
N/// \return event flags after setting or error code if highest bit set.
Nuint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags);
N 
N/// Clear the specified Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags that shall be cleared.
N/// \return event flags before clearing or error code if highest bit set.
Nuint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags);
N 
N/// Get the current Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return current event flags.
Nuint32_t osEventFlagsGet (osEventFlagsId_t ef_id);
N 
N/// Wait for one or more Event Flags to become signaled.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags to wait for.
N/// \param[in]     options       specifies flags options (osFlagsXxxx).
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return event flags before clearing or error code if highest bit set.
Nuint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout);
N 
N/// Delete an Event Flags object.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id);
N 
N 
N//  ==== Mutex Management Functions ====
N 
N/// Create and Initialize a Mutex object.
N/// \param[in]     attr          mutex attributes; NULL: default values.
N/// \return mutex ID for reference by other functions or NULL in case of error.
NosMutexId_t osMutexNew (const osMutexAttr_t *attr);
N 
N/// Get name of a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return name as null-terminated string.
Nconst char *osMutexGetName (osMutexId_t mutex_id);
N 
N/// Acquire a Mutex or timeout if it is locked.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout);
N 
N/// Release a Mutex that was acquired by \ref osMutexAcquire.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexRelease (osMutexId_t mutex_id);
N 
N/// Get Thread which owns a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return thread ID of owner thread or NULL when mutex was not acquired.
NosThreadId_t osMutexGetOwner (osMutexId_t mutex_id);
N 
N/// Delete a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexDelete (osMutexId_t mutex_id);
N 
N 
N//  ==== Semaphore Management Functions ====
N 
N/// Create and Initialize a Semaphore object.
N/// \param[in]     max_count     maximum number of available tokens.
N/// \param[in]     initial_count initial number of available tokens.
N/// \param[in]     attr          semaphore attributes; NULL: default values.
N/// \return semaphore ID for reference by other functions or NULL in case of error.
NosSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr);
N 
N/// Get name of a Semaphore object.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return name as null-terminated string.
Nconst char *osSemaphoreGetName (osSemaphoreId_t semaphore_id);
N 
N/// Acquire a Semaphore token or timeout if no tokens are available.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout);
N 
N/// Release a Semaphore token up to the initial maximum count.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id);
N 
N/// Get current Semaphore token count.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return number of tokens available.
Nuint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id);
N 
N/// Delete a Semaphore object.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id);
N 
N 
N//  ==== Memory Pool Management Functions ====
N 
N/// Create and Initialize a Memory Pool object.
N/// \param[in]     block_count   maximum number of memory blocks in memory pool.
N/// \param[in]     block_size    memory block size in bytes.
N/// \param[in]     attr          memory pool attributes; NULL: default values.
N/// \return memory pool ID for reference by other functions or NULL in case of error.
NosMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr);
N 
N/// Get name of a Memory Pool object.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return name as null-terminated string.
Nconst char *osMemoryPoolGetName (osMemoryPoolId_t mp_id);
N 
N/// Allocate a memory block from a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return address of the allocated memory block or NULL in case of no memory is available.
Nvoid *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout);
N 
N/// Return an allocated memory block back to a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \param[in]     block         address of the allocated memory block to be returned to the memory pool.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block);
N 
N/// Get maximum number of memory blocks in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return maximum number of memory blocks.
Nuint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id);
N 
N/// Get memory block size in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return memory block size in bytes.
Nuint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id);
N 
N/// Get number of memory blocks used in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return number of memory blocks used.
Nuint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id);
N 
N/// Get number of memory blocks available in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return number of memory blocks available.
Nuint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id);
N 
N/// Delete a Memory Pool object.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id);
N 
N 
N//  ==== Message Queue Management Functions ====
N 
N/// Create and Initialize a Message Queue object.
N/// \param[in]     msg_count     maximum number of messages in queue.
N/// \param[in]     msg_size      maximum message size in bytes.
N/// \param[in]     attr          message queue attributes; NULL: default values.
N/// \return message queue ID for reference by other functions or NULL in case of error.
NosMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr);
N 
N/// Get name of a Message Queue object.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return name as null-terminated string.
Nconst char *osMessageQueueGetName (osMessageQueueId_t mq_id);
N 
N/// Put a Message into a Queue or timeout if Queue is full.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \param[in]     msg_ptr       pointer to buffer with message to put into a queue.
N/// \param[in]     msg_prio      message priority.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout);
N 
N/// Get a Message from a Queue or timeout if Queue is empty.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \param[out]    msg_ptr       pointer to buffer for message to get from a queue.
N/// \param[out]    msg_prio      pointer to buffer for message priority or NULL.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout);
N 
N/// Get maximum number of messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return maximum number of messages.
Nuint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id);
N 
N/// Get maximum message size in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return maximum message size in bytes.
Nuint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id);
N 
N/// Get number of queued messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return number of queued messages.
Nuint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id);
N 
N/// Get number of available slots for messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return number of available slots for messages.
Nuint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id);
N 
N/// Reset a Message Queue to initial empty state.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueReset (osMessageQueueId_t mq_id);
N 
N/// Delete a Message Queue object.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id);
N 
N 
N#ifdef  __cplusplus
S}
N#endif
N 
N#endif  // CMSIS_OS2_H_
L 7 "..\..\..\..\board\board_kl520.h" 2
N#include "cmsis_os2.h"                    // ARM::CMSIS:RTOS2:Keil RTX5
N#include "types.h"
L 1 "..\..\..\..\common\include\types.h" 1
N#ifndef TYPES_H
N#define TYPES_H
N
N#include <stdint.h>
N#include <stdbool.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 6 "..\..\..\..\common\include\types.h" 2
N
N//#if TARGET_SCPU
N#define BS              0x08
N#define ESC				27
N
N#ifndef NULL
S#define NULL    0
N#endif
N
N#ifndef ENABLE
N#define ENABLE  1
N#endif
N
N#ifndef DISABLE
N#define DISABLE 0
N#endif
N
N#ifndef FALSE
N#define FALSE   0
N#endif
N
N#ifndef TRUE
N#define TRUE    1
N#endif
N#if 0
Stypedef int bool;
S#define true 1
S#define false 0
N#endif
N/* type define */
N	typedef unsigned long long 		UINT64;
N	typedef long long 				INT64;
N	typedef	unsigned int			UINT32;
N	typedef	int						INT32;
N	typedef	unsigned short			UINT16;
N	typedef	short					INT16;
N	typedef unsigned char			UINT8;
N	typedef char					INT8;
N	typedef unsigned char			BOOL;
N
N	typedef unsigned char           u8_t;
N	typedef unsigned short          u16_t;
N	typedef unsigned long           u32_t;
N	typedef unsigned long long		u64_t;
N
N	typedef unsigned char 			uchar;
N
N    typedef char                    s8;
N	typedef short                   s16;
N    typedef int                     s32;
N    typedef long long               s64;
N
N    typedef unsigned char           u8;
N	typedef unsigned short          u16;
N    typedef unsigned int            u32;
N    typedef unsigned long long      u64;
N
N#ifndef _SIZE_T
N#define _SIZE_T
Ntypedef unsigned int size_t;
N#endif
N
N#ifndef _SSIZE_T
N#define _SSIZE_T
Ntypedef long ssize_t;
N#endif
N
Ntypedef INT8          INT8S;
Ntypedef UINT8         INT8U;
Ntypedef INT16         INT16S;
Ntypedef UINT16        INT16U;
Ntypedef INT32         INT32S;
Ntypedef UINT32        INT32U;
N
N
Ntypedef unsigned char                   byte;
Ntypedef unsigned short                  word;
Ntypedef unsigned long int               dword;
N
N//#endif
N
N#endif //TYPES_H
L 9 "..\..\..\..\board\board_kl520.h" 2
N#include "delay.h"
L 1 "..\..\..\..\common\include\delay.h" 1
N/*
N * Kneron Delay driver
N *
N * Copyright (C) 2019 Kneron, Inc. All rights reserved.
N *
N */
N
N#ifndef __DELAY_H__
N#define __DELAY_H__
N
N/**
N * @brief microseconds delay for any cpu
N *
N * @param [in] usec number of microseconds
N * @return No
N */
Nvoid delay_us(unsigned int usec);
N
Nvoid delay_ms_enable(void);
Nvoid delay_ms_disable(void);
Nvoid delay_ms(unsigned int msec);
N
N#endif
L 10 "..\..\..\..\board\board_kl520.h" 2
N#include "base.h"
L 1 "..\..\..\..\common\include\base.h" 1
N/**
N * @file      base.h
N * @brief     Basic utils & struct
N * @copyright (c) 2018 Kneron Inc. All right reserved.
N */
N
N#ifndef __BASE_H__
N#define __BASE_H__
N
N
N#define BIT0                            0x00000001
N#define BIT1                            0x00000002
N#define BIT2                            0x00000004
N#define BIT3                            0x00000008
N#define BIT4                            0x00000010
N#define BIT5                            0x00000020
N#define BIT6                            0x00000040
N#define BIT7                            0x00000080
N#define BIT8                            0x00000100
N#define BIT9                            0x00000200
N#define BIT10                           0x00000400
N#define BIT11                           0x00000800
N#define BIT12                           0x00001000
N#define BIT13                           0x00002000
N#define BIT14                           0x00004000
N#define BIT15                           0x00008000
N#define BIT16                           0x00010000
N#define BIT17                           0x00020000
N#define BIT18                           0x00040000
N#define BIT19                           0x00080000
N#define BIT20                           0x00100000
N#define BIT21                           0x00200000
N#define BIT22                           0x00400000
N#define BIT23                           0x00800000
N#define BIT24                           0x01000000
N#define BIT25                           0x02000000
N#define BIT26                           0x04000000
N#define BIT27                           0x08000000
N#define BIT28                           0x10000000
N#define BIT29                           0x20000000
N#define BIT30                           0x40000000
N#define BIT31                           0x80000000
N
N#ifndef BIT
N#define BIT(x)      (0x01U << (x))
N#endif
N
N#define divRoundDown(n,s)   ((n) / (s))
N#define divRoundUp(n,s)     ((n+s-1)/(s))
N
N#define ARRAY_SIZE(x) 		(sizeof(x) / sizeof((x)[0]))
N
N#define RoundUp(val, units) \
N		((((unsigned long)(val) + ((units) - 1)) / (units)) * (units))
X#define RoundUp(val, units) 		((((unsigned long)(val) + ((units) - 1)) / (units)) * (units))
N#define RoundDown(val, units) \
N		(((unsigned long)(val)/(units))*(units))
X#define RoundDown(val, units) 		(((unsigned long)(val)/(units))*(units))
N    
N#include "io.h"
L 1 "..\..\..\..\scpu\drivers\include\io.h" 1
N#ifndef IO_H
N#define IO_H
N
N
N#define readl(addr)             (*(volatile unsigned int *)(addr))
N#define writel(val, addr)       (*(volatile unsigned int *)(addr) = (val))
N
N#define readw(addr)             (*(volatile unsigned short *)(addr))
N#define writew(val, addr)       (*(volatile unsigned short *)(addr) = (val))
N
N#define readb(addr)             (*(volatile unsigned char *)(addr))
N#define writeb(val, addr)       (*(volatile unsigned char *)(addr) = (val))
N
N#define inl(p)                  readl(p)
N#define outl(v, p)              writel(v, p)
N
N#define inw(port)               readl(port)
N#define outw(port, val)         writel(val, port)
N
N#define inb(port)               readb(port)
N#define outb(port, val)         writeb(val, port)
N
N//#define inhw(port)            readw(port)
N//#define outhw(port, val)      writew(val, port)
N#define inhw(port)              readl(port)
N#define outhw(port, val)        writel(val, port)
N
N#define u32Lib_LeRead32(x)      *((volatile INT32U *)((INT8U * )x)) //bessel:add  (INT8U * )
N#define vLib_LeWrite32(x,y)     *(volatile INT32U *)((INT8U * )x)=(y)  //bessel:add  (INT8U * )
N
N#define masked_outw(port, val, mask)    outw(port, (inw(port) & ~mask) | (val & mask))
N
N#define GET_BIT(port, __bit) \
N    ((inw(port) & BIT##__bit) >> __bit)
X#define GET_BIT(port, __bit)     ((inw(port) & BIT##__bit) >> __bit)
N
N#define GET_BITS(port, __s_bit, __e_bit) \
N    ((inw(port) & (BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) >> __s_bit)
X#define GET_BITS(port, __s_bit, __e_bit)     ((inw(port) & (BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) >> __s_bit)
N
N#define SET_BIT(port, __bit) \
N    outw(port, BIT##__bit)
X#define SET_BIT(port, __bit)     outw(port, BIT##__bit)
N
N#define SET_MASKED_BIT(port, val, __bit) \
N    outw(port, (inw(port) & ~BIT##__bit) | ((val << __bit) & BIT##__bit))
X#define SET_MASKED_BIT(port, val, __bit)     outw(port, (inw(port) & ~BIT##__bit) | ((val << __bit) & BIT##__bit))
N
N#define SET_MASKED_BITS(port, val, __s_bit, __e_bit) \
N    outw(port, ((inw(port) & ~(BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) | (val << __s_bit))); 
X#define SET_MASKED_BITS(port, val, __s_bit, __e_bit)     outw(port, ((inw(port) & ~(BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) | (val << __s_bit))); 
N
N
N#endif // IO_H
L 59 "..\..\..\..\common\include\base.h" 2
N        
N#endif
N
N
L 11 "..\..\..\..\board\board_kl520.h" 2
N#include "dbg.h"
L 1 "..\..\..\..\common\include\dbg.h" 1
N/**
N * @file      dbg.h
N * @brief     debug macro 
N * @copyright (c) 2018 Kneron Inc. All right reserved.
N */
N
N#ifndef __DBG_H__
N#define __DBG_H__
N
N#include <stdio.h>
N#include "ipc.h"
L 1 "..\..\..\..\common\include\ipc.h" 1
N/*
N * Kneron IPC Header for KL520
N *
N * Copyright (C) 2018-2019 Kneron, Inc. All rights reserved.
N *
N */
N
N#ifndef KNERON_IPC_H
N#define KNERON_IPC_H
N
N#include <stdint.h>
N#include "model_type.h"
L 1 "..\..\..\..\common\include\model_type.h" 1
N#ifndef __MODEL_TYPE_H
N#define __MODEL_TYPE_H
N
N
Nenum model_type {
N#if 0
S    INVALID_ID,
S    KNERON_FDSMALLBOX                   = 1,
S    KNERON_FDANCHOR                     = 2,
S    KNERON_FDSSD                        = 32,
S    AVERAGE_POOLING                     = 4,
S    KNERON_LM_5PTS                      = 5,
S    KNERON_LM_68PTS                     = 6,
S    KNERON_LM_150PTS                    = 7,
S    //KNERON_FR_RES50                     = 8,
S    KNERON_FR_RES34                     = 9,
S    KNERON_FR_VGG10                     = 8,
S    KNERON_TINY_YOLO_PERSON             = 11,
S    KNERON_3D_LIVENESS                  = 12,
S    KNERON_GESTURE_RETINANET            = 13,
S    TINY_YOLO_VOC                       = 14,
S    IMAGENET_CLASSIFICATION_RES50       = 15,
S    IMAGENET_CLASSIFICATION_RES34       = 16,
S    IMAGENET_CLASSIFICATION_INCEPTION_V3= 17,
S    IMAGENET_CLASSIFICATION_MOBILENET_V2= 18,
S    TINY_YOLO_V3                        = 19,
S	KNERON_2D_LIVENESS                  = 20,
S    KNERON_FD_RETINANET                 = 21,
S    KNERON_SSD_PERSON                   = 22,
S    KNERON_AGE_GENDER                   = 23,
S	KNERON_NIR_LIVENESS                 = 30,
S    KNERON_FUSE_LIVENESS                = 41,
S	KNERON_CV_LIVENESS                  = 26,
S    KNERON_OD_MBSSD                     = 27,
S    KNERON_AGE_GROUP                    = 28,
S    KNERON_LM_S_5PTS                    = 55,
S    //KNERON_NIR_HSN_LIVENESS             = 32,
S    KNERON_LM_EYE_LID                   = 42,
S    KNERON_FACE_QUALITY                 = 40,
S    KNERON_RGB_LIVENESS                 = 57,
S    KNERON_NIR_OCCLUDE                  = 51,
S    UPHOTON_LIVENESS                    = 1001,
S		KNERON_FACESEG_DLA34_128_128_3      = 58
N#endif
N    UPHOTON_LIVENESS                    = 1001,
N	INVALID_TYPE = 0,
N	KNERON_FD_SMALLBOX_200_200_3 = 1,
N	KNERON_FD_ANCHOR_200_200_3 = 2,
N	KNERON_FD_MBSSD_200_200_3= 3,
N	AVERAGE_POOLING = 4, //use with FD smallbox and don't use anymore
N	KNERON_LM_5PTS_ONET_56_56_3 = 5,
N	KNERON_LM_68PTS_dlib_112_112_3 = 6,
N	KNERON_LM_150PTS = 7,
N	KNERON_FR_RES50_112_112_3 = 8,
N    //KNERON_FR_RES50_COMPACT=39,
N	KNERON_FR_RES34 = 9,
N	KNERON_FR_VGG10 = 10,
N	KNERON_TINY_YOLO_PERSON_416_416_3 = 11,
N	KNERON_3D_LIVENESS = 12, //has two inputs: depth and RGB
N	KNERON_GESTURE_RETINANET_320_320_3 = 13,
N	TINY_YOLO_VOC_224_224_3 = 14,
N	IMAGENET_CLASSIFICATION_RES50_224_224_3 = 15,
N	IMAGENET_CLASSIFICATION_RES34_224_224_3 = 16,
N	IMAGENET_CLASSIFICATION_INCEPTION_V3_224_224_3 = 17,
N	IMAGENET_CLASSIFICATION_MOBILENET_V2_224_224_3 = 18,
N	TINY_YOLO_V3_224_224_3 = 19,
N	KNERON_2D_LIVENESS_224_224_3 = 20, //oldest rgb liveness model and don't use anymore
N	KNERON_FD_RETINANET_256_256_3 = 21,
N	KNERON_PERSON_MOBILENETSSD_224_224_3 = 22,
N	KNERON_AGE_GENDER = 23, //oldest age gender model and don't use anymore 
N	KNERON_LM_5PTS_BLUR_ONET_48_48_3 = 24,
N	KNERON_2D_LIVENESS_V3_FACEBAGNET_224_224_3 = 25,
N    KNERON_AGE_GENDER_V2_RES18_128_128_3 = 26,
N	KNERON_OD_MBSSD = 27, //HW model and don't know input size
N	KNERON_PD_MBSSD = 28, //HW model and don't know which version and input size
N	KNERON_FR_MASK_RES50_112_112_3 = 29, 
N	KNERON_NIR_LIVENESS_RES18_112_112_3 = 30,
N	KNERON_FR_MASK_RES101_112_112_3 = 31,
N    KNERON_FD_MASK_MBSSD_200_200_3 = 32,	
N    TINY_YOLO_V3_416_416_3 = 33,
N    TINY_YOLO_V3_608_608_3 = 34,
N
N	//Category Face related 40~200
N	KNERON_CAT_FACE = 40,
N	KNERON_FACE_QAULITY_ONET_56_56_1 = KNERON_CAT_FACE,
N	KNERON_FUSE_LIVENESS = KNERON_CAT_FACE +1, // don't know the model backbone and input size of fuse liveness model
N	KNERON_EYELID_DETECTION_ONET_48_48_3 = KNERON_CAT_FACE +2,
N	KNERON_YAWN_DETECTION_PFLD_112_112_3 = KNERON_CAT_FACE +3,
N	KNERON_DBFACE_MBNET_V2_480_864_3 = KNERON_CAT_FACE +4,
N	KNERON_FILTER = KNERON_CAT_FACE +5, //No model inference, just pre and post-process
N	KNERON_ALIGNMENT = KNERON_CAT_FACE +6, //No model inference, just preprocess
N	KNERON_FACE_EXPRESSION_112_112_3 = KNERON_CAT_FACE +7,
N	KNERON_RBG_OCCLUSION_RES18_112_112_3 = KNERON_CAT_FACE +8,
N	KNERON_LM2BBOX = KNERON_CAT_FACE + 9, //No model inference, just post-process
N	KNERON_PUPIL_ONET_48_48_3 = KNERON_CAT_FACE +10,
N    KNERON_NIR_OCCLUSION_RES18_112_112_3 = KNERON_CAT_FACE +11,
N    KNERON_HEAD_SHOULDER_MBNET_V2_112_112_3 = KNERON_CAT_FACE + 12,
N    KNERON_RGB_LIVENESS_RES18_112_112_3 = KNERON_CAT_FACE +13, 
N	KNERON_MOUTH_LM_v1_56_56_1 = KNERON_CAT_FACE +14,    //nose, upper lip middle, chin, two sides of faces
N	KNERON_MOUTH_LM_v2_56_56_1 = KNERON_CAT_FACE +15,    //nose, upper/lower lip middle, two sides of faces
N	KNERON_PUPIL_ONET_48_48_1 = KNERON_CAT_FACE +16,
N    KNERON_RGB_LIVENESS_MBV2_112_112_3 = KNERON_CAT_FACE +17,
N    KNERON_FACESEG_DLA34_128_128_3 = KNERON_CAT_FACE +18,
N    KNERON_OCC_CLS = KNERON_CAT_FACE +19, //no model inference, just post-process
N    KNERON_LMSEG_FUSE = KNERON_CAT_FACE+20, //no model inference, just post-process
N    KNERON_FUSE_LIVENESS_850 = 65,
N    KNERON_FUSE_SC035        = 98,
N    KNERON_FUSE_DUAL_1054    = 103,
N    KNERON_FUSE_LIVENESS_850_940 = 77,
N    KNERON_FACE_POSE = 68,
N    KNERON_FUSE_NIR_LV = 76,
N
N    KNERON_FD_ROTATE=63,
N    KNERON_LM_ROTATE=64,
N    KNERON_FACE_POSE_ROTATE=71,
N    KNERON_NIR_LV_ROTATE=72,
N    KNERON_HSN_LV_ROTATE=81,
N    KNERON_LM_S_ROTATE=87,
N    KNERON_LM_PLUS_ROTATE=93,
N    KNERON_FD_FCOS_ROTATE=94,
N    KNERON_NIR_LV_ROTATE_1054=104,
N    KNERON_FD_FCOS_ROTATE_1054=106,
N    KNERON_HSN_LV_ROTATE_1054=109,
N    KNERON_NIR_COMBO_ROTATE_1054=111,
N    KNERON_FR_RES50_1054=39,
N
N    KNERON_FACE_PUPIL_CLS2_48_48_3 = KNERON_CAT_FACE +52,
N    
N    KNERON_FACE_PUPIL_ROTATE_CLS2_48_48_3 = KNERON_CAT_FACE +56,
N    KNERON_FACESEG_DLA34_rotate_128_128_3 = KNERON_CAT_FACE +60,
N    KNERON_FACESEG_ROTATE = 119,
N    KNERON_TOF_FR50M_112_112_3 = 120,
N
N	//Category Object Detection related 200~300
N	KNERON_OB_DETECT = 200,
N	KNERON_OBJECTDETECTION_CENTERNET_512_512_3 = KNERON_OB_DETECT,
N	KNERON_OBJECTDETECTION_FCOS_416_416_3 = KNERON_OB_DETECT +1,
N	KNERON_PD_MBNET_V2_480_864_3 = KNERON_OB_DETECT +2, //16:9 aspect ratio
N	KNERON_CAR_DETECTION_MBSSD_224_416_3 = KNERON_OB_DETECT +3,
N	KNERON_PD_CROP_MBSSD_304_304_3 = KNERON_OB_DETECT +4,
N	YOLO_V3_416_416_3 = KNERON_OB_DETECT +5,
N	YOLO_V4_416_416_3 = KNERON_OB_DETECT +6,
N	KNERON_CAR_DETECTION_YOLO_V5_352_640_3 = KNERON_OB_DETECT +7,
N	KNERON_LICENSE_DETECT_WPOD_208_416_3 = KNERON_OB_DETECT +8,
N	KNERON_2D_UPPERBODY_KEYPOINT_RES18_384_288_3 = KNERON_OB_DETECT +9,
N	YOLO_V3_608_608_3 = KNERON_OB_DETECT +10,
N    KNERON_YOLOV5S_640_640_3 = KNERON_OB_DETECT +11,
N    KNERON_YOLOV5S_480_256_3 = KNERON_OB_DETECT + 12,
N    KNERON_SITTINGPOSTURE_RESNET34_288_384_3 = KNERON_OB_DETECT + 13,
N    KNERON_PERSONDETECTION_FCOS_416_416_3 = KNERON_OB_DETECT +14,
N    KNERON_YOLOV5m_640_640_3 = KNERON_OB_DETECT +15,
N    KNERON_YOLOV5S6_480_256_3 = KNERON_OB_DETECT + 16,
N    KNERON_PERSONDETECTION_FCOS_384_288_3 = KNERON_OB_DETECT +17,
N    KNERON_PERSONDETECTION_FCOS_720_416_3 = KNERON_OB_DETECT +18,
N    KNERON_PERSONDETECTION_dbface_864_480_3 = KNERON_OB_DETECT +19,
N        
N
N	//Category OCR related 300~400
N	KNERON_OCR = 300,
N	KNERON_LICENSE_OCR_MBNET_64_160_3 = KNERON_OCR,
N	KNERON_WATERMETER_OCR_MBNET = KNERON_OCR +1, //unknown
N
N
N	//Category SDK test related
N	KNERON_CAT_SDK_TEST = 1000,
N	KNERON_SDK_FD = KNERON_CAT_SDK_TEST,
N	KNERON_SDK_LM = KNERON_CAT_SDK_TEST +1,
N	KNERON_SDK_FR = KNERON_CAT_SDK_TEST +2,
N	
N	// Category Function Runner related 2000
N    KNERON_FUNCTION = 2000,
N    KNERON_FUNCTION_NIRLIVENESS_CLS = KNERON_FUNCTION,
N    KNERON_FUNCTION_OCC_CLS = KNERON_FUNCTION +1,
N    KNERON_FUNCTION_LMSEG_FUSE = KNERON_FUNCTION +2, 
N    KNERON_FUNCTION_FILTER_SCORE = KNERON_FUNCTION +3,
N
N	//Category Customer models
N	//0x8000 = 32768
N	CUSTOMER = 32768,
N
N	Count
N
N};
N#endif
L 13 "..\..\..\..\common\include\ipc.h" 2
N#include "model_res.h"
L 1 "..\..\..\..\common\include\model_res.h" 1
N#ifndef __MODEL_RES_H__
N#define __MODEL_RES_H__
N
N/* These header defines structures shared by scpu/ncpu/host_lib */
N
N#define LAND_MARK_POINTS       5
N#define EYE_LID_LM_POINTS      7
N#define FR_FEATURE_MAP_SIZE    512
N#define LV_R_SIZE              1
N#define LV_SCORE_SIZE          2
N#define DUAL_LAND_MARK_POINTS  10
N#define DME_OBJECT_MAX         80
N#define IMAGENET_TOP_MAX       5
N#define HAND_KEY_POINTS        7
N
N/* Yolo Result */
Nstruct bounding_box_s {
N    float x1;      // top-left corner: x
N    float y1;      // top-left corner: y
N    float x2;      // bottom-right corner: x
N    float y2;      // bottom-right corner: y
N    float score;   // probability score
N    int32_t class_num; // class # (of many) with highest probability
N};
N
Nstruct yolo_result_s {
N    uint32_t class_count;            // total class count
N    uint32_t box_count;              // boxes of all classes
N    struct bounding_box_s boxes[1];  // box_count
N};
N
Nstruct age_gender_result_s {
N    uint32_t age;
N    uint8_t ismale;
N};
N
Nstruct imagenet_result_s {
N    int32_t   index; // index of the class
N    float score; // probability score of the class
N};
N
Nstruct facedet_result_s {
N    int32_t len;
N    int32_t xywh[4]; // 4 values for X, Y, W, H
N    float xywh_fl[4]; // 4 values for X, Y, W, H
N    float score;     //prob score
N    int32_t class_num; //class
N};
N
Nstruct landmark_result_s {
N    struct {
N        uint32_t x;
N        uint32_t y;
N        float    x_f;
N        float    y_f;
N    } marks[LAND_MARK_POINTS];
X    } marks[5];
N    float score;
N    float blur;
N};
N
Nstruct hand_kp_result_s {
N    struct {
N        float    x_f;
N        float    y_f;
N    } marks[HAND_KEY_POINTS];
X    } marks[7];
N    float score;
N};
N
Nstruct eye_lid_lm_result_s {
N    struct {
N        uint32_t x;
N        uint32_t y;
N    } marks[EYE_LID_LM_POINTS];
X    } marks[7];
N    float score;
N};
N
Nstruct face_occlude_result_s {
N    float yaw;
N    float pitch;
N    float roll;
N    float occ;
N    float seg_res[7];
N};
N
Nstruct age_group_result_s {
N    int32_t age;
N};
N
Nstruct face_quality_result_s {
N    float face_score;
N};
N
Nstruct fr_result_s {
N    float feature_map[FR_FEATURE_MAP_SIZE];
X    float feature_map[512];
N};
N
N/* by larry lai */
N
Nstruct lv_result_s{
N    int32_t  real[LV_R_SIZE];
X    int32_t  real[1];
N    float    score[LV_SCORE_SIZE];
X    float    score[2];
N    _Bool    wb_result;
N    float    nir_luma_ratio;
N    uint8_t  rgb_quality;
N    uint8_t  rgb_corner_y;
N    float    effect_2d;
N    uint8_t  cal_nir_led_on_tile;
N    uint8_t  cal_distance;
N    float    id_ref_c;   
N};
N
Nstruct dual_landmarks_s {
N    struct {
N        uint32_t x;
N        uint32_t y;
N    } marks[DUAL_LAND_MARK_POINTS];
X    } marks[10];
N};
N
Ntypedef struct {
N    struct bounding_box_s fd_res;
N    struct age_gender_result_s ag_res;
N} fd_age_gender_res;
N
Ntypedef struct {
N    uint32_t class_count; // total class count
N    uint32_t box_count;   // boxes of all classes
N    struct bounding_box_s boxes[DME_OBJECT_MAX]; // box information
X    struct bounding_box_s boxes[80]; 
N} dme_res;
N
N#endif
L 14 "..\..\..\..\common\include\ipc.h" 2
N
N/* IPC memory */
N//----------------------------
N/* N i/d RAM */
N#ifdef TARGET_NCPU
S#define S_D_RAM_ADDR                0x20200000
S#define N_D_RAM_ADDR                0x0FFF0000
N#endif
N#ifdef TARGET_SCPU
N#define S_D_RAM_ADDR                0x10200000
N#define N_D_RAM_ADDR                0x2FFF0000
N#endif
N
N#define S_D_RAM_SIZE                0x18000          /* 96 KB */
N#define N_D_RAM_SIZE                0x10000          /* 64 KB */
N
N#define IPC_RAM_SIZE                0x2000           /* 8K Bytes : split 7 : 1 */
N#define IPC_MEM_OFFSET              (S_D_RAM_SIZE - IPC_RAM_SIZE)
N#define IPC_MEM_OFFSET2             (S_D_RAM_SIZE - IPC_RAM_SIZE / 8)
N#define IPC_MEM_ADDR                (S_D_RAM_ADDR + IPC_MEM_OFFSET)
N#define IPC_MEM_ADDR2               (S_D_RAM_ADDR + IPC_MEM_OFFSET2)
N//----------------------------
N
N#define SCPU2NCPU_ID		('s'<<24 | 'c'<<16 | 'p'<<8 | 'u')
N#define NCPU2SCPU_ID		('n'<<24 | 'c'<<16 | 'p'<<8 | 'u')
N
N#define MULTI_MODEL_MAX         16      /* Max active models in memory */
N#define IPC_IMAGE_ACTIVE_MAX    2       /* Max active images for NCPU/NPU */
N#define IPC_COM_PAX             IPC_IMAGE_ACTIVE_MAX
N#define IPC_IMAGE_MAX           5       /* Max cycled buffer for images */
N
N/* Image process cmd_flags set by scpu */
N#define IMAGE_STATE_INACTIVE                0
N#define IMAGE_STATE_ACTIVE                  1
N#define IMAGE_STATE_RECEIVING               2
N
N/* Image process status set by ncpu */
N#define IMAGE_STATE_IDLE                    0
N#define IMAGE_STATE_NPU_BUSY                1
N#define IMAGE_STATE_NPU_DONE                2
N#define IMAGE_STATE_POST_PROCESSING         IMAGE_STATE_NPU_DONE
N#define IMAGE_STATE_POST_PROCESSING_DONE    3
N#define IMAGE_STATE_DONE                    IMAGE_STATE_POST_PROCESSING_DONE
N
N#define IMAGE_STATE_PREPROC_ERROR           (-1)
N#define IMAGE_STATE_NPU_ERROR               (-2)
N
N/* Image format flags */
N#define IMAGE_FORMAT_SUB128                 BIT31
N#define IMAGE_FORMAT_ROT_MASK               (BIT30 | BIT29)
N#define IMAGE_FORMAT_ROT_SHIFT              29
N#define IMAGE_FORMAT_ROT_CLOCKWISE          0x01
N#define IMAGE_FORMAT_ROT_COUNTER_CLOCKWISE  0x02
N
N#define IMAGE_FORMAT_RAW_OUTPUT             BIT28
N#define IMAGE_FORMAT_PARALLEL_PROC          BIT27
N
N#define IMAGE_FORMAT_MODEL_AGE_GENDER       BIT24
N
N#define IMAGE_FORMAT_SYMMETRIC_PADDING      BIT21
N#define IMAGE_FORMAT_PAD_MODE               (BIT21 | BIT20)
N#define IMAGE_FORMAT_PAD_SHIFT              20
N
N
N#define IMAGE_FORMAT_CHANGE_ASPECT_RATIO    BIT20
N
N#define IMAGE_FORMAT_BYPASS_PRE             BIT19
N#define IMAGE_FORMAT_BYPASS_NPU_OP          BIT18
N#define IMAGE_FORMAT_BYPASS_CPU_OP          BIT17
N#define IMAGE_FORMAT_BYPASS_POST            BIT16
N
N/* Padding mode */
N#define NPU_PAD_RIGHT_BOTTOM 0
N#define NPU_PAD_NONE         1
N#define NPU_PAD_SYMMETRIC    2
N#define NPU_PAD_PREDEFINED   3
N
N
N#define IMAGE_FORMAT_NPU            0x00FF
N#define NPU_FORMAT_RGBA8888         0x00
N#define NPU_FORMAT_NIR              0x20
N/* Support YCBCR (YUV) */
N#define NPU_FORMAT_YCBCR422         0x30
N#define NPU_FORMAT_YCBCR444         0x50
N#define NPU_FORMAT_RGB565           0x60
N
N/* Determine the exact format with the data byte sequence in DDR memory: [lowest byte]...[highest byte] */
N#define NPU_FORMAT_YCBCR422_CRY1CBY0 0x30
N#define NPU_FORMAT_YCBCR422_CBY1CRY0 0x31
N#define NPU_FORMAT_YCBCR422_Y1CRY0CB 0x32
N#define NPU_FORMAT_YCBCR422_Y1CBY0CR 0x33
N#define NPU_FORMAT_YCBCR422_CRY0CBY1 0x34
N#define NPU_FORMAT_YCBCR422_CBY0CRY1 0x35
N#define NPU_FORMAT_YCBCR422_Y0CRY1CB 0x36
N#define NPU_FORMAT_YCBCR422_Y0CBY1CR 0x37  // Y0CbY1CrY2CbY3Cr...
N
N/* Model structure */
Nstruct kdp_model_s {
N    /* Model type */
N    uint32_t    model_type; //defined in model_type.h
N
N    /* Model version */
N    uint32_t    model_version;
N
N    /* Input in memory */
N    uint32_t    input_mem_addr;
N    int32_t     input_mem_len;
N	
N    /* Output in memory */
N    uint32_t    output_mem_addr;
N    int32_t     output_mem_len;
N
N    /* Working buffer */
N    uint32_t    buf_addr;
N    int32_t     buf_len;
N
N    /* command.bin in memory */
N    uint32_t    cmd_mem_addr;
N    int32_t     cmd_mem_len;
N
N    /* weight.bin in memory */
N    uint32_t    weight_mem_addr;
N    int32_t     weight_mem_len;
N
N    /* setup.bin in memory */
N    uint32_t    setup_mem_addr;
N    int32_t     setup_mem_len;
N};
Ntypedef struct kdp_model_s kdp_model_info_t;
N
N/* Result structure of a model */
Nstruct result_buf_s {
N    int32_t     model_id;
N    uint32_t    result_mem_addr;
N    int32_t     result_mem_len;
N    int32_t     result_ret_len;
N};
N
N#define MAX_PARAMS_LEN          40 /* uint32_t */
N
Nstruct kdp_img_cfg {
N    uint32_t image_mem_addr;
N    int32_t image_mem_len;
N    int32_t image_col;
N    int32_t image_row;
N    int32_t image_ch;
N    uint32_t image_format;
N    uint32_t image_buf_active_index; // scpu_to_ncpu->active_img_index
N};
N
Nstruct kdp_crop_box_s {
N    int32_t top;
N    int32_t bottom;
N    int32_t left;
N    int32_t right;
N};
N
Nstruct kdp_pad_value_s {
N    int32_t pad_top;
N    int32_t pad_bottom;
N    int32_t pad_left;
N    int32_t pad_right;
N};
N
N/* Parameter structure of a raw image */
Nstruct parameter_s {
N    /* Crop parameters or other purposes */
N    int         crop_top;
N    int         crop_bottom;
N    int         crop_left;
N    int         crop_right;
N
N    /* Pad parameters or other purposes */
N    int         pad_top;
N    int         pad_bottom;
N    int         pad_left;
N    int         pad_right;
N    int         flip_face;  // for fr, 0 to not, 1 to flip
N
N    /* Shared parameters */
N    uint32_t    params[MAX_PARAMS_LEN];
X    uint32_t    params[40];
N
N    uint32_t    dual_landmarks[20];
N    uint32_t    dual_landmarks_3d[20];
N    uint8_t     init_tile;
N    uint8_t     nir_mode;
N    float       init_nir_gain;
N    float       nir_gain;
N    uint32_t    nir_cur_exp_time;
N    uint32_t    calibration_count;
N    float       registered_offsetX;
N    float       registered_offsetY;
N    uint8_t     rgb_led_flag;
N    uint8_t     rgb_avg_luma;
N    float       x_scaling;
N    uint8_t     d_offset;
N    uint8_t     pass_type;
N    _Bool       ignore_rgb_led;
N    _Bool       bctc;
N    uint8_t     input_nir_led_on_tile;
N    uint8_t     nir_led_flag;
N    uint8_t     input_distance;
N    uint32_t    rgb_cur_exp_time;
N    uint32_t    rgb_init_exp_time;
N    uint8_t     pre_gain;
N    uint8_t     post_gain;
N    uint8_t     global_gain;
N    uint8_t     y_average;
N    float       rgb_lm_score;
N    float       nir_lv_cnn_face_real_score;
N    float       fuse_lv_cnn_real_score;
N};
N
N/* Raw image structure */
Nstruct kdp_img_raw_s {
N    /* Image state: 1 = active, 0 = inactive */
N    int         state;
N
N    /* Image sequence number */
N    int         seq_num;
N
N    /* Image ref index */
N    int         ref_idx;
N
N    /* raw image dimensions */
N    uint32_t    input_row;
N    uint32_t    input_col;
N    uint32_t    input_channel;
N
N    /* Raw image format and pre-process flags
N     * bit-31: = 1 : subtract 128
N     * bit 30:29 00: no rotation; 01: rotate clockwise; 10: rotate counter clockwise; 11: reserved
N     * bit 7:0: format
N     */
N    uint32_t    format;
N
N    /* Parameter structure */
N    struct parameter_s  params_s;
N
N    /* input image in memory */
N    uint32_t    image_mem_addr;
N    int32_t     image_mem_len;
N
N    struct result_buf_s results[MULTI_MODEL_MAX];
X    struct result_buf_s results[16];
N
N    /* Test: SCPU total */
N    uint32_t    tick_start;
N    uint32_t    tick_end;
N
N    /* Test: NCPU processes */
N    uint32_t    tick_start_pre;
N    uint32_t    tick_end_pre;
N    uint32_t    tick_start_npu;
N    uint32_t    tick_end_npu;
N    uint32_t    tick_start_post;
N    uint32_t    tick_end_post;
N};
N
N/* Image result structure */
Nstruct kdp_img_result_s {
N    /* Processing status: 2 = done, 1 = running, 0 = unused */
N    int         status;
N
N    /* Image sequence number */
N    int         seq_num;
N	
N    /* result memory addr */
N    //dummy information
N    uint32_t    result_mem_addr;
N};
N
N/* Structure of sCPU->nCPU Message */
Nstruct scpu_to_ncpu_s {
N    uint32_t    id;        /* = 'scpu' */
N    uint32_t    version;
N    uint32_t    cmd;            // Run / Stop
N    uint32_t    input_count;    // # of input image
N
N    /*
N     * debug control flags (dbg.h):
N     *   bits 19-16: scpu debug level
N     *   bits 03-00: ncpu debug level
N     */
N    uint32_t    debug_flags;
N
N    /* Active images (& model) being processed by npu/ncpu */
N    uint32_t            cmd_flags[IPC_IMAGE_ACTIVE_MAX]; // discussion, IPC_COM_PAX
X    uint32_t            cmd_flags[2]; 
N    int32_t             active_img_index[IPC_IMAGE_ACTIVE_MAX]; // discussion, raw_imgs_idx[IPC_COM_PAX]
X    int32_t             active_img_index[2]; 
N    int32_t             model_slot_index[IPC_IMAGE_ACTIVE_MAX]; // discussion, models_slot_idx[IPC_COM_PAX]
X    int32_t             model_slot_index[2]; 
N
N    int32_t             active_img_index_rgb_liveness;
N
N    /* Models in memory */
N    int32_t             num_models;  //usually, num_models=1 (only one active model)
N    struct kdp_model_s  models[MULTI_MODEL_MAX];            //to save active modelInfo
X    struct kdp_model_s  models[16];            
N    uint32_t            models_type[MULTI_MODEL_MAX];       //to save model type
X    uint32_t            models_type[16];       
N
N    /* Raw image information */
N    struct kdp_img_raw_s raw_images[IPC_IMAGE_MAX];
X    struct kdp_img_raw_s raw_images[5];
N
N    /* Input/Output working buffers for NPU */
N    uint32_t    input_mem_addr2;
N    int32_t     input_mem_len2;
N
N    /* Memory for parallel processing */
N    uint32_t    output_mem_addr2;
N    int32_t     output_mem_len2;
N
N    /* Memory for pre processing command */
N    uint32_t    inproc_mem_addr;
N    
N    /* Memory for post processing parameters */
N    uint32_t    output_mem_addr3;
N};
N
N/* Structure of nCPU->sCPU Message */
Nstruct ncpu_to_scpu_s {
N    uint32_t    id;        /* = 'ncpu' */
N    uint32_t    version;
N    int32_t     status;
N
N    /* Active pipeline */
N    int32_t     cmd_status[IPC_IMAGE_ACTIVE_MAX];
X    int32_t     cmd_status[2];
N    int32_t     img_index_done[IPC_IMAGE_ACTIVE_MAX]; // for debug only
X    int32_t     img_index_done[2]; 
N
N    /* Images result info corresponding to raw_images[] */
N    struct kdp_img_result_s img_results[IPC_IMAGE_MAX];
X    struct kdp_img_result_s img_results[5];
N};
N
N/* scpu_to_ncpu: cmd */
Nenum {
N    CMD_NO,
N    CMD_STOP_NPU,
N    CMD_RUN_NPU,
N    CMD_RUN_NPU_1,
N    CMD_RUN_NCPU,
N    CMD_RUN_NCPU_1,
N};
N
N/* ncpu_to_scpu: status */
Nenum {
N    STATUS_ERR = -1,
N    STATUS_INIT = 0,
N    STATUS_OK,
N    STATUS_OK_1,
N    STATUS_DDR_FAULT = -101,
N};
N
Nstruct nir_camera_tune_s{
N    uint8_t     init_tile;
N    uint8_t     nir_mode;
N    float       init_nir_gain;
N    float       nir_gain;
N    uint32_t    nir_cur_exp_time;
N    uint32_t    calibration_count;
N    float       registered_offsetX;
N    float       registered_offsetY;
N    uint8_t     rgb_led_flag;
N    uint8_t     rgb_avg_luma;
N    float       x_scaling;
N    uint8_t     d_offset;
N    uint8_t     pass_type;
N    _Bool       ignore_rgb_led;
N    _Bool       bctc;
N    uint8_t     input_nir_led_on_tile;
N    uint8_t     nir_led_flag;
N    uint8_t     input_distance;
N    uint32_t    rgb_cur_exp_time;
N    uint32_t    rgb_init_exp_time; 
N    uint8_t     pre_gain;
N    uint8_t     post_gain;
N    uint8_t     global_gain;
N    uint8_t     y_average;
N    float       rgb_lm_score;
N    float       nir_lv_cnn_face_real_score;
N    float       fuse_lv_cnn_real_score;
N    
N};
N
Nstruct lv_params_s {
N    uint32_t dual_landmarks[DUAL_LAND_MARK_POINTS * 2];
X    uint32_t dual_landmarks[10 * 2];
N    uint32_t dual_landmarks_3d[DUAL_LAND_MARK_POINTS * 2];
X    uint32_t dual_landmarks_3d[10 * 2];
N    struct nir_camera_tune_s nir_tune;
N};
N
N#endif
L 12 "..\..\..\..\common\include\dbg.h" 2
N
N//#define DEV_TEST_VERSION
N//#define DEV_PKT_LOG_DETAIL
N
N#define LOG_NONE        0
N#define LOG_USER        1
N#define LOG_CRITICAL    1
N#define LOG_ERROR       2
N
N#define LOG_INFO        4
N#define LOG_TRACE       5
N#define LOG_DBG         6
N#define LOG_PROFILE     9
N
N#define DEBUG_CONSOLE                  DRVUART_PORT0
N
N#ifdef DEV_TEST_VERSION
S#undef CUSTOMER_SETTING_REMOVE_LOG
N#else
N#define CUSTOMER_SETTING_REMOVE_LOG
N#endif
N
N#ifdef  LOG_ENABLE
N
N#ifdef TARGET_NCPU
S
Sextern void fLib_printf(const char *f, ...);
S
Sextern struct scpu_to_ncpu_s *in_comm_p;
Sextern int ncpu_debug_level;
S#define log_get_level_ncpu()    (in_comm_p->debug_flags & 0x0000000F)
S    
S#ifdef CUSTOMER_SETTING_REMOVE_LOG
S    #define dbg_msg(fmt, ...) 
S    #define trace_msg(fmt, ...) 
S    #define info_msg(fmt, ...) 
S    #define err_msg(fmt, ...) fLib_printf(fmt, ##__VA_ARGS__)
S    #define critical_msg(fmt, ...) 
S    #define profile_msg(fmt, ...) 
S    #define dbg_msg_algo(fmt, ...) //MSG(LOG_CRITICAL, fmt, ##__VA_ARGS__) 
S    #define dbg_msg_algo2(fmt, ...) //MSG(LOG_CRITICAL, fmt, ##__VA_ARGS__) 
S#else
S    #define dbg_msg(fmt, ...) //MSG(LOG_DBG, fmt, ##__VA_ARGS__)
S    #define trace_msg(fmt, ...) //MSG(LOG_TRACE, fmt, ##__VA_ARGS__)
S    #define info_msg(fmt, ...) //MSG(LOG_INFO, fmt, ##__VA_ARGS__)
S    #define err_msg(fmt, ...) fLib_printf(fmt, ##__VA_ARGS__)
S    #define critical_msg(fmt, ...) fLib_printf(fmt, ##__VA_ARGS__)
S    #define profile_msg(fmt, ...) fLib_printf(fmt, ##__VA_ARGS__)
S    #define dbg_msg_algo(fmt, ...) fLib_printf(fmt, ##__VA_ARGS__)
S    #define dbg_msg_algo2(fmt, ...) //MSG(LOG_CRITICAL, fmt, ##__VA_ARGS__) 
S#endif   
S    
S    
N#else // TARGET_SCPU
N
Nextern struct scpu_to_ncpu_s *s_out_comm;
Nextern int scpu_debug_level;
N
N#define MSG(level, format, ...) \
N    do {                                                   \
N        if (level <= scpu_debug_level)                     \
N            kdp_printf(format, ##__VA_ARGS__);            \
N    } while (0)
X#define MSG(level, format, ...)     do {                                                           if (level <= scpu_debug_level)                                 kdp_printf(format, ##__VA_ARGS__);                } while (0)
N
N
Nvoid kdp_printf(const char *f, ...);
Nvoid kdp_level_printf(int level, const char *fmt, ...);
Nvoid kdp_user_level_printf(int level, const char *fmt, ...);
Nvoid kdp_printf_nocrlf(const char *f, ...);
N    
N#define dbg_msg(fmt, ...) //MSG(LOG_DBG, fmt, ##__VA_ARGS__)
N#define trace_msg(fmt, ...) MSG(LOG_TRACE, fmt, ##__VA_ARGS__)
N#define info_msg(fmt, ...) //MSG(LOG_INFO, fmt, ##__VA_ARGS__)
N#define err_msg(fmt, ...) kdp_level_printf(LOG_ERROR, fmt, ##__VA_ARGS__)
N#define critical_msg(fmt, ...) MSG(LOG_CRITICAL, fmt, ##__VA_ARGS__)
N#define profile_msg(fmt, ...) MSG(LOG_PROFILE, fmt, ##__VA_ARGS__)
N
N
N#ifdef CUSTOMER_SETTING_REMOVE_LOG
N    #define dbg_msg_console(__format__, ...) kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_err(__format__, ...) kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_flash(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_camera(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_display(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_touch(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_com(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_gui(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_app(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_e2e(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_api(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_usb(__format__, ...) //{ kdp_printf(__format__"\r\n", ##__VA_ARGS__); }
N    #define dbg_msg_algo(__format__, ...) //kdp_level_printf(LOG_CRITICAL, __format__"\r\n", ##__VA_ARGS__)
N    #define dlog(__format__, ...) //kdp_level_printf(LOG_DBG, "[%s][%s] " __format__ "\r\n", DEF_LOG_CATEG, __func__, ##__VA_ARGS__)
N    #define dbg_msg_model(__format__, ...) kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_ncpu(__format__, ...) //kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_engineering(__format__, ...) //kdp_user_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N    #define dbg_msg_tile(__format__, ...) //kdp_level_printf(LOG_USER, __format__, ##__VA_ARGS__)
N#else
S    #define dbg_msg_console(__format__, ...) kdp_printf(__format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_err(__format__, ...) kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_flash(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_camera(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_display(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_touch(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_com(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_gui(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_app(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_e2e(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_api(__format__, ...) //kdp_level_printf(LOG_ERROR, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_usb(__format__, ...) { kdp_printf(__format__"\r\n", ##__VA_ARGS__); }
S    #define dbg_msg_algo(__format__, ...) kdp_level_printf(LOG_CRITICAL, __format__"\r\n", ##__VA_ARGS__)
S    #define dlog(__format__, ...) kdp_level_printf(LOG_DBG, "[%s][%s] " __format__ "\r\n", DEF_LOG_CATEG, __func__, ##__VA_ARGS__)
S    #define dbg_msg_model(__format__, ...) kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)    
S    #define dbg_msg_ncpu(__format__, ...) //kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_engineering(__format__, ...) //kdp_user_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
S    #define dbg_msg_tile(__format__, ...) kdp_level_printf(LOG_USER, __format__, ##__VA_ARGS__)
N#endif 
N
N#define dbg_msg_user(__format__, ...) kdp_user_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N#define dbg_msg_nocrlf(__format__, ...) { kdp_printf_nocrlf(__format__, ##__VA_ARGS__); }
N#define dbg_msg_console_zhian(__format__, ...) kdp_level_printf(LOG_USER, __format__"\r\n", ##__VA_ARGS__)
N
N
N#endif
N
N#else
S
N#endif // LOG_ENABLE
N
Nuint32_t log_get_level_scpu(void);
Nuint32_t log_get_user_level_scpu(void);
Nvoid log_set_level_scpu(uint32_t level);
Nvoid log_set_level_ncpu(uint32_t level);
Nvoid log_set_user_level_scpu(uint32_t level);
Nvoid log_set_user_level_ncpu(uint32_t level);
N
N#define kmdw_console_set_log_level_scpu log_set_level_scpu
N#define kmdw_console_set_log_level_ncpu log_set_level_ncpu
N
N#define ASSERT(x)   do { \
N                        if (!(x)) 	\
N                            for (;;)	\
N                                ; 		\
N                    } while (0)
X#define ASSERT(x)   do {                         if (!(x)) 	                            for (;;)	                                ; 		                    } while (0)
N
N#endif // __DBG_H__
L 12 "..\..\..\..\board\board_kl520.h" 2
N
N#include "v2k_image.h"
L 1 "..\..\..\..\scpu\framework\include\framework\v2k_image.h" 1
N/*
N * Standard image size definitions
N */
N#ifndef __V2K_IMAGE_H__
N#define __V2K_IMAGE_H__
N
N#include "v2k.h"
L 1 "..\..\..\..\scpu\framework\include\framework\v2k.h" 1
N#ifndef __V2K_H__
N#define __V2K_H__
N
N
N#define V2K_CAP_VIDEO_CAPTURE   0x00000001  /* Is a video capture device */
N#define V2K_CAP_STREAMING       0x00000002  /* can stream on/off */
N#define V2K_CAP_DEVICE_CAPS     0x00000004  /* can query capabilities */
N
Nenum v2k_field {
N    V2K_FIELD_ANY               = 0, 
N    V2K_FIELD_NONE              = 1, /* this device has no fields ... */
N    V2K_FIELD_INTERLACED        = 4, /* both fields interlaced */
N    V2K_FIELD_INTERLACED_DEPTH  = 0x10, 
N};
N
Nenum v2k_colorspace {
N    V2K_COLORSPACE_RGB          = 0,
N    V2K_COLORSPACE_YUV          = 1,
N    V2K_COLORSPACE_RAW          = 2,
N};
N
Nstruct v2k_rect {
N    int left;
N    int top;
N    unsigned int width;
N    unsigned int height;
N};
N
Nstruct v2k_fract {
N    unsigned int numerator;
N    unsigned int denominator;
N};
N
Nstruct v2k_capability {
N    char driver[16];
N    char desc[16];
N    unsigned int version;
N    unsigned int capabilities;
N    int device_id;
N};
N
Nstruct v2k_format {
N    unsigned int width;
N    unsigned int height;
N    unsigned int pixelformat;    /* fourcc */
N    unsigned int field;          /* enum v2k_field */
N    unsigned int bytesperline;   /* for padding, zero if unused */
N    unsigned int sizeimage;
N    unsigned int colorspace;     /* enum v2k_colorspace */
N};
N
Nstruct v2k_buffer {
N    unsigned int type;
N    unsigned int index;
N    unsigned int flags;
N    unsigned int field;
N    unsigned int length;
N    unsigned int offset;
N    unsigned long timestamp;    
N};
N
Nstruct v2k_requestbuffers {
N    unsigned int count;
N};
N
Nstruct v2k_dev_operations;
Nstruct v2k_dev_handle {
N    int i_rdev;
N    void *private_data;
N    const struct v2k_dev_operations *dev_ops;
N};
N
Nstruct v2k_dev_operations {
N    int (*open)(struct v2k_dev_handle *);
N    int (*close)(struct v2k_dev_handle *);
N    //int (*release)(struct v2k_dev_handle *);
N    long (*ioctl)(struct v2k_dev_handle *, unsigned int, void * );    
N};
N
N#define v2k_fourcc(a, b, c, d) \
N    ((unsigned int)(a) | ((unsigned int)(b) << 8) | ((unsigned int)(c) << 16) | ((unsigned int)(d) << 24))
X#define v2k_fourcc(a, b, c, d)     ((unsigned int)(a) | ((unsigned int)(b) << 8) | ((unsigned int)(c) << 16) | ((unsigned int)(d) << 24))
N
N#define V2K_PIX_FMT_YCBCR   v2k_fourcc('Y', 'B', 'Y', 'R')
N#define V2K_PIX_FMT_RGB565  v2k_fourcc('R', 'G', 'B', 'P')
N#define V2K_PIX_FMT_RAW10   v2k_fourcc('R', 'A', '1', '0')
N#define V2K_PIX_FMT_RAW8    v2k_fourcc('R', 'A', 'W', '8')
N
N#define V2K_TYPE_STATIC   	0
N#define V2K_TYPE_DYNAMIC    1
N
N#endif 
L 8 "..\..\..\..\scpu\framework\include\framework\v2k_image.h" 2
N
N#define QVGA_LANDSCAPE_WIDTH    320
N#define QVGA_LANDSCAPE_HEIGHT   240
N#define QVGA_PORTRAIT_WIDTH     240
N#define QVGA_PORTRAIT_HEIGHT    320
N
N#define TFT43_WIDTH             480
N#define TFT43_HEIGHT            272
N
N#define VGA_LANDSCAPE_WIDTH     640
N#define VGA_LANDSCAPE_HEIGHT    480
N#define VGA_PORTRAIT_WIDTH      480
N#define VGA_PORTRAIT_HEIGHT     640
N
N#define HD_WIDTH                1280
N#define HD_HEIGHT               720
N
N#define FHD_WIDTH               1920
N#define FHD_HEIGHT              1080
N
N#define HMX_RICA_WIDTH          864
N#define HMX_RICA_HEIGHT         491
N
N#define QVGA_WIDTH              1280
N#define QVGA_HEIGHT             960
N
N#define UGA_WIDTH               1600
N#define UGA_HEIGHT              1200
N
N#define SC132_FULL_RES_WIDTH    1080
N#define SC132_FULL_RES_HEIGHT   1280
N
N
Nenum image_input_format {
N    image_input_format_rgb565 = 0,
N    image_input_format_rgb555,
N    image_input_format_rgb444,
N    image_input_format_rgb24,
N    image_input_format_ycbcr422,
N    image_input_format_ycbcr420,
N    image_input_format_palette_8,
N    image_input_format_palette_4,
N    image_input_format_palette_2,
N    image_input_format_palette_1,
N};
N
Nstruct sensor_datafmt_info {
N    unsigned int fourcc;
N    enum v2k_colorspace colorspace;
N};
N
Nstruct sensor_win_size {
N    unsigned int width;
N    unsigned int height;
N};
N
N// move this to a better place
Nstruct sensor_init_seq {
N    unsigned short addr;
N    unsigned char value;
N}__attribute__((packed));
N
N
Nstruct video_input_params {
N
N    unsigned int    src_fmt;
N    unsigned int    src_type;
N    unsigned short  src_cam_idx;    //input
N    unsigned short  src_width;      //input
N    unsigned short  src_height;     //input
N    
N    unsigned short  dp_area_x;      //display area x relative to src_width
N    unsigned short  dp_area_y;      //display area y relative to src_height
N    unsigned short  dp_area_w;      //display area width relative to src_width 
N    unsigned short  dp_area_h;      //display area height relative to src_height
N    unsigned short  dp_out_w;       //display width
N    unsigned short  dp_out_h;       //display height
N
N    unsigned short  panel_in_w;    //screen in
N    unsigned short  panel_in_h;    //screen in
N    unsigned short  panel_out_w;   //screen out
N    unsigned short  panel_out_h;   //screen out
N};
N
Nstruct kdp_rect {
N    unsigned short start_x;
N    unsigned short start_y;
N    unsigned short end_x;
N    unsigned short end_y;
N};
N
Nint calc_framesize(
N        unsigned short frame_width, 
N        unsigned short frame_height, 
N        unsigned int input_fmt);
N
N#endif
L 14 "..\..\..\..\board\board_kl520.h" 2
N#include "board_cfg.h"
L 1 "..\..\config\board_cfg.h" 1
N#ifndef __BOARD_CFG_H__
N#define __BOARD_CFG_H__
N
N
N// PRE-definition for board configuration
N#define SENSOR_TYPE_NULL                                                                -1
N#define SENSOR_TYPE_HMX2056                                                              0
N#define SENSOR_TYPE_OV9286                                                               1
N#define SENSOR_TYPE_HMXRICA                                                              2
N#define SENSOR_TYPE_GC2145                                                               3
N#define SENSOR_TYPE_SC132GS                                                              4
N#define SENSOR_TYPE_SC035HGS                                                             5
N#define SENSOR_TYPE_GC1054_R                                                             6
N#define SENSOR_TYPE_GC1054_L                                                             7
N#define SENSOR_TYPE_SP2509_R                                                             8
N#define SENSOR_TYPE_SP2509_L                                                             9
N#define SENSOR_TYPE_MIXO3238                                                            10
N#define SENSOR_TYPE_BF20A1_R                                                            11
N#define SENSOR_TYPE_BF20A1_L                                                            12
N#define SENSOR_TYPE_OV02B1B_R                                                           13
N#define SENSOR_TYPE_OV02B1B_L                                                           14
N#define SENSOR_TYPE_MAX                                                                 15
N#define SENSOR_TYPE_HMX2056_OV9286                                                      16
N#define SENSOR_TYPE_GC2145_SC132GS                                                      17
N#define SENSOR_TYPE_SC132GS_GC2145                                                      18
N#define SENSOR_TYPE_GC2145_SC035HGS                                                      19
N#define SENSOR_TYPE_GC1054_GC1054                                                       20
N#define SENSOR_TYPE_SP2509_SP2509                                                       21
N#define SENSOR_TYPE_BF20A1_BF20A1                                                       22
N#define SENSOR_TYPE_OV02B1B_OV02B1B                                                      23
N#define SENSOR_TYPE_USER_DEFINE                                                       0xff
N#define LED_DRIVER_AW36404                                                               0
N#define LED_DRIVER_AW36515                                                               1
N#define LED_DRIVER_GPIO                                                                  2
N#define RES_640_480                                                                      0
N#define RES_480_640                                                                      1
N#define RES_480_272                                                                      2
N#define RES_272_480                                                                      3
N#define RES_864_491                                                                      4
N#define RES_1600_1200                                                                    5
N#define RES_1080_1280                                                                    6
N#define RES_1280_720                                                                     7
N#define RES_1920_1080                                                                    8
N#define RES_800_600                                                                      9
N#define RES_USER_DEFINE                                                                 10
N#define IMAGE_FORMAT_RGB565                                                              0
N#define IMAGE_FORMAT_RAW10                                                               1
N#define IMAGE_FORMAT_RAW8                                                                2
N#define IMAGE_FORMAT_YCBCR                                                               3
N#define IMAGE_MIPILANE_NUM_1                                                             1
N#define IMAGE_MIPILANE_NUM_2                                                             2
N#define DISPLAY_DEVICE_UNKNOWN                                                           0
N#define DISPLAY_DEVICE_LCDC                                                              1
N#define DISPLAY_DEVICE_LCM                                                               2
N#define DISPLAY_DEVICE_SPI_LCD                                                           3
N#define DISPLAY_DEVICE_LCM_AND_SPI_LCD                                                       4
N#define PANEL_NULL                                                                       0
N#define PANEL_MZT_480X272                                                                1
N#define PANEL_ST7789_240X320                                                             2
N#define PANEL_ST7789_320X240                                                             3
N#define PANEL_MZT                                                                        4
N#define PANEL_ST7789_240X320_SPI                                                         5
N#define PANEL_ST7789_240X320_8080_AND_SPI                                                       6
N#define CFG_SENSOR_TYPE                                          SENSOR_TYPE_SP2509_SP2509
N#define CFG_SENSOR_MIPI0_RX_EN                                                           1
N#define CFG_SENSOR_MIPI1_RX_EN                                                           1
N#define CFG_SENSOR_0_TYPE                                             SENSOR_TYPE_SP2509_R
N#define CFR_SENSOR_0_FORMAT                                              IMAGE_FORMAT_RAW8
N#define CFR_SENSOR_0_MIPILANE_NUM                                     IMAGE_MIPILANE_NUM_1
N#define CFR_SENSOR_0_RES                                                       RES_800_600
N#define CFG_SENSOR_0_WIDTH                                                             800
N#define CFG_SENSOR_0_HEIGHT                                                            600
N#define CFG_SENSOR_0_FMT_MIRROR                                                          0
N#define CFG_SENSOR_0_FMT_FLIP                                                            1
N#define CFG_SENSOR_0_I2C_ADDR                                                         0x3d
N#define CFG_SENSOR_1_TYPE                                             SENSOR_TYPE_SP2509_L
N#define CFR_SENSOR_1_FORMAT                                              IMAGE_FORMAT_RAW8
N#define CFR_SENSOR_1_MIPILANE_NUM                                     IMAGE_MIPILANE_NUM_1
N#define CFR_SENSOR_1_RES                                                       RES_800_600
N#define CFG_SENSOR_1_WIDTH                                                             800
N#define CFG_SENSOR_1_HEIGHT                                                            600
N#define CFG_SENSOR_1_FMT_MIRROR                                                          0
N#define CFG_SENSOR_1_FMT_FLIP                                                            1
N#define CFG_SENSOR_1_I2C_ADDR                                                         0x3d
N#define CFR_SENSOR_NUM                                                                   2
N#define CFR_CAM_RGB                                                                      0
N#define CFR_CAM_NIR                                                                      1
N#define CFG_SENSOR_0_FULL_RESOLUTION                                                       1
N#define CFG_SENSOR_1_FULL_RESOLUTION                                                       1
N#define CFG_PANEL_TYPE                                                          PANEL_NULL
N#define CFG_TOUCH_X_RANGE_MAX                                                          240
N#define CFG_TOUCH_Y_RANGE_MAX                                                          320
N#define CFG_TOUCH_X_AXIS_INVERSE                                                         0
N#define CFG_TOUCH_Y_AXIS_INVERSE                                                         1
N#define CFG_DISPLAY_DMA_ENABLE                                                           1
N#define CFG_PREFER_DISPLAY                                                               1
N#define CFG_I2C_0_ENABLE                                                                 1
N#define CFG_I2C_1_ENABLE                                                                 1
N#define CFG_I2C_2_ENABLE                                                                 0
N#define CFG_I2C_3_ENABLE                                                                 0
N#define CFG_UART0_ENABLE                                                                 1
N#define CFG_UART1_ENABLE                                                                 0
N#define CFG_UART1_TX_DMA_ENABLE                                                          0
N#define CFG_UART1_RX_DMA_ENABLE                                                          0
N#define CFG_UART2_ENABLE                                                                 1
N#define CFG_UART2_TX_DMA_ENABLE                                                          0
N#define CFG_UART2_RX_DMA_ENABLE                                                          0
N#define CFG_UART3_ENABLE                                                                 0
N#define CFG_UART3_TX_DMA_ENABLE                                                          0
N#define CFG_UART3_RX_DMA_ENABLE                                                          0
N#define CFG_UART4_ENABLE                                                                 1
N#define CFG_UART4_TX_DMA_ENABLE                                                          0
N#define CFG_UART4_RX_DMA_ENABLE                                                          0
N#define CFG_ADC0_ENABLE                                                                  0
N#define CFG_ADC0_DMA_ENABLE                                                              0
N#define CFG_ADC1_ENABLE                                                                  0
N#define CFG_ADC1_DMA_ENABLE                                                              0
N#define CFG_ADC2_ENABLE                                                                  0
N#define CFG_ADC2_DMA_ENABLE                                                              0
N#define CFG_ADC3_ENABLE                                                                  0
N#define CFG_ADC3_DMA_ENABLE                                                              0
N#define CFG_PWM1_DMA_ENABLE                                                              0
N#define CFG_PWM2_DMA_ENABLE                                                              0
N#define CFG_PWM3_DMA_ENABLE                                                              0
N#define CFG_PWM4_DMA_ENABLE                                                              0
N#define CFG_PWM5_DMA_ENABLE                                                              0
N#define CFG_PWM6_DMA_ENABLE                                                              0
N#define CFG_SSP0_ENABLE                                                                  0
N#define CFG_SSP0_TX_DMA_ENABLE                                                           0
N#define CFG_SSP0_RX_DMA_ENABLE                                                           0
N#define CFG_SSP1_ENABLE                                                                  1
N#define CFG_SSP1_TX_DMA_ENABLE                                                           0
N#define CFG_SSP1_RX_DMA_ENABLE                                                           0
N#define CFG_SPI_ENABLE                                                                   1
N#define CFG_SPI_DMA_ENABLE                                                               0
N#define CFG_SD_ENABLE                                                                    1
N#define CFG_SD_DMA_ENABLE                                                                0
N#define CFG_USBD_ENABLE                                                                  1
N#define CFG_USBH_ENABLE                                                                  0
N#define CFG_USB_OTG_ENABLE                                                               0
N#define CFG_UI_USR_IMG                                                                   1
N#define CFG_OTA_EN                                                                       0
N#define CFG_LED_DRIVER_TYPE                                                LED_DRIVER_GPIO
N// =======================================================================================
N#define AI_TYPE_R1                                                                       0
N#define AI_TYPE_R1N1                                                                     1
N#define AI_TYPE_N1                                                                       2
N#define AI_TYPE_N1R1                                                                     3
N#define AI_TYPE_PR1                                                                      4
N#define AI_TYPE_UPDATE_FMAP                                                              5
N#define CFG_AI_TYPE                                                           AI_TYPE_N1R1
N#define CFG_AI_3D_ENABLE                                                                 1
N#define CFG_AI_3D_LIVENESS_IN                                                            2
N#define CFG_AI_USE_FIXED_IMG                                                             0
N#define USE_N1_FACE_POSE                                                                 1
N#define USE_FUSE_LV__MODEL                                                               1
N#define CFG_RGB_CV_LIVENESS                                                              0
N#define USE_LIVENESS_CV                                                                  0
N#define USE_FACE_QUALITY                                                                 1
N#define KL520_FACE_ADD_BMP                                                               1
N#define CFG_LW3D_NORMAL                                                                  0
N#define CFG_LW3D_850                                                                     1
N#define CFG_LW3D_940                                                                     2
N#define CFG_LW3D_TYPE                                                         CFG_LW3D_850
N#define CFG_FLASH_DB_NIR_ONLY                                                            1
N#define CFG_REUSE_PREPROC                                                                1
N#define CFG_CAMERA_ROTATE                                                                1
N#define CFG_CAMERA_DUAL_1054                                                             1
N#define CFG_NIR_MODE2_SPLIT                                                              1
N#define CFG_FCOS_FD_ROTATE                                                               1
N#define CFG_ZHIAN                                                                        1
N#define CFG_LM_ONET_PLUS                                                                 1
N#define CFG_REC_ERR_NOT_RET                                                              1
N#define CFG_LED_CTRL_ENHANCE                                                             0
N#define CFG_MODELS_LOAD_BY_ORDER                                                         1
N#define CFG_MAX_USER                                                                   100
N#define CFG_ONE_SHOT_MODE                                                                1
N#define CFG_ONE_SHOT_ENHANCE                                                             1
N#define CFG_ONESHOT_PARALLEL                                                             0
N#define CFG_USB_EXPORT_LIVENESS_RET                                                       1
N#define CUSTOMIZE_DB_OFFSET                                                 0x01 //zcymod 
N#define CFG_DEL_CALIBRATION_SETTING_WHEN_DEL_ALL                                                       1
N// CFG_E2E_SETTING========================================================================
N#define CFG_E2E_STRUCT_LIGHT                                                             0
N#define CFG_E2E_NIR_TWO_STAGE_LIGHT                                                       0
N#define CFG_E2E_CHECK_POSITION                                                           1
N#define CFG_E2E_REC_NOTE                                                                 1
N#define CFG_E2E_RGB_LED_STRENGTH                                                       100
N#define CFG_E2E_NIR_LED_STRENGTH                                                        60
N#define CFG_E2E_RGB_LED_DEFAULT_DIM_ENV_STRENGTH                                                       2
N#define CFG_E2E_RGB_LED_WEAK_ENHANCE_COUNT                                                     200
N#define CFG_E2E_RGB_LED_WEAK_ENHANCE_STEP                                                       2
N#define CFG_E2E_RGB_LED_WEAK_ENHANCE_MAX                                                      20
N#define CFG_E2E_RGB_LED_WEAK_ENHANCE_MIN                                                       4
N#define CFG_E2E_RGB_LED_DEFAULT_DARK_ENV_STRENGTH                                                      15
N#define CFG_E2E_RGB_LED_STRONG_ENHANCE_COUNT                                                    1000
N#define CFG_E2E_RGB_LED_STRONG_ENHANCE_STRONG_STEP                                                       3
N#define CFG_E2E_RGB_LED_STRONG_ENHANCE_STRONG_MAX                                                      80
N#define CFG_E2E_RGB_LED_STRONG_ENHANCE_STRONG_MIN                                                      20
N// =======================================================================================
N//  1.Different rgb led on different hardware 2.bctc liveness version 
N//  Recognition and liveness in dark room is affected by these variable.
N// =======================================================================================
N#define CFG_IGNORE_RGB_LED                                                               1
N#define CFG_LV_HARD                                                                      0
N// =======================================================================================
N#define CFG_TOUCH_ENABLE                                                                 0
N#define TOUCH_INT_PIN                                                                   27
N#define TOUCH_TYPE_CT130                                                                 0
N#define TOUCH_TYPE_FT5X06                                                                1
N#define CFG_TOUCH_TYPE                                                    TOUCH_TYPE_CT130
N#define CFG_SNAPSHOT_ENABLE                                                              0
N#define CFG_USB_SIMTOOL                                                                  0
N#define CFG_SNAPSHOT_INFO                                                                1
N#define CFG_SNAPSHOT_NUMS                                                               10
N#define CFG_SNAPSHOT_ADVANCED                                                            0
N#define CFG_OTA_FLASH_BUF_ENABLE                                                         1
N#define CFG_OTA_IMAGE_BUF_ENABLE                                                         1
N#define CFG_KDP_SETTINGS_ENABLE                                                          1
N#define CFG_KDP_SETTINGS_SIZE                                                        20480
N#define CFG_USR_SETTINGS_ENABLE                                                          1
N#define CFG_USR_SETTINGS_SIZE                                                         4096
N#define CFG_GUI_ENABLE                                                                   0
N#define CFG_FMAP_EXTRA_ENABLE                                                            0
N#define DISPLAY_REGISTER_WITH_CUSTOM_IMG                                                       1
N// =======================================================================================
N// EXPORT_INFORMATION like stream, db, fm, etc...
N// =======================================================================================
N#define EX_FM_DISABLE                                                                    0
N#define EX_FM_USB_AP_CTRL_ALL                                                            1
N#define EX_FM_USB_AP_CTRL_MAIN_DB                                                        2
N#define EX_FM_UART_AP_CTRL_MAIN_DB                                                       3
N#define CFG_FMAP_AP_CTRL_TYPE                                   EX_FM_UART_AP_CTRL_MAIN_DB
N#define CFG_FMAP_EX_FIG_ENABLE                                                           0
N#define CFG_USB_PROGRAME_FW_ENABLE                                                       0
N#define CFG_USB_EXPORT_STREAM_IMG                                                        0
N#define CFG_USB_CLOUD_DB_UPDATE                                                          0
N// =======================================================================================
N// Display Setting
N// =======================================================================================
N#define DISPLAY_ENABLE                                                                   0
N#define DISPLAY_DOWNSCALE                                                                0
N#define DISPLAY_WIDTH                                                                  320
N#define DISPLAY_HEIGHT                                                                 240
N#define DISPLAY_RGB_WIDTH                                                             1280
N#define DISPLAY_RGB_HEIGHT                                                             720
N#define DISPLAY_RGB_X_OFFSET                                                             0
N#define DISPLAY_RGB_Y_OFFSET                                                             0
N#define DISPLAY_RGB_OUT_WIDTH                                                          320
N#define DISPLAY_RGB_OUT_HEIGHT                                                         240
N#define DISPLAY_NIR_WIDTH                                                             1280
N#define DISPLAY_NIR_HEIGHT                                                             720
N#define DISPLAY_NIR_X_OFFSET                                                             0
N#define DISPLAY_NIR_Y_OFFSET                                                             0
N#define DISPLAY_NIR_OUT_WIDTH                                                          320
N#define DISPLAY_NIR_OUT_HEIGHT                                                         240
N#define PANEL_IN_WIDTH                                                                 320
N#define PANEL_IN_HEIGHT                                                                240
N#define PANEL_RGB_X_OFFSET                                                               0
N#define PANEL_RGB_Y_OFFSET                                                               0
N#define PANEL_NIR_X_OFFSET                                                               0
N#define PANEL_NIR_Y_OFFSET                                                               0
N// CFG_ST7789_X_Y_INVERSE=1
N// =======================================================================================
N// In this section there are some macros used to selection communication interface which you want
N// If you want to use snapshot or OTA, you need select the correct bus type
N// If you select COM_BUS_TYPE_UART4, and then you need filled it to CFG_COM_BUS_TYPE
N// For example: "#define CFG_COM_BUS_TYPE  COM_BUS_TYPE_UART4"
N// =======================================================================================
N#define COM_BUS_UART_MASK                                                       0x0000007F
N#define COM_BUS_USB_MASK                                                        0x00000080
N#define COM_BUS_SPI_MASK                                                        0x00000F00
N#define COM_BUS_I2C_MASK                                                        0x0000F000
N#define COM_BUS_SDIO_MASK                                                       0x000F0000
N#define COM_BUS_OTG_MASK                                                        0x00100000
N#define COM_BUS_UART0                                                                 0x01
N#define COM_BUS_UART1                                                                 0x02
N#define COM_BUS_UART2                                                                 0x04
N#define COM_BUS_UART3                                                                 0x08
N#define COM_BUS_UART4                                                                 0x10
N#define COM_BUS_USB                                                                   0x80
N#define COM_BUS_SSP0                                                                 0x100
N#define COM_BUS_SSP1                                                                 0x200
N#define COM_BUS_SPI_MS_EN                                                            0x800
N#define COM_BUS_I2C0                                                                0x1000
N#define COM_BUS_I2C1                                                                0x2000
N#define COM_BUS_I2C2                                                                0x4000
N#define COM_BUS_I2C3                                                                0x8000
N#define COM_BUS_SDIO                                                               0x10000
N#define COM_BUS_OTG                                                               0x100000
N#define CFG_COM_BUS_TYPE                                                   (COM_BUS_UART2)
N// =======================================================================================
N#define COM_PROTOCOL_TYPE_LWCOM                                                          0
N#define COM_PROTOCOL_TYPE_KCOMM                                                          1
N#define CFG_COM_PROTOCOL_TYPE                                      COM_PROTOCOL_TYPE_LWCOM
N#define COM_USB_PROT_DEF                                                                 0
N#define COM_USB_PROT_KDP                                                                 1
N#define COM_USB_PROT_DEF_USR                                                             2
N#define COM_USB_PROT_KDP_USR                                                             3
N#define CFG_COM_USB_PROT_TYPE                                             COM_USB_PROT_DEF
N#define COM_UART_PROT_DEF                                                                0
N#define COM_UART_PROT_KDP                                                                1
N#define COM_UART_PROT_DEF_USR                                                            2
N#define COM_UART_PROT_KDP_USR                                                            3
N#define CFG_COM_URT_PROT_TYPE                                            COM_UART_PROT_KDP
N#define NO_ENCRYPTION                                                                    0
N#define AES_ENCRYPTION                                                                0x01
N#define XOR_ENCRYPTION                                                                0x02
N#define ENCRYPTION_MODE                                    (AES_ENCRYPTION|XOR_ENCRYPTION)
N#define COM_UART_MSG_KDP                                                                 0
N#define COM_UART_MSG_USER                                                                1
N#define CFG_COM_UART_MSG                                                 COM_UART_MSG_USER
N// =======================================================================================
N#define CFG_USB_MANUFACTURER                         {'K',0,'n',0,'e',0,'r',0,'o',0,'n',0}
N#define CFG_USB_PRODUCT                              {'K',0,'n',0,'e',0,'r',0,'o',0,'n',0}
N#define CFG_USB_SERIAL                   {'5',0,'5',0,'6',0,'6',0,'7',0,'7',0,'8',0,'8',0}
N#define BOARD_VERSION                                                                    0
N#define FAT_FS                                                                           0
N#define PETIT_FS                                                                         1
N#define CFG_OTG_FSTYPE                                                            PETIT_FS
N#define KL520A                                                                           0
N#define KL520B                                                                           1
N#define CFG_KL520_VERSION                                                           KL520B
N// =======================================================================================
N//  CFG_BOARD_PARAMS_0_ID = X. Means the Xth parameter group of CFG_BOARD_PARAMS_0.
N//  The board uses the same camera sensor, but the module components are different, such as lens.
N//  developer please refer to /doc/developer_only/board_cfg_desc.txt for more details.
N// =======================================================================================
N#define CFG_BOARD_PARAMS_0_ID                                                            2
N#define CFG_BOARD_PARAMS_0_0      {65.0f,130.0f,0.75f,1.33f,1.33f,-120.0f,40.0f,1.385f,0.8f,0.8f,1.00f,1.0f}
N#define CFG_BOARD_PARAMS_0_1      {65.0f,130.0f,0.7825f,0.98f,0.942f,-160.0f,6.0f,1.0f,1.14f,1.00f,1.385f,150.0f}
N#define CFG_BOARD_PARAMS_0_2      {130.0f,65.0f,-0.35f,1.0f,1.0f,-160.0f,6.0f,1.0f,1.14f,1.00f,1.385f,150.0f}
N#define CFG_BOARD_PARAMS_1_ID                                                            0
N#define CFG_BOARD_PARAMS_1_0                                                 {2.77f,94.0f}
N// =======================================================================================
N//  Memory selection for different flash vendor
N// =======================================================================================
N#define IMAGE_16MB                                                                      16
N#define IMAGE_32MB                                                                      32
N#define IMAGE_64MB                                                                      64
N#define IMAGE_SIZE                                                              IMAGE_16MB
N#define FLASH_16MB                                                                      16
N#define FLASH_32MB                                                                      32
N#define FLASH_64MB                                                                      64
N#define FLASH_SIZE                                                              FLASH_32MB
N#define GD25Q256D                                                                        0
N#define GD25S512MD                                                                       1
N#define W25Q256JV                                                                        2
N#define FLASH_VENDOR_SELECT                                                      W25Q256JV
N#define CFG_OTA_FLASH_SLAVE_ENABLE                                                       0
N#define CFG_USB_EXPORT_LIVENESS_RET                                                       1
N// =======================================================================================
N//  mipi pll setting
N//  for more different setting please refer to /doc/developer_only/csirx_pll_setting_table.xslx for more details.
N// =======================================================================================
N#define CFG_PLL_MS                                                                       2
N#define CFG_PLL_NS                                                                     200
N#define CFG_PLL_PS                                                                       2
N#define CFG_CSIRX0_TXESCCLK                                                              3
N#define CFG_CSIRX0_CSI                                                                  16
N#define CFG_CSIRX0_VC0                                                                   7
N#define CFG_CSIRX1_TXESCCLK_PLL3                                                         3
N#define CFG_CSIRX1_CSI                                                                  16
N#define CFG_CSIRX1_VC0                                                                   7
N#define MIPI_PRE_DEF1                                             {2,268,2,5,27,13,5,15,4}
N#define MIPI_PRE_DEF2                                              {1,210,3,5,15,3,2,31,7}
N#define MIPI_PRE_DEF3                                               {2,242,2,4,11,5,4,7,1}
N#define MIPI_PRE_DEF4                                               {2,242,2,4,7,1,4,11,5}
N#define MIPI_PRE_DEF5                                               {2,200,2,3,9,4,3,13,3}
N#define MIPI_PRE_DEF6                                              {2,200,2,3,16,7,3,16,7}
N#define MIPI_PRE_DEF7                                              {2,200,2,3,12,2,3,16,7}
N#define MIPI_PRE_DEF8                                              {2,200,2,3,16,7,3,12,2}
N#define MIPI_PRE_DEF9                                              {2,300,2,2,3,5,5,27,10}
N#define MIPI_PRE_DEF10                                           {2,200,2,3,24,24,3,24,24}
N// ====1600x1200====
N#define MIPI_PRE_DEF11                                             {2,268,2,4,10,4,4,10,4}
N// ================
N// =====800x600=====
N#define MIPI_PRE_DEF12                                             {2,268,2,4,28,9,4,28,9}
N// ================
N#define MIPI_PRE_DEF13                                             {2,400,2,3,26,7,3,26,7}
N#define MIPI_CUSTOM               {CFG_PLL_MS,CFG_PLL_NS,CFG_PLL_PS,CFG_CSIRX0_TXESCCLK,CFG_CSIRX0_CSI,CFG_CSIRX0_VC0,CFG_CSIRX1_TXESCCLK_PLL3,CFG_CSIRX1_CSI,CFG_CSIRX1_VC0}
N#define CFG_MIPI_PLL_SETTING                                                MIPI_PRE_DEF13
N// =======================================================================================
N// =======================================================================================
N
N#endif
L 15 "..\..\..\..\board\board_kl520.h" 2
N
Nextern u8 rgb_sensor_index;
Nextern u8 nir_sensor_index;
Nextern u8 sensor_0_mirror;
Nextern u8 sensor_0_flip;
Nextern u8 sensor_1_mirror;
Nextern u8 sensor_1_flip;
N
N#define YES                         1
N#define NO                          0
N
N#define CFG_AI_3D_LIVENESS_IN_NONE  0
N#define CFG_AI_3D_LIVENESS_IN_SCPU  1
N#define CFG_AI_3D_LIVENESS_IN_NCPU  2
N
N/* Tile average setting */
N#if (CFG_SENSOR_1_TYPE == SENSOR_TYPE_SC035HGS && CFG_CAMERA_ROTATE == 1)
X#if (9 == 5 && 1 == 1)
S#define ALL_TILE_VALUE              (NO)
N#else
N#define ALL_TILE_VALUE              (YES)
N#endif
N
N#define TILE_AVG_32                 (32)
N#define TILE_AVG_64                 (64)
N#define TILE_AVG_128                (128)
N#define TILE_AVG_CAL_SIZE           (TILE_AVG_128)
N
N#if (ALL_TILE_VALUE == NO)  //only for SC035
X#if ((1) == 0)  
S#define TILE_AVG_BLOCK_X            (4)
S#define TILE_AVG_BLOCK_Y            (5)
N#else
N#define TILE_AVG_BLOCK_X            (10)  //cannot modify
N#define TILE_AVG_BLOCK_Y            (6)   //cannot modify
N#endif
N#define TILE_AVG_BLOCK_NUMBER       (TILE_AVG_BLOCK_X * TILE_AVG_BLOCK_Y)
N
N#define TILE_AVG_VALID_X            ( ( (NIR_IMG_SOURCE_W / TILE_AVG_CAL_SIZE) < TILE_AVG_BLOCK_X ) ? (NIR_IMG_SOURCE_W / TILE_AVG_CAL_SIZE) : TILE_AVG_BLOCK_X )
N#define TILE_AVG_VALID_Y            ( ( (NIR_IMG_SOURCE_H / TILE_AVG_CAL_SIZE) < TILE_AVG_BLOCK_Y ) ? (NIR_IMG_SOURCE_H / TILE_AVG_CAL_SIZE) : TILE_AVG_BLOCK_Y )
N
N#if ( CFG_PALM_PRINT_MODE == YES )
X#if ( CFG_PALM_PRINT_MODE == 1 )
S#define BRIGHTNESS_STATS_X_BLOCK_NUM  ( 4 )
S#define BRIGHTNESS_STATS_Y_BLOCK_NUM  ( 15 )
S#define BRIGHTNESS_STATS_BLOCK_MAX    ( BRIGHTNESS_STATS_X_BLOCK_NUM * BRIGHTNESS_STATS_Y_BLOCK_NUM )  //less than "TILE_AVG_BLOCK_NUMBER"
S#define BRIGHTNESS_STATS_X_BLOCK_SIZE ( 100 )   //fixed
S#define BRIGHTNESS_STATS_Y_BLOCK_SIZE ( 26 )    //fixed
S#define BRIGHTNESS_STATS_X_START      ( 100 )
S#define BRIGHTNESS_STATS_Y_START      ( 100 )
S#define BRIGHTNESS_STATS_STEP         ( 4 )     //fixed
N#endif
N
N/* The other definitions which are based on customer board configuration */
N#ifdef CFG_SENSOR_TYPE
N#define CFG_MIPIRX_ENABLE           YES
N#endif
N
N#define MIPI_0_RX_ENABLE            CFG_SENSOR_MIPI0_RX_EN
N#define MIPI_1_RX_ENABLE            CFG_SENSOR_MIPI1_RX_EN
N#define IMGSRC_0_TYPE               CFG_SENSOR_0_TYPE
N#define IMGSRC_1_TYPE               CFG_SENSOR_1_TYPE
N#define IMGSRC_0_RES                CFR_SENSOR_0_RES
N#define IMGSRC_1_RES                CFR_SENSOR_1_RES
N#define IMGSRC_0_FORMAT             CFR_SENSOR_0_FORMAT
N#define IMGSRC_1_FORMAT             CFR_SENSOR_1_FORMAT
N#define IMGSRC_0_MIPILANE_NUM       CFR_SENSOR_0_MIPILANE_NUM
N#define IMGSRC_1_MIPILANE_NUM       CFR_SENSOR_1_MIPILANE_NUM
N#define IMGSRC_NUM                  CFR_SENSOR_NUM
N
N#if (CFG_SENSOR_TYPE == SENSOR_TYPE_GC2145_SC132GS)
X#if (21 == 17)
S#define MIPI_CAM_RGB                0
S#define MIPI_CAM_NIR                1
S#if CFG_SENSOR_0_FULL_RESOLUTION == YES
S#define GC2145_FULL_RES             (YES)
S#else
S#define GC2145_FULL_RES             (NO)
S#endif
S
S#define RGB_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
S#define RGB_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
S
S#if CFG_SENSOR_1_FULL_RESOLUTION == YES
S#define SC132GS_FULL_RES            (YES)
S#else
S#define SC132GS_FULL_RES            (NO)
S#endif
S
S#define NIR_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
S#define NIR_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
S
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_SC132GS_GC2145)
X#elif (21 == 18)
S#define MIPI_CAM_RGB                1
S#define MIPI_CAM_NIR                0
S#if CFG_SENSOR_0_FULL_RESOLUTION == YES
S#define SC132GS_FULL_RES            (YES)
S#else
S#define SC132GS_FULL_RES            (NO)
S#endif
S#define RGB_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
S#define RGB_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
S
S#if CFG_SENSOR_1_FULL_RESOLUTION == YES
S#define GC2145_FULL_RES             (YES)
S#else
S#define GC2145_FULL_RES             (NO)
S#endif
S#define NIR_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
S#define NIR_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
S
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_HMX2056_OV9286)
X#elif (21 == 16)
S#define MIPI_CAM_RGB                0
S#define MIPI_CAM_NIR                1
S#define RGB_IMG_SOURCE_W            640
S#define RGB_IMG_SOURCE_H            480
S#define NIR_IMG_SOURCE_W            480
S#define NIR_IMG_SOURCE_H            640
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_HMXRICA)
X#elif (21 == 2)
S#define MIPI_CAM_NIR                0
S#define RGB_IMG_SOURCE_W            640
S#define RGB_IMG_SOURCE_H            480
S#define NIR_IMG_SOURCE_W            491
S#define NIR_IMG_SOURCE_H            864
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_GC2145_SC035HGS)
X#elif (21 == 19)
S#define MIPI_CAM_RGB                0
S#define MIPI_CAM_NIR                1
S#if CFG_SENSOR_0_FULL_RESOLUTION == YES
S#define RGB_IMG_SOURCE_W            UGA_WIDTH
S#define RGB_IMG_SOURCE_H            UGA_HEIGHT
S#define GC2145_FULL_RES             (YES)
S#else
S#define RGB_IMG_SOURCE_W            640
S#define RGB_IMG_SOURCE_H            480
S#define GC2145_FULL_RES             (NO)
S#endif
S#define NIR_IMG_SOURCE_W            640
S#define NIR_IMG_SOURCE_H            480
S#define SC035HGS_FULL_RES            (NO)
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_GC1054_GC1054)
X#elif (21 == 20)
S#define MIPI_CAM_RGB                rgb_sensor_index
S#define MIPI_CAM_NIR                nir_sensor_index
S
S 
S#define RGB_IMG_SOURCE_W            1280
S#define RGB_IMG_SOURCE_H            720
S#define NIR_IMG_SOURCE_W            1280
S#define NIR_IMG_SOURCE_H            720
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_GC02M1_GC1054)
X#elif (21 == SENSOR_TYPE_GC02M1_GC1054)
S#define MIPI_CAM_RGB                rgb_sensor_index
S#define MIPI_CAM_NIR                nir_sensor_index
S 
S#define RGB_IMG_SOURCE_W            1280
S#define RGB_IMG_SOURCE_H            720
S#define NIR_IMG_SOURCE_W            1280
S#define NIR_IMG_SOURCE_H            720
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_GC2145_GC1054)
X#elif (21 == SENSOR_TYPE_GC2145_GC1054)
S#define MIPI_CAM_RGB                rgb_sensor_index
S#define MIPI_CAM_NIR                nir_sensor_index
S 
S#define RGB_IMG_SOURCE_W            640
S#define RGB_IMG_SOURCE_H            480
S#define NIR_IMG_SOURCE_W            1280
S#define NIR_IMG_SOURCE_H            720
S
S#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_BF20A1_BF20A1)
X#elif (21 == 22)
S 
S#define MIPI_CAM_RGB                rgb_sensor_index
S#define MIPI_CAM_NIR                nir_sensor_index
S
S#define RGB_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
S#define RGB_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
S
S#define NIR_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
S#define NIR_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
S
N#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_OV02B1B_OV02B1B) || (CFG_SENSOR_TYPE == SENSOR_TYPE_SP2509_SP2509)
X#elif (21 == 23) || (21 == 21)
N#define MIPI_CAM_RGB                rgb_sensor_index
N#define MIPI_CAM_NIR                nir_sensor_index
N 
N#define RGB_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
N#define RGB_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
N#define NIR_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
N#define NIR_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
N
N#elif (CFG_SENSOR_TYPE == SENSOR_TYPE_USER_DEFINE)
X#elif (21 == 0xff)
S#if (IMGSRC_0_FORMAT==IMAGE_FORMAT_RGB565) || (IMGSRC_0_FORMAT==IMAGE_FORMAT_YCBCR)
S#define MIPI_CAM_RGB                0
S#define RGB_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
S#define RGB_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
S#elif (IMGSRC_1_FORMAT==IMAGE_FORMAT_RGB565) || (IMGSRC_1_FORMAT==IMAGE_FORMAT_YCBCR)
S#define MIPI_CAM_RGB                1
S#define RGB_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
S#define RGB_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
S#endif
S#if (IMGSRC_0_FORMAT==IMAGE_FORMAT_RAW8) || (IMGSRC_0_FORMAT==IMAGE_FORMAT_RAW10)
S#define MIPI_CAM_NIR                0
S#define NIR_IMG_SOURCE_W            CFG_SENSOR_0_WIDTH
S#define NIR_IMG_SOURCE_H            CFG_SENSOR_0_HEIGHT
S#elif (IMGSRC_1_FORMAT==IMAGE_FORMAT_RAW8) || (IMGSRC_1_FORMAT==IMAGE_FORMAT_RAW10)
S#define MIPI_CAM_NIR                1
S#define NIR_IMG_SOURCE_W            CFG_SENSOR_1_WIDTH
S#define NIR_IMG_SOURCE_H            CFG_SENSOR_1_HEIGHT
S#endif
S#if ((IMGSRC_0_TYPE==SENSOR_TYPE_GC2145) && (IMGSRC_0_RES==RES_1600_1200)) \
S    || ((IMGSRC_1_TYPE==SENSOR_TYPE_GC2145) && (IMGSRC_1_RES==RES_1600_1200))
X#if ((IMGSRC_0_TYPE==SENSOR_TYPE_GC2145) && (IMGSRC_0_RES==RES_1600_1200))     || ((IMGSRC_1_TYPE==SENSOR_TYPE_GC2145) && (IMGSRC_1_RES==RES_1600_1200))
S#define GC2145_FULL_RES             (YES)
S#else
S#define GC2145_FULL_RES             (NO)
S#endif
S#if ((IMGSRC_0_TYPE==SENSOR_TYPE_SC132GS) && (IMGSRC_0_RES==RES_1080_1280)) \
S    || ((IMGSRC_1_TYPE==SENSOR_TYPE_SC132GS) && (IMGSRC_1_RES==RES_1080_1280))
X#if ((IMGSRC_0_TYPE==SENSOR_TYPE_SC132GS) && (IMGSRC_0_RES==RES_1080_1280))     || ((IMGSRC_1_TYPE==SENSOR_TYPE_SC132GS) && (IMGSRC_1_RES==RES_1080_1280))
S#define SC132GS_FULL_RES             (YES)
S#else
S#define SC132GS_FULL_RES             (NO)
S#endif
S
S#else
S#define MIPI_0_RX_ENABLE            YES
S#define MIPI_1_RX_ENABLE            NO
S#define IMGSRC_NUM                  1
N#endif
N
N#if CFG_PANEL_TYPE == PANEL_NULL || CFG_PANEL_TYPE == PANEL_MZT_480X272
X#if 0 == 0 || 0 == 1
N#define PANEL_WIDTH     (TFT43_WIDTH)
N#define PANEL_HEIGHT    (TFT43_HEIGHT)
N#elif (CFG_PANEL_TYPE == PANEL_ST7789_240X320 || CFG_PANEL_TYPE == PANEL_ST7789_240X320_SPI || (CFG_PANEL_TYPE==PANEL_ST7789_240X320_8080_AND_SPI) )
X#elif (0 == 2 || 0 == 5 || (0==6) )
S#define PANEL_WIDTH     (QVGA_PORTRAIT_WIDTH)
S#define PANEL_HEIGHT    (QVGA_PORTRAIT_HEIGHT)
S#elif (CFG_PANEL_TYPE == PANEL_ST7789_320X240)
S#define PANEL_WIDTH     (QVGA_LANDSCAPE_WIDTH)
S#define PANEL_HEIGHT    (QVGA_LANDSCAPE_HEIGHT)
S#elif (CFG_PANEL_TYPE == PANEL_MZT)
S#define PANEL_WIDTH     (VGA_LANDSCAPE_WIDTH)
S#define PANEL_HEIGHT    (VGA_LANDSCAPE_HEIGHT)
N#endif
N
N#if CFG_PANEL_TYPE == PANEL_NULL
X#if 0 == 0
N#   define DISPLAY_DEVICE           DISPLAY_DEVICE_UNKNOWN
N#elif CFG_PANEL_TYPE == PANEL_MZT_480X272
X#elif 0 == 1
S#   define DISPLAY_DEVICE           DISPLAY_DEVICE_LCDC
S#   if CFG_DISPLAY_DMA_ENABLE == YES
S#       define CFG_LCM_DMA_ENABLE YES
S#   endif
S#elif (CFG_PANEL_TYPE == PANEL_ST7789_240X320) || (CFG_PANEL_TYPE == PANEL_ST7789_320X240) || (CFG_PANEL_TYPE==PANEL_ST7789_240X320_8080_AND_SPI)
S#   define DISPLAY_DEVICE           DISPLAY_DEVICE_LCM
S#   if CFG_DISPLAY_DMA_ENABLE == YES
S#       define CFG_LCM_DMA_ENABLE YES
S#   endif
S#elif (CFG_PANEL_TYPE == PANEL_ST7789_240X320_SPI)
S#   define DISPLAY_DEVICE           DISPLAY_DEVICE_SPI_LCD
S#   if CFG_DISPLAY_DMA_ENABLE == YES
S#       define CFG_LCM_DMA_ENABLE YES
S#   endif
S#else
S#   define DISPLAY_DEVICE           DISPLAY_DEVICE_UNKNOWN
N#endif
N
N#define KDP_BIT_CTRL_MODE                   ( NO )
N//#define KDP_REMOTE_CTRL_BY_TYPE				( NO )
N
N#ifdef CFG_CATEYE_COMMON_MIPI
S#define CATEYE_COMMON_MIPI                  ( YES )
N#else
N#define CATEYE_COMMON_MIPI                  ( NO )
N#endif
N#endif
L 4 "..\..\..\..\scpu\middleware\comm\kl520_com.h" 2
N
N#if CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_LWCOM
X#if 0 == 0
N#if ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_DEF )
X#if ( 1 == 0 )
S#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
Stypedef enum kl520_com_flags_enum {
S    KL520_COM_NORMAL = 0,
S    KL520_COM_HAS_ADDITIONAL_IO = 1,
S
S} kl520_com_flags;
S#endif
S
S#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
S#include "host_uart_com.h"
S#include "drivers.h"
S#include "kdp_uart.h"
S
S
S#if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
S#define	COM_BUS_RESPONSE_OFFESET	(14)		//data size packet
S#else
S#define	COM_BUS_RESPONSE_OFFESET	(0)
S#endif
S
S#define     COM_BUS_HEAD_RX                         ((UINT32)0x78875AA5)
S#define     COM_BUS_HEAD_RX_1                       ((COM_BUS_HEAD_RX&0xFF000000)>>24 )
S#define     COM_BUS_HEAD_RX_2                       ((COM_BUS_HEAD_RX&0x00FF0000)>>16 )
S#define     COM_BUS_HEAD_RX_3                       ((COM_BUS_HEAD_RX&0x0000FF00)>>8 )
S#define     COM_BUS_HEAD_RX_4                       ((COM_BUS_HEAD_RX&0x000000FF)>>0 )
S
S#define     COM_BUS_HEAD_TX                         ((UINT32)(~(COM_BUS_HEAD_RX)) )
S#define     COM_BUS_TAIL                            (0x7887)
S#define     COM_BUS_TAIL_1                          (COM_BUS_TAIL&0xFF)
S#define     COM_BUS_TAIL_2                          ((COM_BUS_TAIL>>8)&0xFF)
S
S#define     COM_BUS_GET_DATA_HEAD_TX                (0xC410C410)
S
S//error code
S#define     COM_BUS_HEAD_CHECK_ERROR                (0xEEE0)
S#define     COM_BUS_TAIL_CHECK_ERROR                (0xEEE1)
S#define     COM_BUS_LENGTH_CHECK_ERROR              (0xEEE2)
S#define     COM_BUS_PACKET_OK                       (0x66)
S
S
S//=================================
S
Stypedef enum {
S    DEV_UART,
S    DEV_SPI,
S    DEV_I2C,
S    DEV_USB,
S    DEV_SDIO,
S    DEV_OTG,
S    TOTAL_DEV,
S    DEV_NULL=0xFF,
S} dev_type;
S
Sstruct st_com_type
S{
S    dev_type com_type; //0~4: uart0~uart4, 0x11: SPI1, 0xFF: nothing
S    UINT8 uart_port;
S    kdp_uart_dev_id dev_id;
S    kl520_com_flags flags;
S    UINT8 *tx_buffer;
S    UINT32 *tx_buffer_index;
S    UINT8 *rx_buffer;
S    UINT32 *rx_buffer_index;
S
S    UINT32 head;
S    UINT16 host_number;
S    UINT16 cmd;
S    UINT16 data_len;
S    UINT16 data_start_index; //data end_index = data_start_index + data_len
S    UINT32 checksum;
S    UINT8 no_head_tail_en; //response bit or not
S};
S
S
Stypedef struct kl520_com_user_ops_struct {
S    u16     (*packet_analyze)(struct st_com_type *st_com);
S    void    (*packet_response_w_tx_buffer)( struct st_com_type *st_com, UINT8 *in_data, UINT16 in_data_legn );
S    void    (*parser)(struct st_com_type *st_com);
S} kl520_com_user_ops;
S
S// struct st_com_format
S// {
S// //20200 1 2 1  on going!!
S
S// };
S
Sextern struct st_com_type stCom_type;
Sextern void kl520_com_thread(void);
S
SUINT16 kneron_lwcom_packet_analyze( struct st_com_type *st_com );
Svoid kneron_lwcom_packet_response_w_tx_buffer( struct st_com_type *st_com, UINT8 *in_data, UINT16 in_data_legn );
Svoid kneron_lwcom_packet_response_brief_w_tx_buffer( struct st_com_type *st_com, UINT16 host_number, UINT16 status );
Svoid kneron_lwcom_set_parameter( struct st_com_type *st_com, UINT16 nhost_number, UINT16 cmd );
S
Sextern void kl520_com_buf_addr_init(void);
Sextern void kl520_com_init(kl520_com_flags flags);
Sextern void kl520_com_bus_init(void);
Sextern UINT8 kl520_com_response_Done_check(void);
Sextern UINT8 kl520_com_response( struct st_com_type *st_com );
S
S//-----
Sextern void kl520_com_initial( kl520_com_flags flags );
Sextern void kl520_com_reconfig_baud_rate(int rate);
Svoid kl520_com_reg_user_ops(kl520_com_user_ops *ops);
S
S#endif
S
N#elif ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP )
X#elif ( 1 == 1 )
N#include "kdp_comm.h"
L 1 "..\..\..\..\scpu\middleware\kdp_comm\kdp_comm.h" 1
N#ifndef __KDP_COMM_H__
N#define __KDP_COMM_H__
N
N//#define BYTE_ALIGN   __attribute__ ((packed))
N//#pragma pack(1)
N#include "board_kl520.h"
N
N#if CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_LWCOM
X#if 0 == 0
N#if ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP )
X#if ( 1 == 1 )
N
N#include "host_uart_com.h"
L 1 "..\..\..\..\scpu\middleware\comm\host_uart_com.h" 1
N#ifndef __UART_COM_H__
N#define __UART_COM_H__
N#include "board_kl520.h"
N#include "host_msg.h"
L 1 "..\..\..\..\scpu\middleware\comm\host_msg.h" 1
N#ifndef __MSG_H__
N#define __MSG_H__
N#include "board_kl520.h"
N
N#include "com.h"
L 1 "..\..\..\..\common\include\com.h" 1
N/**
N * @file      com.h
N * @brief     Basic communcation structure
N * @copyright (c) 2018 Kneron Inc. All right reserved.
N */
N#ifndef __COM_H__
N#define __COM_H__
N
N#include <stdint.h>
N
N#if defined(__arm__)
X#if 1L
N#pragma anon_unions
N#endif
N
N#define CUSTOMER_SETTING_REMOVE_CMD
N
Ntypedef enum {
N    CMD_NONE = 0,
N    CMD_MEM_READ,
N    CMD_MEM_WRITE,
N    CMD_DATA,
N    CMD_ACK_NACK,
N    CMD_STS_CLR,
N    CMD_MEM_CLR,
N    CMD_CRC_ERR,
N    CMD_TEST_ECHO,
N    CMD_FILE_WRITE,
N    CMD_FLASH_MEM_WRITE,  // single sector flash write
N
N    CMD_RESET = 0x20,
N    CMD_SYSTEM_STATUS,
N    CMD_OTA_UPDATE,
N    CMD_UPDATE_MODEL,
N
N    CMD_SNAPSHOT,       //0x24
N    CMD_SNAPSHOT_CHECK, //0x25
N    CMD_RECEIVE_IMAGE, //0x26
N    CMD_SIM_START, //0x27
N    CMD_EXTRA_MAP, //0x28
N    CMD_EXTRA_MAP_CHECK, //0x29
N    CMD_E2E_SET_MODE,
N    CMD_E2E_FACE_ADD,
N    CMD_E2E_FACE_RECOGNITION,
N    CMD_E2E_FACE_RECOGNITION_TEST,
N    CMD_E2E_FACE_LIVENESS,
N    CMD_E2E_FACE_PRE_ADD,
N
N
N    CMD_QUERY_APPS = 0x30,
N    CMD_SELECT_APP,
N    CMD_SET_MODE,
N    CMD_SET_EVENTS,
N    CMD_UPDATE,
N    CMD_IMG_RESULT,  // only RESP message is used.  No CMD version is implemented
N    CMD_ABORT,
N
N	CMD_E2E_FACE_COMAPRE_1VS1,
N	CMD_OPEN_FDR_THREAD,
N	CMD_CLOSE_FDR_THREAD,
N
N    CMD_SFID_START = 0x108,
N    CMD_SFID_NEW_USER,
N    CMD_SFID_ADD_DB,
N    CMD_SFID_DELETE_DB,
N    CMD_SEND_IMAGE,
N    CMD_SFID_LW3D_START,
N    CMD_SEND_LW3D,
N    CMD_SFID_EDIT_DB,
N
N    CMD_DME_START = 0x118,
N    CMD_DME_CONFIG,
N    CMD_DME_SEND_IMAGE,
N
N    // Flash command
N    CMD_FLASH_INFO = 0x1000,
N    CMD_FLASH_CHIP_ERASE,
N    CMD_FLASH_SECTOR_ERASE,
N    CMD_FLASH_READ,
N    CMD_FLASH_WRITE,
N
N    // debug utility command
N    CMD_DBG_USB_MEM_WR = 0x2000,
N    CMD_DBG_SET_MODEL_TYPE = 0x2001,
N
N    // for Camera tool
N    CMD_DOWNLOAD_IMAGE_NIR = 0x2100,
N    CMD_DOWNLOAD_IMAGE_RGB,
N    CMD_SET_NIR_AGC,
N    CMD_SET_NIR_AEC,
N    CMD_SET_RGB_AGC,
N    CMD_SET_RGB_AEC,
N    CMD_SET_NIR_LED,
N    CMD_SET_RGB_LED,
N    CMD_CAM_CONNECT,
N    CMD_NIR_FD_RES,
N    CMD_NIR_LM_RES,
N    CMD_RGB_FD_RES,
N    CMD_RGB_LM_RES,
N    CMD_NIR_GET_CONF,
N    CMD_RGB_GET_CONF,
N
N
N    //Jeff add
N    CMD_SCPU_UPDATE = 0x3000,
N    CMD_NCPU_UPDATE,
N    CMD_MODEL_UPDATE,
N
N    CMD_GUI_CTRL_SERIES = 0x4000,
N    CMD_GUI_REGISTER,
N    CMD_GUI_RECOGNIZE,
N    CMD_GUI_DELETE_ALL,
N
N    CMD_CLOUD_UPDATE_DB = 0x5000,
N    CMD_FDFR_THREAD_CLOSE = 0x6000,
N    CMD_EXPORT_STREAM_IMG = 0x6100,
N    CMD_CAPTRUE_SENSOR = 0x6101,
N
N} Cmd;
N
Ntypedef struct {
N    uint16_t preamble;
N    uint16_t ctrl; /* payload_len & ctrl info */
N    uint16_t cmd;
N    uint16_t msg_len;
N} __attribute__((packed)) MsgHdr;
N
Ntypedef struct {
N    uint32_t param1;
N    uint32_t param2;
N    uint8_t data[];
N} __attribute__((packed)) CmdPram;
N
Ntypedef struct {
N    union {
N        uint32_t error;
N        uint32_t param1;
N    } __attribute__((packed));
N    uint32_t param2;
N    uint8_t data[];
N} __attribute__((packed)) RspPram;
N
Ntypedef struct {
N    uint32_t op_parm1;
N    uint32_t op_parm2;
N    uint8_t  data[];
N} __attribute__((packed)) OpPram;
N
N
N#define NO_ERROR        0
N#define PARAM_ERR       1
N#define RSP_NOT_IMPLEMENTED 0xFFFE
N#define RSP_UKNOWN_CMD  0xFFFF
N#define BAD_CONFIRMATION 2  // CMD_RESET RESPONSE
N#define BAD_MODE         1
N#define FILE_ERROR       1  // File data transfer error
N
N#define MSG_HDR_CMD     0xA583
N#define MSG_HDR_RSP     0x8A35
N#define MSG_HDR_VAL     0xA553  // this is used by the pre-packet code
N#define MSG_HDR_SIZE    16  // includes both MsgHdr and CmdPram addr & len
N#define PKT_CRC_FLAG    0x4000
N
N#if (HAPS_ID == 2)
S#define MSG_DATA_BUF_MAX    0x890
N#else
N#define MSG_DATA_BUF_MAX    0x2400  // used for testing (worst case msg payload is 4096+72)
N#endif
N
N#define UPDATE_MODULE_NONE 0
N#define UPDATE_MODULE_SCPU 0x07
N#define UPDATE_MODULE_NCPU 0x08
N
N#endif
L 6 "..\..\..\..\scpu\middleware\comm\host_msg.h" 2
N#define FLAG_COMM_START      BIT(0)
N#define FLAG_COMM_ISR        BIT(1)
N#define FLAG_COMM_TIMER      BIT(2)
N#define FLAG_COMM_APP_DONE   BIT(3) // for tid_appmgr
N#define FLAG_COMM_USB_DONE   BIT(4)
N#define FLAG_COMM_UART_DONE  BIT(5)
N
N#define USB_HOST                (YES)
N
N#if USB_HOST == 1
X#if (1) == 1
N#define FLAG_COMM_RX_DONE    FLAG_COMM_USB_DONE
N#else
S#define FLAG_COMM_RX_DONE    FLAG_COMM_UART_DONE
N#endif
N
Nenum WR_MODE {
N    WMODE_DEF = 0, // regular response message, send immediately
N    WMODE_ACK,     // ack packet, send immediately
N    WMODE_ALT      // FR data, send only after response message is done
N};
N
N/* Modified MSG_DATA_BUF_MAX from 0x100 to 0x1400 to improve the speed of testcase verification */
N//extern u8 msg_rbuf[MSG_DATA_BUF_MAX + sizeof(MsgHdr)+ sizeof(RspPram) + 4 + 4];
N//extern u8 msg_tbuf[MSG_DATA_BUF_MAX + sizeof(MsgHdr)+ sizeof(RspPram) + 4 + 4];
Nextern u8* msg_rbuf;
Nextern u8* msg_tbuf;
N
Nvoid kcomm_msg_init(osThreadId_t tid_comm);
Nextern int32_t kcomm_read(u32 address, u32 size);
Nint kcomm_write_msg(u8 *buf, int len, int crc_flag);
Nint kcomm_write(u8 *buf, int len, int mode);
Nvoid kcomm_wait(void);
Nvoid kcomm_send_no_rsp(void);
Nvoid kcomm_send_rsp(u16 cmd, u8 *buf, int len);
N
Nu16 gen_crc16(u8 *data, u32 size);
N
N#endif
L 5 "..\..\..\..\scpu\middleware\comm\host_uart_com.h" 2
N#include <stdarg.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
N     /* be cooperative with glibc */
N     typedef __CLIBNS va_list __gnuc_va_list;
X     typedef  va_list __gnuc_va_list;
N     #define __GNUC_VA_LIST
N     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 6 "..\..\..\..\scpu\middleware\comm\host_uart_com.h" 2
N
Nextern void kdp_uart_app_com(u8 port, u32 baudrate, u8* buffer, u32 size);
N
N#ifdef USB_HOST
N#else
Sextern void kdp_uart_com_init(void);
Sextern void kdp_uart_com_write(uint8_t *p, int32_t len);
Sextern int kdp_uart_com_read(uint8_t *BufferPtr, uint32_t BufferLen);
N#endif
N#endif
L 12 "..\..\..\..\scpu\middleware\kdp_comm\kdp_comm.h" 2
N#include "drivers.h"
L 1 "..\..\..\..\scpu\drivers\include\drivers.h" 1
N#ifndef __DRIVERS_H__
N#define __DRIVERS_H__
N
N//#define USE_KDRV
N#ifdef USE_KDRV
S#include "kdrv_adc.h"
S#include "kdrv_mpu.h"
S#include "kdrv_ddr.h"
S#include "kdrv_clock.h"
S#include "kdrv_power.h"
S#include "kdrv_system.h"
S#include "kdrv_uart.h"
S#define kdp520_adc_init                 kdrv_adc_initialize
S#define kdp520_adc_read                 kdrv_adc_read
S#define mpu_config                      kdrv_mpu_config
S#define mpu_niram_enable                kdrv_mpu_niram_enable
S#define mpu_niram_disalbe               kdrv_mpu_niram_disable
S#define ddr_init                        kdrv_ddr_system_init
S#define ddr_self_refresh_enter          kdrv_ddr_self_refresh_enter
S#define ddr_self_refresh_exit           kdrv_ddr_self_refresh_exit
S#define ddr_wakeup                      kdrv_ddr_wakeup
S#define clock_mgr_set_scuclkin          kdrv_clock_set_scuclkin
S#define clock_mgr_init                  kdrv_clock_initialize
S#define clk_enable                      kdrv_clock_enable
S#define clk_disable                     kdrv_clock_disable
S#define clock_mgr_change_pll3_clock     kdrv_clock_change_pll3_clock
S#define clock_mgr_change_pll5_clock     kdrv_clock_change_pll5_clock
S#define POWER_MGR_OPS_FCS               POWER_OPS_FCS
S#define POWER_MGR_OPS_CHANGE_BUS_SPEED  POWER_OPS_CHANGE_BUS_SPEED
S#define POWER_MGR_OPS_PLL_UPDATE        POWER_OPS_PLL_UPDATE
S#define POWER_MGR_OPS_SLEEPING          POWER_OPS_SLEEPING
S#define POWER_MGR_MODE_RTC              POWER_MODE_RTC
S#define POWER_MGR_MODE_ALWAYSON         POWER_MODE_ALWAYSON
S#define POWER_MGR_MODE_FULL             POWER_MODE_FULL
S#define POWER_MGR_MODE_RETENTION        POWER_MODE_RETENTION
S#define POWER_MGR_MODE_DEEP_RETENTION   POWER_MODE_DEEP_RETENTION
S#define power_mgr_softoff               kdrv_power_softoff
S#define power_mgr_sw_reset              kdrv_power_sw_reset
S#define power_mgr_set_domain            kdrv_power_set_domain
S#define power_mgr_ops                   kdrv_power_ops
S#define system_init                     kdrv_system_init
S#define system_init_ncpu                kdrv_system_init_ncpu
S#define kdp_uart_dev_id                 kdrv_uart_dev_id_t
S#define kdp_gets(__port, __buf)         kdrv_uart_get_string((kdrv_uart_handle_t)__port, __buf)
S#define kdp_uart_GetRxCount             kdrv_uart_get_rx_count
S#define kdp_uart_read                   kdrv_uart_read
S#define kdp_uart_write                  kdrv_uart_write
N#else
N#include "kdp520_adc.h" // will be removed in next version
L 1 "..\..\..\..\scpu\drivers\include\kdp520_adc.h" 1
N#ifndef __KDP520_ADC_H
N#define __KDP520_ADC_H
N
N#include "types.h"
N
N/* ADC Resource Configuration */
Ntypedef struct {
N  int				io_base;		// I2C register interface
N  int				irq;				// I2C Event IRQ Number
N} kdp_adc_resource;
N
Nstruct kdp_adc_regs {
N	/* DATA: offset 0x000~0x01C */
N	UINT32		data[8];
N	/* reserve */
N	UINT32		reserve[24];
N	/* THRHOLD: offset 0x080~0x09C */
N	UINT32		thrhold[8];
N#define HTHR_EN         (1<<31)
N#define HTHR(x)         (((x)&0xFFF)<<16)
N#define LTHR_EN         (1<<15)
N#define LTHR(x)         (((x)&0xFFF)<<0)
N	/* reserve */
N	UINT32		reserve1[24];
N	/* CTRL: offset 0x100 */
N	UINT32		ctrl;
N#define SCAN_NUM(x)			(x<<16)
N#define SCANMODE_CONT   (1<<9)
N#define SCANMODE_SGL    (1<<8)
N#define SWSTART					(1<<4)
N#define ADC_EN          (1<<0)
N	/* TRIM: offset 0x104 */
N	UINT32		trim;
N	/* INTEN: offset 0x108 */
N	UINT32		inten;
N#define CHDONE_INTEN(x) (1<<((x)+8))
N#define TS_OVR_INTREN 	(1<<3)
N#define TS_UDR_INTREN   (1<<2)
N#define STOP_INTEN      (1<<1)
N#define DONE_INTEN      (1<<0)
N	/* INTST: offset 0x10C */
N	UINT32		intst;
N#define CH_INTRSTS(x)			(1<<((x)+8))
N#define TS_THDOD_INTRSTS	(1<<3)
N#define TS_THDUD_INTRSTS	(1<<2)
N#define ADC_STOP_INTRSTS	(1<<1)
N#define ADC_DONE_INTSTS		(1<<0)
N	/* TPARAM: offset 0x110 */
N	UINT32		tparam;
N	/* TPARAM1: offset 0x114 */
N	UINT32		smpr;
N	/* reserve */
N	UINT32		reserve2;
N	/* PRESCAL: offset 0x11C */
N	UINT32		prescal;
N	/* SQR: 		offset 0x120 */
N	UINT32 		sqr;
N	
N};
N
Nvoid kdp520_adc_init(void);
NINT32 kdp520_adc_uninit(kdp_adc_resource *res);
Nvoid kdp520_adc_reset(kdp_adc_resource *res);
Nvoid kdp520_adc_enable(kdp_adc_resource *res, int mode);
Nint kdp520_adc_read(int id);
N
N#endif //__KDP520_ADC_H
L 50 "..\..\..\..\scpu\drivers\include\drivers.h" 2
N#define kdev_flash_erase_sector kdp_flash_erase_sector
N#define kdev_flash_get_status kdp_flash_get_status
N#define kdev_flash_programdata kdp_flash_program_data
N#define kdev_flash_readdata kdp_flash_read_data
N#define kdev_flash_status_t ARM_FLASH_STATUS
N#define kdev_status_t kdp_status_t
N#define kdrv_power_sw_reset power_mgr_sw_reset
N#endif
N
Nint kdp_drv_init(void);
N
N
N#endif
L 13 "..\..\..\..\scpu\middleware\kdp_comm\kdp_comm.h" 2
N#include "kdp_uart.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp_uart.h" 1
N#ifndef __KDP_UART_H__
N#define __KDP_UART_H__
N
N
N#include "types.h"
N#include "base.h"
N#include "cmsis_os2.h"
N#include "Driver_USART.h" //cmsis driver
L 1 "..\..\..\..\scpu\device\include\CMSIS\Driver_USART.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        9. Apr 2014
N * $Revision:    V2.01
N *
N * Project:      USART (Universal Synchronous Asynchronous Receiver Transmitter)
N *               Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.01
N *    Removed optional argument parameter from Signal Event
N *  Version 2.00
N *    New simplified driver:
N *      complexity moved to upper layer (especially data handling)
N *      more unified API for different communication interfaces
N *      renamed driver UART -> USART (Asynchronous & Synchronous)
N *    Added modes:
N *      Synchronous
N *      Single-wire
N *      IrDA
N *      Smart Card  
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.01
N *    Added events:
N *      ARM_UART_EVENT_TX_EMPTY,     ARM_UART_EVENT_RX_TIMEOUT
N *      ARM_UART_EVENT_TX_THRESHOLD, ARM_UART_EVENT_RX_THRESHOLD
N *    Added functions: SetTxThreshold, SetRxThreshold
N *    Added "rx_timeout_event" to capabilities
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_USART_H
N#define __DRIVER_USART_H
N
N#include "Driver_Common.h"
L 1 "..\..\..\..\scpu\device\include\CMSIS\Driver_Common.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        2. Jan 2014
N * $Revision:    V2.00
N *
N * Project:      Common Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.00
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Added General return codes definitions
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_COMMON_H
N#define __DRIVER_COMMON_H
N
N#include <stddef.h>
N#include <stdint.h>
N#include <stdbool.h>
N
N#define ARM_DRIVER_VERSION_MAJOR_MINOR(major,minor) (((major) << 8) | (minor))
N
N/**
N\brief Driver Version
N*/
Ntypedef struct _ARM_DRIVER_VERSION {
N  uint16_t api;                         ///< API version
N  uint16_t drv;                         ///< Driver version
N} ARM_DRIVER_VERSION;
N
N/* General return codes */
N#define ARM_DRIVER_OK                 0 ///< Operation succeeded 
N#define ARM_DRIVER_ERROR             -1 ///< Unspecified error
N#define ARM_DRIVER_ERROR_BUSY        -2 ///< Driver is busy
N#define ARM_DRIVER_ERROR_TIMEOUT     -3 ///< Timeout occurred
N#define ARM_DRIVER_ERROR_UNSUPPORTED -4 ///< Operation not supported
N#define ARM_DRIVER_ERROR_PARAMETER   -5 ///< Parameter error
N#define ARM_DRIVER_ERROR_SPECIFIC    -6 ///< Start of driver specific errors 
N
N/**
N\brief General power states
N*/ 
Ntypedef enum _ARM_POWER_STATE {
N  ARM_POWER_OFF,                        ///< Power off: no operation possible
N  ARM_POWER_LOW,                        ///< Low Power mode: retain state, detect and signal wake-up events
N  ARM_POWER_FULL                        ///< Power on: full operation at maximum performance
N} ARM_POWER_STATE;
N
N#endif /* __DRIVER_COMMON_H */
L 58 "..\..\..\..\scpu\device\include\CMSIS\Driver_USART.h" 2
N
N#define ARM_USART_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,01)  /* API version */
N
N
N/****** USART Control Codes *****/
N
N#define ARM_USART_CONTROL_Pos                0
N#define ARM_USART_CONTROL_Msk               (0xFFUL << ARM_USART_CONTROL_Pos)
N
N/*----- USART Control Codes: Mode -----*/
N#define ARM_USART_MODE_ASYNCHRONOUS         (0x01UL << ARM_USART_CONTROL_Pos)   ///< UART (Asynchronous); arg = Baudrate
N#define ARM_USART_MODE_SYNCHRONOUS_MASTER   (0x02UL << ARM_USART_CONTROL_Pos)   ///< Synchronous Master (generates clock signal); arg = Baudrate
N#define ARM_USART_MODE_SYNCHRONOUS_SLAVE    (0x03UL << ARM_USART_CONTROL_Pos)   ///< Synchronous Slave (external clock signal)
N#define ARM_USART_MODE_SINGLE_WIRE          (0x04UL << ARM_USART_CONTROL_Pos)   ///< UART Single-wire (half-duplex); arg = Baudrate
N#define ARM_USART_MODE_IRDA                 (0x05UL << ARM_USART_CONTROL_Pos)   ///< UART IrDA; arg = Baudrate
N#define ARM_USART_MODE_SMART_CARD           (0x06UL << ARM_USART_CONTROL_Pos)   ///< UART Smart Card; arg = Baudrate
N
N/*----- USART Control Codes: Mode Parameters: Data Bits -----*/
N#define ARM_USART_DATA_BITS_Pos              8
N#define ARM_USART_DATA_BITS_Msk             (7UL << ARM_USART_DATA_BITS_Pos)
N#define ARM_USART_DATA_BITS_5               (5UL << ARM_USART_DATA_BITS_Pos)    ///< 5 Data bits
N#define ARM_USART_DATA_BITS_6               (6UL << ARM_USART_DATA_BITS_Pos)    ///< 6 Data bit
N#define ARM_USART_DATA_BITS_7               (7UL << ARM_USART_DATA_BITS_Pos)    ///< 7 Data bits
N#define ARM_USART_DATA_BITS_8               (0UL << ARM_USART_DATA_BITS_Pos)    ///< 8 Data bits (default)
N#define ARM_USART_DATA_BITS_9               (1UL << ARM_USART_DATA_BITS_Pos)    ///< 9 Data bits
N
N/*----- USART Control Codes: Mode Parameters: Parity -----*/
N#define ARM_USART_PARITY_Pos                 12
N#define ARM_USART_PARITY_Msk                (3UL << ARM_USART_PARITY_Pos)
N#define ARM_USART_PARITY_NONE               (0UL << ARM_USART_PARITY_Pos)       ///< No Parity (default)
N#define ARM_USART_PARITY_EVEN               (1UL << ARM_USART_PARITY_Pos)       ///< Even Parity
N#define ARM_USART_PARITY_ODD                (2UL << ARM_USART_PARITY_Pos)       ///< Odd Parity
N
N/*----- USART Control Codes: Mode Parameters: Stop Bits -----*/
N#define ARM_USART_STOP_BITS_Pos              14
N#define ARM_USART_STOP_BITS_Msk             (3UL << ARM_USART_STOP_BITS_Pos)
N#define ARM_USART_STOP_BITS_1               (0UL << ARM_USART_STOP_BITS_Pos)    ///< 1 Stop bit (default)
N#define ARM_USART_STOP_BITS_2               (1UL << ARM_USART_STOP_BITS_Pos)    ///< 2 Stop bits
N#define ARM_USART_STOP_BITS_1_5             (2UL << ARM_USART_STOP_BITS_Pos)    ///< 1.5 Stop bits
N#define ARM_USART_STOP_BITS_0_5             (3UL << ARM_USART_STOP_BITS_Pos)    ///< 0.5 Stop bits
N
N/*----- USART Control Codes: Mode Parameters: Flow Control -----*/
N#define ARM_USART_FLOW_CONTROL_Pos           16
N#define ARM_USART_FLOW_CONTROL_Msk          (3UL << ARM_USART_FLOW_CONTROL_Pos)
N#define ARM_USART_FLOW_CONTROL_NONE         (0UL << ARM_USART_FLOW_CONTROL_Pos) ///< No Flow Control (default)
N#define ARM_USART_FLOW_CONTROL_RTS          (1UL << ARM_USART_FLOW_CONTROL_Pos) ///< RTS Flow Control
N#define ARM_USART_FLOW_CONTROL_CTS          (2UL << ARM_USART_FLOW_CONTROL_Pos) ///< CTS Flow Control
N#define ARM_USART_FLOW_CONTROL_RTS_CTS      (3UL << ARM_USART_FLOW_CONTROL_Pos) ///< RTS/CTS Flow Control
N
N/*----- USART Control Codes: Mode Parameters: Clock Polarity (Synchronous mode) -----*/
N#define ARM_USART_CPOL_Pos                   17
N#define ARM_USART_CPOL_Msk                  (1UL << ARM_USART_CPOL_Pos)
N#define ARM_USART_CPOL0                     (0UL << ARM_USART_CPOL_Pos)         ///< CPOL = 0 (default)
N#define ARM_USART_CPOL1                     (1UL << ARM_USART_CPOL_Pos)         ///< CPOL = 1
N
N/*----- USART Control Codes: Mode Parameters: Clock Phase (Synchronous mode) -----*/
N#define ARM_USART_CPHA_Pos                   18
N#define ARM_USART_CPHA_Msk                  (1UL << ARM_USART_CPHA_Pos)
N#define ARM_USART_CPHA0                     (0UL << ARM_USART_CPHA_Pos)         ///< CPHA = 0 (default)
N#define ARM_USART_CPHA1                     (1UL << ARM_USART_CPHA_Pos)         ///< CPHA = 1
N
N
N/*----- USART Control Codes: Miscellaneous Controls  -----*/
N#define ARM_USART_SET_DEFAULT_TX_VALUE      (0x10UL << ARM_USART_CONTROL_Pos)   ///< Set default Transmit value (Synchronous Receive only); arg = value
N#define ARM_USART_SET_IRDA_PULSE            (0x11UL << ARM_USART_CONTROL_Pos)   ///< Set IrDA Pulse in ns; arg: 0=3/16 of bit period  
N#define ARM_USART_SET_SMART_CARD_GUARD_TIME (0x12UL << ARM_USART_CONTROL_Pos)   ///< Set Smart Card Guard Time; arg = number of bit periods
N#define ARM_USART_SET_SMART_CARD_CLOCK      (0x13UL << ARM_USART_CONTROL_Pos)   ///< Set Smart Card Clock in Hz; arg: 0=Clock not generated
N#define ARM_USART_CONTROL_SMART_CARD_NACK   (0x14UL << ARM_USART_CONTROL_Pos)   ///< Smart Card NACK generation; arg: 0=disabled, 1=enabled
N#define ARM_USART_CONTROL_TX                (0x15UL << ARM_USART_CONTROL_Pos)   ///< Transmitter; arg: 0=disabled, 1=enabled
N#define ARM_USART_CONTROL_RX                (0x16UL << ARM_USART_CONTROL_Pos)   ///< Receiver; arg: 0=disabled, 1=enabled
N#define ARM_USART_CONTROL_BREAK             (0x17UL << ARM_USART_CONTROL_Pos)   ///< Continuous Break transmission; arg: 0=disabled, 1=enabled
N#define ARM_USART_ABORT_SEND                (0x18UL << ARM_USART_CONTROL_Pos)   ///< Abort \ref ARM_USART_Send
N#define ARM_USART_ABORT_RECEIVE             (0x19UL << ARM_USART_CONTROL_Pos)   ///< Abort \ref ARM_USART_Receive
N#define ARM_USART_ABORT_TRANSFER            (0x1AUL << ARM_USART_CONTROL_Pos)   ///< Abort \ref ARM_USART_Transfer
N
N
N
N/****** USART specific error codes *****/
N#define ARM_USART_ERROR_MODE                (ARM_DRIVER_ERROR_SPECIFIC - 1)     ///< Specified Mode not supported
N#define ARM_USART_ERROR_BAUDRATE            (ARM_DRIVER_ERROR_SPECIFIC - 2)     ///< Specified baudrate not supported
N#define ARM_USART_ERROR_DATA_BITS           (ARM_DRIVER_ERROR_SPECIFIC - 3)     ///< Specified number of Data bits not supported
N#define ARM_USART_ERROR_PARITY              (ARM_DRIVER_ERROR_SPECIFIC - 4)     ///< Specified Parity not supported
N#define ARM_USART_ERROR_STOP_BITS           (ARM_DRIVER_ERROR_SPECIFIC - 5)     ///< Specified number of Stop bits not supported
N#define ARM_USART_ERROR_FLOW_CONTROL        (ARM_DRIVER_ERROR_SPECIFIC - 6)     ///< Specified Flow Control not supported
N#define ARM_USART_ERROR_CPOL                (ARM_DRIVER_ERROR_SPECIFIC - 7)     ///< Specified Clock Polarity not supported
N#define ARM_USART_ERROR_CPHA                (ARM_DRIVER_ERROR_SPECIFIC - 8)     ///< Specified Clock Phase not supported
N
N
N/**
N\brief USART Status
N*/
Ntypedef struct _ARM_USART_STATUS {
N  uint32_t tx_busy          : 1;        ///< Transmitter busy flag
N  uint32_t rx_busy          : 1;        ///< Receiver busy flag
N  uint32_t tx_underflow     : 1;        ///< Transmit data underflow detected (cleared on start of next send operation)
N  uint32_t rx_overflow      : 1;        ///< Receive data overflow detected (cleared on start of next receive operation)
N  uint32_t rx_break         : 1;        ///< Break detected on receive (cleared on start of next receive operation)
N  uint32_t rx_framing_error : 1;        ///< Framing error detected on receive (cleared on start of next receive operation)
N  uint32_t rx_parity_error  : 1;        ///< Parity error detected on receive (cleared on start of next receive operation)
N} ARM_USART_STATUS;
N
N/**
N\brief USART Modem Control
N*/
Ntypedef enum _ARM_USART_MODEM_CONTROL {
N  ARM_USART_RTS_CLEAR,                  ///< Deactivate RTS
N  ARM_USART_RTS_SET,                    ///< Activate RTS
N  ARM_USART_DTR_CLEAR,                  ///< Deactivate DTR
N  ARM_USART_DTR_SET                     ///< Activate DTR
N} ARM_USART_MODEM_CONTROL;
N
N/**
N\brief USART Modem Status
N*/
Ntypedef struct _ARM_USART_MODEM_STATUS {
N  uint32_t cts : 1;                     ///< CTS state: 1=Active, 0=Inactive
N  uint32_t dsr : 1;                     ///< DSR state: 1=Active, 0=Inactive
N  uint32_t dcd : 1;                     ///< DCD state: 1=Active, 0=Inactive
N  uint32_t ri  : 1;                     ///< RI  state: 1=Active, 0=Inactive
N} ARM_USART_MODEM_STATUS;
N
N
N/****** USART Event *****/
N#define ARM_USART_EVENT_SEND_COMPLETE       (1UL << 0)  ///< Send completed; however USART may still transmit data
N#define ARM_USART_EVENT_RECEIVE_COMPLETE    (1UL << 1)  ///< Receive completed
N#define ARM_USART_EVENT_TRANSFER_COMPLETE   (1UL << 2)  ///< Transfer completed
N#define ARM_USART_EVENT_TX_COMPLETE         (1UL << 3)  ///< Transmit completed (optional)
N#define ARM_USART_EVENT_TX_UNDERFLOW        (1UL << 4)  ///< Transmit data not available (Synchronous Slave)
N#define ARM_USART_EVENT_RX_OVERFLOW         (1UL << 5)  ///< Receive data overflow
N#define ARM_USART_EVENT_RX_TIMEOUT          (1UL << 6)  ///< Receive character timeout (optional)
N#define ARM_USART_EVENT_RX_BREAK            (1UL << 7)  ///< Break detected on receive
N#define ARM_USART_EVENT_RX_FRAMING_ERROR    (1UL << 8)  ///< Framing error detected on receive
N#define ARM_USART_EVENT_RX_PARITY_ERROR     (1UL << 9)  ///< Parity error detected on receive
N#define ARM_USART_EVENT_CTS                 (1UL << 10) ///< CTS state changed (optional)
N#define ARM_USART_EVENT_DSR                 (1UL << 11) ///< DSR state changed (optional)
N#define ARM_USART_EVENT_DCD                 (1UL << 12) ///< DCD state changed (optional)
N#define ARM_USART_EVENT_RI                  (1UL << 13) ///< RI  state changed (optional)
N
N
N// Function documentation
N/**
N  \fn          ARM_DRIVER_VERSION ARM_USART_GetVersion (void)
N  \brief       Get driver version.
N  \return      \ref ARM_DRIVER_VERSION
N
N  \fn          ARM_USART_CAPABILITIES ARM_USART_GetCapabilities (void)
N  \brief       Get driver capabilities
N  \return      \ref ARM_USART_CAPABILITIES
N
N  \fn          int32_t ARM_USART_Initialize (ARM_USART_SignalEvent_t cb_event)
N  \brief       Initialize USART Interface.
N  \param[in]   cb_event  Pointer to \ref ARM_USART_SignalEvent
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Uninitialize (void)
N  \brief       De-initialize USART Interface.
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_PowerControl (ARM_POWER_STATE state)
N  \brief       Control USART Interface Power.
N  \param[in]   state  Power state
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Send (const void *data, uint32_t num)
N  \brief       Start sending data to USART transmitter.
N  \param[in]   data  Pointer to buffer with data to send to USART transmitter
N  \param[in]   num   Number of data items to send
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Receive (void *data, uint32_t num)
N  \brief       Start receiving data from USART receiver.
N  \param[out]  data  Pointer to buffer for data to receive from USART receiver
N  \param[in]   num   Number of data items to receive
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Transfer (const void *data_out,
N                                                 void *data_in,
N                                           uint32_t    num)
N  \brief       Start sending/receiving data to/from USART transmitter/receiver.
N  \param[in]   data_out  Pointer to buffer with data to send to USART transmitter
N  \param[out]  data_in   Pointer to buffer for data to receive from USART receiver
N  \param[in]   num       Number of data items to transfer
N  \return      \ref execution_status
N
N  \fn          uint32_t ARM_USART_GetTxCount (void)
N  \brief       Get transmitted data count.
N  \return      number of data items transmitted
N
N  \fn          uint32_t ARM_USART_GetRxCount (void)
N  \brief       Get received data count.
N  \return      number of data items received
N
N  \fn          int32_t ARM_USART_Control (uint32_t control, uint32_t arg)
N  \brief       Control USART Interface.
N  \param[in]   control  Operation
N  \param[in]   arg      Argument of operation (optional)
N  \return      common \ref execution_status and driver specific \ref usart_execution_status
N
N  \fn          ARM_USART_STATUS ARM_USART_GetStatus (void)
N  \brief       Get USART status.
N  \return      USART status \ref ARM_USART_STATUS
N
N  \fn          int32_t ARM_USART_SetModemControl (ARM_USART_MODEM_CONTROL control)
N  \brief       Set USART Modem Control line state.
N  \param[in]   control  \ref ARM_USART_MODEM_CONTROL
N  \return      \ref execution_status 
N
N  \fn          ARM_USART_MODEM_STATUS ARM_USART_GetModemStatus (void)
N  \brief       Get USART Modem Status lines state.
N  \return      modem status \ref ARM_USART_MODEM_STATUS
N
N  \fn          void ARM_USART_SignalEvent (uint32_t event)
N  \brief       Signal USART Events.
N  \param[in]   event  \ref USART_events notification mask
N  \return      none
N*/
N
Ntypedef void (*ARM_USART_SignalEvent_t) (uint32_t event);  ///< Pointer to \ref ARM_USART_SignalEvent : Signal USART Event.
N
N
N/**
N\brief USART Device Driver Capabilities.
N*/
Ntypedef struct _ARM_USART_CAPABILITIES {
N  uint32_t asynchronous       : 1;      ///< supports UART (Asynchronous) mode 
N  uint32_t synchronous_master : 1;      ///< supports Synchronous Master mode
N  uint32_t synchronous_slave  : 1;      ///< supports Synchronous Slave mode
N  uint32_t single_wire        : 1;      ///< supports UART Single-wire mode
N  uint32_t irda               : 1;      ///< supports UART IrDA mode
N  uint32_t smart_card         : 1;      ///< supports UART Smart Card mode
N  uint32_t smart_card_clock   : 1;      ///< Smart Card Clock generator available
N  uint32_t flow_control_rts   : 1;      ///< RTS Flow Control available
N  uint32_t flow_control_cts   : 1;      ///< CTS Flow Control available
N  uint32_t event_tx_complete  : 1;      ///< Transmit completed event: \ref ARM_USART_EVENT_TX_COMPLETE
N  uint32_t event_rx_timeout   : 1;      ///< Signal receive character timeout event: \ref ARM_USART_EVENT_RX_TIMEOUT
N  uint32_t rts                : 1;      ///< RTS Line: 0=not available, 1=available
N  uint32_t cts                : 1;      ///< CTS Line: 0=not available, 1=available
N  uint32_t dtr                : 1;      ///< DTR Line: 0=not available, 1=available
N  uint32_t dsr                : 1;      ///< DSR Line: 0=not available, 1=available
N  uint32_t dcd                : 1;      ///< DCD Line: 0=not available, 1=available
N  uint32_t ri                 : 1;      ///< RI Line: 0=not available, 1=available
N  uint32_t event_cts          : 1;      ///< Signal CTS change event: \ref ARM_USART_EVENT_CTS
N  uint32_t event_dsr          : 1;      ///< Signal DSR change event: \ref ARM_USART_EVENT_DSR
N  uint32_t event_dcd          : 1;      ///< Signal DCD change event: \ref ARM_USART_EVENT_DCD
N  uint32_t event_ri           : 1;      ///< Signal RI change event: \ref ARM_USART_EVENT_RI
N} ARM_USART_CAPABILITIES;
N
N
N/**
N\brief Access structure of the USART Driver.
N*/
Ntypedef struct _ARM_DRIVER_USART {
N  ARM_DRIVER_VERSION     (*GetVersion)      (void);                              ///< Pointer to \ref ARM_USART_GetVersion : Get driver version.
N  ARM_USART_CAPABILITIES (*GetCapabilities) (void);                              ///< Pointer to \ref ARM_USART_GetCapabilities : Get driver capabilities.
N  int32_t                (*Initialize)      (ARM_USART_SignalEvent_t cb_event);  ///< Pointer to \ref ARM_USART_Initialize : Initialize USART Interface.
N  int32_t                (*Uninitialize)    (void);                              ///< Pointer to \ref ARM_USART_Uninitialize : De-initialize USART Interface.
N  int32_t                (*PowerControl)    (ARM_POWER_STATE state);             ///< Pointer to \ref ARM_USART_PowerControl : Control USART Interface Power.
N  int32_t                (*Send)            (const void *data, uint32_t num);    ///< Pointer to \ref ARM_USART_Send : Start sending data to USART transmitter.
N  int32_t                (*Receive)         (      void *data, uint32_t num);    ///< Pointer to \ref ARM_USART_Receive : Start receiving data from USART receiver.
N  int32_t                (*Transfer)        (const void *data_out,
N                                                   void *data_in,
N                                             uint32_t    num);                   ///< Pointer to \ref ARM_USART_Transfer : Start sending/receiving data to/from USART.
N  uint32_t               (*GetTxCount)      (void);                              ///< Pointer to \ref ARM_USART_GetTxCount : Get transmitted data count.
N  uint32_t               (*GetRxCount)      (void);                              ///< Pointer to \ref ARM_USART_GetRxCount : Get received data count.
N  int32_t                (*Control)         (uint32_t control, uint32_t arg);    ///< Pointer to \ref ARM_USART_Control : Control USART Interface.
N  ARM_USART_STATUS       (*GetStatus)       (void);                              ///< Pointer to \ref ARM_USART_GetStatus : Get USART status.
N  int32_t                (*SetModemControl) (ARM_USART_MODEM_CONTROL control);   ///< Pointer to \ref ARM_USART_SetModemControl : Set USART Modem Control line state.
N  ARM_USART_MODEM_STATUS (*GetModemStatus)  (void);                              ///< Pointer to \ref ARM_USART_GetModemStatus : Get USART Modem Status lines state.
N} const ARM_DRIVER_USART;
N
N#endif /* __DRIVER_USART_H */
L 9 "..\..\..\..\scpu\drivers\include\kdp_uart.h" 2
N
N
N#define UART_CLOCK                     (30000000UL) //kneron
N#define BAUD_1500000                   (UART_CLOCK / 24000000)  //Verification
N#define BAUD_921600                    (UART_CLOCK / 14745600)
N#define BAUD_460800                    (UART_CLOCK / 7372800)
N#define BAUD_230400                    (UART_CLOCK / 3686400)
N#define BAUD_115200                    (UART_CLOCK / 1843200)
N#define BAUD_57600                     (UART_CLOCK / 921600)
N#define BAUD_38400                     (UART_CLOCK / 614400)
N#define BAUD_19200                     (UART_CLOCK / 307200)
N#define BAUD_14400                     (UART_CLOCK / 230400)
N#define BAUD_9600                      (UART_CLOCK / 153600)
N#define BAUD_4800                      (UART_CLOCK / 76800)
N#define BAUD_2400                      (UART_CLOCK / 38400)
N#define BAUD_1200                      (UART_CLOCK / 19200)
N
Ntypedef enum {
N    DRVUART_PORT0=0,
N    DRVUART_PORT1=1,
N    DRVUART_PORT2=2,
N    DRVUART_PORT3=3,
N    DRVUART_PORT4=4,
N} DRVUART_PORT;
N
N#define SERIAL_THR                     0x00             /*  Transmitter Holding Register(Write).*/
N#define SERIAL_RBR                     0x00             /*  Receive Buffer register (Read).*/
N#define SERIAL_IER                     0x04             /*  Interrupt Enable register.*/
N#define SERIAL_IIR                     0x08             /*  Interrupt Identification register(Read).*/
N#define SERIAL_FCR                     0x08             /*  FIFO control register(Write).*/
N#define SERIAL_LCR                     0x0C             /*  Line Control register.*/
N#define SERIAL_MCR                     0x10             /*  Modem Control Register.*/
N#define SERIAL_LSR                     0x14             /*  Line status register(Read) .*/
N#define SERIAL_MSR                     0x18             /*  Modem Status register (Read).*/
N#define SERIAL_SPR                     0x1C         /*  Scratch pad register */
N#define SERIAL_DLL                     0x0          /*  Divisor Register LSB */
N#define SERIAL_DLM                     0x4          /*  Divisor Register MSB */
N#define SERIAL_PSR                     0x8             /* Prescale Divison Factor */
N
N#define SERIAL_MDR                     0x20
N#define SERIAL_ACR                     0x24
N#define SERIAL_TXLENL                  0x28
N#define SERIAL_TXLENH                  0x2C
N#define SERIAL_MRXLENL                 0x30
N#define SERIAL_MRXLENH                 0x34
N#define SERIAL_PLR                     0x38
N#define SERIAL_FMIIR_PIO               0x3C
N#define SERIAL_FEATURE                 0x68
N
N/* IER Register */
N#define SERIAL_IER_DR                  0x1          /* Data ready Enable */
N#define SERIAL_IER_TE                  0x2          /* THR Empty Enable */
N#define SERIAL_IER_RLS                 0x4          /* Receive Line Status Enable */
N#define SERIAL_IER_MS                  0x8          /* Modem Staus Enable */
N
N/* IIR Register */
N#define SERIAL_IIR_NONE                0x1            /* No interrupt pending */
N#define SERIAL_IIR_RLS                 0x6            /* Receive Line Status */
N#define SERIAL_IIR_DR                  0x4            /* Receive Data Ready */
N#define SERIAL_IIR_TIMEOUT             0xc            /* Receive Time Out */
N#define SERIAL_IIR_TE                  0x2            /* THR Empty */
N#define SERIAL_IIR_MODEM               0x0            /* Modem Status */
N
N/* FCR Register */
N#define SERIAL_FCR_FE                  0x1              /* FIFO Enable */
N#define SERIAL_FCR_RXFR                0x2              /* Rx FIFO Reset */
N#define SERIAL_FCR_TXFR                0x4              /* Tx FIFO Reset */
N
N/* LCR Register */
N#define SERIAL_LCR_LEN5                0x0
N#define SERIAL_LCR_LEN6                0x1
N#define SERIAL_LCR_LEN7                0x2
N#define SERIAL_LCR_LEN8                0x3
N
N#define SERIAL_LCR_STOP                0x4
N#define SERIAL_LCR_EVEN                0x18          /* Even Parity */
N#define SERIAL_LCR_ODD                 0x8          /* Odd Parity */
N#define SERIAL_LCR_PE                  0x8            /* Parity Enable */
N#define SERIAL_LCR_SETBREAK            0x40             /* Set Break condition */
N#define SERIAL_LCR_STICKPARITY         0x20             /* Stick Parity Enable */
N#define SERIAL_LCR_DLAB                0x80         /* Divisor Latch Access Bit */
N
N/* LSR Register */
N#define SERIAL_LSR_DR                  0x1          /* Data Ready */
N#define SERIAL_LSR_OE                  0x2          /* Overrun Error */
N#define SERIAL_LSR_PE                  0x4          /* Parity Error */
N#define SERIAL_LSR_FE                  0x8          /* Framing Error */
N#define SERIAL_LSR_BI                  0x10         /* Break Interrupt */
N#define SERIAL_LSR_THRE                0x20         /* THR Empty */
N#define SERIAL_LSR_TE                  0x40         /* Transmitte Empty */
N#define SERIAL_LSR_DE                  0x80         /* FIFO Data Error */
N
N/* MCR Register */
N#define SERIAL_MCR_DTR                 0x1        /* Data Terminal Ready */
N#define SERIAL_MCR_RTS                 0x2        /* Request to Send */
N#define SERIAL_MCR_OUT1                0x4        /* output    1 */
N#define SERIAL_MCR_OUT2                0x8        /* output2 or global interrupt enable */
N#define SERIAL_MCR_LPBK                0x10         /* loopback mode */
N
N
N/* MSR Register */
N#define SERIAL_MSR_DELTACTS            0x1        /* Delta CTS */
N#define SERIAL_MSR_DELTADSR            0x2        /* Delta DSR */
N#define SERIAL_MSR_TERI                0x4        /* Trailing Edge RI */
N#define SERIAL_MSR_DELTACD             0x8        /* Delta CD */
N#define SERIAL_MSR_CTS                 0x10         /* Clear To Send */
N#define SERIAL_MSR_DSR                 0x20         /* Data Set Ready */
N#define SERIAL_MSR_RI                  0x40         /* Ring Indicator */
N#define SERIAL_MSR_DCD                 0x80         /* Data Carrier Detect */
N
N
N/* MDR register */
N#define SERIAL_MDR_MODE_SEL            0x03
N#define SERIAL_MDR_UART                0x0
N#define SERIAL_MDR_SIR                 0x1
N#define SERIAL_MDR_FIR                 0x2
N
N/* ACR register */
N#define SERIAL_ACR_TXENABLE            0x1
N#define SERIAL_ACR_RXENABLE            0x2
N#define SERIAL_ACR_SET_EOT             0x4
N
N#ifndef PARITY_NONE
N#define PARITY_NONE             0
N#endif
N
N#ifndef PARITY_ODD
N#define PARITY_ODD              1
N#endif
N
N#ifndef PARITY_EVEN
N#define PARITY_EVEN             2
N#endif
N
N#ifndef PARITY_MARK
N#define PARITY_MARK             3
N#endif
N
N#ifndef PARITY_SPACE
N#define PARITY_SPACE            4
N#endif
N
N#define BACKSP_KEY 0x08
N#define RETURN_KEY 0x0D
N#define DELETE_KEY 0x7F
N#define BELL       0x07
N
N
N#define MAX_UART_INST  5  //max uart instance
N#define MAX_BUF_LEN   512 //max buffer len for every individual UART port
N#define NO_FIFO 0
N
N#define UART_SUCCESS  0
N#define UART_FAIL     -1
N
N#define SERIAL_RX_FIFO_COUNT      0x5C 
N
N#define SERIAL_FIFO_DEPTH_REG     0x68
N
N#define SERIAL_FIFO_DEPTH_16B     0x1
N#define SERIAL_FIFO_DEPTH_32B     0x2
N#define SERIAL_FIFO_DEPTH_64B     0x4
N#define SERIAL_FIFO_DEPTH_128B    0x8
N
N#define SERIAL_FIFO_TRIG_LVEL_1   0x0
N#define SERIAL_FIFO_TRIG_LVEL_4   0x1
N#define SERIAL_FIFO_TRIG_LVEL_8   0x2
N#define SERIAL_FIFO_TRIG_LVEL_14  0x3
N
N#define DEFAULT_SYNC_TIMEOUT_CHARS_TIME  512     //for UART_SYNC_MODE: correspond to 512 chars transmission time 
N
Ntypedef int kdp_uart_hdl_t;
Ntypedef void(*uart_isr_t)(void);
Ntypedef void(*kdp_uart_callback_t)(uint32_t event);
N
N/**
N * UART driver status
N */
Ntypedef enum
N{
N    KDP_UART_STATUS_OK,     /**< UART driver status : OK*/
N    KDP_UART_STATUS_ERROR,  /**< UART driver status : ERROR */
N    KDP_UART_STATUS_BUSY    /**< UART driver status : BUSY */
N} KDP_UART_DRV_STATUS_t;
N
N/**
N * UART initialization structure
N*/
Ntypedef struct KDP_UART_CONFIG
N{
N    uint32_t baudrate;
N    uint8_t  data_bits;
N    uint8_t  frame_length;
N    uint8_t  stop_bits;
N    uint8_t  parity_mode;
N    uint8_t  fifo_en;
N} KDP_UART_CONFIG_t;
N
N/**
N\brief KDP UART Device Driver Capabilities. This capability covers ARM_USART_CAPABILITIES
N*/
Ntypedef struct _KDP_USART_CAPABILITIES {
N    uint32_t asynchronous : 1;      ///< supports UART (Asynchronous) mode 
N    uint32_t synchronous_master : 1;///< supports Synchronous Master mode
N    uint32_t synchronous_slave : 1; ///< supports Synchronous Slave mode
N    uint32_t serial_irda : 1;       ///< supports SIR (Serial IrDA mode)
N    uint32_t fast_irda : 1;         ///< supports FIR (Fast IrDA mode)
N    uint32_t flow_control_rts : 1;  ///< RTS Flow Control available
N    uint32_t flow_control_cts : 1;  ///< CTS Flow Control available
N    uint32_t event_tx_complete : 1; ///< Transmit completed event: \ref ARM_USART_EVENT_TX_COMPLETE
N    uint32_t event_rx_timeout : 1;  ///< Signal receive character timeout event: \ref ARM_USART_EVENT_RX_TIMEOUT
N    uint32_t rts : 1;               ///< RTS Line: 0=not available, 1=available
N    uint32_t cts : 1;               ///< CTS Line: 0=not available, 1=available
N    uint32_t dtr : 1;               ///< DTR Line: 0=not available, 1=available
N    uint32_t dsr : 1;               ///< DSR Line: 0=not available, 1=available
N    uint32_t dcd : 1;               ///< DCD Line: 0=not available, 1=available
N    uint32_t ri : 1;                ///< RI Line: 0=not available, 1=available
N    uint32_t event_cts : 1;         ///< Signal CTS change event: \ref ARM_USART_EVENT_CTS
N    uint32_t event_dsr : 1;         ///< Signal DSR change event: \ref ARM_USART_EVENT_DSR
N    uint32_t event_dcd : 1;         ///< Signal DCD change event: \ref ARM_USART_EVENT_DCD
N    uint32_t event_ri : 1;          ///< Signal RI change event: \ref ARM_USART_EVENT_RI
N} KDP_USART_CAPABILITIES;
N
N// UART flags
N
N#define     UART_INITIALIZED          (1 << 0)
N#define     UART_POWERED              (1 << 1)
N#define     UART_BASIC_CONFIGURED     (1 << 2)
N#define     UART_FIFO_RX_CONFIGURED   (1 << 3)
N#define     UART_FIFO_TX_CONFIGURED   (1 << 4)
N#define     UART_TX_ENABLED           (1 << 5)
N#define     UART_RX_ENABLED           (1 << 6)
N#define     UART_LOOPBACK_ENABLED     (1 << 7)
N
N#define     UART_MODE_ASYN_RX  (1 << 0)
N#define     UART_MODE_ASYN_TX  (1 << 1)
N#define     UART_MODE_SYNC_RX  (1 << 2)
N#define     UART_MODE_SYNC_TX  (1 << 3)
N#define     SIR_MODE_ASYN      (1 << 4)
N#define     FIR_MODE_ASYN      (1 << 5)
N
N
N// UART Transfer Information (Run-Time)
Ntypedef struct UART_TRANSFER_INFO
N{
N    volatile uint32_t                rx_num;        // Total number of data to be received
N    volatile uint32_t                tx_num;        // Total number of data to be send
N    volatile uint8_t                 *rx_buf;       // Pointer to in data buffer
N    volatile uint8_t                 *tx_buf;       // Pointer to out data buffer
N    volatile uint32_t                rx_cnt;        // Number of data received
N    volatile uint32_t                tx_cnt;        // Number of data sent
N    volatile uint32_t                write_idx;     // Write index
N    volatile uint32_t                read_idx;      // Read index
N} UART_TRANSFER_INFO_t;
N
Ntypedef struct
N{
N    volatile uint8_t tx_busy;             // Transmitter busy flag
N    volatile uint8_t rx_busy;             // Receiver busy flag
N    uint8_t tx_underflow;                 // Transmit data underflow detected (cleared on start of next send operation)
N    uint8_t rx_overflow;                  // Receive data overflow detected (cleared on start of next receive operation)
N    uint8_t rx_break;                     // Break detected on receive (cleared on start of next receive operation)
N    uint8_t rx_framing_error;             // Framing error detected on receive (cleared on start of next receive operation)
N    uint8_t rx_parity_error;              // Parity error detected on receive (cleared on start of next receive operation)
N} UART_STATUS_t;
N
N// UART Information (Run-Time)
Ntypedef struct
N{
N    ARM_USART_SignalEvent_t cb_event;           // Event callback
N    UART_STATUS_t           status;             // Status flags
N    UART_TRANSFER_INFO_t    xfer;               // Transfer information
N    uint32_t                flags;              // UART driver flags: UART_FLAG_T
N    uint32_t                mode;               // UART mode
N} UART_INFO_T;
N
N
N// UART Resources definitions
Ntypedef struct
N{
N    uint32_t               irq_num;                    // UART TX IRQ Number
N    uart_isr_t             isr;                        // ISR route
N    uint32_t               fifo_depth;                 //16/32/64/128 depth, set by UART_CTRL_CONFIG
N    uint32_t               tx_fifo_threshold;          // FIFO tx trigger threshold
N    uint32_t               rx_fifo_threshold;          // FIFO rx trigger threshold
N    uint32_t               fifo_len;                   // FIFO tx buffer len
N    uint32_t               clock;                      //clock
N    uint32_t               hw_base;                    // hardware base address
N} UART_RESOURCES_T;
N
Ntypedef enum {
N    UART_UNINIT,
N    UART_INIT_DONE,
N    UART_WORKING,
N    UART_CLOSED
N}kdp_uart_drv_state_t;
N
Ntypedef enum {
N    UART0_DEV,
N    UART1_DEV,
N    UART2_DEV,
N    UART3_DEV,
N    UART4_DEV,
N    TOTAL_UART_DEV
N} kdp_uart_dev_id;
N
Ntypedef struct {
N    bool     bEnFifo;
X    _Bool     bEnFifo;
N    uint8_t  fifo_trig_level;
N} kdp_uart_fifo_cfg_t;
N
Ntypedef enum {
N    UART_CTRL_CONFIG,      //param: KDP_UART_CONFIG_t
N    UART_CTRL_FIFO_RX,     //param: kdp_uart_fifo_cfg_t
N    UART_CTRL_FIFO_TX,     //param: kdp_uart_fifo_cfg_t
N    UART_CTRL_LOOPBACK,
N    UART_CTRL_TX_EN,
N    UART_CTRL_RX_EN,
N    UART_CTRL_RTS_EN,
N    UART_CTRL_DTR_EN,
N    UART_CTRL_ABORT_TX,
N    UART_CTRL_ABORT_RX,
N    UART_CTRL_TIMEOUT_RX,
N    UART_CTRL_TIMEOUT_TX
N}kdp_uart_ctrl_t;
N
N/* driver instance handle */
Ntypedef struct {
N    uint32_t                 uart_port;
N    kdp_uart_drv_state_t     state;
N    KDP_USART_CAPABILITIES   *pCap;
N    KDP_UART_CONFIG_t        config;
N    UART_INFO_T              info;
N    UART_RESOURCES_T         res;
N    int32_t                  nTimeOutTx;       //Tx timeout (ms) for UART_SYNC_MODE
N    int32_t                  nTimeOutRx;       //Rx timeout (ms) for UART_SYNC_MODE
N    uint32_t                 iir;              //store IIR register value (IIR register will be reset once it is 
N                                               //read once, need to store for further process)
N} kdp_driver_hdl_t;
N
Ntypedef struct {
N    int8_t             total_open_uarts;
N    bool               active_dev[TOTAL_UART_DEV];
X    _Bool               active_dev[TOTAL_UART_DEV];
N    kdp_driver_hdl_t   *uart_dev[MAX_UART_INST];
X    kdp_driver_hdl_t   *uart_dev[5];
N
N} kdp_uart_drv_ctx_t;
N
N/******** kdp_uart_api_sts_t *********/
Ntypedef uint32_t kdp_uart_api_sts_t;
N
N#define UART_API_RETURN_SUCCESS     0
N#define UART_API_NOT_POWRERED       (1<<0)
N#define UART_API_TX_BUSY            (1<<1)
N#define UART_API_RX_BUSY            (1<<2)
N#define UART_API_INVALID_PARAM      (1<<3)
N#define UART_API_ERROR              (1<<4)
N#define UART_API_TIMEOUT            (1<<5)
N
N/*************************************/
N
N/* Init the UART device driver, it shall be called once in lifecycle
N*/
Nvoid kdp_uart_init(void);
N
N/*
N  Open one UART port
NInput:
N  com_port: UART port id
N  cb: callback function
N
NOutput:
N  return device handle: >=0 means success; -1 means open fail
N*/
Nkdp_uart_hdl_t kdp_uart_open(uint8_t com_port, uint32_t mode, kdp_uart_callback_t cb);
N
N/*
N Query capability
NInput:
N handle: driver handle
N
NOutput:
N capability of the UART port
N*/
N
NKDP_USART_CAPABILITIES* kdp_uart_get_capability(kdp_uart_hdl_t hanle);
N
N/*
NSet control for the device
NInput:
N    handle: device handle
N    prop: control enumeration
N    val: pointer to control value/structure
Nreturn:
N    error code
N*/
Nint32_t kdp_uart_control(kdp_uart_hdl_t handle, kdp_uart_ctrl_t prop, uint8_t * val);
N
N/*
NQuery driver status
NInput:
N    handle: driver handle
N
NOutput:
N    driver status
N*/
NUART_STATUS_t* kdp_uart_get_status(kdp_uart_hdl_t hanle);
N
N/*
NWrite data to Mozart device, such as command, parameters, but not suitable for chunk data
NInput:
N    hdl: device handle
N    buf: data buffer
N    len: data buffer length
Nreturn:
N    driver status
N*/
Nkdp_uart_api_sts_t kdp_uart_write(kdp_uart_hdl_t hdl, uint8_t *buf, uint32_t len);
N
N/*
NRead data from Mozart device
NInput:
N    handle: device handle
N    buf: data buffer
N    len: data buffer length
Nreturn:
N    driver status
N*/
Nkdp_uart_api_sts_t kdp_uart_read(kdp_uart_hdl_t handle, uint8_t *buf, uint32_t len);
N
N/*
NPower control
NInput:
N    handle: driver handle
N    pwr_set: power status expected to be set
N
NOutput:
N    success or fail
N*/
Nint32_t kdp_uart_power_control(kdp_uart_hdl_t handle, ARM_POWER_STATE pwr_st);
N
N
N/* close the device
NInput:
N    handle: device handle
Nreturn:
N    0 - success; -1 - failure
N*/
Nint32_t kdp_uart_close(kdp_uart_hdl_t handle);
N
N/* get char number in Rx buffer 
NInput:
N    handle: device handle
NReturn:
N    Received bytes 
N*/
Nuint32_t kdp_uart_GetRxCount(kdp_uart_hdl_t handle);
N
N/* get char number in Tx buffer 
NInput:
N    handle: device handle
NReturn:
N    Sent bytes
N*/
Nuint32_t kdp_uart_GetTxCount(kdp_uart_hdl_t handle);
N
Nuint32_t kdp_uart_GetRxBufSize(kdp_uart_hdl_t handle);
Nuint32_t kdp_uart_GetWriteIndex(kdp_uart_hdl_t handle);
Nuint32_t kdp_uart_GetReadIndex(kdp_uart_hdl_t handle);
Nuint32_t kdp_uart_SetWriteIndex(kdp_uart_hdl_t handle, uint32_t index);
Nuint32_t kdp_uart_SetReadIndex(kdp_uart_hdl_t handle, uint32_t index);
N
Nchar kdp_getchar(DRVUART_PORT port_no);
Nint kdp_gets(DRVUART_PORT port_no, char *buf);
Nvoid kdp_uart_rx_busy_clear(kdp_uart_hdl_t handle);
Nextern void kdp_uart_print_register(uint8_t port_no);
N
N#endif  //__KDP_UART_H__
L 14 "..\..\..\..\scpu\middleware\kdp_comm\kdp_comm.h" 2
N//#include "user_com_protoco.h"
N#if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
X#if ( (0x04)&0x00000F00 )
S#define	COM_BUS_RESPONSE_OFFESET	(14)		//data size packet
N#else
N#define	COM_BUS_RESPONSE_OFFESET	(0)
N#endif
N
N#if (CFG_COM_UART_MSG == COM_UART_MSG_KDP)
X#if (1 == 0)
S#include "kdp_comm_msg_define.h"
N#else
N#include "user_comm_msg_define.h"
L 1 "..\..\user\user_comm_msg_define.h" 1
N#ifndef __USER_COMM_MSG_DEFINE_H__
N#define __USER_COMM_MSG_DEFINE_H__
N
N
N//--------------------PROTOCOL
N#define     COM_BUS_HEAD_RX                         ((UINT32)(0xEFAA))
N#define     COM_BUS_HEAD_RX_1                       ((COM_BUS_HEAD_RX&0x0000FF00)>>8 )
N#define     COM_BUS_HEAD_RX_2                       ((COM_BUS_HEAD_RX&0x000000FF)>>0 )
N
N#define     COM_BUS_HEAD_TX                         ((UINT32)(0xEFAA))
N#define     COM_BUS_HEAD_TX_1                       ((COM_BUS_HEAD_TX&0x0000FF00)>>8 )
N#define     COM_BUS_HEAD_TX_2                       ((COM_BUS_HEAD_TX&0x000000FF)>>0 )
N
N#define     COM_BUS_TAIL                            (0x7887)
N#define     COM_BUS_TAIL_1                          (COM_BUS_TAIL&0xFF)
N#define     COM_BUS_TAIL_2                          ((COM_BUS_TAIL>>8)&0xFF)
N
N#define     COM_BUS_GET_DATA_HEAD_TX                (0xC410C410)
N
N//error code
N#define     COM_BUS_HEAD_CHECK_ERROR                (0xEEE0)
N#define     COM_BUS_TAIL_CHECK_ERROR                (0xEEE1)
N#define     COM_BUS_PACKAGE_SIZE_ERROR              (0xEEE2)
N#define     COM_BUS_CHECK_SUM_ERROR                 (0xEEE3)
N#define     COM_BUS_DATA_SIZE_ERROR                 (0xEEE4)
N#define     COM_BUS_ENCRYPTION_ERROR                (0xEEE5)
N#define     COM_BUS_PACKET_OK                       (0x66)
N
N// Host to Module                   // KID: kneron ID
N	//Register and recognition
N#define KID_RESET 0x10                     //v stop and clear all in-processing messages. enter standby mode
N#define KID_GET_STATUS 0x11                //v to ping the module and get the status
N#define KID_VERIFY 0x12                    //v to verify the person in front of the camera
N#define KID_ENROLL 0x13                    //v to enroll and register the persion in front of the camera
N
N#define KID_ENROLL_OVERWRITE 0x14
N
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N
N	//Snapshot
N//#define KID_SNAP_IMAGE 0x16                //v to snap a picture and save it
N//#define KID_GET_SAVED_IMAGE 0x17           //v to get size of saved image
N//#define KID_UPLOAD_IMAGE 0x18              //v upload images
N
N#define KID_ENROLL_SINGLE 0x1D
N
N	//User info
N#define KID_DEL_USER 0x20                  //v Delete the specified user with user id
N#define KID_DEL_ALL 0x21                   //v Delete all registerred users
N#define KID_GET_USER_INFO 0x22             //v Get user info
N#define KID_FACE_RESET 0x23                //v Reset face status
N#define KID_GET_ALL_USER_ID 0x24           //v get all users ID
N
N#define KID_ENROLL_ITG 0x26
N#endif
N
N	//Version info
N#define KID_GET_VERSION 0x30               //v get version information
N#define KID_GET_VERSION_ZA 0x6a               //zcy v get version information
N#define KID_GET_VERSION_ZAPRD 0x3a               //zcy v get version information
N#define KID_GET_VERSION_HARDWARE 0x3b               //zcy v get version information
N
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N	//OTA
N#define KID_START_OTA 0x40                 //v ask the module to enter OTA mode
N#define KID_STOP_OTA 0x41                  //v ask the module to exit OTA mode
N#define KID_GET_OTA_STATUS 0x42            //v query the current ota status
N#define KID_OTA_HEADER 0x43                //v the ota header data
N#define KID_OTA_PACKET 0x44                //v the data packet, carries real firmware data
N#endif
N
N	//Encryption
N#define KID_INIT_ENCRYPTION 0x50           //v initialize encrypted communication
N#define KID_CONFIG_BAUDRATE 0x51           //v config uart baudrate
N#define KID_SET_RELEASE_ENC_KEY 0x52       //v set release encrypted key(Warning!!!:Once set, the KEY will not be able to modify)
N#define KID_SET_DEBUG_ENC_KEY 0x53         //v set debug encrypted key
N
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N	//Log
N//#define KID_GET_LOG_FILE 0x60              // get log file
N//#define KID_UPLOAD_LOG_FILE 0x61           // upload log file
N
N#if ( CFG_FMAP_EXTRA_ENABLE == YES ) && ( CFG_FMAP_AP_CTRL_TYPE > EX_FM_DISABLE )
X#if ( 0 == 1 ) && ( 3 > 0 )
S#define KID_SW_EXP_FM_MODE 0x70
S#define KID_SW_EXP_DB_MODE 0x71
S#if CFG_FMAP_AP_CTRL_TYPE >= EX_FM_UART_AP_CTRL_MAIN_DB // uart contrl
S#define KID_EXP_FM_DATA 0x72
S#define KID_EXP_DB_DATA 0x73
S#define KID_IMP_DB_DATA 0x74
S
S#define KID_IMP_IMG_DATA 0x76
S#endif //CFG_FMAP_AP_CTRL_TYPE >= EX_FM_UART_AP_CTRL_MAIN_DB // uart contrl
N#endif //( CFG_FMAP_EXTRA_ENABLE == YES ) && ( CFG_FMAP_AP_CTRL_TYPE > EX_FM_DISABLE )
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N#define KID_IMP_FM_DATA 0x75
N//#define KID_SET_EXP_MASS_DATA_HEADER 0x78  //v
N#define KID_SET_IMP_MASS_DATA_HEADER 0x79
N#endif
N
N//#define KID_EXP_ALL_DB 0x7A
N//#define KID_IMP_ALL_DB 0x7B
N#endif
N
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N#define KID_DB_EXPORT_REQUEST   0x7C
N#define KID_UPLOAD_DATA         0x7D
N#define KID_DB_IMPORT_REQUEST   0x7E
N#define KID_DOWNLOAD_DATA       0x7F
N#endif
N
N//-----0xA0-0xAF Unit control
N#if ( CFG_PRODUCTION_TEST == YES ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 1 ) || ( IGNORE_PRODUCTION_TEST == 1 )
S//#define KID_TURN_ON_CAMERA              ( 0x80 ) //
S//#define KID_TURN_OFF_CAMERA             ( 0x81 ) //
S//#define KID_TURN_ON_VIS_LED             ( 0x82 ) //Visible
S//#define KID_TURN_OFF_VIS_LED            ( 0x83 ) //
S#define KID_TURN_ON_IR_LED              ( 0x84 ) //
S#define KID_TURN_OFF_IR_LED             ( 0x85 ) //
S//#define KID_TURN_ON_STRUCT_LED          ( 0x86 ) //
S//#define KID_TURN_OFF_STRUCT_LED         ( 0x87 ) //
S//#define KID_TURN_ON_PANEL               ( 0x88 )
S//#define KID_TURN_OFF_PANEL              ( 0x89 )
S#define KID_SET_EXP_TIME                ( 0x8A )
S#define KID_SET_GAIN                    ( 0x8B )
N#endif
N
N    //MP
N#define KID_SW_BOOT_PART 0xAA
N#define KID_GET_CUR_PART 0xAB
N
N#if ( CFG_PRODUCTION_TEST == NO ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 0 ) || ( IGNORE_PRODUCTION_TEST == 1 )
N#define KID_KN_SNAP_IMAGE 0xAC
N#define KID_KN_GET_SAVED_IMAGE 0xAD
N#define KID_KN_UPLOAD_IMAGE 0xAE
N#endif
N
N// user cmd
N#define KID_SOFT_RESET   0xCA
N#define KID_KN_DEVICE_INFO  0xCB
N#define KID_MP_CALIBRATION  0xCC
N#define KID_USER_ROTATE_180 0xCD
N
N#if ( CFG_PRODUCTION_TEST == YES ) || ( IGNORE_PRODUCTION_TEST == YES )
X#if ( CFG_PRODUCTION_TEST == 1 ) || ( IGNORE_PRODUCTION_TEST == 1 )
S#if CFG_SNAPSHOT_ENABLE == 1 || CFG_SNAPSHOT_ENABLE == 2
S#define KID_SNAPSHOT_MODE   0xCE
S#endif
N#endif
N    
N#if ((CFG_COM_BUS_TYPE&COM_BUS_USB_MASK) != COM_BUS_USB_MASK)
X#if (((0x04)&0x00000080) != 0x00000080)
N	//Other
N#define KID_SET_THRESHOLD_LEVEL 0xD4       //v Set threshold level
N#define KID_DEBUG_MODE 0xF0                //v
N//#define KID_GET_DEBUG_INFO 0xF1            //v get size of debug information
N//#define KID_UPLOAD_DEBUG_INFO 0xF2         //v upload debug information
N
N#endif
N
N#define KID_DEMO_MODE 0xFE                 //v enter demo mode, verify flow will skip feature comparation step.
N#define KID_POWERDOWN 0xED                 //v be prepared to power off
N
N#define CMD_REPLY_RESULT_MACRO(CMD_TYPE)    \
N    CMD_TYPE(MR_SUCCESS, 0x00) \
N    CMD_TYPE(MR_REJECTED, 0x01) \
N    CMD_TYPE(MR_ABORTED, 0x02) \
N    CMD_TYPE(MR_FAILED_DEV_OPEN_FAIL, 0x04) \
N    CMD_TYPE(MR_FAILED_UNKNOWN_REASON, 0x05) \
N    CMD_TYPE(MR_FAILED_INVALID_PARAM, 0x06) \
N    CMD_TYPE(MR_FAILED_OOM, 0x07) \
N    CMD_TYPE(MR_FAILED_UNKNOWN_USER, 0x08) \
N    CMD_TYPE(MR_FAILED_MAX_USER, 0x09) \
N    CMD_TYPE(MR_FAILED_FACE_ENROLLED, 0x0A) \
N    CMD_TYPE(MR_FAILED_LIVENESS_CHECK, 0x0C) \
N    CMD_TYPE(MR_FAILED_TIME_OUT, 0x0D) \
N    CMD_TYPE(MR_FAILED_AUTHORIZATION, 0x0E) \
N    CMD_TYPE(MR_FAILED_READ_FILE, 0x13) \
N    CMD_TYPE(MR_FAILED_WRITE_FILE, 0x14) \
N    CMD_TYPE(MR_FAILED_NO_ENCRYPT, 0x15) \
N    CMD_TYPE(MR_FAILED_STORE_ERR, 0x16) \
N    CMD_TYPE(MR_FAILED_NO_IMG, 0x17) \
N    CMD_TYPE(MR_FAILED_NO_IDX, 0x18) \
N    CMD_TYPE(MR_FAILED_BUF_OVERFLOW, 0x19) \
N    CMD_TYPE(MR_FAILED_MASS_DATA_HEAD_EMPTY, 0x30) \
N    CMD_TYPE(MR_FAILED_MASS_DATA_DB_ABNORMAL, 0x31) \
N    CMD_TYPE(MR_FAILED_MASS_DATA_FM_ABNORMAL, 0x32) \
N    CMD_TYPE(MR_FAILED_NOT_READY, 0x33) \
N    CMD_TYPE(MR_FAILED_EXISTED_USER, 0x34) \
N    CMD_TYPE(MR_FAILED_IDX_OVERFLOW, 0x35) \
N    CMD_TYPE(MR_CONTIUNOUS, 0x36) \
N    CMD_TYPE(MR_SUCCESS_BUT_DEL_USER, 0x40) \
N    CMD_TYPE(MR_FAILED_INVALID_CMD, 0xFF) \
N
X#define CMD_REPLY_RESULT_MACRO(CMD_TYPE)        CMD_TYPE(MR_SUCCESS, 0x00)     CMD_TYPE(MR_REJECTED, 0x01)     CMD_TYPE(MR_ABORTED, 0x02)     CMD_TYPE(MR_FAILED_DEV_OPEN_FAIL, 0x04)     CMD_TYPE(MR_FAILED_UNKNOWN_REASON, 0x05)     CMD_TYPE(MR_FAILED_INVALID_PARAM, 0x06)     CMD_TYPE(MR_FAILED_OOM, 0x07)     CMD_TYPE(MR_FAILED_UNKNOWN_USER, 0x08)     CMD_TYPE(MR_FAILED_MAX_USER, 0x09)     CMD_TYPE(MR_FAILED_FACE_ENROLLED, 0x0A)     CMD_TYPE(MR_FAILED_LIVENESS_CHECK, 0x0C)     CMD_TYPE(MR_FAILED_TIME_OUT, 0x0D)     CMD_TYPE(MR_FAILED_AUTHORIZATION, 0x0E)     CMD_TYPE(MR_FAILED_READ_FILE, 0x13)     CMD_TYPE(MR_FAILED_WRITE_FILE, 0x14)     CMD_TYPE(MR_FAILED_NO_ENCRYPT, 0x15)     CMD_TYPE(MR_FAILED_STORE_ERR, 0x16)     CMD_TYPE(MR_FAILED_NO_IMG, 0x17)     CMD_TYPE(MR_FAILED_NO_IDX, 0x18)     CMD_TYPE(MR_FAILED_BUF_OVERFLOW, 0x19)     CMD_TYPE(MR_FAILED_MASS_DATA_HEAD_EMPTY, 0x30)     CMD_TYPE(MR_FAILED_MASS_DATA_DB_ABNORMAL, 0x31)     CMD_TYPE(MR_FAILED_MASS_DATA_FM_ABNORMAL, 0x32)     CMD_TYPE(MR_FAILED_NOT_READY, 0x33)     CMD_TYPE(MR_FAILED_EXISTED_USER, 0x34)     CMD_TYPE(MR_FAILED_IDX_OVERFLOW, 0x35)     CMD_TYPE(MR_CONTIUNOUS, 0x36)     CMD_TYPE(MR_SUCCESS_BUT_DEL_USER, 0x40)     CMD_TYPE(MR_FAILED_INVALID_CMD, 0xFF) 
N#define TO_ENUM(result, value) result=value,
N#define TO_STR(result, value)  {case result: return #result; break;}
N
Nenum uart_reply_result {
N    CMD_REPLY_RESULT_MACRO(TO_ENUM)
X    MR_SUCCESS=0x00, MR_REJECTED=0x01, MR_ABORTED=0x02, MR_FAILED_DEV_OPEN_FAIL=0x04, MR_FAILED_UNKNOWN_REASON=0x05, MR_FAILED_INVALID_PARAM=0x06, MR_FAILED_OOM=0x07, MR_FAILED_UNKNOWN_USER=0x08, MR_FAILED_MAX_USER=0x09, MR_FAILED_FACE_ENROLLED=0x0A, MR_FAILED_LIVENESS_CHECK=0x0C, MR_FAILED_TIME_OUT=0x0D, MR_FAILED_AUTHORIZATION=0x0E, MR_FAILED_READ_FILE=0x13, MR_FAILED_WRITE_FILE=0x14, MR_FAILED_NO_ENCRYPT=0x15, MR_FAILED_STORE_ERR=0x16, MR_FAILED_NO_IMG=0x17, MR_FAILED_NO_IDX=0x18, MR_FAILED_BUF_OVERFLOW=0x19, MR_FAILED_MASS_DATA_HEAD_EMPTY=0x30, MR_FAILED_MASS_DATA_DB_ABNORMAL=0x31, MR_FAILED_MASS_DATA_FM_ABNORMAL=0x32, MR_FAILED_NOT_READY=0x33, MR_FAILED_EXISTED_USER=0x34, MR_FAILED_IDX_OVERFLOW=0x35, MR_CONTIUNOUS=0x36, MR_SUCCESS_BUT_DEL_USER=0x40, MR_FAILED_INVALID_CMD=0xFF,
N};
N
Nchar *_str_uart_reply(enum uart_reply_result result);
N
N#pragma diag_suppress 111
Ninline char *_str_uart_reply(enum uart_reply_result result)
N{
N    switch (result)
N    {
N        CMD_REPLY_RESULT_MACRO(TO_STR)
X        {case MR_SUCCESS: return "MR_SUCCESS"; break;} {case MR_REJECTED: return "MR_REJECTED"; break;} {case MR_ABORTED: return "MR_ABORTED"; break;} {case MR_FAILED_DEV_OPEN_FAIL: return "MR_FAILED_DEV_OPEN_FAIL"; break;} {case MR_FAILED_UNKNOWN_REASON: return "MR_FAILED_UNKNOWN_REASON"; break;} {case MR_FAILED_INVALID_PARAM: return "MR_FAILED_INVALID_PARAM"; break;} {case MR_FAILED_OOM: return "MR_FAILED_OOM"; break;} {case MR_FAILED_UNKNOWN_USER: return "MR_FAILED_UNKNOWN_USER"; break;} {case MR_FAILED_MAX_USER: return "MR_FAILED_MAX_USER"; break;} {case MR_FAILED_FACE_ENROLLED: return "MR_FAILED_FACE_ENROLLED"; break;} {case MR_FAILED_LIVENESS_CHECK: return "MR_FAILED_LIVENESS_CHECK"; break;} {case MR_FAILED_TIME_OUT: return "MR_FAILED_TIME_OUT"; break;} {case MR_FAILED_AUTHORIZATION: return "MR_FAILED_AUTHORIZATION"; break;} {case MR_FAILED_READ_FILE: return "MR_FAILED_READ_FILE"; break;} {case MR_FAILED_WRITE_FILE: return "MR_FAILED_WRITE_FILE"; break;} {case MR_FAILED_NO_ENCRYPT: return "MR_FAILED_NO_ENCRYPT"; break;} {case MR_FAILED_STORE_ERR: return "MR_FAILED_STORE_ERR"; break;} {case MR_FAILED_NO_IMG: return "MR_FAILED_NO_IMG"; break;} {case MR_FAILED_NO_IDX: return "MR_FAILED_NO_IDX"; break;} {case MR_FAILED_BUF_OVERFLOW: return "MR_FAILED_BUF_OVERFLOW"; break;} {case MR_FAILED_MASS_DATA_HEAD_EMPTY: return "MR_FAILED_MASS_DATA_HEAD_EMPTY"; break;} {case MR_FAILED_MASS_DATA_DB_ABNORMAL: return "MR_FAILED_MASS_DATA_DB_ABNORMAL"; break;} {case MR_FAILED_MASS_DATA_FM_ABNORMAL: return "MR_FAILED_MASS_DATA_FM_ABNORMAL"; break;} {case MR_FAILED_NOT_READY: return "MR_FAILED_NOT_READY"; break;} {case MR_FAILED_EXISTED_USER: return "MR_FAILED_EXISTED_USER"; break;} {case MR_FAILED_IDX_OVERFLOW: return "MR_FAILED_IDX_OVERFLOW"; break;} {case MR_CONTIUNOUS: return "MR_CONTIUNOUS"; break;} {case MR_SUCCESS_BUT_DEL_USER: return "MR_SUCCESS_BUT_DEL_USER"; break;} {case MR_FAILED_INVALID_CMD: return "MR_FAILED_INVALID_CMD"; break;}
N    default:
N        break;
N    }
N    
N    return "";
N}
N#pragma diag_warning 111
N
N
N#endif    //__USER_COMM_MSG_DEFINE_H__
N
L 25 "..\..\..\..\scpu\middleware\kdp_comm\kdp_comm.h" 2
N#endif
N
N//#define v MR_SUCCESS     0     // success   //Lucien
N//#define v MR_REJECTED    1     // module rejected this command
N//#define v MR_ABORTED     2     // algo aborted
N//#define v MR_FAILED4_CAMERA  4 // camera open failed
N//#define v MR_FAILED4_UNKNOWNREASON  5 // UNKNOWN_ERROR
N//#define MR_FAILED4_INVALIDPARAM  6  // invalid param
N//#define MR_FAILED4_NOMEMORY  7      // no enough memory
N//#define MR_FAILED4_UNKNOWNUSER  8   // no user enrolled
N//#define MR_FAILED4_MAXUSER  9       // exceed maximum user number
N//#define MR_FAILED4_FACEENROLLED  10 // this face has been enrolled
N//#define MR_FAILED4_LIVENESSCHECK  12// liveness check failed
N//#define MR_FAILED4_TIMEOUT  13      // exceed the time limit
N//#define x MR_FAILED4_AUTHORIZATION  14// authorization failed
N//#define x MR_FAILED4_CAMERAFOV  15    // camera fov test failed
N//#define x MR_FAILED4_CAMERAQUA  16    // camera quality test failed
N//#define x MR_FAILED4_CAMERASTRU  17   // camera structure test failed
N//#define x MR_FAILED4_BOOT_TIMEOUT  18 // boot up timeout
N//#define x MR_FAILED4_READ_FILE   19    // read file failed
N//#define x MR_FAILED4_WRITE_FILE  20   // write file failed
N//#define x MR_FAILED4_NO_ENCRYPT  21   // encrypt must be set
N
N#pragma pack(1)
Ntypedef enum kl520_com_flags_enum {
N    KL520_COM_NORMAL = 0,
N    KL520_COM_HAS_ADDITIONAL_IO = 1,
N
N} kl520_com_flags;
N
N//=================================
Ntypedef enum {
N    DEV_UART,
N    DEV_SPI,
N    DEV_I2C,
N    DEV_USB,
N    DEV_SDIO,
N    DEV_OTG,
N    TOTAL_DEV,
N    DEV_NULL=0xFF,
N} dev_type;
N
Nstruct st_com_type
N{
N    dev_type com_type; //0~4: uart0~uart4, 0x11: SPI1, 0xFF: nothing
N    UINT8 uart_port;
N    kdp_uart_dev_id dev_id;
N    kl520_com_flags flags;
N    UINT8 *tx_buffer;
N    UINT32 *tx_buffer_index;
N    UINT8 *rx_buffer;
N    UINT32 *rx_buffer_index;
N    u8 *parser_buffer;
N    u32 parser_cnt;
N    UINT32 parser_end;
N
N    UINT16 head;  //syncword
N    UINT8 cmd;    //msgid
N    UINT16 host_number;//not used
N    UINT16 data_len;//size
N    UINT16 data_start_index; //data end_index = data_start_index + data_len
N    UINT32 checksum; // exp suncWord XOR-alg-result
N
N#if ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
X#if ( (0x04)&0x00000F00 )
S    UINT8 no_head_tail_en; //response bit or not deshiman no
N#endif
N};
N
Ntypedef struct kl520_com_user_ops_struct {
N    u16     (*packet_analyze)(struct st_com_type *st_com);
N    void    (*parser)(struct st_com_type *st_com);
N} kl520_com_user_ops;
N
Nextern struct st_com_type stCom_type;
N
N#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
X#if ( (0x04)&0x0000007F ) || ( (0x04)&0x00000F00 )
N#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
X#if ( (0x04)&0x0000007F )
Nextern void kl520_com_reconfig_baud_rate(int rate);
N#endif
N
Nextern void kl520_com_buf_addr_init(void);
Nextern void kl520_com_init(kl520_com_flags flags);
Nextern void kl520_com_initial( kl520_com_flags flags );
Nextern UINT8 kl520_com_response( struct st_com_type *st_com );
Nextern UINT8 kl520_com_response_Done_check(void);
NUINT16 kneron_lwcom_packet_analyze( struct st_com_type *st_com );
Nvoid kl520_com_reg_user_ops(kl520_com_user_ops *ops);
Nextern void kl520_com_thread(void);
N#endif
N
N
Nextern void kl520_com_bus_init(void);
N
N//-----
N#pragma pack()
N//#endif
N#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_USB_MASK )
X#if ( (0x04)&0x0000007F ) || ( (0x04)&0x00000080 )
N//--------------------PARAER
N// error code for cmd parser
N#define NO_ERROR        0
N#define NO_MATCH        1
N#define RSP_NOT_IMPLEMENTED 0xFFFE
N#define RSP_UKNOWN_CMD  0xFFFF
N#define BAD_CONFIRMATION 2  // CMD_RESET RESPONSE
N#define BAD_MODE         1
N#define FILE_ERROR       1  // File data transfer error
N
N#endif
N#endif
N#endif
N#endif    //__KDP_COMM_H__
L 116 "..\..\..\..\scpu\middleware\comm\kl520_com.h" 2
N#elif ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_DEF_USR )
X#elif ( 1 == 2 )
S#include "user_com.h"
S#elif ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_KDP_USR )
S#include "user_comm.h"
N#endif
N#endif
N#endif
L 2 "..\..\..\..\scpu\middleware\comm\kl520_com.c" 2
N
N#if CFG_COM_PROTOCOL_TYPE == COM_PROTOCOL_TYPE_LWCOM
X#if 0 == 0
N#if ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK ) || ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )
X#if ( (0x04)&0x0000007F ) || ( (0x04)&0x00000F00 )
N#if ( CFG_COM_URT_PROT_TYPE == COM_UART_PROT_DEF )
X#if ( 1 == 0 )
S
S#include "io.h"
S#include "pinmux.h"
S#include "framework/init.h"
S#include "framework/v2k_image.h"
S#include "framework/framework_driver.h"
S#include "framework/event.h"
S#include "kl520_api_ssp.h"
S#include "kl520_include.h"
S#include "kdp_memory.h"
S#include "kdp_ddr_table.h"
S#include "sample_user_com_and_gui_fdr.h"
S
S#if ( !(CFG_COM_BUS_TYPE&COM_BUS_SPI_MS_EN) ) && ( ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )&( ~COM_BUS_SPI_MS_EN ) )
S#include "kdp520_ssp.h"
S#endif
S
Suint8_t *pgcom_tx_buf = (uint8_t *)KDP_DDR_DRV_COM_BUS_TX_START_ADDR;
Suint8_t *pgcom_rx_buf = (uint8_t *)KDP_DDR_DRV_COM_BUS_RX0_START_ADDR;
Suint32_t gcom_tx_index = 0; //data legnth
Suint32_t gcom_rx_index = 0; //data legnth
S
Sstruct st_com_type stCom_type;
Sstatic kl520_com_user_ops *_user_com_ops = NULL;
S
S__WEAK void kneron_com_parser( struct st_com_type *st_com ){}
S
Svoid kl520_com_buf_addr_init(void)
S{
S    stCom_type.tx_buffer = pgcom_tx_buf;
S    stCom_type.rx_buffer = pgcom_rx_buf;
S    stCom_type.tx_buffer_index = &gcom_tx_index;
S    stCom_type.rx_buffer_index = &gcom_rx_index;
S}
S
Sextern UINT32 Drv_utility_checksum( UINT8 * buf, UINT16 start, UINT16 end );
SUINT16 kneron_lwcom_packet_analyze( struct st_com_type *st_com )
S{
S    UINT32  i = 0;
S    UINT8   *ptr = st_com->rx_buffer;
S    UINT32  *ptr_indedx = st_com->rx_buffer_index;
S    UINT32  nhead_index = 0xFFFFFFFF;
S    UINT32  ncheck_sum = 0;
S
S    st_com->no_head_tail_en = 0;
S
S    //-----------------------
S    //----- length check ------
S    //-----------------------
S    if( *ptr_indedx < 16  )    //Head(4B) + Host(2B) + CMD(2B) + DL(2B) + CSUM(4B) + Tail(2B)
S    {
S        return COM_BUS_LENGTH_CHECK_ERROR;
S    }
S
S    //-----------------------
S    //-----	head check ------
S    //-----------------------
S    for( i = 0; i < ( *ptr_indedx-4 ); i++ )
S    {
S        if(	 (*(ptr + i + 0 ) == COM_BUS_HEAD_RX_1) && (*(ptr +i +  1 ) == COM_BUS_HEAD_RX_2 )
S        && (*(ptr +i +  2 ) == COM_BUS_HEAD_RX_3) && (*(ptr +i +  3 ) == COM_BUS_HEAD_RX_4 )	)
S        {
S            nhead_index = i;
S            *(ptr + i + 0 ) = 0;
S            *(ptr +i +  1 ) = 0;
S            break;
S        }
S    }
S
S    //-----------------------
S    //packet tail  check
S    //-----------------------
S    if(	(*(ptr + (*ptr_indedx) -1)  !=  COM_BUS_TAIL_1) || ( *(ptr + (*ptr_indedx) -2 )  != COM_BUS_TAIL_2 ) )
S    {
S        return COM_BUS_TAIL_CHECK_ERROR;
S    }
S
S    if( nhead_index == 0xFFFFFFFF  )
S    {
S        return COM_BUS_HEAD_CHECK_ERROR;
S    }
S
S    st_com->host_number = (*( ptr+nhead_index+4 )<<8) + *( ptr+nhead_index+5 );
S    st_com->cmd         = (*( ptr+nhead_index+6 )<<8) + *( ptr+nhead_index+7 );
S    st_com->data_len    = (*( ptr+nhead_index+8 )<<8) + *( ptr+nhead_index+9 );
S    st_com->data_start_index = nhead_index + sizeof(st_com->head) + sizeof( st_com->host_number ) + sizeof( st_com->cmd ) + sizeof(st_com->data_len);
S    st_com->checksum    = (*( ptr+(*ptr_indedx)-6 )<<24) | (*(ptr+(*ptr_indedx)-5 )<<16) |
S                          (*( ptr+(*ptr_indedx)-4 )<<8 ) | (*(ptr+(*ptr_indedx)-3 ));
S						  
S    ncheck_sum = Drv_utility_checksum( ptr, nhead_index+6, *ptr_indedx - 6 );
S
S    if( st_com->checksum != ncheck_sum  )
S    {
S        return COM_BUS_HEAD_CHECK_ERROR;
S    }
S    return COM_BUS_PACKET_OK;	//exist good data
S}
S
Svoid kneron_lwcom_packet_response_w_tx_buffer( struct st_com_type *st_com, UINT8 *in_data, UINT16 in_data_legn )
S{
S    UINT16	i ;
S    UINT32	nchecksum = 0;
S    UINT8	*ptr = st_com->tx_buffer;
S    *st_com->tx_buffer_index = 0;
S
S#if ( !(CFG_COM_BUS_TYPE&COM_BUS_SPI_MS_EN) ) && ( ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )&( ~COM_BUS_SPI_MS_EN ) )
S    if( st_com->no_head_tail_en == 0 )
S    {
S        *st_com->tx_buffer_index = 0;
S        ptr += COM_BUS_RESPONSE_OFFESET;
S    }
S    else
S    {
S        //no head and tail Bytes
S        *st_com->tx_buffer_index = 0;
S        ptr += ( COM_BUS_RESPONSE_OFFESET - 6 );
S    }
S#endif
S
S    st_com->head = COM_BUS_HEAD_TX;
S    st_com->data_len = in_data_legn;
S
S    if( st_com->no_head_tail_en == 0 )
S    {
S        //head
S        *(ptr + *st_com->tx_buffer_index ) = (COM_BUS_HEAD_TX>>24)&0xFF;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S        *(ptr + *st_com->tx_buffer_index ) = (COM_BUS_HEAD_TX>>16)&0xFF;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S        *(ptr + *st_com->tx_buffer_index ) = (COM_BUS_HEAD_TX>>8)&0xFF;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S        *(ptr + *st_com->tx_buffer_index ) = (COM_BUS_HEAD_TX>>0)&0xFF;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    }
S
S    //host number
S    *(ptr + *st_com->tx_buffer_index ) = (st_com->host_number>>8)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    *(ptr + *st_com->tx_buffer_index ) = (st_com->host_number>>0)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S
S    //command
S    *(ptr + *st_com->tx_buffer_index ) = (st_com->cmd>>8)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    *(ptr + *st_com->tx_buffer_index ) = (st_com->cmd>>0)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    nchecksum+= (st_com->cmd>>8)&0xFF;
S    nchecksum+= (st_com->cmd>>0)&0xFF;
S
S    //length
S    *(ptr + *st_com->tx_buffer_index ) = (st_com->data_len>>8)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    *(ptr + *st_com->tx_buffer_index ) = (st_com->data_len>>0)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    nchecksum+= (st_com->data_len>>8)&0xFF;
S    nchecksum+= (st_com->data_len>>0)&0xFF;
S
S    for( i = 0; i < st_com->data_len; i++  )
S    {
S        *(ptr + *st_com->tx_buffer_index ) = *( in_data+i );
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S        nchecksum+= *( in_data+i );
S    }
S
S    //checksum
S    *(ptr + *st_com->tx_buffer_index ) = (nchecksum>>24)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    *(ptr + *st_com->tx_buffer_index ) = (nchecksum>>16)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    *(ptr + *st_com->tx_buffer_index ) = (nchecksum>>8)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    *(ptr + *st_com->tx_buffer_index ) = (nchecksum>>0)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S
S    if( st_com->no_head_tail_en == 0 )
S    {
S        //tail
S        *(ptr + *st_com->tx_buffer_index ) = COM_BUS_TAIL_2;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S        *(ptr + *st_com->tx_buffer_index ) = COM_BUS_TAIL_1;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    }
S
S}
S
S// OTA CMD
S//
S//  format: head   host number response    tail
S//  size  :  4   2   2   2
S//
Svoid kneron_lwcom_packet_response_brief_w_tx_buffer( struct st_com_type *st_com, UINT16 host_number, UINT16 status )
S{
S    UINT8   *ptr = st_com->tx_buffer;
S
S#if ( !(CFG_COM_BUS_TYPE&COM_BUS_SPI_MS_EN) ) && ( ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )&( ~COM_BUS_SPI_MS_EN ) )
S    if( st_com->no_head_tail_en == 0 )
S    {
S        *st_com->tx_buffer_index = 0;
S        ptr += COM_BUS_RESPONSE_OFFESET;
S    }
S    else
S    {
S        //no head and tail Bytes
S        *st_com->tx_buffer_index = 0;
S        ptr += ( COM_BUS_RESPONSE_OFFESET - 6 );
S    }
S#endif
S
S    st_com->head = COM_BUS_HEAD_TX;
S
S    if( st_com->no_head_tail_en == 0 )
S    {
S        //head
S        *(ptr + *st_com->tx_buffer_index ) = (COM_BUS_HEAD_TX>>24)&0xFF;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S        *(ptr + *st_com->tx_buffer_index ) = (COM_BUS_HEAD_TX>>16)&0xFF;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S        *(ptr + *st_com->tx_buffer_index ) = (COM_BUS_HEAD_TX>>8)&0xFF;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S        *(ptr + *st_com->tx_buffer_index ) = (COM_BUS_HEAD_TX>>0)&0xFF;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    }
S
S    //host number
S    *(ptr + *st_com->tx_buffer_index ) = (host_number>>8)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    *(ptr + *st_com->tx_buffer_index ) = (host_number>>0)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S
S    //status
S    *(ptr + *st_com->tx_buffer_index ) = (status>>8)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    *(ptr + *st_com->tx_buffer_index ) = (status>>0)&0xFF;
S    *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S
S    if( st_com->no_head_tail_en == 0 )
S    {
S        //tail
S        *(ptr + *st_com->tx_buffer_index ) = COM_BUS_TAIL_2;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S        *(ptr + *st_com->tx_buffer_index ) = COM_BUS_TAIL_1;
S        *st_com->tx_buffer_index = *st_com->tx_buffer_index+1;
S    }
S
S}
S
Svoid kneron_lwcom_set_parameter( struct st_com_type *st_com, UINT16 nhost_number, UINT16 cmd )
S{
S    st_com->cmd = cmd;
S    st_com->host_number = nhost_number;
S}
S// OTA CMD
S
S
S
Svoid kl520_com_init(kl520_com_flags flags)
S{
S    stCom_type.flags = flags;
S    stCom_type.com_type = DEV_NULL;
S    stCom_type.uart_port = 0xFF;
S
S    kl520_com_buf_addr_init();
S
S#if ( !(CFG_COM_BUS_TYPE&COM_BUS_SPI_MS_EN) ) && ( ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )&( ~COM_BUS_SPI_MS_EN ) )
S#ifdef COM_BUS_RESPONSE_REQUEST_PIN
S    kdp_slave_request_init();
S    kdp_slave_request_inactive();
S#endif
S#endif
S    
S    
S#if ( !(CFG_COM_BUS_TYPE&COM_BUS_SPI_MS_EN) ) && ( ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )&( ~COM_BUS_SPI_MS_EN ) )
S    stCom_type.com_type = DEV_SPI;
S    driver_ssp_ctx.Tx_buffer_index = stCom_type.tx_buffer_index;
S    driver_ssp_ctx.Rx_buffer_index = stCom_type.rx_buffer_index;
S    kdp_ssp_statemachine( &driver_ssp_ctx, e_spi_init_slave );
S    kdp_ssp_clear_rxhw( driver_ssp_ctx.reg_base_address );
S    kdp_ssp_clear_txhw( driver_ssp_ctx.reg_base_address );
S    kdp_ssp_clear_rx_buf_index( &driver_ssp_ctx );
S    kdp_ssp_clear_tx_buf_index( &driver_ssp_ctx );
S    kdp_ssp_clear_tx_current_buf_index(&driver_ssp_ctx);
S    kdp_ssp_clear_tx_done_flag(&driver_ssp_ctx);
S    kdp_ssp_statemachine( &driver_ssp_ctx, e_spi_disable );
S    kdp_ssp_statemachine( &driver_ssp_ctx, e_spi_enable );
S
S#elif ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
S    stCom_type.com_type = DEV_UART;
S
S#if ( ( CFG_COM_BUS_TYPE&COM_BUS_UART0 ) == COM_BUS_UART0 )
S    stCom_type.uart_port = 0;
S    stCom_type.dev_id = UART0_DEV;
S#elif ( ( CFG_COM_BUS_TYPE&COM_BUS_UART1 ) == COM_BUS_UART1 )
S    stCom_type.uart_port = 1;
S    stCom_type.dev_id = UART1_DEV;
S#elif ( ( CFG_COM_BUS_TYPE&COM_BUS_UART2 ) == COM_BUS_UART2 )
S    stCom_type.uart_port = 2;
S    stCom_type.dev_id = UART2_DEV;
S#elif ( ( CFG_COM_BUS_TYPE&COM_BUS_UART3 ) == COM_BUS_UART3 )
S    stCom_type.uart_port = 3;
S    stCom_type.dev_id = UART3_DEV;
S#elif ( ( CFG_COM_BUS_TYPE&COM_BUS_UART4 ) == COM_BUS_UART4 )
S    stCom_type.uart_port = 4;
S    stCom_type.dev_id = UART4_DEV;
S#endif
S
S    kdp_uart_app_com( stCom_type.uart_port , BAUD_115200, (UINT8 *)stCom_type.rx_buffer, KDP_DDR_DRV_COM_BUS_RESERVED);
S#endif
S}
S
Svoid kl520_com_reconfig_baud_rate(int rate)
S{
S    u32 baudrate;
S    
S    if(rate == 0)     {baudrate = BAUD_115200;}
S    else if(rate == 1){baudrate = BAUD_921600;}
S    else if(rate == 2){baudrate = BAUD_460800;}
S    else{baudrate = BAUD_921600;}
S
S#ifdef COM_BUS_RESPONSE_REQUEST_PIN
S    stCom_type.flags = KL520_COM_HAS_ADDITIONAL_IO;
S#else
S    stCom_type.flags = KL520_COM_NORMAL;
S#endif
S
S    kl520_com_buf_addr_init();
S
S    kdp_uart_app_com( stCom_type.uart_port, baudrate, (UINT8 *)stCom_type.rx_buffer, KDP_DDR_DRV_COM_BUS_RESERVED);
S}
S
Svoid kl520_com_initial( kl520_com_flags flags )
S{
S    kl520_com_init( flags );
S}
S
S
S//waiting for new data coming and processing it
S//this is a shared function
SBOOL kl520_com_wait_receive(void)
S{
S    BOOL ret = FALSE;
S    //check Rx busy
S#if ( !(CFG_COM_BUS_TYPE&COM_BUS_SPI_MS_EN) ) && ( ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )&( ~COM_BUS_SPI_MS_EN ) )
S    UINT8	timeout_cnt = 0, time_out_th = 10;
S    UINT16  ncount = 0xFFFF;
S    //spi busy check
S    if ( stCom_type.com_type == DEV_SPI )
S    {
S        while(1)
S        {
S            ncount = *stCom_type.rx_buffer_index;
S            if( ncount == 0 )
S            {
S                timeout_cnt++;
S                delay_ms(1);
S                if( timeout_cnt > time_out_th )
S                {
S                #if( COM_DEBUG_LOG_EN == YES)
S                    dbg_msg("[com_bus] spi timeout ");
S                #endif
S                    break;
S                }
S            }
S            else
S            {
S                timeout_cnt = 0;
S                while( kl520_api_ssp_spi1_receive(&driver_ssp_ctx) == 0 );
S            #if( COM_DEBUG_LOG_EN == YES)
S                dbg_msg("[com_bus] spi data get size: %d ", *stCom_type.rx_buffer_index );
S            #endif
S                ret = TRUE;
S                break;
S            }
S            osDelay(20);
S        }
S    }
S#elif ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
S    UINT16  ncount = 0xFFFF;
S    //Uart Busy check
S    //go to Uart interface, check bus is busy or idle
S    if (stCom_type.com_type == DEV_UART )
S    {
S        //protect and receive all data
S        while( ncount != *stCom_type.rx_buffer_index ){
S            ncount = *stCom_type.rx_buffer_index;
S            delay_ms(20);
S            *stCom_type.rx_buffer_index = kdp_uart_GetRxCount( stCom_type.dev_id );
S        }
S        if( *stCom_type.rx_buffer_index > 0 ){
S            #if( COM_DEBUG_LOG_EN == YES)
S            dbg_msg("[com_bus] uart rx receive done ");
S            #endif
S            ret = TRUE; //data at least 1 Byte
S        }
S    }
S#elif ( CFG_COM_BUS_TYPE&COM_BUS_USB_MASK )
S    //USB Busy check
S    //go to USB interface, check bus is busy or idle
S    if ( stCom_type.com_type == DEV_USB )
S    {
S
S    }
S#elif #if ( CFG_COM_BUS_TYPE&COM_BUS_I2C_MASK )
S    //I2C Busy check
S    //go to I2C interface, check bus is busy or idle
S    if (stCom_type.com_type == DEV_I2C )
S    {
S
S    }
S#endif
S
S    return ret; //no data receive
S}
S
Sstatic UINT16 kl520_com_analyze(void)
S{
S    //how many parser type?
S    //head type + tail
S    //no head type+no tail => command only type
S    if ((_user_com_ops) && (_user_com_ops->packet_analyze)) 
S        return _user_com_ops->packet_analyze(&stCom_type);
S    else
S        return kneron_lwcom_packet_analyze( &stCom_type );
S}
S
Sstatic void kl520_com_parser(void)
S{
S    kl520_com_response_Done_check();//work around for uart rx with no tx.
S    // if( stCom_type.no_head_tail_en == 1  )
S    // {
S    //     _kneron_host_com_parser( &stCom_type );		//for future work
S    //     stCom_type.no_head_tail_en = 0;
S    // }
S    // else
S    // {
S    if ((_user_com_ops) && (_user_com_ops->parser)) 
S        return _user_com_ops->parser(&stCom_type);
S    else
S        return kneron_com_parser( &stCom_type );
S        //Kneron API
S        //for add customer parser API
S    //}
S}
S
S
Svoid kl520_com_response_start(void)
S{
S#if ( !(CFG_COM_BUS_TYPE&COM_BUS_SPI_MS_EN) ) && ( ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )&( ~COM_BUS_SPI_MS_EN ) )
S    UINT32	nchecksum =0;
S    UINT16	noffest = 0;
S
S    if( stCom_type.no_head_tail_en == 0 )
S    {
S        *(stCom_type.tx_buffer+ noffest++) = ( COM_BUS_GET_DATA_HEAD_TX>>24 &0xFF );
S        *(stCom_type.tx_buffer+ noffest++) = ( COM_BUS_GET_DATA_HEAD_TX>>16 &0xFF );
S        *(stCom_type.tx_buffer+ noffest++) = ( COM_BUS_GET_DATA_HEAD_TX>>8 &0xFF );
S        *(stCom_type.tx_buffer+ noffest++) = ( COM_BUS_GET_DATA_HEAD_TX>>0 &0xFF );
S    }
S
S    *(stCom_type.tx_buffer+ noffest++) = ( *stCom_type.tx_buffer_index>>24 &0xFF );
S    *(stCom_type.tx_buffer+ noffest++) = ( *stCom_type.tx_buffer_index>>16 &0xFF );
S    *(stCom_type.tx_buffer+ noffest++) = ( *stCom_type.tx_buffer_index>>8 &0xFF );
S    *(stCom_type.tx_buffer+ noffest++) = ( *stCom_type.tx_buffer_index>>0 &0xFF );
S
S    nchecksum = ( *stCom_type.tx_buffer_index>>24 &0xFF ) +( *stCom_type.tx_buffer_index>>16 &0xFF )
S                            +( *stCom_type.tx_buffer_index>>8 &0xFF )+( *stCom_type.tx_buffer_index>>0 &0xFF );
S
S    *(stCom_type.tx_buffer+ noffest++) =  ( nchecksum>>24 &0xFF );
S    *(stCom_type.tx_buffer+ noffest++) =  ( nchecksum>>16 &0xFF );
S    *(stCom_type.tx_buffer+ noffest++) = ( nchecksum>>8 &0xFF );
S    *(stCom_type.tx_buffer+ noffest++) = ( nchecksum>>0 &0xFF );
S
S    if( stCom_type.no_head_tail_en == 0 )
S    {
S        //tail
S        *(stCom_type.tx_buffer+ noffest++) = ( COM_BUS_TAIL_2 );
S        *(stCom_type.tx_buffer+ noffest++) = ( COM_BUS_TAIL_1 );
S    }
S
S    *stCom_type.tx_buffer_index += noffest;
S
S//	kdp_ssp_statemachine( &driver_ssp_ctx, e_spi_disable );
S    kl520_api_ssp_spi1_clear_tx_current_buff_size();
S    kdp_ssp_clear_rxhw( driver_ssp_ctx.reg_base_address );
S    kdp_ssp_clear_txhw( driver_ssp_ctx.reg_base_address );
S//	kdp_ssp_statemachine( &driver_ssp_ctx, e_spi_enable );
S
S  //Need set a GPIO
S    kdp_ssp_pre_write_to_fifo( &driver_ssp_ctx, 5 );
S
S#elif ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
S
S    if( kdp_uart_write( stCom_type.uart_port, stCom_type.tx_buffer, *stCom_type.tx_buffer_index ) == UART_API_ERROR )
S    {
S        #if( COM_DEBUG_LOG_EN == YES)
S        dbg_msg("[com_bus] Response Uart Tx fail ");
S        #endif
S    }
S
S#endif
S
S}
S
S
S
SUINT8 kl520_com_response_Done_check(void)
S{
S    volatile UINT16 current_count = 0, pre_count = 0;    
S#if ( !(CFG_COM_BUS_TYPE&COM_BUS_SPI_MS_EN) ) && ( ( CFG_COM_BUS_TYPE&COM_BUS_SPI_MASK )&( ~COM_BUS_SPI_MS_EN ) )
S    UINT8	response_TO = 0 , response_TO_target = 100;
S
S#ifdef COM_BUS_RESPONSE_REQUEST_PIN
S    if (stCom_type.flags == KL520_COM_HAS_ADDITIONAL_IO)
S    {
S        kdp_slave_request_active();
S    }
S#endif
S
S#if( COM_DEBUG_LOG_EN == YES)
S    dbg_msg("[com_bus] Response SPI Tx wait ing !!!");
S#endif
S    kdp_ssp_clear_tx_done_flag( &driver_ssp_ctx ) ;
S    while( kdp_ssp_get_tx_done_flag( &driver_ssp_ctx ) == 0 )
S    {
S        osDelay(50);
S        response_TO ++;
S        if(response_TO > response_TO_target)
S        {
S#if( COM_DEBUG_LOG_EN == YES)
S            dbg_msg("[com_bus] Response SPI Tx wait Timeout !!!");
S#endif
S            *stCom_type.tx_buffer_index = 0;
S            *stCom_type.rx_buffer_index = 0;
S            kl520_api_ssp_spi1_clear_tx_current_buff_size();
S            kdp_ssp_clear_rxhw( driver_ssp_ctx.reg_base_address );
S            kdp_ssp_clear_txhw( driver_ssp_ctx.reg_base_address );
S            return 0;
S        }
S    }
S
S#if( COM_DEBUG_LOG_EN == YES)
S    dbg_msg("[com_bus] Response SPI Tx wait done!!!");
S#endif
S    while( kdp_ssp_statemachine( &driver_ssp_ctx, e_spi_rx ) == e_spi_ret_rxbusy )
S    {
S        delay_us(30);
S    }
S
S#if( COM_DEBUG_LOG_EN == YES)
S    dbg_msg("[com_bus] Response SPI Tx busy done!!!");
S#endif
S
S#ifdef COM_BUS_RESPONSE_REQUEST_PIN
S    if (stCom_type.flags == KL520_COM_HAS_ADDITIONAL_IO)
S    {
S        kdp_slave_request_inactive();
S    }
S#endif
S
S#if( COM_DEBUG_LOG_EN == YES)
S    dbg_msg("[com_bus] Response SPI Tx Done");
S#endif
S    kdp_ssp_statemachine( &driver_ssp_ctx, e_spi_disable );
S    kdp_ssp_clear_rxhw( driver_ssp_ctx.reg_base_address );
S    kdp_ssp_clear_txhw( driver_ssp_ctx.reg_base_address );
S    kdp_ssp_statemachine( &driver_ssp_ctx, e_spi_enable );
S
S#elif ( CFG_COM_BUS_TYPE&COM_BUS_UART_MASK )
S
S  kdp_uart_read( stCom_type.uart_port, stCom_type.rx_buffer, KDP_DDR_DRV_COM_BUS_RESERVED );
S#if( COM_DEBUG_LOG_EN == YES)
S    dbg_msg("[com_bus] Response Uart Tx Done");
S#endif
S#endif
S
S    //clear all sw buffers
S    *stCom_type.tx_buffer_index = 0;
S    *stCom_type.rx_buffer_index = 0;
S    return 1;
S
S}
S
SUINT16 kl520_com_rx_size(void)
S{
S    return *stCom_type.rx_buffer_index;
S}
S
SUINT8 kl520_com_response( struct st_com_type *st_com )
S{
S    if( *st_com->tx_buffer_index > 0 )
S    {
S        //do response or not !!!
S        kl520_com_response_start();
S        return ( kl520_com_response_Done_check() );
S    }
S
S    return 0;
S}
S
S
S
S//===============================================
S//normal command and analyze
S//===============================================
Svoid kl520_com_thread(void)
S{
S    UINT16	npacket_result = 0;
S    #if( COM_DEBUG_LOG_EN == YES)
S    dbg_msg("[com_bus] communication start ");
S    #endif
S
S#ifdef CFG_USER_CUSTOM_COMM_WHEN_BOOTING
S    user_custom_comm_power_on();
S#endif
S
S    while(1)
S    {
S        osDelay(30);
S        //step1: wait and receive data
S        if( (kl520_com_wait_receive()) && ( kl520_com_rx_size() > 0 ) )
S        {
S            //data analyze!   => user_com.c and user_com.h, need to check host_com or customer_com
S            if( (npacket_result = kl520_com_analyze() ) == COM_BUS_PACKET_OK )
S            {
S                //parser and trigger customer API
S                kl520_com_parser();
S            }
S            else
S            {
S                #if( COM_DEBUG_LOG_EN == YES)
S                dbg_msg("[com_bus] communication analyze fail ");
S                #endif
S
S                //nee tp modify this!!!
S                kneron_lwcom_packet_response_w_tx_buffer( &stCom_type, (UINT8 *)&npacket_result, sizeof(npacket_result) );
S                kl520_com_response( &stCom_type );
S            }
S        #if( COM_DEBUG_LOG_EN == YES)
S        dbg_msg("===========");
S        #endif
S        }
S    }
S
S}
S//===============================================
Sextern void Drv_OTA_Thread( void );
Svoid kl520_com_bus_init(void)
S{
S    Drv_OTA_Thread();
S}
S
Svoid kl520_com_reg_user_ops(kl520_com_user_ops *ops)
S{
S    _user_com_ops = ops;
S}
N#endif
N#endif
N//#endif
N#endif
