; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\rtx_mempool.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\rtx_mempool.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\rtx_mempool.crf F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_mempool.c]
                          THUMB

                          AREA ||i.IsException||, CODE, READONLY, ALIGN=1

                  IsException PROC
;;;122    /// \return     true=exception, false=thread
;;;123    __STATIC_INLINE bool_t IsException (void) {
000000  f3ef8005          MRS      r0,IPSR
000004  2800              CMP      r0,#0
000006  d000              BEQ      |L1.10|
;;;124      return (__get_IPSR() != 0U);
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;125    }
00000a  4770              BX       lr
;;;126    
                          ENDP


                          AREA ||i.IsIrqMasked||, CODE, READONLY, ALIGN=1

                  IsIrqMasked PROC
;;;128    /// \return     true=masked, false=not masked
;;;129    __STATIC_INLINE bool_t IsIrqMasked (void) {
000000  f3ef8010          MRS      r0,PRIMASK
000004  b918              CBNZ     r0,|L2.14|
000006  f3ef8011          MRS      r0,BASEPRI
;;;130    #if   ((defined(__ARM_ARCH_7M__)        && (__ARM_ARCH_7M__        != 0)) || \
;;;131           (defined(__ARM_ARCH_7EM__)       && (__ARM_ARCH_7EM__       != 0)) || \
;;;132           (defined(__ARM_ARCH_8M_MAIN__)   && (__ARM_ARCH_8M_MAIN__   != 0)) || \
;;;133           (defined(__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ != 0)))
;;;134      return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L2.16|
                  |L2.14|
00000e  2001              MOVS     r0,#1
                  |L2.16|
;;;135    #else
;;;136      return  (__get_PRIMASK() != 0U);
;;;137    #endif
;;;138    }
000010  4770              BX       lr
;;;139    
                          ENDP


                          AREA ||i.osMemoryPoolAlloc||, CODE, READONLY, ALIGN=2

                  osMemoryPoolAlloc PROC
;;;615    /// Allocate a memory block from a Memory Pool.
;;;616    void *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;617      void *memory;
;;;618    
;;;619      EvrRtxMemoryPoolAlloc(mp_id, timeout);
000006  f7fffffe          BL       EvrRtxMemoryPoolAlloc
;;;620      if (IsException() || IsIrqMasked()) {
00000a  f7fffffe          BL       IsException
00000e  b910              CBNZ     r0,|L3.22|
000010  f7fffffe          BL       IsIrqMasked
000014  b1d8              CBZ      r0,|L3.78|
                  |L3.22|
;;;621        memory = isrRtxMemoryPoolAlloc(mp_id, timeout);
000016  b11c              CBZ      r4,|L3.32|
000018  7820              LDRB     r0,[r4,#0]
00001a  28f7              CMP      r0,#0xf7
00001c  d100              BNE      |L3.32|
00001e  b135              CBZ      r5,|L3.46|
                  |L3.32|
000020  f06f0103          MVN      r1,#3
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       EvrRtxMemoryPoolError
00002a  2000              MOVS     r0,#0
;;;622      } else {
;;;623        memory =  __svcMemoryPoolAlloc(mp_id, timeout);
;;;624      }
;;;625      return memory;
;;;626    }
00002c  bd70              POP      {r4-r6,pc}
                  |L3.46|
00002e  f104000c          ADD      r0,r4,#0xc
000032  f7fffffe          BL       osRtxMemoryPoolAlloc
000036  0005              MOVS     r5,r0
000038  d005              BEQ      |L3.70|
00003a  4601              MOV      r1,r0
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       EvrRtxMemoryPoolAllocated
                  |L3.66|
000042  4628              MOV      r0,r5
000044  bd70              POP      {r4-r6,pc}
                  |L3.70|
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       EvrRtxMemoryPoolAllocFailed
00004c  e7f9              B        |L3.66|
                  |L3.78|
00004e  4620              MOV      r0,r4                 ;623
000050  4629              MOV      r1,r5                 ;623
000052  f8dfc008          LDR      r12,|L3.92|
000056  df00              SVC      #0x0                  ;623
000058  bd70              POP      {r4-r6,pc}
;;;627    
                          ENDP

00005a  0000              DCW      0x0000
                  |L3.92|
                          DCD      svcRtxMemoryPoolAlloc

                          AREA ||i.osMemoryPoolDelete||, CODE, READONLY, ALIGN=2

                  osMemoryPoolDelete PROC
;;;689    /// Delete a Memory Pool object.
;;;690    osStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;691      osStatus_t status;
;;;692    
;;;693      EvrRtxMemoryPoolDelete(mp_id);
000004  f7fffffe          BL       EvrRtxMemoryPoolDelete
;;;694      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L4.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L4.36|
                  |L4.20|
;;;695        EvrRtxMemoryPoolError(mp_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxMemoryPoolError
;;;696        status = osErrorISR;
000020  4628              MOV      r0,r5
;;;697      } else {
;;;698        status = __svcMemoryPoolDelete(mp_id);
;;;699      }
;;;700      return status;
;;;701    }
000022  bd70              POP      {r4-r6,pc}
                  |L4.36|
000024  4620              MOV      r0,r4                 ;698
000026  f8dfc008          LDR      r12,|L4.48|
00002a  df00              SVC      #0x0                  ;698
00002c  bd70              POP      {r4-r6,pc}
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      svcRtxMemoryPoolDelete

                          AREA ||i.osMemoryPoolFree||, CODE, READONLY, ALIGN=2

                  osMemoryPoolFree PROC
;;;628    /// Return an allocated memory block back to a Memory Pool.
;;;629    osStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block) {
000000  b570              PUSH     {r4-r6,lr}
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;630      osStatus_t status;
;;;631    
;;;632      EvrRtxMemoryPoolFree(mp_id, block);
000006  f7fffffe          BL       EvrRtxMemoryPoolFree
;;;633      if (IsException() || IsIrqMasked()) {
00000a  f7fffffe          BL       IsException
00000e  b910              CBNZ     r0,|L5.22|
000010  f7fffffe          BL       IsIrqMasked
000014  b1f8              CBZ      r0,|L5.86|
                  |L5.22|
;;;634        status = isrRtxMemoryPoolFree(mp_id, block);
000016  b114              CBZ      r4,|L5.30|
000018  7820              LDRB     r0,[r4,#0]
00001a  28f7              CMP      r0,#0xf7
00001c  d006              BEQ      |L5.44|
                  |L5.30|
00001e  f06f0503          MVN      r5,#3
000022  4629              MOV      r1,r5
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       EvrRtxMemoryPoolError
00002a  e00a              B        |L5.66|
                  |L5.44|
00002c  4631              MOV      r1,r6
00002e  f104000c          ADD      r0,r4,#0xc
000032  f7fffffe          BL       osRtxMemoryPoolFree
000036  0005              MOVS     r5,r0
000038  d005              BEQ      |L5.70|
00003a  4631              MOV      r1,r6
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       EvrRtxMemoryPoolFreeFailed
                  |L5.66|
000042  4628              MOV      r0,r5
;;;635      } else {
;;;636        status =  __svcMemoryPoolFree(mp_id, block);
;;;637      }
;;;638      return status;
;;;639    }
000044  bd70              POP      {r4-r6,pc}
                  |L5.70|
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       osRtxPostProcess
00004c  4631              MOV      r1,r6
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       EvrRtxMemoryPoolDeallocated
000054  e7f5              B        |L5.66|
                  |L5.86|
000056  4620              MOV      r0,r4                 ;636
000058  4631              MOV      r1,r6                 ;636
00005a  f8dfc008          LDR      r12,|L5.100|
00005e  df00              SVC      #0x0                  ;636
000060  bd70              POP      {r4-r6,pc}
;;;640    
                          ENDP

000062  0000              DCW      0x0000
                  |L5.100|
                          DCD      svcRtxMemoryPoolFree

                          AREA ||i.osMemoryPoolGetBlockSize||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetBlockSize PROC
;;;653    /// Get memory block size in a Memory Pool.
;;;654    uint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;655      uint32_t block_size;
;;;656    
;;;657      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L6.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b120              CBZ      r0,|L6.26|
                  |L6.16|
;;;658        block_size = svcRtxMemoryPoolGetBlockSize(mp_id);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      svcRtxMemoryPoolGetBlockSize
                  |L6.26|
;;;659      } else {
;;;660        block_size =  __svcMemoryPoolGetBlockSize(mp_id);
00001a  4620              MOV      r0,r4
00001c  f8dfc004          LDR      r12,|L6.36|
000020  df00              SVC      #0x0
;;;661      }
;;;662      return block_size;
;;;663    }
000022  bd10              POP      {r4,pc}
;;;664    
                          ENDP

                  |L6.36|
                          DCD      svcRtxMemoryPoolGetBlockSize

                          AREA ||i.osMemoryPoolGetCapacity||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetCapacity PROC
;;;641    /// Get maximum number of memory blocks in a Memory Pool.
;;;642    uint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;643      uint32_t capacity;
;;;644    
;;;645      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L7.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b120              CBZ      r0,|L7.26|
                  |L7.16|
;;;646        capacity = svcRtxMemoryPoolGetCapacity(mp_id);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      svcRtxMemoryPoolGetCapacity
                  |L7.26|
;;;647      } else {
;;;648        capacity =  __svcMemoryPoolGetCapacity(mp_id);
00001a  4620              MOV      r0,r4
00001c  f8dfc004          LDR      r12,|L7.36|
000020  df00              SVC      #0x0
;;;649      }
;;;650      return capacity;
;;;651    }
000022  bd10              POP      {r4,pc}
;;;652    
                          ENDP

                  |L7.36|
                          DCD      svcRtxMemoryPoolGetCapacity

                          AREA ||i.osMemoryPoolGetCount||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetCount PROC
;;;665    /// Get number of memory blocks used in a Memory Pool.
;;;666    uint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;667      uint32_t count;
;;;668    
;;;669      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L8.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b120              CBZ      r0,|L8.26|
                  |L8.16|
;;;670        count = svcRtxMemoryPoolGetCount(mp_id);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      svcRtxMemoryPoolGetCount
                  |L8.26|
;;;671      } else {
;;;672        count =  __svcMemoryPoolGetCount(mp_id);
00001a  4620              MOV      r0,r4
00001c  f8dfc004          LDR      r12,|L8.36|
000020  df00              SVC      #0x0
;;;673      }
;;;674      return count;
;;;675    }
000022  bd10              POP      {r4,pc}
;;;676    
                          ENDP

                  |L8.36|
                          DCD      svcRtxMemoryPoolGetCount

                          AREA ||i.osMemoryPoolGetName||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetName PROC
;;;602    /// Get name of a Memory Pool object.
;;;603    const char *osMemoryPoolGetName (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;604      const char *name;
;;;605    
;;;606      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L9.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b128              CBZ      r0,|L9.28|
                  |L9.16|
;;;607        EvrRtxMemoryPoolGetName(mp_id, NULL);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxMemoryPoolGetName
;;;608        name = NULL;
000018  2000              MOVS     r0,#0
;;;609      } else {
;;;610        name = __svcMemoryPoolGetName(mp_id);
;;;611      }
;;;612      return name;
;;;613    }
00001a  bd10              POP      {r4,pc}
                  |L9.28|
00001c  4620              MOV      r0,r4                 ;610
00001e  f8dfc008          LDR      r12,|L9.40|
000022  df00              SVC      #0x0                  ;610
000024  bd10              POP      {r4,pc}
;;;614    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      svcRtxMemoryPoolGetName

                          AREA ||i.osMemoryPoolGetSpace||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetSpace PROC
;;;677    /// Get number of memory blocks available in a Memory Pool.
;;;678    uint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;679      uint32_t space;
;;;680    
;;;681      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L10.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b120              CBZ      r0,|L10.26|
                  |L10.16|
;;;682        space = svcRtxMemoryPoolGetSpace(mp_id);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      svcRtxMemoryPoolGetSpace
                  |L10.26|
;;;683      } else {
;;;684        space =  __svcMemoryPoolGetSpace(mp_id);
00001a  4620              MOV      r0,r4
00001c  f8dfc004          LDR      r12,|L10.36|
000020  df00              SVC      #0x0
;;;685      }
;;;686      return space;
;;;687    }
000022  bd10              POP      {r4,pc}
;;;688    
                          ENDP

                  |L10.36|
                          DCD      svcRtxMemoryPoolGetSpace

                          AREA ||i.osMemoryPoolNew||, CODE, READONLY, ALIGN=2

                  osMemoryPoolNew PROC
;;;588    /// Create and Initialize a Memory Pool object.
;;;589    osMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr) {
000000  b570              PUSH     {r4-r6,lr}
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;590      osMemoryPoolId_t mp_id;
;;;591    
;;;592      EvrRtxMemoryPoolNew(block_count, block_size, attr);
000008  f7fffffe          BL       EvrRtxMemoryPoolNew
;;;593      if (IsException() || IsIrqMasked()) {
00000c  f7fffffe          BL       IsException
000010  b910              CBNZ     r0,|L11.24|
000012  f7fffffe          BL       IsIrqMasked
000016  b130              CBZ      r0,|L11.38|
                  |L11.24|
;;;594        EvrRtxMemoryPoolError(NULL, (int32_t)osErrorISR);
000018  f06f0105          MVN      r1,#5
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       EvrRtxMemoryPoolError
;;;595        mp_id = NULL;
000022  2000              MOVS     r0,#0
;;;596      } else {
;;;597        mp_id = __svcMemoryPoolNew(block_count, block_size, attr);
;;;598      }
;;;599      return mp_id;
;;;600    }
000024  bd70              POP      {r4-r6,pc}
                  |L11.38|
000026  4630              MOV      r0,r6                 ;597
000028  4629              MOV      r1,r5                 ;597
00002a  4622              MOV      r2,r4                 ;597
00002c  f8dfc004          LDR      r12,|L11.52|
000030  df00              SVC      #0x0                  ;597
000032  bd70              POP      {r4-r6,pc}
;;;601    
                          ENDP

                  |L11.52|
                          DCD      svcRtxMemoryPoolNew

                          AREA ||i.osRtxMemoryPoolAlloc||, CODE, READONLY, ALIGN=1

                  osRtxMemoryPoolAlloc PROC
;;;80     /// \return address of the allocated memory block or NULL in case of no memory is available.
;;;81     void *osRtxMemoryPoolAlloc (os_mp_info_t *mp_info) {
000000  b570              PUSH     {r4-r6,lr}
000002  0004              MOVS     r4,r0
000004  d00e              BEQ      |L12.36|
;;;82     #if (EXCLUSIVE_ACCESS == 0)
;;;83       uint32_t primask = __get_PRIMASK();
;;;84     #endif
;;;85       void *block;
;;;86     
;;;87       if (mp_info == NULL) {
;;;88         EvrRtxMemoryBlockAlloc(NULL, NULL);
;;;89         //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;90         return NULL;
;;;91       }
;;;92     
;;;93     #if (EXCLUSIVE_ACCESS == 0)
;;;94       __disable_irq();
;;;95     
;;;96       block = mp_info->block_free;
;;;97       if (block != NULL) {
;;;98         //lint --e{9079} --e{9087} "conversion from pointer to void to pointer to other type"
;;;99         mp_info->block_free = *((void **)block);
;;;100        mp_info->used_blocks++;
;;;101      }
;;;102    
;;;103      if (primask == 0U) {
;;;104        __enable_irq();
;;;105      }
;;;106    #else
;;;107      block = atomic_link_get(&mp_info->block_free);
000006  f1040014          ADD      r0,r4,#0x14
00000a  f7fffffe          BL       __asm___13_rtx_mempool_c_c97899d2__atomic_link_get
00000e  0005              MOVS     r5,r0
;;;108      if (block != NULL) {
000010  d002              BEQ      |L12.24|
;;;109        (void)atomic_inc32(&mp_info->used_blocks);
000012  1d20              ADDS     r0,r4,#4
000014  f7fffffe          BL       __asm___13_rtx_mempool_c_c97899d2__atomic_inc32
                  |L12.24|
;;;110      }
;;;111    #endif
;;;112    
;;;113      EvrRtxMemoryBlockAlloc(mp_info, block);
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxMemoryBlockAlloc
;;;114    
;;;115      return block;
000020  4628              MOV      r0,r5
;;;116    }
000022  bd70              POP      {r4-r6,pc}
                  |L12.36|
000024  2100              MOVS     r1,#0                 ;88
000026  4608              MOV      r0,r1                 ;88
000028  f7fffffe          BL       EvrRtxMemoryBlockAlloc
00002c  2000              MOVS     r0,#0                 ;90
00002e  bd70              POP      {r4-r6,pc}
;;;117    
                          ENDP


                          AREA ||i.osRtxMemoryPoolFree||, CODE, READONLY, ALIGN=1

                  osRtxMemoryPoolFree PROC
;;;121    /// \return status code that indicates the execution status of the function.
;;;122    osStatus_t osRtxMemoryPoolFree (os_mp_info_t *mp_info, void *block) {
000000  b570              PUSH     {r4-r6,lr}
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
000006  d005              BEQ      |L13.20|
;;;123    #if (EXCLUSIVE_ACCESS == 0)
;;;124      uint32_t primask = __get_PRIMASK();
;;;125    #endif
;;;126    
;;;127      //lint -e{946} "Relational operator applied to pointers"
;;;128      if ((mp_info == NULL) || (block < mp_info->block_base) || (block >= mp_info->block_lim)) {
000008  68e0              LDR      r0,[r4,#0xc]
00000a  42a8              CMP      r0,r5
00000c  d802              BHI      |L13.20|
00000e  6920              LDR      r0,[r4,#0x10]
000010  42a8              CMP      r0,r5
000012  d807              BHI      |L13.36|
                  |L13.20|
;;;129        EvrRtxMemoryBlockFree(mp_info, block, (int32_t)osErrorParameter);
000014  f06f0603          MVN      r6,#3
000018  4632              MOV      r2,r6
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxMemoryBlockFree
;;;130        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;131        return osErrorParameter;
000020  4630              MOV      r0,r6
;;;132      }
;;;133    
;;;134    #if (EXCLUSIVE_ACCESS == 0)
;;;135      __disable_irq();
;;;136    
;;;137      //lint --e{9079} --e{9087} "conversion from pointer to void to pointer to other type"
;;;138      *((void **)block) = mp_info->block_free;
;;;139      mp_info->block_free = block;
;;;140      mp_info->used_blocks--;
;;;141    
;;;142      if (primask == 0U) {
;;;143        __enable_irq();
;;;144      }
;;;145    #else
;;;146      atomic_link_put(&mp_info->block_free, block);
;;;147      (void)atomic_dec32(&mp_info->used_blocks);
;;;148    #endif
;;;149    
;;;150      EvrRtxMemoryBlockFree(mp_info, block, (int32_t)osOK);
;;;151    
;;;152      return osOK;
;;;153    }
000022  bd70              POP      {r4-r6,pc}
                  |L13.36|
000024  f1040014          ADD      r0,r4,#0x14           ;146
000028  f7fffffe          BL       __asm___13_rtx_mempool_c_c97899d2__atomic_link_put
00002c  1d20              ADDS     r0,r4,#4              ;147
00002e  f7fffffe          BL       __asm___13_rtx_mempool_c_c97899d2__atomic_dec32
000032  2200              MOVS     r2,#0                 ;150
000034  4629              MOV      r1,r5                 ;150
000036  4620              MOV      r0,r4                 ;150
000038  f7fffffe          BL       EvrRtxMemoryBlockFree
00003c  2000              MOVS     r0,#0                 ;152
00003e  bd70              POP      {r4-r6,pc}
;;;154    
                          ENDP


                          AREA ||i.osRtxMemoryPoolInit||, CODE, READONLY, ALIGN=1

                  osRtxMemoryPoolInit PROC
;;;44     /// \return 1 - success, 0 - failure.
;;;45     uint32_t osRtxMemoryPoolInit (os_mp_info_t *mp_info, uint32_t block_count, uint32_t block_size, void *block_mem) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461c              MOV      r4,r3
000006  4616              MOV      r6,r2
000008  460d              MOV      r5,r1
00000a  b188              CBZ      r0,|L14.48|
;;;46       //lint --e{9079} --e{9087} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
;;;47       void *mem;
;;;48       void *block;
;;;49     
;;;50       // Check parameters
;;;51       if ((mp_info == NULL) || (block_count == 0U) || (block_size  == 0U) || (block_mem  == NULL)) {
00000c  b185              CBZ      r5,|L14.48|
00000e  b17e              CBZ      r6,|L14.48|
000010  b174              CBZ      r4,|L14.48|
;;;52         //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;53         return 0U;
;;;54       }
;;;55     
;;;56       // Initialize information structure
;;;57       mp_info->max_blocks  = block_count;
;;;58       mp_info->used_blocks = 0U;
000012  e9c06402          STRD     r6,r4,[r0,#8]
;;;59       mp_info->block_size  = block_size;
;;;60       mp_info->block_base  = block_mem;
;;;61       mp_info->block_free  = block_mem;
;;;62       mp_info->block_lim   = &(((uint8_t *)block_mem)[block_count * block_size]);
000016  fb054106          MLA      r1,r5,r6,r4
;;;63     
;;;64       EvrRtxMemoryBlockInit(mp_info, block_count, block_size, block_mem);
00001a  e9c01404          STRD     r1,r4,[r0,#0x10]
00001e  2700              MOVS     r7,#0                 ;58
000020  e9c05700          STRD     r5,r7,[r0,#0]
000024  4623              MOV      r3,r4
000026  4632              MOV      r2,r6
000028  4629              MOV      r1,r5
00002a  f7fffffe          BL       EvrRtxMemoryBlockInit
;;;65     
;;;66       // Link all free blocks
;;;67       mem = block_mem;
;;;68       while (--block_count != 0U) {
00002e  e005              B        |L14.60|
                  |L14.48|
000030  2000              MOVS     r0,#0                 ;53
                  |L14.50|
;;;69         block = &((uint8_t *)mem)[block_size];
;;;70         *((void **)mem) = block;
;;;71         mem = block;
;;;72       }
;;;73       *((void **)mem) = NULL;
;;;74     
;;;75       return 1U;
;;;76     }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L14.54|
000036  19a0              ADDS     r0,r4,r6              ;69
000038  6020              STR      r0,[r4,#0]            ;71
00003a  4604              MOV      r4,r0                 ;71
                  |L14.60|
00003c  1e6d              SUBS     r5,r5,#1              ;71
00003e  d1fa              BNE      |L14.54|
000040  2001              MOVS     r0,#1                 ;75
000042  6027              STR      r7,[r4,#0]            ;75
000044  e7f5              B        |L14.50|
;;;77     
                          ENDP


                          AREA ||i.osRtxMemoryPoolPostProcess||, CODE, READONLY, ALIGN=1

                  osRtxMemoryPoolPostProcess PROC
;;;159    /// \param[in]  mp              memory pool object.
;;;160    static void osRtxMemoryPoolPostProcess (os_memory_pool_t *mp) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;161      void        *block;
;;;162      os_thread_t *thread;
;;;163    
;;;164      // Check if Thread is waiting to allocate memory
;;;165      if (mp->thread_list != NULL) {
000004  6880              LDR      r0,[r0,#8]
000006  2800              CMP      r0,#0                 ;160
000008  d012              BEQ      |L15.48|
;;;166        // Allocate memory
;;;167        block = osRtxMemoryPoolAlloc(&mp->mp_info);
00000a  f104000c          ADD      r0,r4,#0xc
00000e  f7fffffe          BL       osRtxMemoryPoolAlloc
000012  0005              MOVS     r5,r0
;;;168        if (block != NULL) {
000014  d00c              BEQ      |L15.48|
;;;169          // Wakeup waiting Thread with highest Priority
;;;170          thread = osRtxThreadListGet(osRtxObject(mp));
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       osRtxThreadListGet
;;;171          //lint -e{923} "cast from pointer to unsigned int"
;;;172          osRtxThreadWaitExit(thread, (uint32_t)block, FALSE);
00001c  2200              MOVS     r2,#0
00001e  4629              MOV      r1,r5
000020  f7fffffe          BL       osRtxThreadWaitExit
;;;173          EvrRtxMemoryPoolAllocated(mp, block);
000024  4629              MOV      r1,r5
000026  4620              MOV      r0,r4
000028  e8bd4070          POP      {r4-r6,lr}
00002c  f7ffbffe          B.W      EvrRtxMemoryPoolAllocated
                  |L15.48|
;;;174        }
;;;175      }
;;;176    }
000030  bd70              POP      {r4-r6,pc}
;;;177    
                          ENDP


                          AREA ||i.svcRtxMemoryPoolAlloc||, CODE, READONLY, ALIGN=2

                  svcRtxMemoryPoolAlloc PROC
;;;330    /// \note API identical to osMemoryPoolAlloc
;;;331    static void *svcRtxMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
;;;332      os_memory_pool_t *mp = osRtxMemoryPoolId(mp_id);
000004  0004              MOVS     r4,r0
000006  d002              BEQ      |L16.14|
;;;333      void             *block;
;;;334    
;;;335      // Check parameters
;;;336      if ((mp == NULL) || (mp->id != osRtxIdMemoryPool)) {
000008  7820              LDRB     r0,[r4,#0]
00000a  28f7              CMP      r0,#0xf7
00000c  d006              BEQ      |L16.28|
                  |L16.14|
;;;337        EvrRtxMemoryPoolError(mp, (int32_t)osErrorParameter);
00000e  f06f0103          MVN      r1,#3
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxMemoryPoolError
;;;338        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;339        return NULL;
000018  2000              MOVS     r0,#0
;;;340      }
;;;341    
;;;342      // Allocate memory
;;;343      block = osRtxMemoryPoolAlloc(&mp->mp_info);
;;;344      if (block != NULL) {
;;;345        EvrRtxMemoryPoolAllocated(mp, block);
;;;346      } else {
;;;347        // No memory available
;;;348        if (timeout != 0U) {
;;;349          EvrRtxMemoryPoolAllocPending(mp, timeout);
;;;350          // Suspend current Thread
;;;351          if (osRtxThreadWaitEnter(osRtxThreadWaitingMemoryPool, timeout)) {
;;;352            osRtxThreadListPut(osRtxObject(mp), osRtxThreadGetRunning());
;;;353          } else {
;;;354            EvrRtxMemoryPoolAllocTimeout(mp);
;;;355          }
;;;356        } else {
;;;357          EvrRtxMemoryPoolAllocFailed(mp);
;;;358        }
;;;359      }
;;;360    
;;;361      return block;
;;;362    }
00001a  bd70              POP      {r4-r6,pc}
                  |L16.28|
00001c  f104000c          ADD      r0,r4,#0xc            ;343
000020  f7fffffe          BL       osRtxMemoryPoolAlloc
000024  0006              MOVS     r6,r0                 ;343
000026  d004              BEQ      |L16.50|
000028  4601              MOV      r1,r0                 ;345
00002a  4620              MOV      r0,r4                 ;345
00002c  f7fffffe          BL       EvrRtxMemoryPoolAllocated
000030  e016              B        |L16.96|
                  |L16.50|
000032  b195              CBZ      r5,|L16.90|
000034  4629              MOV      r1,r5                 ;349
000036  4620              MOV      r0,r4                 ;349
000038  f7fffffe          BL       EvrRtxMemoryPoolAllocPending
00003c  4629              MOV      r1,r5                 ;351
00003e  2073              MOVS     r0,#0x73              ;351
000040  f7fffffe          BL       osRtxThreadWaitEnter
000044  b128              CBZ      r0,|L16.82|
000046  4807              LDR      r0,|L16.100|
000048  6941              LDR      r1,[r0,#0x14]         ;352  ; osRtxInfo
00004a  4620              MOV      r0,r4                 ;352
00004c  f7fffffe          BL       osRtxThreadListPut
000050  e006              B        |L16.96|
                  |L16.82|
000052  4620              MOV      r0,r4                 ;354
000054  f7fffffe          BL       EvrRtxMemoryPoolAllocTimeout
000058  e002              B        |L16.96|
                  |L16.90|
00005a  4620              MOV      r0,r4                 ;357
00005c  f7fffffe          BL       EvrRtxMemoryPoolAllocFailed
                  |L16.96|
000060  4630              MOV      r0,r6                 ;361
000062  bd70              POP      {r4-r6,pc}
;;;363    
                          ENDP

                  |L16.100|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxMemoryPoolDelete||, CODE, READONLY, ALIGN=2

                  svcRtxMemoryPoolDelete PROC
;;;471    /// \note API identical to osMemoryPoolDelete
;;;472    static osStatus_t svcRtxMemoryPoolDelete (osMemoryPoolId_t mp_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;473      os_memory_pool_t *mp = osRtxMemoryPoolId(mp_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L17.12|
;;;474      os_thread_t      *thread;
;;;475    
;;;476      // Check parameters
;;;477      if ((mp == NULL) || (mp->id != osRtxIdMemoryPool)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f7              CMP      r0,#0xf7
00000a  d007              BEQ      |L17.28|
                  |L17.12|
;;;478        EvrRtxMemoryPoolError(mp, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxMemoryPoolError
;;;479        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;480        return osErrorParameter;
000018  4628              MOV      r0,r5
;;;481      }
;;;482    
;;;483      // Unblock waiting threads
;;;484      if (mp->thread_list != NULL) {
;;;485        do {
;;;486          thread = osRtxThreadListGet(osRtxObject(mp));
;;;487          osRtxThreadWaitExit(thread, 0U, FALSE);
;;;488        } while (mp->thread_list != NULL);
;;;489        osRtxThreadDispatch(NULL);
;;;490      }
;;;491    
;;;492      // Mark object as invalid
;;;493      mp->id = osRtxIdInvalid;
;;;494    
;;;495      // Free data memory
;;;496      if ((mp->flags & osRtxFlagSystemMemory) != 0U) {
;;;497        (void)osRtxMemoryFree(osRtxInfo.mem.mp_data, mp->mp_info.block_base);
;;;498      }
;;;499    
;;;500      // Free object memory
;;;501      if ((mp->flags & osRtxFlagSystemObject) != 0U) {
;;;502        if (osRtxInfo.mpi.memory_pool != NULL) {
;;;503          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.memory_pool, mp);
;;;504        } else {
;;;505          (void)osRtxMemoryFree(osRtxInfo.mem.common, mp);
;;;506        }
;;;507    #ifdef RTX_OBJ_MEM_USAGE
;;;508        osRtxMemoryPoolMemUsage.cnt_free++;
;;;509    #endif
;;;510      }
;;;511    
;;;512      EvrRtxMemoryPoolDestroyed(mp);
;;;513    
;;;514      return osOK;
;;;515    }
00001a  bd70              POP      {r4-r6,pc}
                  |L17.28|
00001c  68a0              LDR      r0,[r4,#8]            ;484
00001e  b158              CBZ      r0,|L17.56|
                  |L17.32|
000020  4620              MOV      r0,r4                 ;486
000022  f7fffffe          BL       osRtxThreadListGet
000026  2200              MOVS     r2,#0                 ;487
000028  4611              MOV      r1,r2                 ;487
00002a  f7fffffe          BL       osRtxThreadWaitExit
00002e  68a0              LDR      r0,[r4,#8]            ;488
000030  2800              CMP      r0,#0                 ;488
000032  d1f5              BNE      |L17.32|
000034  f7fffffe          BL       osRtxThreadDispatch
                  |L17.56|
000038  2000              MOVS     r0,#0                 ;493
00003a  7020              STRB     r0,[r4,#0]            ;493
00003c  78a0              LDRB     r0,[r4,#2]            ;496
00003e  4d0f              LDR      r5,|L17.124|
000040  0780              LSLS     r0,r0,#30             ;496
000042  d503              BPL      |L17.76|
000044  69a1              LDR      r1,[r4,#0x18]         ;497
000046  6fa8              LDR      r0,[r5,#0x78]         ;497  ; osRtxInfo
000048  f7fffffe          BL       osRtxMemoryFree
                  |L17.76|
00004c  78a0              LDRB     r0,[r4,#2]            ;501
00004e  07c0              LSLS     r0,r0,#31             ;501
000050  d00f              BEQ      |L17.114|
000052  f8d5009c          LDR      r0,[r5,#0x9c]         ;502  ; osRtxInfo
000056  b118              CBZ      r0,|L17.96|
000058  4621              MOV      r1,r4                 ;503
00005a  f7fffffe          BL       osRtxMemoryPoolFree
00005e  e004              B        |L17.106|
                  |L17.96|
000060  4621              MOV      r1,r4                 ;505
000062  f8d50080          LDR      r0,[r5,#0x80]         ;505  ; osRtxInfo
000066  f7fffffe          BL       osRtxMemoryFree
                  |L17.106|
00006a  4805              LDR      r0,|L17.128|
00006c  6841              LDR      r1,[r0,#4]            ;508  ; osRtxMemoryPoolMemUsage
00006e  1c49              ADDS     r1,r1,#1              ;508
000070  6041              STR      r1,[r0,#4]            ;508  ; osRtxMemoryPoolMemUsage
                  |L17.114|
000072  4620              MOV      r0,r4                 ;512
000074  f7fffffe          BL       EvrRtxMemoryPoolDestroyed
000078  2000              MOVS     r0,#0                 ;514
00007a  bd70              POP      {r4-r6,pc}
;;;516    
                          ENDP

                  |L17.124|
                          DCD      osRtxInfo
                  |L17.128|
                          DCD      ||.data.os.mempool.obj||

                          AREA ||i.svcRtxMemoryPoolFree||, CODE, READONLY, ALIGN=1

                  svcRtxMemoryPoolFree PROC
;;;365    /// \note API identical to osMemoryPoolFree
;;;366    static osStatus_t svcRtxMemoryPoolFree (osMemoryPoolId_t mp_id, void *block) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  460d              MOV      r5,r1
;;;367      os_memory_pool_t *mp = osRtxMemoryPoolId(mp_id);
000006  0004              MOVS     r4,r0
000008  d002              BEQ      |L18.16|
;;;368      void             *block0;
;;;369      os_thread_t      *thread;
;;;370      osStatus_t        status;
;;;371    
;;;372      // Check parameters
;;;373      if ((mp == NULL) || (mp->id != osRtxIdMemoryPool)) {
00000a  7820              LDRB     r0,[r4,#0]
00000c  28f7              CMP      r0,#0xf7
00000e  d008              BEQ      |L18.34|
                  |L18.16|
;;;374        EvrRtxMemoryPoolError(mp, (int32_t)osErrorParameter);
000010  f06f0503          MVN      r5,#3
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       EvrRtxMemoryPoolError
;;;375        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;376        return osErrorParameter;
00001c  4628              MOV      r0,r5
                  |L18.30|
;;;377      }
;;;378    
;;;379      // Free memory
;;;380      status = osRtxMemoryPoolFree(&mp->mp_info, block);
;;;381      if (status == osOK) {
;;;382        EvrRtxMemoryPoolDeallocated(mp, block);
;;;383        // Check if Thread is waiting to allocate memory
;;;384        if (mp->thread_list != NULL) {
;;;385          // Allocate memory
;;;386          block0 = osRtxMemoryPoolAlloc(&mp->mp_info);
;;;387          if (block0 != NULL) {
;;;388            // Wakeup waiting Thread with highest Priority
;;;389            thread = osRtxThreadListGet(osRtxObject(mp));
;;;390            //lint -e{923} "cast from pointer to unsigned int"
;;;391            osRtxThreadWaitExit(thread, (uint32_t)block0, TRUE);
;;;392            EvrRtxMemoryPoolAllocated(mp, block0);
;;;393          }
;;;394        }
;;;395      } else {
;;;396        EvrRtxMemoryPoolFreeFailed(mp, block);
;;;397      }
;;;398    
;;;399      return status;
;;;400    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L18.34|
000022  f104000c          ADD      r0,r4,#0xc            ;380
000026  4607              MOV      r7,r0                 ;380
000028  f7fffffe          BL       osRtxMemoryPoolFree
00002c  0006              MOVS     r6,r0                 ;380
00002e  4629              MOV      r1,r5                 ;396
000030  4620              MOV      r0,r4                 ;396
000032  d003              BEQ      |L18.60|
000034  f7fffffe          BL       EvrRtxMemoryPoolFreeFailed
                  |L18.56|
000038  4630              MOV      r0,r6                 ;399
00003a  e7f0              B        |L18.30|
                  |L18.60|
00003c  f7fffffe          BL       EvrRtxMemoryPoolDeallocated
000040  68a0              LDR      r0,[r4,#8]            ;384
000042  2800              CMP      r0,#0                 ;384
000044  d0f8              BEQ      |L18.56|
000046  4638              MOV      r0,r7                 ;384
000048  f7fffffe          BL       osRtxMemoryPoolAlloc
00004c  0005              MOVS     r5,r0                 ;386
00004e  d0f3              BEQ      |L18.56|
000050  4620              MOV      r0,r4                 ;389
000052  f7fffffe          BL       osRtxThreadListGet
000056  2201              MOVS     r2,#1                 ;391
000058  4629              MOV      r1,r5                 ;391
00005a  f7fffffe          BL       osRtxThreadWaitExit
00005e  4629              MOV      r1,r5                 ;392
000060  4620              MOV      r0,r4                 ;392
000062  f7fffffe          BL       EvrRtxMemoryPoolAllocated
000066  e7e7              B        |L18.56|
;;;401    
                          ENDP


                          AREA ||i.svcRtxMemoryPoolGetBlockSize||, CODE, READONLY, ALIGN=1

                  svcRtxMemoryPoolGetBlockSize PROC
;;;420    /// \note API identical to osMemoryPoolGetBlockSize
;;;421    static uint32_t svcRtxMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
;;;422      os_memory_pool_t *mp = osRtxMemoryPoolId(mp_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L19.12|
;;;423    
;;;424      // Check parameters
;;;425      if ((mp == NULL) || (mp->id != osRtxIdMemoryPool)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f7              CMP      r0,#0xf7
00000a  d005              BEQ      |L19.24|
                  |L19.12|
;;;426        EvrRtxMemoryPoolGetBlockSize(mp, 0U);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxMemoryPoolGetBlockSize
;;;427        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;428        return 0U;
000014  2000              MOVS     r0,#0
;;;429      }
;;;430    
;;;431      EvrRtxMemoryPoolGetBlockSize(mp, mp->mp_info.block_size);
;;;432    
;;;433      return mp->mp_info.block_size;
;;;434    }
000016  bd10              POP      {r4,pc}
                  |L19.24|
000018  4620              MOV      r0,r4                 ;431
00001a  6961              LDR      r1,[r4,#0x14]         ;431
00001c  f7fffffe          BL       EvrRtxMemoryPoolGetBlockSize
000020  6960              LDR      r0,[r4,#0x14]         ;433
000022  bd10              POP      {r4,pc}
;;;435    
                          ENDP


                          AREA ||i.svcRtxMemoryPoolGetCapacity||, CODE, READONLY, ALIGN=1

                  svcRtxMemoryPoolGetCapacity PROC
;;;403    /// \note API identical to osMemoryPoolGetCapacity
;;;404    static uint32_t svcRtxMemoryPoolGetCapacity (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
;;;405      os_memory_pool_t *mp = osRtxMemoryPoolId(mp_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L20.12|
;;;406    
;;;407      // Check parameters
;;;408      if ((mp == NULL) || (mp->id != osRtxIdMemoryPool)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f7              CMP      r0,#0xf7
00000a  d005              BEQ      |L20.24|
                  |L20.12|
;;;409        EvrRtxMemoryPoolGetCapacity(mp, 0U);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxMemoryPoolGetCapacity
;;;410        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;411        return 0U;
000014  2000              MOVS     r0,#0
;;;412      }
;;;413    
;;;414      EvrRtxMemoryPoolGetCapacity(mp, mp->mp_info.max_blocks);
;;;415    
;;;416      return mp->mp_info.max_blocks;
;;;417    }
000016  bd10              POP      {r4,pc}
                  |L20.24|
000018  4620              MOV      r0,r4                 ;414
00001a  68e1              LDR      r1,[r4,#0xc]          ;414
00001c  f7fffffe          BL       EvrRtxMemoryPoolGetCapacity
000020  68e0              LDR      r0,[r4,#0xc]          ;416
000022  bd10              POP      {r4,pc}
;;;418    
                          ENDP


                          AREA ||i.svcRtxMemoryPoolGetCount||, CODE, READONLY, ALIGN=1

                  svcRtxMemoryPoolGetCount PROC
;;;437    /// \note API identical to osMemoryPoolGetCount
;;;438    static uint32_t svcRtxMemoryPoolGetCount (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
;;;439      os_memory_pool_t *mp = osRtxMemoryPoolId(mp_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L21.12|
;;;440    
;;;441      // Check parameters
;;;442      if ((mp == NULL) || (mp->id != osRtxIdMemoryPool)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f7              CMP      r0,#0xf7
00000a  d005              BEQ      |L21.24|
                  |L21.12|
;;;443        EvrRtxMemoryPoolGetCount(mp, 0U);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxMemoryPoolGetCount
;;;444        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;445        return 0U;
000014  2000              MOVS     r0,#0
;;;446      }
;;;447    
;;;448      EvrRtxMemoryPoolGetCount(mp, mp->mp_info.used_blocks);
;;;449    
;;;450      return mp->mp_info.used_blocks;
;;;451    }
000016  bd10              POP      {r4,pc}
                  |L21.24|
000018  4620              MOV      r0,r4                 ;448
00001a  6921              LDR      r1,[r4,#0x10]         ;448
00001c  f7fffffe          BL       EvrRtxMemoryPoolGetCount
000020  6920              LDR      r0,[r4,#0x10]         ;450
000022  bd10              POP      {r4,pc}
;;;452    
                          ENDP


                          AREA ||i.svcRtxMemoryPoolGetName||, CODE, READONLY, ALIGN=1

                  svcRtxMemoryPoolGetName PROC
;;;313    /// \note API identical to osMemoryPoolGetName
;;;314    static const char *svcRtxMemoryPoolGetName (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
;;;315      os_memory_pool_t *mp = osRtxMemoryPoolId(mp_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L22.12|
;;;316    
;;;317      // Check parameters
;;;318      if ((mp == NULL) || (mp->id != osRtxIdMemoryPool)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f7              CMP      r0,#0xf7
00000a  d005              BEQ      |L22.24|
                  |L22.12|
;;;319        EvrRtxMemoryPoolGetName(mp, NULL);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxMemoryPoolGetName
;;;320        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;321        return NULL;
000014  2000              MOVS     r0,#0
;;;322      }
;;;323    
;;;324      EvrRtxMemoryPoolGetName(mp, mp->name);
;;;325    
;;;326      return mp->name;
;;;327    }
000016  bd10              POP      {r4,pc}
                  |L22.24|
000018  4620              MOV      r0,r4                 ;324
00001a  6861              LDR      r1,[r4,#4]            ;324
00001c  f7fffffe          BL       EvrRtxMemoryPoolGetName
000020  6860              LDR      r0,[r4,#4]            ;326
000022  bd10              POP      {r4,pc}
;;;328    
                          ENDP


                          AREA ||i.svcRtxMemoryPoolGetSpace||, CODE, READONLY, ALIGN=1

                  svcRtxMemoryPoolGetSpace PROC
;;;454    /// \note API identical to osMemoryPoolGetSpace
;;;455    static uint32_t svcRtxMemoryPoolGetSpace (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
;;;456      os_memory_pool_t *mp = osRtxMemoryPoolId(mp_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L23.12|
;;;457    
;;;458      // Check parameters
;;;459      if ((mp == NULL) || (mp->id != osRtxIdMemoryPool)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28f7              CMP      r0,#0xf7
00000a  d005              BEQ      |L23.24|
                  |L23.12|
;;;460        EvrRtxMemoryPoolGetSpace(mp, 0U);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxMemoryPoolGetSpace
;;;461        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;462        return 0U;
000014  2000              MOVS     r0,#0
;;;463      }
;;;464    
;;;465      EvrRtxMemoryPoolGetSpace(mp, mp->mp_info.max_blocks - mp->mp_info.used_blocks);
;;;466    
;;;467      return (mp->mp_info.max_blocks - mp->mp_info.used_blocks);
;;;468    }
000016  bd10              POP      {r4,pc}
                  |L23.24|
000018  e9d40103          LDRD     r0,r1,[r4,#0xc]
00001c  1a41              SUBS     r1,r0,r1              ;465
00001e  4620              MOV      r0,r4                 ;465
000020  f7fffffe          BL       EvrRtxMemoryPoolGetSpace
000024  e9d40103          LDRD     r0,r1,[r4,#0xc]       ;465
000028  1a40              SUBS     r0,r0,r1              ;467
00002a  bd10              POP      {r4,pc}
;;;469    
                          ENDP


                          AREA ||i.svcRtxMemoryPoolNew||, CODE, READONLY, ALIGN=2

                  svcRtxMemoryPoolNew PROC
;;;182    /// \note API identical to osMemoryPoolNew
;;;183    static osMemoryPoolId_t svcRtxMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  b138              CBZ      r0,|L24.22|
;;;184      os_memory_pool_t *mp;
;;;185      void             *mp_mem;
;;;186      uint32_t          mp_size;
;;;187      uint32_t          b_count;
;;;188      uint32_t          b_size;
;;;189      uint32_t          size;
;;;190      uint8_t           flags;
;;;191      const char       *name;
;;;192    
;;;193      // Check parameters
;;;194      if ((block_count == 0U) || (block_size == 0U) ||
000006  b131              CBZ      r1,|L24.22|
;;;195          ((__CLZ(block_count) + __CLZ(block_size)) < 32U)) {
000008  fab0f380          CLZ      r3,r0
00000c  fab1f481          CLZ      r4,r1
000010  4423              ADD      r3,r3,r4
000012  2b20              CMP      r3,#0x20
000014  d202              BCS      |L24.28|
                  |L24.22|
;;;196        EvrRtxMemoryPoolError(NULL, (int32_t)osErrorParameter);
000016  f06f0103          MVN      r1,#3
;;;197        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;198        return NULL;
00001a  e020              B        |L24.94|
                  |L24.28|
;;;199      }
;;;200    
;;;201      b_count =  block_count;
00001c  1cc9              ADDS     r1,r1,#3
;;;202      b_size  = (block_size + 3U) & ~3UL;
00001e  f0210b03          BIC      r11,r1,#3
;;;203      size    =  b_count * b_size;
;;;204    
;;;205      // Process attributes
;;;206      if (attr != NULL) {
;;;207        name    = attr->name;
;;;208        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
;;;209        mp      = attr->cb_mem;
;;;210        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
;;;211        mp_mem  = attr->mp_mem;
;;;212        mp_size = attr->mp_size;
;;;213        if (mp != NULL) {
;;;214          //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
;;;215          if ((((uint32_t)mp & 3U) != 0U) || (attr->cb_size < sizeof(os_memory_pool_t))) {
;;;216            EvrRtxMemoryPoolError(NULL, osRtxErrorInvalidControlBlock);
;;;217            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;218            return NULL;
;;;219          }
;;;220        } else {
;;;221          if (attr->cb_size != 0U) {
;;;222            EvrRtxMemoryPoolError(NULL, osRtxErrorInvalidControlBlock);
;;;223            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;224            return NULL;
;;;225          }
;;;226        }
;;;227        if (mp_mem != NULL) {
;;;228          //lint -e{923} "cast from pointer to unsigned int" [MISRA Note 7]
;;;229          if ((((uint32_t)mp_mem & 3U) != 0U) || (mp_size < size)) {
;;;230            EvrRtxMemoryPoolError(NULL, osRtxErrorInvalidDataMemory);
;;;231            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;232            return NULL;
;;;233          }
;;;234        } else {
;;;235          if (mp_size != 0U) {
;;;236            EvrRtxMemoryPoolError(NULL, osRtxErrorInvalidDataMemory);
;;;237            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;238            return NULL;
;;;239          }
;;;240        }
;;;241      } else {
;;;242        name   = NULL;
;;;243        mp     = NULL;
;;;244        mp_mem = NULL;
;;;245      }
;;;246    
;;;247      // Allocate object memory if not provided
;;;248      if (mp == NULL) {
;;;249        if (osRtxInfo.mpi.memory_pool != NULL) {
000022  f8df8104          LDR      r8,|L24.296|
000026  4682              MOV      r10,r0                ;201
000028  fb00f90b          MUL      r9,r0,r11             ;203
00002c  b1ea              CBZ      r2,|L24.106|
00002e  e9d25004          LDRD     r5,r0,[r2,#0x10]      ;216
000032  6816              LDR      r6,[r2,#0]            ;213
000034  6894              LDR      r4,[r2,#8]            ;213
000036  f06f0108          MVN      r1,#8                 ;216
00003a  b12c              CBZ      r4,|L24.72|
00003c  07a3              LSLS     r3,r4,#30             ;215
00003e  d10e              BNE      |L24.94|
000040  68d2              LDR      r2,[r2,#0xc]          ;215
000042  2a24              CMP      r2,#0x24              ;215
000044  d30b              BCC      |L24.94|
000046  e001              B        |L24.76|
                  |L24.72|
000048  68d2              LDR      r2,[r2,#0xc]          ;221
00004a  b942              CBNZ     r2,|L24.94|
                  |L24.76|
00004c  f06f0109          MVN      r1,#9                 ;230
000050  b125              CBZ      r5,|L24.92|
000052  07aa              LSLS     r2,r5,#30             ;229
000054  d103              BNE      |L24.94|
000056  4548              CMP      r0,r9                 ;229
000058  d301              BCC      |L24.94|
00005a  e009              B        |L24.112|
                  |L24.92|
00005c  b140              CBZ      r0,|L24.112|
                  |L24.94|
00005e  2000              MOVS     r0,#0                 ;236
000060  f7fffffe          BL       EvrRtxMemoryPoolError
000064  2000              MOVS     r0,#0                 ;238
                  |L24.102|
;;;250          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;251          mp = osRtxMemoryPoolAlloc(osRtxInfo.mpi.memory_pool);
;;;252        } else {
;;;253          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;254          mp = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_memory_pool_t), 1U);
;;;255        }
;;;256    #ifdef RTX_OBJ_MEM_USAGE
;;;257        if (mp != NULL) {
;;;258          uint32_t used;
;;;259          osRtxMemoryPoolMemUsage.cnt_alloc++;
;;;260          used = osRtxMemoryPoolMemUsage.cnt_alloc - osRtxMemoryPoolMemUsage.cnt_free;
;;;261          if (osRtxMemoryPoolMemUsage.max_used < used) {
;;;262            osRtxMemoryPoolMemUsage.max_used = used;
;;;263          }
;;;264        }
;;;265    #endif
;;;266        flags = osRtxFlagSystemObject;
;;;267      } else {
;;;268        flags = 0U;
;;;269      }
;;;270    
;;;271      // Allocate data memory if not provided
;;;272      if ((mp != NULL) && (mp_mem == NULL)) {
;;;273        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;274        mp_mem = osRtxMemoryAlloc(osRtxInfo.mem.mp_data, size, 0U);
;;;275        if (mp_mem == NULL) {
;;;276          if ((flags & osRtxFlagSystemObject) != 0U) {
;;;277            if (osRtxInfo.mpi.memory_pool != NULL) {
;;;278              (void)osRtxMemoryPoolFree(osRtxInfo.mpi.memory_pool, mp);
;;;279            } else {
;;;280              (void)osRtxMemoryFree(osRtxInfo.mem.common, mp);
;;;281            }
;;;282    #ifdef RTX_OBJ_MEM_USAGE
;;;283            osRtxMemoryPoolMemUsage.cnt_free++;
;;;284    #endif
;;;285          }
;;;286          mp = NULL;
;;;287        } else {
;;;288          (void)memset(mp_mem, 0, size);
;;;289        }
;;;290        flags |= osRtxFlagSystemMemory;
;;;291      }
;;;292    
;;;293      if (mp != NULL) {
;;;294        // Initialize control block
;;;295        mp->id          = osRtxIdMemoryPool;
;;;296        mp->flags       = flags;
;;;297        mp->name        = name;
;;;298        mp->thread_list = NULL;
;;;299        (void)osRtxMemoryPoolInit(&mp->mp_info, b_count, b_size, mp_mem);
;;;300    
;;;301        // Register post ISR processing function
;;;302        osRtxInfo.post_process.memory_pool = osRtxMemoryPoolPostProcess;
;;;303    
;;;304        EvrRtxMemoryPoolCreated(mp, mp->name);
;;;305      } else {
;;;306        EvrRtxMemoryPoolError(NULL, (int32_t)osErrorNoMemory);
;;;307      }
;;;308    
;;;309      return mp;
;;;310    }
000066  e8bd9ff0          POP      {r4-r12,pc}
                  |L24.106|
00006a  2600              MOVS     r6,#0                 ;242
00006c  4635              MOV      r5,r6                 ;244
00006e  e003              B        |L24.120|
                  |L24.112|
000070  b114              CBZ      r4,|L24.120|
000072  2700              MOVS     r7,#0                 ;268
                  |L24.116|
000074  b1dd              CBZ      r5,|L24.174|
000076  e027              B        |L24.200|
                  |L24.120|
000078  f8d8109c          LDR      r1,[r8,#0x9c]         ;249  ; osRtxInfo
00007c  b119              CBZ      r1,|L24.134|
00007e  4608              MOV      r0,r1                 ;249
000080  f7fffffe          BL       osRtxMemoryPoolAlloc
000084  e005              B        |L24.146|
                  |L24.134|
000086  2201              MOVS     r2,#1                 ;254
000088  2124              MOVS     r1,#0x24              ;254
00008a  f8d80080          LDR      r0,[r8,#0x80]         ;254  ; osRtxInfo
00008e  f7fffffe          BL       osRtxMemoryAlloc
                  |L24.146|
000092  0004              MOVS     r4,r0                 ;254
000094  d041              BEQ      |L24.282|
000096  4825              LDR      r0,|L24.300|
000098  6801              LDR      r1,[r0,#0]            ;259  ; osRtxMemoryPoolMemUsage
00009a  1c49              ADDS     r1,r1,#1              ;259
00009c  6001              STR      r1,[r0,#0]            ;260  ; osRtxMemoryPoolMemUsage
00009e  6842              LDR      r2,[r0,#4]            ;260  ; osRtxMemoryPoolMemUsage
0000a0  1a89              SUBS     r1,r1,r2              ;260
0000a2  6882              LDR      r2,[r0,#8]            ;261  ; osRtxMemoryPoolMemUsage
0000a4  428a              CMP      r2,r1                 ;261
0000a6  d200              BCS      |L24.170|
0000a8  6081              STR      r1,[r0,#8]            ;262  ; osRtxMemoryPoolMemUsage
                  |L24.170|
0000aa  2701              MOVS     r7,#1                 ;266
0000ac  e7e2              B        |L24.116|
                  |L24.174|
0000ae  2200              MOVS     r2,#0                 ;274
0000b0  4649              MOV      r1,r9                 ;274
0000b2  f8d80078          LDR      r0,[r8,#0x78]         ;274  ; osRtxInfo
0000b6  f7fffffe          BL       osRtxMemoryAlloc
0000ba  0005              MOVS     r5,r0                 ;274
0000bc  d019              BEQ      |L24.242|
0000be  4649              MOV      r1,r9                 ;288
0000c0  f7fffffe          BL       __aeabi_memclr
0000c4  f0470702          ORR      r7,r7,#2              ;290
                  |L24.200|
0000c8  20f7              MOVS     r0,#0xf7              ;295
0000ca  7020              STRB     r0,[r4,#0]            ;295
0000cc  70a7              STRB     r7,[r4,#2]            ;296
0000ce  2000              MOVS     r0,#0                 ;298
0000d0  e9c46001          STRD     r6,r0,[r4,#4]         ;299
0000d4  462b              MOV      r3,r5                 ;299
0000d6  465a              MOV      r2,r11                ;299
0000d8  4651              MOV      r1,r10                ;299
0000da  f104000c          ADD      r0,r4,#0xc            ;299
0000de  f7fffffe          BL       osRtxMemoryPoolInit
0000e2  4913              LDR      r1,|L24.304|
0000e4  f8c8106c          STR      r1,[r8,#0x6c]         ;304  ; osRtxInfo
0000e8  4620              MOV      r0,r4                 ;304
0000ea  6861              LDR      r1,[r4,#4]            ;304
0000ec  f7fffffe          BL       EvrRtxMemoryPoolCreated
0000f0  e018              B        |L24.292|
                  |L24.242|
0000f2  07f8              LSLS     r0,r7,#31             ;276
0000f4  d010              BEQ      |L24.280|
0000f6  f8d8209c          LDR      r2,[r8,#0x9c]         ;277  ; osRtxInfo
0000fa  b122              CBZ      r2,|L24.262|
0000fc  4621              MOV      r1,r4                 ;278
0000fe  4610              MOV      r0,r2                 ;278
000100  f7fffffe          BL       osRtxMemoryPoolFree
000104  e004              B        |L24.272|
                  |L24.262|
000106  4621              MOV      r1,r4                 ;280
000108  f8d80080          LDR      r0,[r8,#0x80]         ;280  ; osRtxInfo
00010c  f7fffffe          BL       osRtxMemoryFree
                  |L24.272|
000110  4806              LDR      r0,|L24.300|
000112  6841              LDR      r1,[r0,#4]            ;283  ; osRtxMemoryPoolMemUsage
000114  1c49              ADDS     r1,r1,#1              ;283
000116  6041              STR      r1,[r0,#4]            ;283  ; osRtxMemoryPoolMemUsage
                  |L24.280|
000118  2400              MOVS     r4,#0                 ;286
                  |L24.282|
00011a  f06f0104          MVN      r1,#4                 ;306
00011e  2000              MOVS     r0,#0                 ;306
000120  f7fffffe          BL       EvrRtxMemoryPoolError
                  |L24.292|
000124  4620              MOV      r0,r4                 ;309
000126  e79e              B        |L24.102|
;;;311    
                          ENDP

                  |L24.296|
                          DCD      osRtxInfo
                  |L24.300|
                          DCD      ||.data.os.mempool.obj||
                  |L24.304|
                          DCD      osRtxMemoryPoolPostProcess

                          AREA ||.data.os.mempool.obj||, DATA, ALIGN=2

                  osRtxMemoryPoolMemUsage
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_mempool.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___13_rtx_mempool_c_c97899d2____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2____REVSH|
#line 223
|__asm___13_rtx_mempool_c_c97899d2____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2____RRX|
#line 410
|__asm___13_rtx_mempool_c_c97899d2____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_wr8|
#line 464 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_core_cm.h"
|__asm___13_rtx_mempool_c_c97899d2__atomic_wr8| PROC
#line 464

 mov r2,r0
1
 ldrexb r0,[r2]
 strexb r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_set32|
#line 511
|__asm___13_rtx_mempool_c_c97899d2__atomic_set32| PROC
#line 511

 mov r2,r0
1
 ldrex r0,[r2]
 orr r0,r0,r1
 strex r3,r0,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_clr32|
#line 570
|__asm___13_rtx_mempool_c_c97899d2__atomic_clr32| PROC
#line 570

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F2
 b %B1
2
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_chk32_all|
#line 630
|__asm___13_rtx_mempool_c_c97899d2__atomic_chk32_all| PROC
#line 630

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 and r4,r0,r1
 cmp r4,r1
 beq %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_chk32_any|
#line 705
|__asm___13_rtx_mempool_c_c97899d2__atomic_chk32_any| PROC
#line 705

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 tst r0,r1
 bne %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_inc32|
#line 772
|__asm___13_rtx_mempool_c_c97899d2__atomic_inc32| PROC
#line 772

 mov r2,r0
1
 ldrex r0,[r2]
 adds r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_inc16_lt|
#line 821
|__asm___13_rtx_mempool_c_c97899d2__atomic_inc16_lt| PROC
#line 821

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 cmp r1,r0
 bhi %F2
 clrex
 pop {r4,pc}
2
 adds r4,r0,#1
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_inc16_lim|
#line 882
|__asm___13_rtx_mempool_c_c97899d2__atomic_inc16_lim| PROC
#line 882

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 adds r4,r0,#1
 cmp r1,r4
 bhi %F2
 movs r4,#0
2
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_dec32|
#line 940
|__asm___13_rtx_mempool_c_c97899d2__atomic_dec32| PROC
#line 940

 mov r2,r0
1
 ldrex r0,[r2]
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_dec32_nz|
#line 988
|__asm___13_rtx_mempool_c_c97899d2__atomic_dec32_nz| PROC
#line 988

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_dec16_nz|
#line 1044
|__asm___13_rtx_mempool_c_c97899d2__atomic_dec16_nz| PROC
#line 1044

 mov r2,r0
1
 ldrexh r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strexh r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_link_get|
#line 1100
|__asm___13_rtx_mempool_c_c97899d2__atomic_link_get| PROC
#line 1100

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 ldr r1,[r0]
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_rtx_mempool_c_c97899d2__atomic_link_put|
#line 1156
|__asm___13_rtx_mempool_c_c97899d2__atomic_link_put| PROC
#line 1156

1
 ldr r2,[r0]
 str r2,[r1]
 dmb
 ldrex r2,[r0]
 ldr r3,[r1]
 cmp r3,r2
 bne %B1
 strex r3,r1,[r0]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP

;*** End   embedded assembler ***
