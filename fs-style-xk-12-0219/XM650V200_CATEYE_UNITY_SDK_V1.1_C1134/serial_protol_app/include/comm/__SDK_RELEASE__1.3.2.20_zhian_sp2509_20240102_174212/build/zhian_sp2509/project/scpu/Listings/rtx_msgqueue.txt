; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\rtx_msgqueue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\rtx_msgqueue.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\rtx_msgqueue.crf F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_msgqueue.c]
                          THUMB

                          AREA ||i.IsException||, CODE, READONLY, ALIGN=1

                  IsException PROC
;;;122    /// \return     true=exception, false=thread
;;;123    __STATIC_INLINE bool_t IsException (void) {
000000  f3ef8005          MRS      r0,IPSR
000004  2800              CMP      r0,#0
000006  d000              BEQ      |L1.10|
;;;124      return (__get_IPSR() != 0U);
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;125    }
00000a  4770              BX       lr
;;;126    
                          ENDP


                          AREA ||i.IsIrqMasked||, CODE, READONLY, ALIGN=1

                  IsIrqMasked PROC
;;;128    /// \return     true=masked, false=not masked
;;;129    __STATIC_INLINE bool_t IsIrqMasked (void) {
000000  f3ef8010          MRS      r0,PRIMASK
000004  b918              CBNZ     r0,|L2.14|
000006  f3ef8011          MRS      r0,BASEPRI
;;;130    #if   ((defined(__ARM_ARCH_7M__)        && (__ARM_ARCH_7M__        != 0)) || \
;;;131           (defined(__ARM_ARCH_7EM__)       && (__ARM_ARCH_7EM__       != 0)) || \
;;;132           (defined(__ARM_ARCH_8M_MAIN__)   && (__ARM_ARCH_8M_MAIN__   != 0)) || \
;;;133           (defined(__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ != 0)))
;;;134      return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L2.16|
                  |L2.14|
00000e  2001              MOVS     r0,#1
                  |L2.16|
;;;135    #else
;;;136      return  (__get_PRIMASK() != 0U);
;;;137    #endif
;;;138    }
000010  4770              BX       lr
;;;139    
                          ENDP


                          AREA ||i.MessageQueueGet||, CODE, READONLY, ALIGN=1

                  MessageQueueGet PROC
;;;89     /// \return message object or NULL.
;;;90     static os_message_t *MessageQueueGet (os_message_queue_t *mq) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;91     #if (EXCLUSIVE_ACCESS == 0)
;;;92       uint32_t      primask = __get_PRIMASK();
;;;93     #endif
;;;94       os_message_t *msg;
;;;95       uint32_t      count;
;;;96       uint8_t       flags;
;;;97     
;;;98     #if (EXCLUSIVE_ACCESS == 0)
;;;99       __disable_irq();
;;;100    
;;;101      count = mq->msg_count;
;;;102      if (count != 0U) {
;;;103        mq->msg_count--;
;;;104      }
;;;105    
;;;106      if (primask == 0U) {
;;;107        __enable_irq();
;;;108      }
;;;109    #else
;;;110      count = atomic_dec32_nz(&mq->msg_count);
000004  3028              ADDS     r0,r0,#0x28
000006  f7fffffe          BL       __asm___14_rtx_msgqueue_c_6fef6d89__atomic_dec32_nz
;;;111    #endif
;;;112    
;;;113      if (count != 0U) {
00000a  b150              CBZ      r0,|L3.34|
;;;114        msg = mq->msg_first;
00000c  6ae4              LDR      r4,[r4,#0x2c]
;;;115    
;;;116        while (msg != NULL) {
00000e  e005              B        |L3.28|
                  |L3.16|
;;;117    #if (EXCLUSIVE_ACCESS == 0)
;;;118          __disable_irq();
;;;119    
;;;120          flags = msg->flags;
;;;121          msg->flags = 1U;
;;;122    
;;;123          if (primask == 0U) {
;;;124            __enable_irq();
;;;125          }
;;;126    #else
;;;127          flags = atomic_wr8(&msg->flags, 1U);
000010  2101              MOVS     r1,#1
000012  1ca0              ADDS     r0,r4,#2
000014  f7fffffe          BL       __asm___14_rtx_msgqueue_c_6fef6d89__atomic_wr8
;;;128    #endif
;;;129          if (flags == 0U) {
000018  b120              CBZ      r0,|L3.36|
;;;130            break;
;;;131          }
;;;132          msg = msg->next;
00001a  68a4              LDR      r4,[r4,#8]
                  |L3.28|
00001c  2c00              CMP      r4,#0                 ;116
00001e  d1f7              BNE      |L3.16|
000020  e000              B        |L3.36|
                  |L3.34|
;;;133        }
;;;134      } else {
;;;135        msg = NULL;
000022  2400              MOVS     r4,#0
                  |L3.36|
;;;136      }
;;;137    
;;;138      return msg;
000024  4620              MOV      r0,r4
;;;139    }
000026  bd10              POP      {r4,pc}
;;;140    
                          ENDP


                          AREA ||i.MessageQueuePut||, CODE, READONLY, ALIGN=1

                  MessageQueuePut PROC
;;;41     /// \param[in]  msg             message object.
;;;42     static void MessageQueuePut (os_message_queue_t *mq, os_message_t *msg) {
000000  b430              PUSH     {r4,r5}
000002  6b02              LDR      r2,[r0,#0x30]
000004  b1b2              CBZ      r2,|L4.52|
;;;43     #if (EXCLUSIVE_ACCESS == 0)
;;;44       uint32_t      primask = __get_PRIMASK();
;;;45     #endif
;;;46       os_message_t *prev, *next;
;;;47     
;;;48       if (mq->msg_last != NULL) {
;;;49         prev = mq->msg_last;
;;;50         next = NULL;
000006  2300              MOVS     r3,#0
;;;51         while ((prev != NULL) && (prev->priority < msg->priority)) {
000008  78cc              LDRB     r4,[r1,#3]
00000a  e002              B        |L4.18|
                  |L4.12|
;;;52           next = prev;
00000c  4613              MOV      r3,r2
;;;53           prev = prev->prev;
00000e  6852              LDR      r2,[r2,#4]
000010  b112              CBZ      r2,|L4.24|
                  |L4.18|
000012  78d5              LDRB     r5,[r2,#3]            ;51
000014  42a5              CMP      r5,r4                 ;51
000016  d3f9              BCC      |L4.12|
                  |L4.24|
000018  e9c12301          STRD     r2,r3,[r1,#4]         ;51
;;;54         }
;;;55         msg->prev = prev;
;;;56         msg->next = next;
;;;57         if (prev != NULL) {
00001c  b10a              CBZ      r2,|L4.34|
;;;58           prev->next = msg;
00001e  6091              STR      r1,[r2,#8]
000020  e000              B        |L4.36|
                  |L4.34|
;;;59         } else {
;;;60           mq->msg_first = msg;
000022  62c1              STR      r1,[r0,#0x2c]
                  |L4.36|
;;;61         }
;;;62         if (next != NULL) {
000024  b10b              CBZ      r3,|L4.42|
;;;63           next->prev = msg;
000026  6059              STR      r1,[r3,#4]
000028  e000              B        |L4.44|
                  |L4.42|
;;;64         } else {
;;;65           mq->msg_last = msg;
00002a  6301              STR      r1,[r0,#0x30]
                  |L4.44|
;;;66         }
;;;67       } else {
;;;68         msg->prev = NULL;
;;;69         msg->next = NULL;
;;;70         mq->msg_first= msg;
;;;71         mq->msg_last = msg;
;;;72       }
;;;73     
;;;74     #if (EXCLUSIVE_ACCESS == 0)
;;;75       __disable_irq();
;;;76     
;;;77       mq->msg_count++;
;;;78     
;;;79       if (primask == 0U) {
;;;80         __enable_irq();
;;;81       }
;;;82     #else
;;;83       (void)atomic_inc32(&mq->msg_count);
00002c  bc30              POP      {r4,r5}
00002e  3028              ADDS     r0,r0,#0x28           ;65
000030  f7ffbffe          B.W      __asm___14_rtx_msgqueue_c_6fef6d89__atomic_inc32
                  |L4.52|
000034  2200              MOVS     r2,#0                 ;68
000036  604a              STR      r2,[r1,#4]            ;69
000038  608a              STR      r2,[r1,#8]            ;70
00003a  62c1              STR      r1,[r0,#0x2c]         ;71
00003c  e7f5              B        |L4.42|
;;;84     #endif
;;;85     }
;;;86     
                          ENDP


                          AREA ||i.MessageQueueRemove||, CODE, READONLY, ALIGN=1

                  MessageQueueRemove PROC
;;;143    /// \param[in]  msg             message object.
;;;144    static void MessageQueueRemove (os_message_queue_t *mq, const os_message_t *msg) {
000000  e9d13201          LDRD     r3,r2,[r1,#4]
000004  b10b              CBZ      r3,|L5.10|
;;;145    
;;;146      if (msg->prev != NULL) {
;;;147        msg->prev->next = msg->next;
000006  609a              STR      r2,[r3,#8]
000008  e000              B        |L5.12|
                  |L5.10|
;;;148      } else {
;;;149        mq->msg_first = msg->next;
00000a  62c2              STR      r2,[r0,#0x2c]
                  |L5.12|
;;;150      }
;;;151      if (msg->next != NULL) {
00000c  688a              LDR      r2,[r1,#8]
00000e  b112              CBZ      r2,|L5.22|
;;;152        msg->next->prev = msg->prev;
000010  6848              LDR      r0,[r1,#4]
000012  6050              STR      r0,[r2,#4]
;;;153      } else {
;;;154        mq->msg_last = msg->prev;
;;;155      }
;;;156    }
000014  4770              BX       lr
                  |L5.22|
000016  6849              LDR      r1,[r1,#4]            ;154
000018  6301              STR      r1,[r0,#0x30]         ;154
00001a  4770              BX       lr
;;;157    
                          ENDP


                          AREA ||i.osMessageQueueDelete||, CODE, READONLY, ALIGN=2

                  osMessageQueueDelete PROC
;;;935    /// Delete a Message Queue object.
;;;936    osStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;937      osStatus_t status;
;;;938    
;;;939      EvrRtxMessageQueueDelete(mq_id);
000004  f7fffffe          BL       EvrRtxMessageQueueDelete
;;;940      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L6.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L6.36|
                  |L6.20|
;;;941        EvrRtxMessageQueueError(mq_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxMessageQueueError
;;;942        status = osErrorISR;
000020  4628              MOV      r0,r5
;;;943      } else {
;;;944        status = __svcMessageQueueDelete(mq_id);
;;;945      }
;;;946      return status;
;;;947    }
000022  bd70              POP      {r4-r6,pc}
                  |L6.36|
000024  4620              MOV      r0,r4                 ;944
000026  f8dfc008          LDR      r12,|L6.48|
00002a  df00              SVC      #0x0                  ;944
00002c  bd70              POP      {r4-r6,pc}
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      svcRtxMessageQueueDelete

                          AREA ||i.osMessageQueueGet||, CODE, READONLY, ALIGN=2

                  osMessageQueueGet PROC
;;;860    /// Get a Message from a Queue or timeout if Queue is empty.
;;;861    osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461f              MOV      r7,r3
000006  4616              MOV      r6,r2
000008  460d              MOV      r5,r1
00000a  4604              MOV      r4,r0
;;;862      osStatus_t status;
;;;863    
;;;864      EvrRtxMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
00000c  f7fffffe          BL       EvrRtxMessageQueueGet
;;;865      if (IsException() || IsIrqMasked()) {
000010  f7fffffe          BL       IsException
000014  b910              CBNZ     r0,|L7.28|
000016  f7fffffe          BL       IsIrqMasked
00001a  b368              CBZ      r0,|L7.120|
                  |L7.28|
;;;866        status = isrRtxMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
00001c  b124              CBZ      r4,|L7.40|
00001e  7820              LDRB     r0,[r4,#0]
000020  28fa              CMP      r0,#0xfa
000022  d101              BNE      |L7.40|
000024  b105              CBZ      r5,|L7.40|
000026  b137              CBZ      r7,|L7.54|
                  |L7.40|
000028  f06f0503          MVN      r5,#3
00002c  4629              MOV      r1,r5
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       EvrRtxMessageQueueError
000034  e01d              B        |L7.114|
                  |L7.54|
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       MessageQueueGet
00003c  0007              MOVS     r7,r0
00003e  d012              BEQ      |L7.102|
000040  f107010c          ADD      r1,r7,#0xc
000044  4628              MOV      r0,r5
000046  6a62              LDR      r2,[r4,#0x24]
000048  f7fffffe          BL       __aeabi_memcpy
00004c  b10e              CBZ      r6,|L7.82|
00004e  78f8              LDRB     r0,[r7,#3]
000050  7030              STRB     r0,[r6,#0]
                  |L7.82|
000052  4638              MOV      r0,r7
000054  60fc              STR      r4,[r7,#0xc]
000056  f7fffffe          BL       osRtxPostProcess
00005a  4629              MOV      r1,r5
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       EvrRtxMessageQueueRetrieved
000062  2500              MOVS     r5,#0
000064  e005              B        |L7.114|
                  |L7.102|
000066  4629              MOV      r1,r5
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       EvrRtxMessageQueueNotRetrieved
00006e  f06f0502          MVN      r5,#2
                  |L7.114|
000072  4628              MOV      r0,r5
                  |L7.116|
;;;867      } else {
;;;868        status =  __svcMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
;;;869      }
;;;870      return status;
;;;871    }
000074  e8bd81f0          POP      {r4-r8,pc}
                  |L7.120|
000078  4620              MOV      r0,r4                 ;868
00007a  4629              MOV      r1,r5                 ;868
00007c  4632              MOV      r2,r6                 ;868
00007e  463b              MOV      r3,r7                 ;868
000080  f8dfc004          LDR      r12,|L7.136|
000084  df00              SVC      #0x0                  ;868
000086  e7f5              B        |L7.116|
;;;872    
                          ENDP

                  |L7.136|
                          DCD      svcRtxMessageQueueGet

                          AREA ||i.osMessageQueueGetCapacity||, CODE, READONLY, ALIGN=2

                  osMessageQueueGetCapacity PROC
;;;873    /// Get maximum number of messages in a Message Queue.
;;;874    uint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;875      uint32_t capacity;
;;;876    
;;;877      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L8.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b120              CBZ      r0,|L8.26|
                  |L8.16|
;;;878        capacity = svcRtxMessageQueueGetCapacity(mq_id);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      svcRtxMessageQueueGetCapacity
                  |L8.26|
;;;879      } else {
;;;880        capacity =  __svcMessageQueueGetCapacity(mq_id);
00001a  4620              MOV      r0,r4
00001c  f8dfc004          LDR      r12,|L8.36|
000020  df00              SVC      #0x0
;;;881      }
;;;882      return capacity;
;;;883    }
000022  bd10              POP      {r4,pc}
;;;884    
                          ENDP

                  |L8.36|
                          DCD      svcRtxMessageQueueGetCapacity

                          AREA ||i.osMessageQueueGetCount||, CODE, READONLY, ALIGN=2

                  osMessageQueueGetCount PROC
;;;897    /// Get number of queued messages in a Message Queue.
;;;898    uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;899      uint32_t count;
;;;900    
;;;901      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L9.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b120              CBZ      r0,|L9.26|
                  |L9.16|
;;;902        count = svcRtxMessageQueueGetCount(mq_id);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      svcRtxMessageQueueGetCount
                  |L9.26|
;;;903      } else {
;;;904        count =  __svcMessageQueueGetCount(mq_id);
00001a  4620              MOV      r0,r4
00001c  f8dfc004          LDR      r12,|L9.36|
000020  df00              SVC      #0x0
;;;905      }
;;;906      return count;
;;;907    }
000022  bd10              POP      {r4,pc}
;;;908    
                          ENDP

                  |L9.36|
                          DCD      svcRtxMessageQueueGetCount

                          AREA ||i.osMessageQueueGetMsgSize||, CODE, READONLY, ALIGN=2

                  osMessageQueueGetMsgSize PROC
;;;885    /// Get maximum message size in a Memory Pool.
;;;886    uint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;887      uint32_t msg_size;
;;;888    
;;;889      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L10.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b120              CBZ      r0,|L10.26|
                  |L10.16|
;;;890        msg_size = svcRtxMessageQueueGetMsgSize(mq_id);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      svcRtxMessageQueueGetMsgSize
                  |L10.26|
;;;891      } else {
;;;892        msg_size =  __svcMessageQueueGetMsgSize(mq_id);
00001a  4620              MOV      r0,r4
00001c  f8dfc004          LDR      r12,|L10.36|
000020  df00              SVC      #0x0
;;;893      }
;;;894      return msg_size;
;;;895    }
000022  bd10              POP      {r4,pc}
;;;896    
                          ENDP

                  |L10.36|
                          DCD      svcRtxMessageQueueGetMsgSize

                          AREA ||i.osMessageQueueGetName||, CODE, READONLY, ALIGN=2

                  osMessageQueueGetName PROC
;;;834    /// Get name of a Message Queue object.
;;;835    const char *osMessageQueueGetName (osMessageQueueId_t mq_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;836      const char *name;
;;;837    
;;;838      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L11.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b128              CBZ      r0,|L11.28|
                  |L11.16|
;;;839        EvrRtxMessageQueueGetName(mq_id, NULL);
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxMessageQueueGetName
;;;840        name = NULL;
000018  2000              MOVS     r0,#0
;;;841      } else {
;;;842        name = __svcMessageQueueGetName(mq_id);
;;;843      }
;;;844      return name;
;;;845    }
00001a  bd10              POP      {r4,pc}
                  |L11.28|
00001c  4620              MOV      r0,r4                 ;842
00001e  f8dfc008          LDR      r12,|L11.40|
000022  df00              SVC      #0x0                  ;842
000024  bd10              POP      {r4,pc}
;;;846    
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      svcRtxMessageQueueGetName

                          AREA ||i.osMessageQueueGetSpace||, CODE, READONLY, ALIGN=2

                  osMessageQueueGetSpace PROC
;;;909    /// Get number of available slots for messages in a Message Queue.
;;;910    uint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;911      uint32_t space;
;;;912    
;;;913      if (IsException() || IsIrqMasked()) {
000004  f7fffffe          BL       IsException
000008  b910              CBNZ     r0,|L12.16|
00000a  f7fffffe          BL       IsIrqMasked
00000e  b120              CBZ      r0,|L12.26|
                  |L12.16|
;;;914        space = svcRtxMessageQueueGetSpace(mq_id);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      svcRtxMessageQueueGetSpace
                  |L12.26|
;;;915      } else {
;;;916        space =  __svcMessageQueueGetSpace(mq_id);
00001a  4620              MOV      r0,r4
00001c  f8dfc004          LDR      r12,|L12.36|
000020  df00              SVC      #0x0
;;;917      }
;;;918      return space;
;;;919    }
000022  bd10              POP      {r4,pc}
;;;920    
                          ENDP

                  |L12.36|
                          DCD      svcRtxMessageQueueGetSpace

                          AREA ||i.osMessageQueueNew||, CODE, READONLY, ALIGN=2

                  osMessageQueueNew PROC
;;;820    /// Create and Initialize a Message Queue object.
;;;821    osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
000000  b570              PUSH     {r4-r6,lr}
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;822      osMessageQueueId_t mq_id;
;;;823    
;;;824      EvrRtxMessageQueueNew(msg_count, msg_size, attr);
000008  f7fffffe          BL       EvrRtxMessageQueueNew
;;;825      if (IsException() || IsIrqMasked()) {
00000c  f7fffffe          BL       IsException
000010  b910              CBNZ     r0,|L13.24|
000012  f7fffffe          BL       IsIrqMasked
000016  b130              CBZ      r0,|L13.38|
                  |L13.24|
;;;826        EvrRtxMessageQueueError(NULL, (int32_t)osErrorISR);
000018  f06f0105          MVN      r1,#5
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       EvrRtxMessageQueueError
;;;827        mq_id = NULL;
000022  2000              MOVS     r0,#0
;;;828      } else {
;;;829        mq_id = __svcMessageQueueNew(msg_count, msg_size, attr);
;;;830      }
;;;831      return mq_id;
;;;832    }
000024  bd70              POP      {r4-r6,pc}
                  |L13.38|
000026  4630              MOV      r0,r6                 ;829
000028  4629              MOV      r1,r5                 ;829
00002a  4622              MOV      r2,r4                 ;829
00002c  f8dfc004          LDR      r12,|L13.52|
000030  df00              SVC      #0x0                  ;829
000032  bd70              POP      {r4-r6,pc}
;;;833    
                          ENDP

                  |L13.52|
                          DCD      svcRtxMessageQueueNew

                          AREA ||i.osMessageQueuePut||, CODE, READONLY, ALIGN=2

                  osMessageQueuePut PROC
;;;847    /// Put a Message into a Queue or timeout if Queue is full.
;;;848    osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461e              MOV      r6,r3
000006  4617              MOV      r7,r2
000008  460d              MOV      r5,r1
00000a  4604              MOV      r4,r0
;;;849      osStatus_t status;
;;;850    
;;;851      EvrRtxMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
00000c  f7fffffe          BL       EvrRtxMessageQueuePut
;;;852      if (IsException() || IsIrqMasked()) {
000010  f7fffffe          BL       IsException
000014  b910              CBNZ     r0,|L14.28|
000016  f7fffffe          BL       IsIrqMasked
00001a  b388              CBZ      r0,|L14.128|
                  |L14.28|
;;;853        status = isrRtxMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
00001c  b124              CBZ      r4,|L14.40|
00001e  7820              LDRB     r0,[r4,#0]
000020  28fa              CMP      r0,#0xfa
000022  d101              BNE      |L14.40|
000024  b105              CBZ      r5,|L14.40|
000026  b136              CBZ      r6,|L14.54|
                  |L14.40|
000028  f06f0503          MVN      r5,#3
00002c  4629              MOV      r1,r5
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       EvrRtxMessageQueueError
000034  e021              B        |L14.122|
                  |L14.54|
000036  f104000c          ADD      r0,r4,#0xc
00003a  f7fffffe          BL       osRtxMemoryPoolAlloc
00003e  0006              MOVS     r6,r0
000040  d015              BEQ      |L14.110|
000042  4629              MOV      r1,r5
000044  f106000c          ADD      r0,r6,#0xc
000048  6a62              LDR      r2,[r4,#0x24]
00004a  f7fffffe          BL       __aeabi_memcpy
00004e  20f9              MOVS     r0,#0xf9
000050  7030              STRB     r0,[r6,#0]
000052  2000              MOVS     r0,#0
000054  70b0              STRB     r0,[r6,#2]
000056  70f7              STRB     r7,[r6,#3]
000058  e9c65401          STRD     r5,r4,[r6,#4]
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       osRtxPostProcess
000062  4629              MOV      r1,r5
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       EvrRtxMessageQueueInsertPending
00006a  2500              MOVS     r5,#0
00006c  e005              B        |L14.122|
                  |L14.110|
00006e  4629              MOV      r1,r5
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       EvrRtxMessageQueueNotInserted
000076  f06f0502          MVN      r5,#2
                  |L14.122|
00007a  4628              MOV      r0,r5
                  |L14.124|
;;;854      } else {
;;;855        status =  __svcMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
;;;856      }
;;;857      return status;
;;;858    }
00007c  e8bd81f0          POP      {r4-r8,pc}
                  |L14.128|
000080  e7ff              B        |L14.130|
                  |L14.130|
000082  4620              MOV      r0,r4                 ;855
000084  4629              MOV      r1,r5                 ;855
000086  463a              MOV      r2,r7                 ;855
000088  4633              MOV      r3,r6                 ;855
00008a  f8dfc008          LDR      r12,|L14.148|
00008e  df00              SVC      #0x0                  ;855
000090  e7f4              B        |L14.124|
;;;859    
                          ENDP

000092  0000              DCW      0x0000
                  |L14.148|
                          DCD      svcRtxMessageQueuePut

                          AREA ||i.osMessageQueueReset||, CODE, READONLY, ALIGN=2

                  osMessageQueueReset PROC
;;;921    /// Reset a Message Queue to initial empty state.
;;;922    osStatus_t osMessageQueueReset (osMessageQueueId_t mq_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;923      osStatus_t status;
;;;924    
;;;925      EvrRtxMessageQueueReset(mq_id);
000004  f7fffffe          BL       EvrRtxMessageQueueReset
;;;926      if (IsException() || IsIrqMasked()) {
000008  f7fffffe          BL       IsException
00000c  b910              CBNZ     r0,|L15.20|
00000e  f7fffffe          BL       IsIrqMasked
000012  b138              CBZ      r0,|L15.36|
                  |L15.20|
;;;927        EvrRtxMessageQueueError(mq_id, (int32_t)osErrorISR);
000014  f06f0505          MVN      r5,#5
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EvrRtxMessageQueueError
;;;928        status = osErrorISR;
000020  4628              MOV      r0,r5
;;;929      } else {
;;;930        status = __svcMessageQueueReset(mq_id);
;;;931      }
;;;932      return status;
;;;933    }
000022  bd70              POP      {r4-r6,pc}
                  |L15.36|
000024  4620              MOV      r0,r4                 ;930
000026  f8dfc008          LDR      r12,|L15.48|
00002a  df00              SVC      #0x0                  ;930
00002c  bd70              POP      {r4-r6,pc}
;;;934    
                          ENDP

00002e  0000              DCW      0x0000
                  |L15.48|
                          DCD      svcRtxMessageQueueReset

                          AREA ||i.osRtxMessageQueuePostProcess||, CODE, READONLY, ALIGN=1

                  osRtxMessageQueuePostProcess PROC
;;;162    /// \param[in]  msg             message object.
;;;163    static void osRtxMessageQueuePostProcess (os_message_t *msg) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;164      os_message_queue_t *mq;
;;;165      os_message_t       *msg0;
;;;166      os_thread_t        *thread;
;;;167      const uint32_t     *reg;
;;;168      const void         *ptr_src;
;;;169            void         *ptr_dst;
;;;170    
;;;171      if (msg->flags != 0U) {
000006  7880              LDRB     r0,[r0,#2]
000008  2600              MOVS     r6,#0
00000a  b3b8              CBZ      r0,|L16.124|
;;;172        // Remove Message
;;;173        //lint -e{9079} -e{9087} "cast between pointers to different object types"
;;;174        mq = *((os_message_queue_t **)(void *)&msg[1]);
;;;175        MessageQueueRemove(mq, msg);
00000c  68e5              LDR      r5,[r4,#0xc]
00000e  4621              MOV      r1,r4
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       MessageQueueRemove
;;;176        // Free memory
;;;177        msg->id = osRtxIdInvalid;
000016  7026              STRB     r6,[r4,#0]
;;;178        (void)osRtxMemoryPoolFree(&mq->mp_info, msg);
000018  4621              MOV      r1,r4
00001a  f105000c          ADD      r0,r5,#0xc
00001e  46b0              MOV      r8,r6                 ;177
000020  4604              MOV      r4,r0
000022  f7fffffe          BL       osRtxMemoryPoolFree
;;;179        // Check if Thread is waiting to send a Message
;;;180        if (mq->thread_list != NULL) {
000026  68a8              LDR      r0,[r5,#8]
000028  2800              CMP      r0,#0
00002a  d05d              BEQ      |L16.232|
00002c  4620              MOV      r0,r4
;;;181          // Try to allocate memory
;;;182          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;183          msg0 = osRtxMemoryPoolAlloc(&mq->mp_info);
00002e  f7fffffe          BL       osRtxMemoryPoolAlloc
000032  0004              MOVS     r4,r0
;;;184          if (msg0 != NULL) {
000034  d058              BEQ      |L16.232|
;;;185            // Wakeup waiting Thread with highest Priority
;;;186            thread = osRtxThreadListGet(osRtxObject(mq));
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       osRtxThreadListGet
;;;187            osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
00003c  2200              MOVS     r2,#0
00003e  4606              MOV      r6,r0                 ;186
000040  4611              MOV      r1,r2
000042  f7fffffe          BL       osRtxThreadWaitExit
;;;188            // Copy Message (R1: const void *msg_ptr, R2: uint8_t msg_prio)
;;;189            reg = osRtxThreadRegPtr(thread);
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       osRtxThreadRegPtr
;;;190            //lint -e{923} "cast from unsigned int to pointer"
;;;191            ptr_src = (const void *)reg[1];
;;;192            (void)memcpy(&msg0[1], ptr_src, mq->msg_size);
00004c  6846              LDR      r6,[r0,#4]
00004e  4607              MOV      r7,r0                 ;189
000050  4631              MOV      r1,r6
000052  f104000c          ADD      r0,r4,#0xc
000056  6a6a              LDR      r2,[r5,#0x24]
000058  f7fffffe          BL       __aeabi_memcpy
;;;193            // Store Message into Queue
;;;194            msg0->id       = osRtxIdMessage;
00005c  20f9              MOVS     r0,#0xf9
00005e  7020              STRB     r0,[r4,#0]
;;;195            msg0->flags    = 0U;
000060  f8848002          STRB     r8,[r4,#2]
;;;196            msg0->priority = (uint8_t)reg[2];
000064  7a38              LDRB     r0,[r7,#8]
000066  70e0              STRB     r0,[r4,#3]
;;;197            MessageQueuePut(mq, msg0);
000068  4621              MOV      r1,r4
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       MessageQueuePut
;;;198            EvrRtxMessageQueueInserted(mq, ptr_src);
000070  4631              MOV      r1,r6
000072  4628              MOV      r0,r5
000074  e8bd41f0          POP      {r4-r8,lr}
000078  f7ffbffe          B.W      EvrRtxMessageQueueInserted
                  |L16.124|
00007c  e9d41501          LDRD     r1,r5,[r4,#4]
;;;199          }
;;;200        }
;;;201      } else {
;;;202        // New Message
;;;203        //lint -e{9079} -e{9087} "cast between pointers to different object types"
;;;204        mq = (void *)msg->next;
;;;205        //lint -e{9087} "cast between pointers to different object types"
;;;206        ptr_src = (const void *)msg->prev;
;;;207        // Check if Thread is waiting to receive a Message
;;;208        if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessageGet)) {
000080  68a8              LDR      r0,[r5,#8]
000082  b110              CBZ      r0,|L16.138|
000084  7840              LDRB     r0,[r0,#1]
000086  2883              CMP      r0,#0x83
000088  d008              BEQ      |L16.156|
                  |L16.138|
;;;209          EvrRtxMessageQueueInserted(mq, ptr_src);
;;;210          // Wakeup waiting Thread with highest Priority
;;;211          thread = osRtxThreadListGet(osRtxObject(mq));
;;;212          osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
;;;213          // Copy Message (R1: void *msg_ptr, R2: uint8_t *msg_prio)
;;;214          reg = osRtxThreadRegPtr(thread);
;;;215          //lint -e{923} "cast from unsigned int to pointer"
;;;216          ptr_dst = (void *)reg[1];
;;;217          (void)memcpy(ptr_dst, &msg[1], mq->msg_size);
;;;218          if (reg[2] != 0U) {
;;;219            //lint -e{923} -e{9078} "cast from unsigned int to pointer"
;;;220            *((uint8_t *)reg[2]) = msg->priority;
;;;221          }
;;;222          EvrRtxMessageQueueRetrieved(mq, ptr_dst);
;;;223          // Free memory
;;;224          msg->id = osRtxIdInvalid;
;;;225          (void)osRtxMemoryPoolFree(&mq->mp_info, msg);
;;;226        } else {
;;;227          EvrRtxMessageQueueInserted(mq, ptr_src);
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       EvrRtxMessageQueueInserted
;;;228          MessageQueuePut(mq, msg);
000090  4621              MOV      r1,r4
000092  4628              MOV      r0,r5
000094  e8bd41f0          POP      {r4-r8,lr}
000098  f7ffbffe          B.W      MessageQueuePut
                  |L16.156|
00009c  4628              MOV      r0,r5                 ;209
00009e  f7fffffe          BL       EvrRtxMessageQueueInserted
0000a2  4628              MOV      r0,r5                 ;211
0000a4  f7fffffe          BL       osRtxThreadListGet
0000a8  2200              MOVS     r2,#0                 ;212
0000aa  4607              MOV      r7,r0                 ;211
0000ac  4611              MOV      r1,r2                 ;212
0000ae  f7fffffe          BL       osRtxThreadWaitExit
0000b2  4638              MOV      r0,r7                 ;214
0000b4  f7fffffe          BL       osRtxThreadRegPtr
0000b8  4607              MOV      r7,r0                 ;214
0000ba  6840              LDR      r0,[r0,#4]            ;216
0000bc  f104010c          ADD      r1,r4,#0xc            ;217
0000c0  4680              MOV      r8,r0                 ;216
0000c2  6a6a              LDR      r2,[r5,#0x24]         ;217
0000c4  f7fffffe          BL       __aeabi_memcpy
0000c8  68b8              LDR      r0,[r7,#8]            ;218
0000ca  b108              CBZ      r0,|L16.208|
0000cc  78e1              LDRB     r1,[r4,#3]            ;220
0000ce  7001              STRB     r1,[r0,#0]            ;220
                  |L16.208|
0000d0  4641              MOV      r1,r8                 ;222
0000d2  4628              MOV      r0,r5                 ;222
0000d4  f7fffffe          BL       EvrRtxMessageQueueRetrieved
0000d8  7026              STRB     r6,[r4,#0]            ;224
0000da  4621              MOV      r1,r4                 ;225
0000dc  f105000c          ADD      r0,r5,#0xc            ;225
0000e0  e8bd41f0          POP      {r4-r8,lr}            ;225
0000e4  f7ffbffe          B.W      osRtxMemoryPoolFree
                  |L16.232|
;;;229        }
;;;230      }
;;;231    }
0000e8  e8bd81f0          POP      {r4-r8,pc}
;;;232    
                          ENDP


                          AREA ||i.osRtxMessageQueueTimerSetup||, CODE, READONLY, ALIGN=2

                  osRtxMessageQueueTimerSetup PROC
;;;803    /// Create a Message Queue for the Timer Thread.
;;;804    int32_t osRtxMessageQueueTimerSetup (void) {
000000  b510              PUSH     {r4,lr}
;;;805      int32_t ret = -1;
;;;806    
;;;807      osRtxInfo.timer.mq = osRtxMessageQueueId(
000002  4807              LDR      r0,|L17.32|
000004  f04f34ff          MOV      r4,#0xffffffff        ;805
000008  2108              MOVS     r1,#8
00000a  e9d0201a          LDRD     r2,r0,[r0,#0x68]
00000e  f7fffffe          BL       svcRtxMessageQueueNew
000012  4904              LDR      r1,|L17.36|
;;;808        svcRtxMessageQueueNew(osRtxConfig.timer_mq_mcnt, sizeof(os_timer_finfo_t), osRtxConfig.timer_mq_attr)
;;;809      );
;;;810      if (osRtxInfo.timer.mq != NULL) {
000014  64c8              STR      r0,[r1,#0x4c]  ; osRtxInfo
000016  b100              CBZ      r0,|L17.26|
;;;811        ret = 0;
000018  2400              MOVS     r4,#0
                  |L17.26|
;;;812      }
;;;813    
;;;814      return ret;
00001a  4620              MOV      r0,r4
;;;815    }
00001c  bd10              POP      {r4,pc}
;;;816    
                          ENDP

00001e  0000              DCW      0x0000
                  |L17.32|
                          DCD      osRtxConfig
                  |L17.36|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxMessageQueueDelete||, CODE, READONLY, ALIGN=2

                  svcRtxMessageQueueDelete PROC
;;;658    /// \note API identical to osMessageQueueDelete
;;;659    static osStatus_t svcRtxMessageQueueDelete (osMessageQueueId_t mq_id) {
000000  b570              PUSH     {r4-r6,lr}
;;;660      os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L18.12|
;;;661      os_thread_t        *thread;
;;;662    
;;;663      // Check parameters
;;;664      if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28fa              CMP      r0,#0xfa
00000a  d007              BEQ      |L18.28|
                  |L18.12|
;;;665        EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
00000c  f06f0503          MVN      r5,#3
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       EvrRtxMessageQueueError
;;;666        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;667        return osErrorParameter;
000018  4628              MOV      r0,r5
;;;668      }
;;;669    
;;;670      // Unblock waiting threads
;;;671      if (mq->thread_list != NULL) {
;;;672        do {
;;;673          thread = osRtxThreadListGet(osRtxObject(mq));
;;;674          osRtxThreadWaitExit(thread, (uint32_t)osErrorResource, FALSE);
;;;675        } while (mq->thread_list != NULL);
;;;676        osRtxThreadDispatch(NULL);
;;;677      }
;;;678    
;;;679      // Mark object as invalid
;;;680      mq->id = osRtxIdInvalid;
;;;681    
;;;682      // Free data memory
;;;683      if ((mq->flags & osRtxFlagSystemMemory) != 0U) {
;;;684        (void)osRtxMemoryFree(osRtxInfo.mem.mq_data, mq->mp_info.block_base);
;;;685      }
;;;686    
;;;687      // Free object memory
;;;688      if ((mq->flags & osRtxFlagSystemObject) != 0U) {
;;;689        if (osRtxInfo.mpi.message_queue != NULL) {
;;;690          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.message_queue, mq);
;;;691        } else {
;;;692          (void)osRtxMemoryFree(osRtxInfo.mem.common, mq);
;;;693        }
;;;694    #ifdef RTX_OBJ_MEM_USAGE
;;;695        osRtxMessageQueueMemUsage.cnt_free++;
;;;696    #endif
;;;697      }
;;;698    
;;;699      EvrRtxMessageQueueDestroyed(mq);
;;;700    
;;;701      return osOK;
;;;702    }
00001a  bd70              POP      {r4-r6,pc}
                  |L18.28|
00001c  68a0              LDR      r0,[r4,#8]            ;671
00001e  b168              CBZ      r0,|L18.60|
000020  f06f0502          MVN      r5,#2                 ;674
                  |L18.36|
000024  4620              MOV      r0,r4                 ;673
000026  f7fffffe          BL       osRtxThreadListGet
00002a  2200              MOVS     r2,#0                 ;674
00002c  4629              MOV      r1,r5                 ;674
00002e  f7fffffe          BL       osRtxThreadWaitExit
000032  68a0              LDR      r0,[r4,#8]            ;675
000034  2800              CMP      r0,#0                 ;675
000036  d1f5              BNE      |L18.36|
000038  f7fffffe          BL       osRtxThreadDispatch
                  |L18.60|
00003c  2000              MOVS     r0,#0                 ;680
00003e  7020              STRB     r0,[r4,#0]            ;680
000040  78a0              LDRB     r0,[r4,#2]            ;683
000042  4d0f              LDR      r5,|L18.128|
000044  0780              LSLS     r0,r0,#30             ;683
000046  d503              BPL      |L18.80|
000048  69a1              LDR      r1,[r4,#0x18]         ;684
00004a  6fe8              LDR      r0,[r5,#0x7c]         ;684  ; osRtxInfo
00004c  f7fffffe          BL       osRtxMemoryFree
                  |L18.80|
000050  78a0              LDRB     r0,[r4,#2]            ;688
000052  07c0              LSLS     r0,r0,#31             ;688
000054  d00f              BEQ      |L18.118|
000056  f8d500a0          LDR      r0,[r5,#0xa0]         ;689  ; osRtxInfo
00005a  b118              CBZ      r0,|L18.100|
00005c  4621              MOV      r1,r4                 ;690
00005e  f7fffffe          BL       osRtxMemoryPoolFree
000062  e004              B        |L18.110|
                  |L18.100|
000064  4621              MOV      r1,r4                 ;692
000066  f8d50080          LDR      r0,[r5,#0x80]         ;692  ; osRtxInfo
00006a  f7fffffe          BL       osRtxMemoryFree
                  |L18.110|
00006e  4805              LDR      r0,|L18.132|
000070  6841              LDR      r1,[r0,#4]            ;695  ; osRtxMessageQueueMemUsage
000072  1c49              ADDS     r1,r1,#1              ;695
000074  6041              STR      r1,[r0,#4]            ;695  ; osRtxMessageQueueMemUsage
                  |L18.118|
000076  4620              MOV      r0,r4                 ;699
000078  f7fffffe          BL       EvrRtxMessageQueueDestroyed
00007c  2000              MOVS     r0,#0                 ;701
00007e  bd70              POP      {r4-r6,pc}
;;;703    
                          ENDP

                  |L18.128|
                          DCD      osRtxInfo
                  |L18.132|
                          DCD      ||.data.os.msgqueue.obj||

                          AREA ||i.svcRtxMessageQueueGet||, CODE, READONLY, ALIGN=2

                  svcRtxMessageQueueGet PROC
;;;456    /// \note API identical to osMessageQueueGet
;;;457    static osStatus_t svcRtxMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461e              MOV      r6,r3
000006  4617              MOV      r7,r2
000008  4688              MOV      r8,r1
;;;458      os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
00000a  0004              MOVS     r4,r0
00000c  d050              BEQ      |L19.176|
;;;459      os_message_t       *msg;
;;;460      os_thread_t        *thread;
;;;461      uint32_t           *reg;
;;;462      const void         *ptr;
;;;463      osStatus_t          status;
;;;464    
;;;465      // Check parameters
;;;466      if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL)) {
00000e  7820              LDRB     r0,[r4,#0]
000010  28fa              CMP      r0,#0xfa
000012  d14d              BNE      |L19.176|
000014  f1b80f00          CMP      r8,#0
000018  d04a              BEQ      |L19.176|
;;;467        EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
;;;468        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;469        return osErrorParameter;
;;;470      }
;;;471    
;;;472      // Get Message from Queue
;;;473      msg = MessageQueueGet(mq);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       MessageQueueGet
000020  0005              MOVS     r5,r0
;;;474      if (msg != NULL) {
000022  d04d              BEQ      |L19.192|
;;;475        MessageQueueRemove(mq, msg);
000024  4601              MOV      r1,r0
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       MessageQueueRemove
;;;476        // Copy Message
;;;477        (void)memcpy(msg_ptr, &msg[1], mq->msg_size);
00002c  f105010c          ADD      r1,r5,#0xc
000030  4640              MOV      r0,r8
000032  6a62              LDR      r2,[r4,#0x24]
000034  f7fffffe          BL       __aeabi_memcpy
;;;478        if (msg_prio != NULL) {
000038  b10f              CBZ      r7,|L19.62|
;;;479          *msg_prio = msg->priority;
00003a  78e8              LDRB     r0,[r5,#3]
00003c  7038              STRB     r0,[r7,#0]
                  |L19.62|
;;;480        }
;;;481        EvrRtxMessageQueueRetrieved(mq, msg_ptr);
00003e  4641              MOV      r1,r8
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       EvrRtxMessageQueueRetrieved
;;;482        // Free memory
;;;483        msg->id = osRtxIdInvalid;
000046  f04f0800          MOV      r8,#0
00004a  f8858000          STRB     r8,[r5,#0]
;;;484        (void)osRtxMemoryPoolFree(&mq->mp_info, msg);
00004e  4629              MOV      r1,r5
000050  f104000c          ADD      r0,r4,#0xc
000054  4605              MOV      r5,r0
000056  f7fffffe          BL       osRtxMemoryPoolFree
;;;485        // Check if Thread is waiting to send a Message
;;;486        if (mq->thread_list != NULL) {
00005a  68a0              LDR      r0,[r4,#8]
00005c  b328              CBZ      r0,|L19.170|
00005e  4628              MOV      r0,r5
;;;487          // Try to allocate memory
;;;488          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;489          msg = osRtxMemoryPoolAlloc(&mq->mp_info);
000060  f7fffffe          BL       osRtxMemoryPoolAlloc
000064  0005              MOVS     r5,r0
;;;490          if (msg != NULL) {
000066  d020              BEQ      |L19.170|
;;;491            // Wakeup waiting Thread with highest Priority
;;;492            thread = osRtxThreadListGet(osRtxObject(mq));
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       osRtxThreadListGet
00006e  4606              MOV      r6,r0
;;;493            osRtxThreadWaitExit(thread, (uint32_t)osOK, TRUE);
000070  2201              MOVS     r2,#1
000072  2100              MOVS     r1,#0
000074  f7fffffe          BL       osRtxThreadWaitExit
;;;494            // Copy Message (R1: const void *msg_ptr, R2: uint8_t msg_prio)
;;;495            reg = osRtxThreadRegPtr(thread);
000078  4630              MOV      r0,r6
00007a  f7fffffe          BL       osRtxThreadRegPtr
;;;496            //lint -e{923} "cast from unsigned int to pointer"
;;;497            ptr = (const void *)reg[1];
;;;498            (void)memcpy(&msg[1], ptr, mq->msg_size);
00007e  6846              LDR      r6,[r0,#4]
000080  4607              MOV      r7,r0                 ;495
000082  4631              MOV      r1,r6
000084  f105000c          ADD      r0,r5,#0xc
000088  6a62              LDR      r2,[r4,#0x24]
00008a  f7fffffe          BL       __aeabi_memcpy
;;;499            // Store Message into Queue
;;;500            msg->id       = osRtxIdMessage;
00008e  20f9              MOVS     r0,#0xf9
000090  7028              STRB     r0,[r5,#0]
;;;501            msg->flags    = 0U;
000092  f8858002          STRB     r8,[r5,#2]
;;;502            msg->priority = (uint8_t)reg[2];
000096  7a38              LDRB     r0,[r7,#8]
000098  70e8              STRB     r0,[r5,#3]
;;;503            MessageQueuePut(mq, msg);
00009a  4629              MOV      r1,r5
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       MessageQueuePut
;;;504            EvrRtxMessageQueueInserted(mq, ptr);
0000a2  4631              MOV      r1,r6
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       EvrRtxMessageQueueInserted
                  |L19.170|
;;;505          }
;;;506        }
;;;507        status = osOK;
0000aa  2000              MOVS     r0,#0
                  |L19.172|
;;;508      } else {
;;;509        // No Message available
;;;510        if (timeout != 0U) {
;;;511          EvrRtxMessageQueueGetPending(mq, msg_ptr, timeout);
;;;512          // Suspend current Thread
;;;513          if (osRtxThreadWaitEnter(osRtxThreadWaitingMessageGet, timeout)) {
;;;514            osRtxThreadListPut(osRtxObject(mq), osRtxThreadGetRunning());
;;;515          } else {
;;;516            EvrRtxMessageQueueGetTimeout(mq);
;;;517          }
;;;518          status = osErrorTimeout;
;;;519        } else {
;;;520          EvrRtxMessageQueueNotRetrieved(mq, msg_ptr);
;;;521          status = osErrorResource;
;;;522        }
;;;523      }
;;;524    
;;;525      return status;
;;;526    }
0000ac  e8bd81f0          POP      {r4-r8,pc}
                  |L19.176|
0000b0  f06f0503          MVN      r5,#3                 ;467
0000b4  4629              MOV      r1,r5                 ;467
0000b6  4620              MOV      r0,r4                 ;467
0000b8  f7fffffe          BL       EvrRtxMessageQueueError
0000bc  4628              MOV      r0,r5                 ;469
0000be  e7f5              B        |L19.172|
                  |L19.192|
0000c0  b1ae              CBZ      r6,|L19.238|
0000c2  4632              MOV      r2,r6                 ;511
0000c4  4641              MOV      r1,r8                 ;511
0000c6  4620              MOV      r0,r4                 ;511
0000c8  f7fffffe          BL       EvrRtxMessageQueueGetPending
0000cc  4631              MOV      r1,r6                 ;513
0000ce  2083              MOVS     r0,#0x83              ;513
0000d0  f7fffffe          BL       osRtxThreadWaitEnter
0000d4  b128              CBZ      r0,|L19.226|
0000d6  4809              LDR      r0,|L19.252|
0000d8  6941              LDR      r1,[r0,#0x14]         ;514  ; osRtxInfo
0000da  4620              MOV      r0,r4                 ;514
0000dc  f7fffffe          BL       osRtxThreadListPut
0000e0  e002              B        |L19.232|
                  |L19.226|
0000e2  4620              MOV      r0,r4                 ;516
0000e4  f7fffffe          BL       EvrRtxMessageQueueGetTimeout
                  |L19.232|
0000e8  f06f0001          MVN      r0,#1                 ;518
0000ec  e7de              B        |L19.172|
                  |L19.238|
0000ee  4641              MOV      r1,r8                 ;520
0000f0  4620              MOV      r0,r4                 ;520
0000f2  f7fffffe          BL       EvrRtxMessageQueueNotRetrieved
0000f6  f06f0002          MVN      r0,#2                 ;521
0000fa  e7d7              B        |L19.172|
;;;527    
                          ENDP

                  |L19.252|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxMessageQueueGetCapacity||, CODE, READONLY, ALIGN=1

                  svcRtxMessageQueueGetCapacity PROC
;;;529    /// \note API identical to osMessageQueueGetCapacity
;;;530    static uint32_t svcRtxMessageQueueGetCapacity (osMessageQueueId_t mq_id) {
000000  b510              PUSH     {r4,lr}
;;;531      os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L20.12|
;;;532    
;;;533      // Check parameters
;;;534      if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28fa              CMP      r0,#0xfa
00000a  d005              BEQ      |L20.24|
                  |L20.12|
;;;535        EvrRtxMessageQueueGetCapacity(mq, 0U);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxMessageQueueGetCapacity
;;;536        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;537        return 0U;
000014  2000              MOVS     r0,#0
;;;538      }
;;;539    
;;;540      EvrRtxMessageQueueGetCapacity(mq, mq->mp_info.max_blocks);
;;;541    
;;;542      return mq->mp_info.max_blocks;
;;;543    }
000016  bd10              POP      {r4,pc}
                  |L20.24|
000018  4620              MOV      r0,r4                 ;540
00001a  68e1              LDR      r1,[r4,#0xc]          ;540
00001c  f7fffffe          BL       EvrRtxMessageQueueGetCapacity
000020  68e0              LDR      r0,[r4,#0xc]          ;542
000022  bd10              POP      {r4,pc}
;;;544    
                          ENDP


                          AREA ||i.svcRtxMessageQueueGetCount||, CODE, READONLY, ALIGN=1

                  svcRtxMessageQueueGetCount PROC
;;;563    /// \note API identical to osMessageQueueGetCount
;;;564    static uint32_t svcRtxMessageQueueGetCount (osMessageQueueId_t mq_id) {
000000  b510              PUSH     {r4,lr}
;;;565      os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L21.12|
;;;566    
;;;567      // Check parameters
;;;568      if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28fa              CMP      r0,#0xfa
00000a  d005              BEQ      |L21.24|
                  |L21.12|
;;;569        EvrRtxMessageQueueGetCount(mq, 0U);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxMessageQueueGetCount
;;;570        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;571        return 0U;
000014  2000              MOVS     r0,#0
;;;572      }
;;;573    
;;;574      EvrRtxMessageQueueGetCount(mq, mq->msg_count);
;;;575    
;;;576      return mq->msg_count;
;;;577    }
000016  bd10              POP      {r4,pc}
                  |L21.24|
000018  4620              MOV      r0,r4                 ;574
00001a  6aa1              LDR      r1,[r4,#0x28]         ;574
00001c  f7fffffe          BL       EvrRtxMessageQueueGetCount
000020  6aa0              LDR      r0,[r4,#0x28]         ;576
000022  bd10              POP      {r4,pc}
;;;578    
                          ENDP


                          AREA ||i.svcRtxMessageQueueGetMsgSize||, CODE, READONLY, ALIGN=1

                  svcRtxMessageQueueGetMsgSize PROC
;;;546    /// \note API identical to osMessageQueueGetMsgSize
;;;547    static uint32_t svcRtxMessageQueueGetMsgSize (osMessageQueueId_t mq_id) {
000000  b510              PUSH     {r4,lr}
;;;548      os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L22.12|
;;;549    
;;;550      // Check parameters
;;;551      if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28fa              CMP      r0,#0xfa
00000a  d005              BEQ      |L22.24|
                  |L22.12|
;;;552        EvrRtxMessageQueueGetMsgSize(mq, 0U);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxMessageQueueGetMsgSize
;;;553        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;554        return 0U;
000014  2000              MOVS     r0,#0
;;;555      }
;;;556    
;;;557      EvrRtxMessageQueueGetMsgSize(mq, mq->msg_size);
;;;558    
;;;559      return mq->msg_size;
;;;560    }
000016  bd10              POP      {r4,pc}
                  |L22.24|
000018  4620              MOV      r0,r4                 ;557
00001a  6a61              LDR      r1,[r4,#0x24]         ;557
00001c  f7fffffe          BL       EvrRtxMessageQueueGetMsgSize
000020  6a60              LDR      r0,[r4,#0x24]         ;559
000022  bd10              POP      {r4,pc}
;;;561    
                          ENDP


                          AREA ||i.svcRtxMessageQueueGetName||, CODE, READONLY, ALIGN=1

                  svcRtxMessageQueueGetName PROC
;;;370    /// \note API identical to osMessageQueueGetName
;;;371    static const char *svcRtxMessageQueueGetName (osMessageQueueId_t mq_id) {
000000  b510              PUSH     {r4,lr}
;;;372      os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L23.12|
;;;373    
;;;374      // Check parameters
;;;375      if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28fa              CMP      r0,#0xfa
00000a  d005              BEQ      |L23.24|
                  |L23.12|
;;;376        EvrRtxMessageQueueGetName(mq, NULL);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxMessageQueueGetName
;;;377        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;378        return NULL;
000014  2000              MOVS     r0,#0
;;;379      }
;;;380    
;;;381      EvrRtxMessageQueueGetName(mq, mq->name);
;;;382    
;;;383      return mq->name;
;;;384    }
000016  bd10              POP      {r4,pc}
                  |L23.24|
000018  4620              MOV      r0,r4                 ;381
00001a  6861              LDR      r1,[r4,#4]            ;381
00001c  f7fffffe          BL       EvrRtxMessageQueueGetName
000020  6860              LDR      r0,[r4,#4]            ;383
000022  bd10              POP      {r4,pc}
;;;385    
                          ENDP


                          AREA ||i.svcRtxMessageQueueGetSpace||, CODE, READONLY, ALIGN=1

                  svcRtxMessageQueueGetSpace PROC
;;;580    /// \note API identical to osMessageQueueGetSpace
;;;581    static uint32_t svcRtxMessageQueueGetSpace (osMessageQueueId_t mq_id) {
000000  b510              PUSH     {r4,lr}
;;;582      os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L24.12|
;;;583    
;;;584      // Check parameters
;;;585      if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
000006  7820              LDRB     r0,[r4,#0]
000008  28fa              CMP      r0,#0xfa
00000a  d005              BEQ      |L24.24|
                  |L24.12|
;;;586        EvrRtxMessageQueueGetSpace(mq, 0U);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EvrRtxMessageQueueGetSpace
;;;587        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;588        return 0U;
000014  2000              MOVS     r0,#0
;;;589      }
;;;590    
;;;591      EvrRtxMessageQueueGetSpace(mq, mq->mp_info.max_blocks - mq->msg_count);
;;;592    
;;;593      return (mq->mp_info.max_blocks - mq->msg_count);
;;;594    }
000016  bd10              POP      {r4,pc}
                  |L24.24|
000018  6aa1              LDR      r1,[r4,#0x28]         ;591
00001a  68e0              LDR      r0,[r4,#0xc]          ;591
00001c  1a41              SUBS     r1,r0,r1              ;591
00001e  4620              MOV      r0,r4                 ;591
000020  f7fffffe          BL       EvrRtxMessageQueueGetSpace
000024  6aa1              LDR      r1,[r4,#0x28]         ;593
000026  68e0              LDR      r0,[r4,#0xc]          ;593
000028  1a40              SUBS     r0,r0,r1              ;593
00002a  bd10              POP      {r4,pc}
;;;595    
                          ENDP


                          AREA ||i.svcRtxMessageQueueNew||, CODE, READONLY, ALIGN=2

                  svcRtxMessageQueueNew PROC
;;;237    /// \note API identical to osMessageQueueNew
;;;238    static osMessageQueueId_t svcRtxMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  460e              MOV      r6,r1
000006  ea5f0800          MOVS     r8,r0
00000a  d007              BEQ      |L25.28|
;;;239      os_message_queue_t *mq;
;;;240      void               *mq_mem;
;;;241      uint32_t            mq_size;
;;;242      uint32_t            block_size;
;;;243      uint32_t            size;
;;;244      uint8_t             flags;
;;;245      const char         *name;
;;;246    
;;;247      // Check parameters
;;;248      if ((msg_count == 0U) || (msg_size == 0U) ||
00000c  b136              CBZ      r6,|L25.28|
;;;249          ((__CLZ(msg_count) + __CLZ(msg_size)) < 32U)) {
00000e  fab8f088          CLZ      r0,r8
000012  fab6f186          CLZ      r1,r6
000016  4408              ADD      r0,r0,r1
000018  2820              CMP      r0,#0x20
00001a  d202              BCS      |L25.34|
                  |L25.28|
;;;250        EvrRtxMessageQueueError(NULL, (int32_t)osErrorParameter);
00001c  f06f0103          MVN      r1,#3
;;;251        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;252        return NULL;
000020  e022              B        |L25.104|
                  |L25.34|
;;;253      }
;;;254    
;;;255      block_size = ((msg_size + 3U) & ~3UL) + sizeof(os_message_t);
000022  1cf0              ADDS     r0,r6,#3
000024  f0200003          BIC      r0,r0,#3
000028  300c              ADDS     r0,r0,#0xc
;;;256      size       = msg_count * block_size;
;;;257    
;;;258      // Process attributes
;;;259      if (attr != NULL) {
;;;260        name    = attr->name;
;;;261        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
;;;262        mq      = attr->cb_mem;
;;;263        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
;;;264        mq_mem  = attr->mq_mem;
;;;265        mq_size = attr->mq_size;
;;;266        if (mq != NULL) {
;;;267          //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
;;;268          if ((((uint32_t)mq & 3U) != 0U) || (attr->cb_size < sizeof(os_message_queue_t))) {
;;;269            EvrRtxMessageQueueError(NULL, osRtxErrorInvalidControlBlock);
;;;270            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;271            return NULL;
;;;272          }
;;;273        } else {
;;;274          if (attr->cb_size != 0U) {
;;;275            EvrRtxMessageQueueError(NULL, osRtxErrorInvalidControlBlock);
;;;276            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;277            return NULL;
;;;278          }
;;;279        }
;;;280        if (mq_mem != NULL) {
;;;281          //lint -e{923} "cast from pointer to unsigned int" [MISRA Note 7]
;;;282          if ((((uint32_t)mq_mem & 3U) != 0U) || (mq_size < size)) {
;;;283            EvrRtxMessageQueueError(NULL, osRtxErrorInvalidDataMemory);
;;;284            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;285            return NULL;
;;;286          }
;;;287        } else {
;;;288          if (mq_size != 0U) {
;;;289            EvrRtxMessageQueueError(NULL, osRtxErrorInvalidDataMemory);
;;;290            //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;291            return NULL;
;;;292          }
;;;293        }
;;;294      } else {
;;;295        name   = NULL;
;;;296        mq     = NULL;
;;;297        mq_mem = NULL;
;;;298      }
;;;299    
;;;300      // Allocate object memory if not provided
;;;301      if (mq == NULL) {
;;;302        if (osRtxInfo.mpi.message_queue != NULL) {
00002a  f8dfa110          LDR      r10,|L25.316|
00002e  fb08fb00          MUL      r11,r8,r0             ;256
000032  9000              STR      r0,[sp,#0]            ;259
000034  b1f2              CBZ      r2,|L25.116|
000036  e9d25004          LDRD     r5,r0,[r2,#0x10]      ;269
00003a  f8d29000          LDR      r9,[r2,#0]            ;266
00003e  6894              LDR      r4,[r2,#8]            ;266
000040  f06f0108          MVN      r1,#8                 ;269
000044  b12c              CBZ      r4,|L25.82|
000046  07a3              LSLS     r3,r4,#30             ;268
000048  d10e              BNE      |L25.104|
00004a  68d2              LDR      r2,[r2,#0xc]          ;268
00004c  2a34              CMP      r2,#0x34              ;268
00004e  d30b              BCC      |L25.104|
000050  e001              B        |L25.86|
                  |L25.82|
000052  68d2              LDR      r2,[r2,#0xc]          ;274
000054  b942              CBNZ     r2,|L25.104|
                  |L25.86|
000056  f06f0109          MVN      r1,#9                 ;283
00005a  b125              CBZ      r5,|L25.102|
00005c  07aa              LSLS     r2,r5,#30             ;282
00005e  d103              BNE      |L25.104|
000060  4558              CMP      r0,r11                ;282
000062  d301              BCC      |L25.104|
000064  e00a              B        |L25.124|
                  |L25.102|
000066  b148              CBZ      r0,|L25.124|
                  |L25.104|
000068  2000              MOVS     r0,#0                 ;289
00006a  f7fffffe          BL       EvrRtxMessageQueueError
00006e  2000              MOVS     r0,#0                 ;291
                  |L25.112|
;;;303          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;304          mq = osRtxMemoryPoolAlloc(osRtxInfo.mpi.message_queue);
;;;305        } else {
;;;306          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;307          mq = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_message_queue_t), 1U);
;;;308        }
;;;309    #ifdef RTX_OBJ_MEM_USAGE
;;;310        if (mq != NULL) {
;;;311          uint32_t used;
;;;312          osRtxMessageQueueMemUsage.cnt_alloc++;
;;;313          used = osRtxMessageQueueMemUsage.cnt_alloc - osRtxMessageQueueMemUsage.cnt_free;
;;;314          if (osRtxMessageQueueMemUsage.max_used < used) {
;;;315            osRtxMessageQueueMemUsage.max_used = used;
;;;316          }
;;;317        }
;;;318    #endif
;;;319        flags = osRtxFlagSystemObject;
;;;320      } else {
;;;321        flags = 0U;
;;;322      }
;;;323    
;;;324      // Allocate data memory if not provided
;;;325      if ((mq != NULL) && (mq_mem == NULL)) {
;;;326        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;327        mq_mem = osRtxMemoryAlloc(osRtxInfo.mem.mq_data, size, 0U);
;;;328        if (mq_mem == NULL) {
;;;329          if ((flags & osRtxFlagSystemObject) != 0U) {
;;;330            if (osRtxInfo.mpi.message_queue != NULL) {
;;;331              (void)osRtxMemoryPoolFree(osRtxInfo.mpi.message_queue, mq);
;;;332            } else {
;;;333              (void)osRtxMemoryFree(osRtxInfo.mem.common, mq);
;;;334            }
;;;335    #ifdef RTX_OBJ_MEM_USAGE
;;;336            osRtxMessageQueueMemUsage.cnt_free++;
;;;337    #endif
;;;338          }
;;;339          mq = NULL;
;;;340        } else {
;;;341          (void)memset(mq_mem, 0, size);
;;;342        }
;;;343        flags |= osRtxFlagSystemMemory;
;;;344      }
;;;345    
;;;346      if (mq != NULL) {
;;;347        // Initialize control block
;;;348        mq->id          = osRtxIdMessageQueue;
;;;349        mq->flags       = flags;
;;;350        mq->name        = name;
;;;351        mq->thread_list = NULL;
;;;352        mq->msg_size    = msg_size;
;;;353        mq->msg_count   = 0U;
;;;354        mq->msg_first   = NULL;
;;;355        mq->msg_last    = NULL;
;;;356        (void)osRtxMemoryPoolInit(&mq->mp_info, msg_count, block_size, mq_mem);
;;;357    
;;;358        // Register post ISR processing function
;;;359        osRtxInfo.post_process.message = osRtxMessageQueuePostProcess;
;;;360    
;;;361        EvrRtxMessageQueueCreated(mq, mq->name);
;;;362      } else {
;;;363        EvrRtxMessageQueueError(NULL, (int32_t)osErrorNoMemory);
;;;364      }
;;;365    
;;;366      return mq;
;;;367    }
000070  e8bd8ff8          POP      {r3-r11,pc}
                  |L25.116|
000074  f04f0900          MOV      r9,#0                 ;295
000078  464d              MOV      r5,r9                 ;297
00007a  e003              B        |L25.132|
                  |L25.124|
00007c  b114              CBZ      r4,|L25.132|
00007e  2700              MOVS     r7,#0                 ;321
                  |L25.128|
000080  b1dd              CBZ      r5,|L25.186|
000082  e027              B        |L25.212|
                  |L25.132|
000084  f8da10a0          LDR      r1,[r10,#0xa0]        ;302  ; osRtxInfo
000088  b119              CBZ      r1,|L25.146|
00008a  4608              MOV      r0,r1                 ;302
00008c  f7fffffe          BL       osRtxMemoryPoolAlloc
000090  e005              B        |L25.158|
                  |L25.146|
000092  2201              MOVS     r2,#1                 ;307
000094  2134              MOVS     r1,#0x34              ;307
000096  f8da0080          LDR      r0,[r10,#0x80]        ;307  ; osRtxInfo
00009a  f7fffffe          BL       osRtxMemoryAlloc
                  |L25.158|
00009e  0004              MOVS     r4,r0                 ;307
0000a0  d045              BEQ      |L25.302|
0000a2  4827              LDR      r0,|L25.320|
0000a4  6801              LDR      r1,[r0,#0]            ;312  ; osRtxMessageQueueMemUsage
0000a6  1c49              ADDS     r1,r1,#1              ;312
0000a8  6001              STR      r1,[r0,#0]            ;313  ; osRtxMessageQueueMemUsage
0000aa  6842              LDR      r2,[r0,#4]            ;313  ; osRtxMessageQueueMemUsage
0000ac  1a89              SUBS     r1,r1,r2              ;313
0000ae  6882              LDR      r2,[r0,#8]            ;314  ; osRtxMessageQueueMemUsage
0000b0  428a              CMP      r2,r1                 ;314
0000b2  d200              BCS      |L25.182|
0000b4  6081              STR      r1,[r0,#8]            ;315  ; osRtxMessageQueueMemUsage
                  |L25.182|
0000b6  2701              MOVS     r7,#1                 ;319
0000b8  e7e2              B        |L25.128|
                  |L25.186|
0000ba  2200              MOVS     r2,#0                 ;327
0000bc  4659              MOV      r1,r11                ;327
0000be  f8da007c          LDR      r0,[r10,#0x7c]        ;327  ; osRtxInfo
0000c2  f7fffffe          BL       osRtxMemoryAlloc
0000c6  0005              MOVS     r5,r0                 ;327
0000c8  d01d              BEQ      |L25.262|
0000ca  4659              MOV      r1,r11                ;341
0000cc  f7fffffe          BL       __aeabi_memclr
0000d0  f0470702          ORR      r7,r7,#2              ;343
                  |L25.212|
0000d4  20fa              MOVS     r0,#0xfa              ;348
0000d6  7020              STRB     r0,[r4,#0]            ;348
0000d8  70a7              STRB     r7,[r4,#2]            ;349
0000da  2000              MOVS     r0,#0                 ;351
0000dc  e9c49001          STRD     r9,r0,[r4,#4]         ;351
0000e0  e9c46009          STRD     r6,r0,[r4,#0x24]      ;351
0000e4  62e0              STR      r0,[r4,#0x2c]         ;355
0000e6  6320              STR      r0,[r4,#0x30]         ;356
0000e8  462b              MOV      r3,r5                 ;356
0000ea  4641              MOV      r1,r8                 ;356
0000ec  f104000c          ADD      r0,r4,#0xc            ;356
0000f0  9a00              LDR      r2,[sp,#0]            ;356
0000f2  f7fffffe          BL       osRtxMemoryPoolInit
0000f6  4913              LDR      r1,|L25.324|
0000f8  f8ca1070          STR      r1,[r10,#0x70]        ;361  ; osRtxInfo
0000fc  4620              MOV      r0,r4                 ;361
0000fe  6861              LDR      r1,[r4,#4]            ;361
000100  f7fffffe          BL       EvrRtxMessageQueueCreated
000104  e018              B        |L25.312|
                  |L25.262|
000106  07f8              LSLS     r0,r7,#31             ;329
000108  d010              BEQ      |L25.300|
00010a  f8da20a0          LDR      r2,[r10,#0xa0]        ;330  ; osRtxInfo
00010e  b122              CBZ      r2,|L25.282|
000110  4621              MOV      r1,r4                 ;331
000112  4610              MOV      r0,r2                 ;331
000114  f7fffffe          BL       osRtxMemoryPoolFree
000118  e004              B        |L25.292|
                  |L25.282|
00011a  4621              MOV      r1,r4                 ;333
00011c  f8da0080          LDR      r0,[r10,#0x80]        ;333  ; osRtxInfo
000120  f7fffffe          BL       osRtxMemoryFree
                  |L25.292|
000124  4806              LDR      r0,|L25.320|
000126  6841              LDR      r1,[r0,#4]            ;336  ; osRtxMessageQueueMemUsage
000128  1c49              ADDS     r1,r1,#1              ;336
00012a  6041              STR      r1,[r0,#4]            ;336  ; osRtxMessageQueueMemUsage
                  |L25.300|
00012c  2400              MOVS     r4,#0                 ;339
                  |L25.302|
00012e  f06f0104          MVN      r1,#4                 ;363
000132  2000              MOVS     r0,#0                 ;363
000134  f7fffffe          BL       EvrRtxMessageQueueError
                  |L25.312|
000138  4620              MOV      r0,r4                 ;366
00013a  e799              B        |L25.112|
;;;368    
                          ENDP

                  |L25.316|
                          DCD      osRtxInfo
                  |L25.320|
                          DCD      ||.data.os.msgqueue.obj||
                  |L25.324|
                          DCD      osRtxMessageQueuePostProcess

                          AREA ||i.svcRtxMessageQueuePut||, CODE, READONLY, ALIGN=2

                  svcRtxMessageQueuePut PROC
;;;387    /// \note API identical to osMessageQueuePut
;;;388    static osStatus_t svcRtxMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4698              MOV      r8,r3
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
;;;389      os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
00000a  0004              MOVS     r4,r0
00000c  d024              BEQ      |L26.88|
;;;390      os_message_t       *msg;
;;;391      os_thread_t        *thread;
;;;392      uint32_t           *reg;
;;;393      void               *ptr;
;;;394      osStatus_t          status;
;;;395    
;;;396      // Check parameters
;;;397      if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL)) {
00000e  7820              LDRB     r0,[r4,#0]
000010  28fa              CMP      r0,#0xfa
000012  d121              BNE      |L26.88|
000014  b307              CBZ      r7,|L26.88|
;;;398        EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
;;;399        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;400        return osErrorParameter;
;;;401      }
;;;402    
;;;403      // Check if Thread is waiting to receive a Message
;;;404      if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessageGet)) {
000016  68a0              LDR      r0,[r4,#8]
000018  b110              CBZ      r0,|L26.32|
00001a  7840              LDRB     r0,[r0,#1]
00001c  2883              CMP      r0,#0x83
00001e  d023              BEQ      |L26.104|
                  |L26.32|
;;;405        EvrRtxMessageQueueInserted(mq, msg_ptr);
;;;406        // Wakeup waiting Thread with highest Priority
;;;407        thread = osRtxThreadListGet(osRtxObject(mq));
;;;408        osRtxThreadWaitExit(thread, (uint32_t)osOK, TRUE);
;;;409        // Copy Message (R1: void *msg_ptr, R2: uint8_t *msg_prio)
;;;410        reg = osRtxThreadRegPtr(thread);
;;;411        //lint -e{923} "cast from unsigned int to pointer"
;;;412        ptr = (void *)reg[1];
;;;413        (void)memcpy(ptr, msg_ptr, mq->msg_size);
;;;414        if (reg[2] != 0U) {
;;;415          //lint -e{923} -e{9078} "cast from unsigned int to pointer"
;;;416          *((uint8_t *)reg[2]) = msg_prio;
;;;417        }
;;;418        EvrRtxMessageQueueRetrieved(mq, ptr);
;;;419        status = osOK;
;;;420      } else {
;;;421        // Try to allocate memory
;;;422        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;423        msg = osRtxMemoryPoolAlloc(&mq->mp_info);
000020  f104000c          ADD      r0,r4,#0xc
000024  f7fffffe          BL       osRtxMemoryPoolAlloc
000028  0005              MOVS     r5,r0
;;;424        if (msg != NULL) {
00002a  d03a              BEQ      |L26.162|
;;;425          // Copy Message
;;;426          (void)memcpy(&msg[1], msg_ptr, mq->msg_size);
00002c  4639              MOV      r1,r7
00002e  f105000c          ADD      r0,r5,#0xc
000032  6a62              LDR      r2,[r4,#0x24]
000034  f7fffffe          BL       __aeabi_memcpy
;;;427          // Put Message into Queue
;;;428          msg->id       = osRtxIdMessage;
000038  20f9              MOVS     r0,#0xf9
00003a  7028              STRB     r0,[r5,#0]
;;;429          msg->flags    = 0U;
00003c  2000              MOVS     r0,#0
00003e  70a8              STRB     r0,[r5,#2]
;;;430          msg->priority = msg_prio;
000040  70ee              STRB     r6,[r5,#3]
;;;431          MessageQueuePut(mq, msg);
000042  4629              MOV      r1,r5
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       MessageQueuePut
;;;432          EvrRtxMessageQueueInserted(mq, msg_ptr);
00004a  4639              MOV      r1,r7
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       EvrRtxMessageQueueInserted
                  |L26.82|
000052  2000              MOVS     r0,#0                 ;419
                  |L26.84|
;;;433          status = osOK;
;;;434        } else {
;;;435          // No memory available
;;;436          if (timeout != 0U) {
;;;437            EvrRtxMessageQueuePutPending(mq, msg_ptr, timeout);
;;;438            // Suspend current Thread
;;;439            if (osRtxThreadWaitEnter(osRtxThreadWaitingMessagePut, timeout)) {
;;;440              osRtxThreadListPut(osRtxObject(mq), osRtxThreadGetRunning());
;;;441            } else {
;;;442              EvrRtxMessageQueuePutTimeout(mq);
;;;443            }
;;;444            status = osErrorTimeout;
;;;445          } else {
;;;446            EvrRtxMessageQueueNotInserted(mq, msg_ptr);
;;;447            status = osErrorResource;
;;;448          }
;;;449        }
;;;450      }
;;;451    
;;;452      return status;
;;;453    }
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L26.88|
000058  f06f0503          MVN      r5,#3                 ;398
00005c  4629              MOV      r1,r5                 ;398
00005e  4620              MOV      r0,r4                 ;398
000060  f7fffffe          BL       EvrRtxMessageQueueError
000064  4628              MOV      r0,r5                 ;400
000066  e7f5              B        |L26.84|
                  |L26.104|
000068  4620              MOV      r0,r4                 ;405
00006a  f7fffffe          BL       EvrRtxMessageQueueInserted
00006e  4620              MOV      r0,r4                 ;407
000070  f7fffffe          BL       osRtxThreadListGet
000074  4605              MOV      r5,r0                 ;407
000076  2201              MOVS     r2,#1                 ;408
000078  2100              MOVS     r1,#0                 ;408
00007a  f7fffffe          BL       osRtxThreadWaitExit
00007e  4628              MOV      r0,r5                 ;410
000080  f7fffffe          BL       osRtxThreadRegPtr
000084  4605              MOV      r5,r0                 ;410
000086  6840              LDR      r0,[r0,#4]            ;412
000088  4639              MOV      r1,r7                 ;413
00008a  4680              MOV      r8,r0                 ;412
00008c  6a62              LDR      r2,[r4,#0x24]         ;413
00008e  f7fffffe          BL       __aeabi_memcpy
000092  68a8              LDR      r0,[r5,#8]            ;414
000094  b100              CBZ      r0,|L26.152|
000096  7006              STRB     r6,[r0,#0]            ;416
                  |L26.152|
000098  4641              MOV      r1,r8                 ;418
00009a  4620              MOV      r0,r4                 ;418
00009c  f7fffffe          BL       EvrRtxMessageQueueRetrieved
0000a0  e7d7              B        |L26.82|
                  |L26.162|
0000a2  f1b80000          SUBS     r0,r8,#0              ;436
0000a6  d015              BEQ      |L26.212|
0000a8  4602              MOV      r2,r0                 ;437
0000aa  4639              MOV      r1,r7                 ;437
0000ac  4620              MOV      r0,r4                 ;437
0000ae  f7fffffe          BL       EvrRtxMessageQueuePutPending
0000b2  4641              MOV      r1,r8                 ;439
0000b4  2093              MOVS     r0,#0x93              ;439
0000b6  f7fffffe          BL       osRtxThreadWaitEnter
0000ba  b128              CBZ      r0,|L26.200|
0000bc  4809              LDR      r0,|L26.228|
0000be  6941              LDR      r1,[r0,#0x14]         ;440  ; osRtxInfo
0000c0  4620              MOV      r0,r4                 ;440
0000c2  f7fffffe          BL       osRtxThreadListPut
0000c6  e002              B        |L26.206|
                  |L26.200|
0000c8  4620              MOV      r0,r4                 ;442
0000ca  f7fffffe          BL       EvrRtxMessageQueuePutTimeout
                  |L26.206|
0000ce  f06f0001          MVN      r0,#1                 ;444
0000d2  e7bf              B        |L26.84|
                  |L26.212|
0000d4  4639              MOV      r1,r7                 ;446
0000d6  4620              MOV      r0,r4                 ;446
0000d8  f7fffffe          BL       EvrRtxMessageQueueNotInserted
0000dc  f06f0002          MVN      r0,#2                 ;447
0000e0  e7b8              B        |L26.84|
;;;454    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L26.228|
                          DCD      osRtxInfo

                          AREA ||i.svcRtxMessageQueueReset||, CODE, READONLY, ALIGN=1

                  svcRtxMessageQueueReset PROC
;;;597    /// \note API identical to osMessageQueueReset
;;;598    static osStatus_t svcRtxMessageQueueReset (osMessageQueueId_t mq_id) {
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;599      os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
000004  0004              MOVS     r4,r0
000006  d002              BEQ      |L27.14|
;;;600      os_message_t       *msg;
;;;601      os_thread_t        *thread;
;;;602      const uint32_t     *reg;
;;;603      const void         *ptr;
;;;604    
;;;605      // Check parameters
;;;606      if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
000008  7820              LDRB     r0,[r4,#0]
00000a  28fa              CMP      r0,#0xfa
00000c  d008              BEQ      |L27.32|
                  |L27.14|
;;;607        EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
00000e  f06f0503          MVN      r5,#3
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       EvrRtxMessageQueueError
;;;608        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
;;;609        return osErrorParameter;
00001a  4628              MOV      r0,r5
                  |L27.28|
;;;610      }
;;;611    
;;;612      // Remove Messages from Queue
;;;613      for (;;) {
;;;614        // Get Message from Queue
;;;615        msg = MessageQueueGet(mq);
;;;616        if (msg == NULL) {
;;;617          break;
;;;618        }
;;;619        MessageQueueRemove(mq, msg);
;;;620        EvrRtxMessageQueueRetrieved(mq, NULL);
;;;621        // Free memory
;;;622        msg->id = osRtxIdInvalid;
;;;623        (void)osRtxMemoryPoolFree(&mq->mp_info, msg);
;;;624      }
;;;625    
;;;626      // Check if Threads are waiting to send Messages
;;;627      if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessagePut)) {
;;;628        do {
;;;629          // Try to allocate memory
;;;630          //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
;;;631          msg = osRtxMemoryPoolAlloc(&mq->mp_info);
;;;632          if (msg != NULL) {
;;;633            // Wakeup waiting Thread with highest Priority
;;;634            thread = osRtxThreadListGet(osRtxObject(mq));
;;;635            osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
;;;636            // Copy Message (R1: const void *msg_ptr, R2: uint8_t msg_prio)
;;;637            reg = osRtxThreadRegPtr(thread);
;;;638            //lint -e{923} "cast from unsigned int to pointer"
;;;639            ptr = (const void *)reg[1];
;;;640            (void)memcpy(&msg[1], ptr, mq->msg_size);
;;;641            // Store Message into Queue
;;;642            msg->id       = osRtxIdMessage;
;;;643            msg->flags    = 0U;
;;;644            msg->priority = (uint8_t)reg[2];
;;;645            MessageQueuePut(mq, msg);
;;;646            EvrRtxMessageQueueInserted(mq, ptr);
;;;647          }
;;;648        } while ((msg != NULL) && (mq->thread_list != NULL));
;;;649        osRtxThreadDispatch(NULL);
;;;650      }
;;;651    
;;;652      EvrRtxMessageQueueResetDone(mq);
;;;653    
;;;654      return osOK;
;;;655    }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L27.32|
000020  f104090c          ADD      r9,r4,#0xc            ;623
000024  f04f0800          MOV      r8,#0                 ;623
                  |L27.40|
000028  4620              MOV      r0,r4                 ;615
00002a  f7fffffe          BL       MessageQueueGet
00002e  0005              MOVS     r5,r0                 ;615
000030  d00e              BEQ      |L27.80|
000032  4601              MOV      r1,r0                 ;619
000034  4620              MOV      r0,r4                 ;619
000036  f7fffffe          BL       MessageQueueRemove
00003a  2100              MOVS     r1,#0                 ;620
00003c  4620              MOV      r0,r4                 ;620
00003e  f7fffffe          BL       EvrRtxMessageQueueRetrieved
000042  f8858000          STRB     r8,[r5,#0]            ;622
000046  4629              MOV      r1,r5                 ;623
000048  4648              MOV      r0,r9                 ;623
00004a  f7fffffe          BL       osRtxMemoryPoolFree
00004e  e7eb              B        |L27.40|
                  |L27.80|
000050  68a0              LDR      r0,[r4,#8]            ;627
000052  b370              CBZ      r0,|L27.178|
000054  7840              LDRB     r0,[r0,#1]            ;627
000056  2893              CMP      r0,#0x93              ;627
000058  d12b              BNE      |L27.178|
                  |L27.90|
00005a  4648              MOV      r0,r9                 ;627
00005c  f7fffffe          BL       osRtxMemoryPoolAlloc
000060  0005              MOVS     r5,r0                 ;631
000062  d023              BEQ      |L27.172|
000064  4620              MOV      r0,r4                 ;634
000066  f7fffffe          BL       osRtxThreadListGet
00006a  2200              MOVS     r2,#0                 ;635
00006c  4606              MOV      r6,r0                 ;634
00006e  4611              MOV      r1,r2                 ;635
000070  f7fffffe          BL       osRtxThreadWaitExit
000074  4630              MOV      r0,r6                 ;637
000076  f7fffffe          BL       osRtxThreadRegPtr
00007a  6846              LDR      r6,[r0,#4]            ;640
00007c  4607              MOV      r7,r0                 ;637
00007e  4631              MOV      r1,r6                 ;640
000080  f105000c          ADD      r0,r5,#0xc            ;640
000084  6a62              LDR      r2,[r4,#0x24]         ;640
000086  f7fffffe          BL       __aeabi_memcpy
00008a  20f9              MOVS     r0,#0xf9              ;642
00008c  7028              STRB     r0,[r5,#0]            ;642
00008e  f8858002          STRB     r8,[r5,#2]            ;643
000092  7a38              LDRB     r0,[r7,#8]            ;644
000094  70e8              STRB     r0,[r5,#3]            ;644
000096  4629              MOV      r1,r5                 ;645
000098  4620              MOV      r0,r4                 ;645
00009a  f7fffffe          BL       MessageQueuePut
00009e  4631              MOV      r1,r6                 ;646
0000a0  4620              MOV      r0,r4                 ;646
0000a2  f7fffffe          BL       EvrRtxMessageQueueInserted
0000a6  68a0              LDR      r0,[r4,#8]            ;646
0000a8  2800              CMP      r0,#0                 ;646
0000aa  d1d6              BNE      |L27.90|
                  |L27.172|
0000ac  2000              MOVS     r0,#0                 ;649
0000ae  f7fffffe          BL       osRtxThreadDispatch
                  |L27.178|
0000b2  4620              MOV      r0,r4                 ;652
0000b4  f7fffffe          BL       EvrRtxMessageQueueResetDone
0000b8  2000              MOVS     r0,#0                 ;654
0000ba  e7af              B        |L27.28|
;;;656    
                          ENDP


                          AREA ||.data.os.msgqueue.obj||, DATA, ALIGN=2

                  osRtxMessageQueueMemUsage
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_msgqueue.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___14_rtx_msgqueue_c_6fef6d89____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89____REVSH|
#line 223
|__asm___14_rtx_msgqueue_c_6fef6d89____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89____RRX|
#line 410
|__asm___14_rtx_msgqueue_c_6fef6d89____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_wr8|
#line 464 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_core_cm.h"
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_wr8| PROC
#line 464

 mov r2,r0
1
 ldrexb r0,[r2]
 strexb r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_set32|
#line 511
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_set32| PROC
#line 511

 mov r2,r0
1
 ldrex r0,[r2]
 orr r0,r0,r1
 strex r3,r0,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_clr32|
#line 570
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_clr32| PROC
#line 570

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F2
 b %B1
2
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_chk32_all|
#line 630
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_chk32_all| PROC
#line 630

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 and r4,r0,r1
 cmp r4,r1
 beq %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_chk32_any|
#line 705
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_chk32_any| PROC
#line 705

 push {r4,lr}
 mov r2,r0
1
 ldrex r0,[r2]
 tst r0,r1
 bne %F2
 clrex
 movs r0,#0
 pop {r4,pc}
2
 bic r4,r0,r1
 strex r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_inc32|
#line 772
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_inc32| PROC
#line 772

 mov r2,r0
1
 ldrex r0,[r2]
 adds r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_inc16_lt|
#line 821
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_inc16_lt| PROC
#line 821

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 cmp r1,r0
 bhi %F2
 clrex
 pop {r4,pc}
2
 adds r4,r0,#1
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_inc16_lim|
#line 882
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_inc16_lim| PROC
#line 882

 push {r4,lr}
 mov r2,r0
1
 ldrexh r0,[r2]
 adds r4,r0,#1
 cmp r1,r4
 bhi %F2
 movs r4,#0
2
 strexh r3,r4,[r2]
 cbz r3,%F3
 b %B1
3
 pop {r4,pc}
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_dec32|
#line 940
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_dec32| PROC
#line 940

 mov r2,r0
1
 ldrex r0,[r2]
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_dec32_nz|
#line 988
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_dec32_nz| PROC
#line 988

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_dec16_nz|
#line 1044
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_dec16_nz| PROC
#line 1044

 mov r2,r0
1
 ldrexh r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 subs r1,r0,#1
 strexh r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_link_get|
#line 1100
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_link_get| PROC
#line 1100

 mov r2,r0
1
 ldrex r0,[r2]
 cbnz r0,%F2
 clrex
 bx lr
2
 ldr r1,[r0]
 strex r3,r1,[r2]
 cbz r3,%F3
 b %B1
3
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_rtx_msgqueue_c_6fef6d89__atomic_link_put|
#line 1156
|__asm___14_rtx_msgqueue_c_6fef6d89__atomic_link_put| PROC
#line 1156

1
 ldr r2,[r0]
 str r2,[r1]
 dmb
 ldrex r2,[r0]
 ldr r3,[r1]
 cmp r3,r2
 bne %B1
 strex r3,r1,[r0]
 cbz r3,%F2
 b %B1
2
 bx lr
	ENDP

;*** End   embedded assembler ***
