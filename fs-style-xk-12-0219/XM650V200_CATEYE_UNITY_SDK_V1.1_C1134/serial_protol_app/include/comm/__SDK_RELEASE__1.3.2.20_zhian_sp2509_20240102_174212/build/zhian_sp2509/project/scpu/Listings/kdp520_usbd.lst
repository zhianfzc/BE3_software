L 1 "..\..\..\..\scpu\drivers\src\kdp520_usbd.c"
N/*
N * Kneron Peripheral API
N *
N * Copyright (C) 2019 Kneron, Inc. All rights reserved.
N *
N */
N
N#ifndef USE_KDRV
N
N#include <stdlib.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
X  #elif !0L
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !1L
S#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 0L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 11 "..\..\..\..\scpu\drivers\src\kdp520_usbd.c" 2
N#include <string.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 12 "..\..\..\..\scpu\drivers\src\kdp520_usbd.c" 2
N
N#include "cmsis_os2.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include\cmsis_os2.h" 1
N/*
N * Copyright (c) 2013-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * ----------------------------------------------------------------------
N *
N * $Date:        12. June 2020
N * $Revision:    V2.1.3
N *
N * Project:      CMSIS-RTOS2 API
N * Title:        cmsis_os2.h header file
N *
N * Version 2.1.3
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osThreadGetId
N * Version 2.1.2
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osKernelGetInfo, osKernelGetState
N * Version 2.1.1
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osKernelGetTickCount, osKernelGetTickFreq
N *    Changed Kernel Tick type to uint32_t:
N *    - updated: osKernelGetTickCount, osDelayUntil
N * Version 2.1.0
N *    Support for critical and uncritical sections (nesting safe):
N *    - updated: osKernelLock, osKernelUnlock
N *    - added: osKernelRestoreLock
N *    Updated Thread and Event Flags:
N *    - changed flags parameter and return type from int32_t to uint32_t
N * Version 2.0.0
N *    Initial Release
N *---------------------------------------------------------------------------*/
N 
N#ifndef CMSIS_OS2_H_
N#define CMSIS_OS2_H_
N 
N#ifndef __NO_RETURN
N#if   defined(__CC_ARM)
X#if   1L
N#define __NO_RETURN __declspec(noreturn)
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S#define __NO_RETURN __attribute__((__noreturn__))
S#elif defined(__GNUC__)
S#define __NO_RETURN __attribute__((__noreturn__))
S#elif defined(__ICCARM__)
S#define __NO_RETURN __noreturn
S#else
S#define __NO_RETURN
N#endif
N#endif
N 
N#include <stdint.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 65 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include\cmsis_os2.h" 2
N#include <stddef.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
X  #elif !0L
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 66 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include\cmsis_os2.h" 2
N 
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N 
N 
N//  ==== Enumerations, structures, defines ====
N 
N/// Version information.
Ntypedef struct {
N  uint32_t                       api;   ///< API version (major.minor.rev: mmnnnrrrr dec).
N  uint32_t                    kernel;   ///< Kernel version (major.minor.rev: mmnnnrrrr dec).
N} osVersion_t;
N 
N/// Kernel state.
Ntypedef enum {
N  osKernelInactive        =  0,         ///< Inactive.
N  osKernelReady           =  1,         ///< Ready.
N  osKernelRunning         =  2,         ///< Running.
N  osKernelLocked          =  3,         ///< Locked.
N  osKernelSuspended       =  4,         ///< Suspended.
N  osKernelError           = -1,         ///< Error.
N  osKernelReserved        = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osKernelState_t;
N 
N/// Thread state.
Ntypedef enum {
N  osThreadInactive        =  0,         ///< Inactive.
N  osThreadReady           =  1,         ///< Ready.
N  osThreadRunning         =  2,         ///< Running.
N  osThreadBlocked         =  3,         ///< Blocked.
N  osThreadTerminated      =  4,         ///< Terminated.
N  osThreadError           = -1,         ///< Error.
N  osThreadReserved        = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osThreadState_t;
N 
N/// Priority values.
Ntypedef enum {
N  osPriorityNone          =  0,         ///< No priority (not initialized).
N  osPriorityIdle          =  1,         ///< Reserved for Idle thread.
N  osPriorityLow           =  8,         ///< Priority: low
N  osPriorityLow1          =  8+1,       ///< Priority: low + 1
N  osPriorityLow2          =  8+2,       ///< Priority: low + 2
N  osPriorityLow3          =  8+3,       ///< Priority: low + 3
N  osPriorityLow4          =  8+4,       ///< Priority: low + 4
N  osPriorityLow5          =  8+5,       ///< Priority: low + 5
N  osPriorityLow6          =  8+6,       ///< Priority: low + 6
N  osPriorityLow7          =  8+7,       ///< Priority: low + 7
N  osPriorityBelowNormal   = 16,         ///< Priority: below normal
N  osPriorityBelowNormal1  = 16+1,       ///< Priority: below normal + 1
N  osPriorityBelowNormal2  = 16+2,       ///< Priority: below normal + 2
N  osPriorityBelowNormal3  = 16+3,       ///< Priority: below normal + 3
N  osPriorityBelowNormal4  = 16+4,       ///< Priority: below normal + 4
N  osPriorityBelowNormal5  = 16+5,       ///< Priority: below normal + 5
N  osPriorityBelowNormal6  = 16+6,       ///< Priority: below normal + 6
N  osPriorityBelowNormal7  = 16+7,       ///< Priority: below normal + 7
N  osPriorityNormal        = 24,         ///< Priority: normal
N  osPriorityNormal1       = 24+1,       ///< Priority: normal + 1
N  osPriorityNormal2       = 24+2,       ///< Priority: normal + 2
N  osPriorityNormal3       = 24+3,       ///< Priority: normal + 3
N  osPriorityNormal4       = 24+4,       ///< Priority: normal + 4
N  osPriorityNormal5       = 24+5,       ///< Priority: normal + 5
N  osPriorityNormal6       = 24+6,       ///< Priority: normal + 6
N  osPriorityNormal7       = 24+7,       ///< Priority: normal + 7
N  osPriorityAboveNormal   = 32,         ///< Priority: above normal
N  osPriorityAboveNormal1  = 32+1,       ///< Priority: above normal + 1
N  osPriorityAboveNormal2  = 32+2,       ///< Priority: above normal + 2
N  osPriorityAboveNormal3  = 32+3,       ///< Priority: above normal + 3
N  osPriorityAboveNormal4  = 32+4,       ///< Priority: above normal + 4
N  osPriorityAboveNormal5  = 32+5,       ///< Priority: above normal + 5
N  osPriorityAboveNormal6  = 32+6,       ///< Priority: above normal + 6
N  osPriorityAboveNormal7  = 32+7,       ///< Priority: above normal + 7
N  osPriorityHigh          = 40,         ///< Priority: high
N  osPriorityHigh1         = 40+1,       ///< Priority: high + 1
N  osPriorityHigh2         = 40+2,       ///< Priority: high + 2
N  osPriorityHigh3         = 40+3,       ///< Priority: high + 3
N  osPriorityHigh4         = 40+4,       ///< Priority: high + 4
N  osPriorityHigh5         = 40+5,       ///< Priority: high + 5
N  osPriorityHigh6         = 40+6,       ///< Priority: high + 6
N  osPriorityHigh7         = 40+7,       ///< Priority: high + 7
N  osPriorityRealtime      = 48,         ///< Priority: realtime
N  osPriorityRealtime1     = 48+1,       ///< Priority: realtime + 1
N  osPriorityRealtime2     = 48+2,       ///< Priority: realtime + 2
N  osPriorityRealtime3     = 48+3,       ///< Priority: realtime + 3
N  osPriorityRealtime4     = 48+4,       ///< Priority: realtime + 4
N  osPriorityRealtime5     = 48+5,       ///< Priority: realtime + 5
N  osPriorityRealtime6     = 48+6,       ///< Priority: realtime + 6
N  osPriorityRealtime7     = 48+7,       ///< Priority: realtime + 7
N  osPriorityISR           = 56,         ///< Reserved for ISR deferred thread.
N  osPriorityError         = -1,         ///< System cannot determine priority or illegal priority.
N  osPriorityReserved      = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osPriority_t;
N 
N/// Entry point of a thread.
Ntypedef void (*osThreadFunc_t) (void *argument);
N 
N/// Timer callback function.
Ntypedef void (*osTimerFunc_t) (void *argument);
N 
N/// Timer type.
Ntypedef enum {
N  osTimerOnce               = 0,          ///< One-shot timer.
N  osTimerPeriodic           = 1           ///< Repeating timer.
N} osTimerType_t;
N 
N// Timeout value.
N#define osWaitForever         0xFFFFFFFFU ///< Wait forever timeout value.
N 
N// Flags options (\ref osThreadFlagsWait and \ref osEventFlagsWait).
N#define osFlagsWaitAny        0x00000000U ///< Wait for any flag (default).
N#define osFlagsWaitAll        0x00000001U ///< Wait for all flags.
N#define osFlagsNoClear        0x00000002U ///< Do not clear flags which have been specified to wait for.
N 
N// Flags errors (returned by osThreadFlagsXxxx and osEventFlagsXxxx).
N#define osFlagsError          0x80000000U ///< Error indicator.
N#define osFlagsErrorUnknown   0xFFFFFFFFU ///< osError (-1).
N#define osFlagsErrorTimeout   0xFFFFFFFEU ///< osErrorTimeout (-2).
N#define osFlagsErrorResource  0xFFFFFFFDU ///< osErrorResource (-3).
N#define osFlagsErrorParameter 0xFFFFFFFCU ///< osErrorParameter (-4).
N#define osFlagsErrorISR       0xFFFFFFFAU ///< osErrorISR (-6).
N 
N// Thread attributes (attr_bits in \ref osThreadAttr_t).
N#define osThreadDetached      0x00000000U ///< Thread created in detached mode (default)
N#define osThreadJoinable      0x00000001U ///< Thread created in joinable mode
N 
N// Mutex attributes (attr_bits in \ref osMutexAttr_t).
N#define osMutexRecursive      0x00000001U ///< Recursive mutex.
N#define osMutexPrioInherit    0x00000002U ///< Priority inherit protocol.
N#define osMutexRobust         0x00000008U ///< Robust mutex.
N 
N/// Status code values returned by CMSIS-RTOS functions.
Ntypedef enum {
N  osOK                      =  0,         ///< Operation completed successfully.
N  osError                   = -1,         ///< Unspecified RTOS error: run-time error but no other error message fits.
N  osErrorTimeout            = -2,         ///< Operation not completed within the timeout period.
N  osErrorResource           = -3,         ///< Resource not available.
N  osErrorParameter          = -4,         ///< Parameter error.
N  osErrorNoMemory           = -5,         ///< System is out of memory: it was impossible to allocate or reserve memory for the operation.
N  osErrorISR                = -6,         ///< Not allowed in ISR context: the function cannot be called from interrupt service routines.
N  osStatusReserved          = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osStatus_t;
N 
N 
N/// \details Thread ID identifies the thread.
Ntypedef void *osThreadId_t;
N 
N/// \details Timer ID identifies the timer.
Ntypedef void *osTimerId_t;
N 
N/// \details Event Flags ID identifies the event flags.
Ntypedef void *osEventFlagsId_t;
N 
N/// \details Mutex ID identifies the mutex.
Ntypedef void *osMutexId_t;
N 
N/// \details Semaphore ID identifies the semaphore.
Ntypedef void *osSemaphoreId_t;
N 
N/// \details Memory Pool ID identifies the memory pool.
Ntypedef void *osMemoryPoolId_t;
N 
N/// \details Message Queue ID identifies the message queue.
Ntypedef void *osMessageQueueId_t;
N 
N 
N#ifndef TZ_MODULEID_T
N#define TZ_MODULEID_T
N/// \details Data type that identifies secure software modules called by a process.
Ntypedef uint32_t TZ_ModuleId_t;
N#endif
N 
N 
N/// Attributes structure for thread.
Ntypedef struct {
N  const char                   *name;   ///< name of the thread
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                   *stack_mem;    ///< memory for stack
N  uint32_t                stack_size;   ///< size of stack
N  osPriority_t              priority;   ///< initial thread priority (default: osPriorityNormal)
N  TZ_ModuleId_t            tz_module;   ///< TrustZone module identifier
N  uint32_t                  reserved;   ///< reserved (must be 0)
N} osThreadAttr_t;
N 
N/// Attributes structure for timer.
Ntypedef struct {
N  const char                   *name;   ///< name of the timer
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osTimerAttr_t;
N 
N/// Attributes structure for event flags.
Ntypedef struct {
N  const char                   *name;   ///< name of the event flags
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osEventFlagsAttr_t;
N 
N/// Attributes structure for mutex.
Ntypedef struct {
N  const char                   *name;   ///< name of the mutex
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osMutexAttr_t;
N 
N/// Attributes structure for semaphore.
Ntypedef struct {
N  const char                   *name;   ///< name of the semaphore
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osSemaphoreAttr_t;
N 
N/// Attributes structure for memory pool.
Ntypedef struct {
N  const char                   *name;   ///< name of the memory pool
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                      *mp_mem;    ///< memory for data storage
N  uint32_t                   mp_size;   ///< size of provided memory for data storage 
N} osMemoryPoolAttr_t;
N 
N/// Attributes structure for message queue.
Ntypedef struct {
N  const char                   *name;   ///< name of the message queue
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                      *mq_mem;    ///< memory for data storage
N  uint32_t                   mq_size;   ///< size of provided memory for data storage 
N} osMessageQueueAttr_t;
N 
N 
N//  ==== Kernel Management Functions ====
N 
N/// Initialize the RTOS Kernel.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelInitialize (void);
N 
N///  Get RTOS Kernel Information.
N/// \param[out]    version       pointer to buffer for retrieving version information.
N/// \param[out]    id_buf        pointer to buffer for retrieving kernel identification string.
N/// \param[in]     id_size       size of buffer for kernel identification string.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size);
N 
N/// Get the current RTOS Kernel state.
N/// \return current RTOS Kernel state.
NosKernelState_t osKernelGetState (void);
N 
N/// Start the RTOS Kernel scheduler.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelStart (void);
N 
N/// Lock the RTOS Kernel scheduler.
N/// \return previous lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelLock (void);
N 
N/// Unlock the RTOS Kernel scheduler.
N/// \return previous lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelUnlock (void);
N 
N/// Restore the RTOS Kernel scheduler lock state.
N/// \param[in]     lock          lock state obtained by \ref osKernelLock or \ref osKernelUnlock.
N/// \return new lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelRestoreLock (int32_t lock);
N 
N/// Suspend the RTOS Kernel scheduler.
N/// \return time in ticks, for how long the system can sleep or power-down.
Nuint32_t osKernelSuspend (void);
N 
N/// Resume the RTOS Kernel scheduler.
N/// \param[in]     sleep_ticks   time in ticks for how long the system was in sleep or power-down mode.
Nvoid osKernelResume (uint32_t sleep_ticks);
N 
N/// Get the RTOS kernel tick count.
N/// \return RTOS kernel current tick count.
Nuint32_t osKernelGetTickCount (void);
N 
N/// Get the RTOS kernel tick frequency.
N/// \return frequency of the kernel tick in hertz, i.e. kernel ticks per second.
Nuint32_t osKernelGetTickFreq (void);
N 
N/// Get the RTOS kernel system timer count.
N/// \return RTOS kernel current system timer count as 32-bit value.
Nuint32_t osKernelGetSysTimerCount (void);
N 
N/// Get the RTOS kernel system timer frequency.
N/// \return frequency of the system timer in hertz, i.e. timer ticks per second.
Nuint32_t osKernelGetSysTimerFreq (void);
N 
N 
N//  ==== Thread Management Functions ====
N 
N/// Create a thread and add it to Active Threads.
N/// \param[in]     func          thread function.
N/// \param[in]     argument      pointer that is passed to the thread function as start argument.
N/// \param[in]     attr          thread attributes; NULL: default values.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr);
N 
N/// Get name of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return name as null-terminated string.
Nconst char *osThreadGetName (osThreadId_t thread_id);
N 
N/// Return the thread ID of the current running thread.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId_t osThreadGetId (void);
N 
N/// Get current thread state of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return current thread state of the specified thread.
NosThreadState_t osThreadGetState (osThreadId_t thread_id);
N 
N/// Get stack size of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return stack size in bytes.
Nuint32_t osThreadGetStackSize (osThreadId_t thread_id);
N 
N/// Get available stack space of a thread based on stack watermark recording during execution.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return remaining stack space in bytes.
Nuint32_t osThreadGetStackSpace (osThreadId_t thread_id);
N 
N/// Change priority of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \param[in]     priority      new priority value for the thread function.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority);
N 
N/// Get current priority of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return current priority value of the specified thread.
NosPriority_t osThreadGetPriority (osThreadId_t thread_id);
N 
N/// Pass control to next thread that is in state \b READY.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadYield (void);
N 
N/// Suspend execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadSuspend (osThreadId_t thread_id);
N 
N/// Resume execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadResume (osThreadId_t thread_id);
N 
N/// Detach a thread (thread storage can be reclaimed when thread terminates).
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadDetach (osThreadId_t thread_id);
N 
N/// Wait for specified thread to terminate.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadJoin (osThreadId_t thread_id);
N 
N/// Terminate execution of current running thread.
N__NO_RETURN void osThreadExit (void);
X__declspec(noreturn) void osThreadExit (void);
N 
N/// Terminate execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadTerminate (osThreadId_t thread_id);
N 
N/// Get number of active threads.
N/// \return number of active threads.
Nuint32_t osThreadGetCount (void);
N 
N/// Enumerate active threads.
N/// \param[out]    thread_array  pointer to array for retrieving thread IDs.
N/// \param[in]     array_items   maximum number of items in array for retrieving thread IDs.
N/// \return number of enumerated threads.
Nuint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items);
N 
N 
N//  ==== Thread Flags Functions ====
N 
N/// Set the specified Thread Flags of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \param[in]     flags         specifies the flags of the thread that shall be set.
N/// \return thread flags after setting or error code if highest bit set.
Nuint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags);
N 
N/// Clear the specified Thread Flags of current running thread.
N/// \param[in]     flags         specifies the flags of the thread that shall be cleared.
N/// \return thread flags before clearing or error code if highest bit set.
Nuint32_t osThreadFlagsClear (uint32_t flags);
N 
N/// Get the current Thread Flags of current running thread.
N/// \return current thread flags.
Nuint32_t osThreadFlagsGet (void);
N 
N/// Wait for one or more Thread Flags of the current running thread to become signaled.
N/// \param[in]     flags         specifies the flags to wait for.
N/// \param[in]     options       specifies flags options (osFlagsXxxx).
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return thread flags before clearing or error code if highest bit set.
Nuint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout);
N 
N 
N//  ==== Generic Wait Functions ====
N 
N/// Wait for Timeout (Time Delay).
N/// \param[in]     ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value
N/// \return status code that indicates the execution status of the function.
NosStatus_t osDelay (uint32_t ticks);
N 
N/// Wait until specified time.
N/// \param[in]     ticks         absolute time in ticks
N/// \return status code that indicates the execution status of the function.
NosStatus_t osDelayUntil (uint32_t ticks);
N 
N 
N//  ==== Timer Management Functions ====
N 
N/// Create and Initialize a timer.
N/// \param[in]     func          function pointer to callback function.
N/// \param[in]     type          \ref osTimerOnce for one-shot or \ref osTimerPeriodic for periodic behavior.
N/// \param[in]     argument      argument to the timer callback function.
N/// \param[in]     attr          timer attributes; NULL: default values.
N/// \return timer ID for reference by other functions or NULL in case of error.
NosTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr);
N 
N/// Get name of a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return name as null-terminated string.
Nconst char *osTimerGetName (osTimerId_t timer_id);
N 
N/// Start or restart a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \param[in]     ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value of the timer.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks);
N 
N/// Stop a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerStop (osTimerId_t timer_id);
N 
N/// Check if a timer is running.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return 0 not running, 1 running.
Nuint32_t osTimerIsRunning (osTimerId_t timer_id);
N 
N/// Delete a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerDelete (osTimerId_t timer_id);
N 
N 
N//  ==== Event Flags Management Functions ====
N 
N/// Create and Initialize an Event Flags object.
N/// \param[in]     attr          event flags attributes; NULL: default values.
N/// \return event flags ID for reference by other functions or NULL in case of error.
NosEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr);
N 
N/// Get name of an Event Flags object.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return name as null-terminated string.
Nconst char *osEventFlagsGetName (osEventFlagsId_t ef_id);
N 
N/// Set the specified Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags that shall be set.
N/// \return event flags after setting or error code if highest bit set.
Nuint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags);
N 
N/// Clear the specified Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags that shall be cleared.
N/// \return event flags before clearing or error code if highest bit set.
Nuint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags);
N 
N/// Get the current Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return current event flags.
Nuint32_t osEventFlagsGet (osEventFlagsId_t ef_id);
N 
N/// Wait for one or more Event Flags to become signaled.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags to wait for.
N/// \param[in]     options       specifies flags options (osFlagsXxxx).
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return event flags before clearing or error code if highest bit set.
Nuint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout);
N 
N/// Delete an Event Flags object.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id);
N 
N 
N//  ==== Mutex Management Functions ====
N 
N/// Create and Initialize a Mutex object.
N/// \param[in]     attr          mutex attributes; NULL: default values.
N/// \return mutex ID for reference by other functions or NULL in case of error.
NosMutexId_t osMutexNew (const osMutexAttr_t *attr);
N 
N/// Get name of a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return name as null-terminated string.
Nconst char *osMutexGetName (osMutexId_t mutex_id);
N 
N/// Acquire a Mutex or timeout if it is locked.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout);
N 
N/// Release a Mutex that was acquired by \ref osMutexAcquire.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexRelease (osMutexId_t mutex_id);
N 
N/// Get Thread which owns a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return thread ID of owner thread or NULL when mutex was not acquired.
NosThreadId_t osMutexGetOwner (osMutexId_t mutex_id);
N 
N/// Delete a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexDelete (osMutexId_t mutex_id);
N 
N 
N//  ==== Semaphore Management Functions ====
N 
N/// Create and Initialize a Semaphore object.
N/// \param[in]     max_count     maximum number of available tokens.
N/// \param[in]     initial_count initial number of available tokens.
N/// \param[in]     attr          semaphore attributes; NULL: default values.
N/// \return semaphore ID for reference by other functions or NULL in case of error.
NosSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr);
N 
N/// Get name of a Semaphore object.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return name as null-terminated string.
Nconst char *osSemaphoreGetName (osSemaphoreId_t semaphore_id);
N 
N/// Acquire a Semaphore token or timeout if no tokens are available.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout);
N 
N/// Release a Semaphore token up to the initial maximum count.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id);
N 
N/// Get current Semaphore token count.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return number of tokens available.
Nuint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id);
N 
N/// Delete a Semaphore object.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id);
N 
N 
N//  ==== Memory Pool Management Functions ====
N 
N/// Create and Initialize a Memory Pool object.
N/// \param[in]     block_count   maximum number of memory blocks in memory pool.
N/// \param[in]     block_size    memory block size in bytes.
N/// \param[in]     attr          memory pool attributes; NULL: default values.
N/// \return memory pool ID for reference by other functions or NULL in case of error.
NosMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr);
N 
N/// Get name of a Memory Pool object.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return name as null-terminated string.
Nconst char *osMemoryPoolGetName (osMemoryPoolId_t mp_id);
N 
N/// Allocate a memory block from a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return address of the allocated memory block or NULL in case of no memory is available.
Nvoid *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout);
N 
N/// Return an allocated memory block back to a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \param[in]     block         address of the allocated memory block to be returned to the memory pool.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block);
N 
N/// Get maximum number of memory blocks in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return maximum number of memory blocks.
Nuint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id);
N 
N/// Get memory block size in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return memory block size in bytes.
Nuint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id);
N 
N/// Get number of memory blocks used in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return number of memory blocks used.
Nuint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id);
N 
N/// Get number of memory blocks available in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return number of memory blocks available.
Nuint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id);
N 
N/// Delete a Memory Pool object.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id);
N 
N 
N//  ==== Message Queue Management Functions ====
N 
N/// Create and Initialize a Message Queue object.
N/// \param[in]     msg_count     maximum number of messages in queue.
N/// \param[in]     msg_size      maximum message size in bytes.
N/// \param[in]     attr          message queue attributes; NULL: default values.
N/// \return message queue ID for reference by other functions or NULL in case of error.
NosMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr);
N 
N/// Get name of a Message Queue object.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return name as null-terminated string.
Nconst char *osMessageQueueGetName (osMessageQueueId_t mq_id);
N 
N/// Put a Message into a Queue or timeout if Queue is full.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \param[in]     msg_ptr       pointer to buffer with message to put into a queue.
N/// \param[in]     msg_prio      message priority.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout);
N 
N/// Get a Message from a Queue or timeout if Queue is empty.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \param[out]    msg_ptr       pointer to buffer for message to get from a queue.
N/// \param[out]    msg_prio      pointer to buffer for message priority or NULL.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout);
N 
N/// Get maximum number of messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return maximum number of messages.
Nuint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id);
N 
N/// Get maximum message size in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return maximum message size in bytes.
Nuint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id);
N 
N/// Get number of queued messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return number of queued messages.
Nuint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id);
N 
N/// Get number of available slots for messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return number of available slots for messages.
Nuint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id);
N 
N/// Reset a Message Queue to initial empty state.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueReset (osMessageQueueId_t mq_id);
N 
N/// Delete a Message Queue object.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id);
N 
N 
N#ifdef  __cplusplus
S}
N#endif
N 
N#endif  // CMSIS_OS2_H_
L 14 "..\..\..\..\scpu\drivers\src\kdp520_usbd.c" 2
N#include "scu_extreg.h"
L 1 "..\..\..\..\scpu\drivers\include\scu_extreg.h" 1
N#ifndef __SCU_EXTREG_H__
N#define __SCU_EXTREG_H__
N
N
N#include "kneron_mozart.h"
L 1 "..\..\..\..\scpu\device\include\Kneron\kneron_mozart.h" 1
N/**************************************************************************//**
N * @file     kneron_mozart.h
N * @brief    CMSIS Core Peripheral Access Layer Header File for
N *           ARMCM4 Device (configured for CM4 without FPU)
N * @version  V5.3.1
N * @date     09. July 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef Kneron_Mozart
N#define Kneron_Mozart
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N// base on Kneron_0221_v014.resmap_int_n_dma.xml
Ntypedef enum {
N/* -------------------  Cortex-M4 Processor Exceptions Numbers  ------------------- */
N    Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N    NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
N    HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N    MemoryManagement_IRQn         = -12,              /*!<   4  Memory Management, MPU mismatch, including Access Violation
N                                                                and No Match                                                     */
N    BusFault_IRQn                 = -11,              /*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
N                                                                related Fault                                                    */
N    UsageFault_IRQn               = -10,              /*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition    */
N    SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
N    DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
N    PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
N    SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
N/* -------------------  Kneron_Mozart Specific Interrupt Numbers  ------------------- */
N    PINMUX_FUNCTION_IRQ           =  0,               /*!<  0   PINMUX             */
N    DDR_FTDDR3030_IRQ             =  1,               /*!<  1   DDR                */
N    ADC_FTADCC010_IRQ             =  2,               /*!<  2   ADC                */
N    DMA_FTDMAC020_0_IRQ           =  3,               /*!<  3   DMA0               */
N    DMA_FTDMAC020_0_TC_IRQ        =  4,               /*!<  4   DMA0_TC            */
N    DMA_FTDMAC020_0_ERR_IRQ       =  5,               /*!<  5   DMA0_ERR           */
N    DMA_FTDMAC020_1_IRQ           =  6,               /*!<  6   DMA1_TC            */
N    DMA_FTDMAC020_1_TC_IRQ        =  7,               /*!<  7   DMA1               */
N    DMA_FTDMAC020_1_ERR_IRQ       =  8,               /*!<  8   DMA1_ERR           */
N    D2A_FTDPI2AHB_IRQ             =  9,               /*!<  9   DPI2AHB            */
N    GPIO_FTGPIO010_IRQ            =  10,              /*!<  10  GPIO               */
N    PWM_FTPWMTMR010_GLOBAL_IRQ    =  11,              /*!<  11  PWMTMR_GLOBAL    	 */
N    PWM_FTPWMTMR010_1_IRQ         =  12,              /*!<  12  PWMTMR_1           */
N    PWM_FTPWMTMR010_2_IRQ         =  13,              /*!<  13  PWMTMR_2           */
N    PWM_FTPWMTMR010_3_IRQ         =  14,              /*!<  14  PWMTMR_3           */
N    PWM_FTPWMTMR010_4_IRQ         =  15,              /*!<  15  PWMTMR_4           */
N    PWM_FTPWMTMR010_5_IRQ         =  16,              /*!<  16  PWMTMR_5           */
N    PWM_FTPWMTMR010_6_IRQ         =  17,              /*!<  17  PWMTMR_6           */
N    SDC_FTSDC021_IRQ              =  18,              /*!<  18  SDC                */
N    SPI_FTSPI020_IRQ              =  19,              /*!<  19  SPI                */
N    SPI_FTSPI2AHB_RD_IRQ          =  20,              /*!<  20  SPI2AHB_RD         */
N    SPI_FTSPI2AHB_WR_IRQ          =  21,              /*!<  21  SPI2AHB_WR         */
N    SPI_FTSPI2AHB_IRQ             =  22,              /*!<  22  SPI2AHB            */
N    SSP_FTSSP010_0_IRQ            =  23,              /*!<  23  SSP                */
N    SSP_FTSSP010_1_IRQ            =  24,              /*!<  24  SSP                */
N    TMR_FTTMR010_0_1_IRQ          =  25,              /*!<  25  TMR_1              */
N    TMR_FTTMR010_0_2_IRQ          =  26,              /*!<  26  TMR_2              */
N    TMR_FTTMR010_0_3_IRQ          =  27,              /*!<  27  TMR_3              */
N    TMR_FTTMR010_0_GLOBAL_IRQ     =  25,              /*!<  28  TMR_GLOBAL         */
N    UART_FTUART010_IRDA_IRQ       =  29,              /*!<  29  UART0_IRDA         */
N    UART_FTUART010_0_IRQ          =  30,              /*!<  30  UART0              */
N    UART_FTUART010_1_IRQ          =  31,              /*!<  31  UART1              */
N    WDT_FTWDT010_IRQ              =  32,              /*!<  32  WDT                */
N    NPU_NPU_IRQ                   =  33,              /*!<  33  NPU                */
N    CSI_FTCSIRX100_IRQ            =  34,              /*!<  34  CSIRX              */
N    OTG_SBS_3_IRQ                 =  35,              /*!<  35  OTG_SBS            */
N    #if 0
S    TMR_FTTMR010_1_1_IRQ          =  36,              /*!<  36  TMR010_1           */
S    TMR_FTTMR010_1_2_IRQ          =  37,              /*!<  37  TMR010_2           */
S    TMR_FTTMR010_1_3_IRQ          =  38,              /*!<  38  TMR010_3           */
S    TMR_FTTMR010_1_IRQ            =  39,              /*!<  39  TMR010             */
N    #endif
N    TMR_FTTMR010_1_GLOBAL_IRQ     =  36,              /*!<  36  TMR010_1           */
N    TMR_FTTMR010_1_1_IRQ          =  37,              /*!<  37  TMR010_2           */
N    TMR_FTTMR010_1_2_IRQ          =  38,              /*!<  38  TMR010_3           */
N    TMR_FTTMR010_1_3_IRQ          =  39,              /*!<  39  TMR010             */
N    SYS_SYSTEM_IRQ                =  40,              /*!<  40  SYSC               */
N    MIPI_TX_IRQ                   =  41,              /*!<  41  MIPI_TX            */
N    IIC_FTIIC010_0_IRQ            =  42,              /*!<  42  I2C0               */
N    IIC_FTIIC010_1_IRQ            =  43,              /*!<  43  I2C1               */
N    IIC_FTIIC010_2_IRQ            =  44,              /*!<  44  I2C2               */
N    IIC_FTIIC010_3_IRQ            =  45,              /*!<  45  I2C3               */
N    SSP_FTSSP010_0_1_IRQ          =  46,              /*!<  46  SSP_u0_1           */
N    SSP_FTSSP010_1_1_IRQ          =  47,              /*!<  47  SSP_u1_1           */
N    UART_FTUART010_1_1_IRQ        =  48,              /*!<  48  UART2              */
N    UART_FTUART010_1_2_IRQ        =  49,              /*!<  49  UART3              */
N    UART_FTUART010_1_3_IRQ        =  50,              /*!<  50  UART4              */
N    SYSC_SGI_S_STATUS_IRQ         =  51,              /*!<  51  SYSC_SGI_S         */
N    SBS_CSI_RX_IRQ                =  52,              /*!<  52  CSI_RX             */
N    LCDC_FTLCDC210_VSTATUS_IRQ    =  53,              /*!<  53  LCDC_VSTATUS       */
N    LCDC_FTLCDC210_BAUPD_IRQ      =  54,              /*!<  54  LCDC_BAUPD         */
N    LCDC_FTLCDC210_FUR_IRQ        =  55,              /*!<  55  LCDC_FUR           */
N    LCDC_FTLCDC210_MERR_IRQ       =  56,              /*!<  56  LCDC_MERR          */
N    LCDC_FTLCDC210_IRQ            =  57,              /*!<  57  LCDC               */
N    D2A_FTDPI2AHB_1_IRQ           =  58,              /*!<  9  DPI2AHB_1          */    
N} IRQn_Type;
N
N
N/* -------------------------  AHB DMA Request Number  ------------------------ */
N/* -------------------------      FTDMAC020_u0        ------------------------ */
N/* -----[Request Name]                  [Num]           [Instance] ----------- */
N#define IRDA_u1_2_NTX_RDY_REQ           0               /*FTUART010_u1_2*/
N#define IRDA_u1_2_TX_ACK                0               /*FTUART010_u1_2*/
N#define IRDA_u1_2_NRX_RDY_REQ           1               /*FTUART010_u1_2*/
N#define IRDA_u1_2_RX_ACK                1               /*FTUART010_u1_2*/
N#define IRDA_u1_3_NTX_RDY_REQ           2               /*FTUART010_u1_3*/
N#define IRDA_u1_3_TX_ACK                2               /*FTUART010_u1_3*/
N#define IRDA_u1_3_NRX_RDY_REQ           3               /*FTUART010_u1_3*/
N#define IRDA_u1_3_RX_ACK                3               /*FTUART010_u1_3*/
N#define TMR1_DMA_REQ                    4               /*FTPWM010_1*/
N#define TMR1_DMA_ACK                    4               /*FTPWM010_1*/
N#define TMR2_DMA_REQ                    5               /*FTPWM010_2*/
N#define TMR2_DMA_ACK                    5               /*FTPWM010_2*/
N#define TMR3_DMA_REQ                    6               /*FTPWM010_3*/
N#define TMR3_DMA_ACK                    6               /*FTPWM010_3*/
N#define TMR4_DMA_REQ                    7               /*FTPWM010_4*/
N#define TMR4_DMA_ACK                    7               /*FTPWM010_4*/
N#define TMR5_DMA_REQ                    8               /*FTPWM010_5*/
N#define TMR5_DMA_ACK                    8               /*FTPWM010_5*/
N#define TMR6_DMA_REQ                    9               /*FTPWM010_6*/
N#define TMR6_DMA_ACK                    9               /*FTPWM010_6*/
N#define SD_DMA_REQ                      10              /*FTSDC021*/
N#define SD_DMA_ACK                      10              /*FTSDC021*/
N#define SPI_DMA_REQ                     11              /*FTSPI020*/
N#define SPI_DMA_ACK                     11              /*FTSPI020*/
N#define SSP_u0_TX_DMA_REQ               12              /*FTSSP010_u0*/
N#define SSP_u0_TX_DMA_GNT               12              /*FTSSP010_u0*/
N#define SSP_u0_RX_DMA_REQ               13              /*FTSSP010_u0*/
N#define SSP_u0_RX_DMA_GNT               13              /*FTSSP010_u0*/
N#define SSP_u0_1_TX_DMA_REQ             14              /*FTSSP010_u0_1*/
N#define SSP_u0_1_TX_DMA_GNT             14              /*FTSSP010_u0_1*/
N#define SSP_u0_1_RX_DMA_REQ             15              /*FTSSP010_u0_1*/
N#define SSP_u0_1_RX_DMA_GNT             15              /*FTSSP010_u0_1*/
N/* -------------------------      FTDMAC020_u1        ------------------------ */
N/* -----[Request Name]                  [Num]           [Instance] ----------- */
N#define SSP_u1_TX_DMA_REQ               0               /*FTSSP010_u1*/
N#define SSP_u1_TX_DMA_GNT               0               /*FTSSP010_u1*/
N#define SSP_u1_RX_DMA_REQ               1               /*FTSSP010_u1*/
N#define SSP_u1_RX_DMA_RGNT              1               /*FTSSP010_u1*/
N#define SSP_u1_1_TX_DMA_REQ             2               /*FTSSP010_u1_1*/
N#define SSP_u1_1_TX_DMA_GNT             2               /*FTSSP010_u1_1*/
N#define SSP_u1_1_RX_DMA_REQ             3               /*FTSSP010_u1_1*/
N#define SSP_u1_1_RX_DMA_GNT             3               /*FTSSP010_u1_1*/
N#define IRDA_u0_DMA_REQ                 4               /*FTUART010_u0*/
N#define IRDA_u0_DMA_ACK                 4               /*FTUART010_u0*/
N#define IRDA_u0_NTX_RDY                 5               /*FTUART010_u0*/
N#define IRDA_u0_TX_ACK                  5               /*FTUART010_u0*/
N#define IRDA_u0_NRX_RDY                 6               /*FTUART010_u0*/
N#define IRDA_u0_RX_ACK                  6               /*FTUART010_u0*/
N#define IRDA_u1_NTX_RDY                 7               /*FTUART010_u1*/
N#define IRDA_u1_TX_ACK                  7               /*FTUART010_u1*/
N#define IRDA_u1_NRX_RDY                 8               /*FTUART010_u1*/
N#define IRDA_u1_RX_ACK                  8               /*FTUART010_u1*/
N#define IRDA_u1_1_NTX_RDY               9               /*FTUART010_u1_1*/
N#define IRDA_u1_1_TX_ACK                9               /*FTUART010_u1_1*/
N#define IRDA_u1_1_NRX_RDY               10              /*FTUART010_u1_1*/
N#define IRDA_u1_1_RX_ACK                10              /*FTUART010_u1_1*/
N#define ADC_DMA_REQ_0                   11              /*FTADCC010*/
N#define ADC_DMA_ACK_0                   11              /*FTADCC010*/
N#define ADC_DMA_REQ_1                   12              /*FTADCC010*/
N#define ADC_DMA_ACK_1                   12              /*FTADCC010*/
N#define ADC_DMA_REQ_2                   13              /*FTADCC010*/
N#define ADC_DMA_ACK_2                   13              /*FTADCC010*/
N#define ADC_DMA_REQ_3                   14              /*FTADCC010*/
N#define ADC_DMA_REQ_3                   14              /*FTADCC010*/
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* -------  Start of section using anonymous unions and disabling warnings  ------- */
N#if   defined (__CC_ARM)
X#if   1L
N    #pragma push
N    #pragma anon_unions
N#elif defined (__ICCARM__)
X#elif 0L
S    #pragma language=extended
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S    #pragma clang diagnostic push
S    #pragma clang diagnostic ignored "-Wc11-extensions"
S    #pragma clang diagnostic ignored "-Wreserved-id-macro"
S#elif defined (__GNUC__)
S    /* anonymous unions are enabled by default */
S#elif defined (__TMS470__)
S    /* anonymous unions are enabled by default */
S#elif defined (__TASKING__)
S    #pragma warning 586
S#elif defined (__CSMC__)
S    /* anonymous unions are enabled by default */
S#else
S    #warning Not supported compiler type
N#endif
N
N/* --------  Configuration of Core Peripherals  ----------------------------------- */
N#define __CM4_REV                 0x0001U   /* Core revision r0p1 */
N#define __MPU_PRESENT             1U        /* MPU present */
N#define __VTOR_PRESENT            1U        /* VTOR present */
N#define __NVIC_PRIO_BITS          3U        /* Number of Bits used for Priority Levels */
N#define __Vendor_SysTickConfig    0U        /* Set to 1 if different SysTick Config is used */
N#define __FPU_PRESENT             1U        /* with FPU present */
N
N#include "core_cm4.h"                       /* Processor and core peripherals */
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V5.1.2
N * @date     04. June 2021
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M4
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.5
N * @date     02. February 2022
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2022 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 6U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 2
N
N/* CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM4_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM4_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) |                                     __CM4_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (4U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
X    #if 1L && (1U == 1U)
N      #define __FPU_USED       1U
N    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
N    #endif
N  #else
S    #define __FPU_USED         0U
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #if defined __ARM_FP
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.1.0
N * @date     09. October 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.3.2
N * @date     27. May 2021
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2021 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060750 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (0L && (__TARGET_ARCH_6S_M  == 1))   )
S  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (1L && (1 == 1))
N  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N  /* __ARM_ARCH_8_1M_MAIN__  not applicable */
N
N/* CMSIS compiler control DSP macros */
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1 == 1))     )
N  #define __ARM_FEATURE_DSP         1
N#endif
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif
N#ifndef   __NO_RETURN
S  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N#ifndef   __COMPILER_BARRIER
N  #define __COMPILER_BARRIER()                   __memory_changed()
N#endif
N
N/* #########################  Startup and Lowlevel Init  ######################## */
N
N#ifndef __PROGRAM_START
N#define __PROGRAM_START           __main
N#endif
N
N#ifndef __INITIAL_SP
N#define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit
N#endif
N
N#ifndef __STACK_LIMIT
N#define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base
N#endif
N
N#ifndef __VECTOR_TABLE
N#define __VECTOR_TABLE            __Vectors
N#endif
N
N#ifndef __VECTOR_TABLE_ATTRIBUTE
N#define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section("RESET")))
N#endif
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (1L && (1 == 1))     )
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value != 0U; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return result;
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (1L && (1 == 1))     )
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
S{
S  if ((sat >= 1U) && (sat <= 32U))
S  {
S    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
S    const int32_t min = -1 - max ;
S    if (val > max)
S    {
S      return max;
S    }
S    else if (val < min)
S    {
S      return min;
S    }
S  }
S  return val;
S}
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
S{
S  if (sat <= 31U)
S  {
S    const uint32_t max = ((1U << sat) - 1U);
S    if (val > (int32_t)max)
S    {
S      return max;
S    }
S    else if (val < 0)
S    {
S      return 0U;
S    }
S  }
S  return (uint32_t)val;
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing special-purpose register PRIMASK.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N  __ISB();
X  __isb(0xF);
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (1L && (1 == 1))     )
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing special-purpose register FAULTMASK.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting special-purpose register FAULTMASK.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1U);
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((1L && (1U == 1U)) &&      (1L && (1U    == 1U))     )
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((1L && (1U == 1U)) &&      (1L && (1U    == 1U))     )
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#else
S  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1 == 1))     )
N
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
N
N#define __SXTB16_RORn(ARG1, ARG2)        __SXTB16(__ROR(ARG1, ARG2))
N
N#define __SXTAB16_RORn(ARG1, ARG2, ARG3) __SXTAB16(ARG1, __ROR(ARG2, ARG3))
N
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6.6 LTM (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)
X#elif 1L && (5060750 >= 6010050) && (5060750 < 6100100)
S  #include "cmsis_armclang_ltm.h"
S
S  /*
S * Arm Compiler above 6.10.1 (armclang)
S */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #define __RESTRICT                             __restrict
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 163 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000U
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT             1U
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
N    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
N    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
N#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
N#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RESERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_MMARVALID_Pos             (SCB_CFSR_MEMFAULTSR_Pos + 7U)                 /*!< SCB CFSR (MMFSR): MMARVALID Position */
N#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
N
N#define SCB_CFSR_MLSPERR_Pos               (SCB_CFSR_MEMFAULTSR_Pos + 5U)                 /*!< SCB CFSR (MMFSR): MLSPERR Position */
N#define SCB_CFSR_MLSPERR_Msk               (1UL << SCB_CFSR_MLSPERR_Pos)                  /*!< SCB CFSR (MMFSR): MLSPERR Mask */
N
N#define SCB_CFSR_MSTKERR_Pos               (SCB_CFSR_MEMFAULTSR_Pos + 4U)                 /*!< SCB CFSR (MMFSR): MSTKERR Position */
N#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
N
N#define SCB_CFSR_MUNSTKERR_Pos             (SCB_CFSR_MEMFAULTSR_Pos + 3U)                 /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
N#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
N
N#define SCB_CFSR_DACCVIOL_Pos              (SCB_CFSR_MEMFAULTSR_Pos + 1U)                 /*!< SCB CFSR (MMFSR): DACCVIOL Position */
N#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
N
N#define SCB_CFSR_IACCVIOL_Pos              (SCB_CFSR_MEMFAULTSR_Pos + 0U)                 /*!< SCB CFSR (MMFSR): IACCVIOL Position */
N#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
N
N/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
N#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
N
N#define SCB_CFSR_LSPERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 5U)                  /*!< SCB CFSR (BFSR): LSPERR Position */
N#define SCB_CFSR_LSPERR_Msk               (1UL << SCB_CFSR_LSPERR_Pos)                    /*!< SCB CFSR (BFSR): LSPERR Mask */
N
N#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
N#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
N
N#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
N#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
N
N#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
N#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
N
N#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
N#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
N
N#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
N#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
N
N/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
N#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
N
N#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
N#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
N
N#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
N#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
N
N#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
N#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
N
N#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
N#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
N
N#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
N#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[32U];
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFFFFFFFFUL /*<< ITM_TPR_PRIVMASK_Pos*/)     /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IM  uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile const  uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER Register */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x1UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x1UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY2_Pos          0U                                         /*!< TPI ITATBCTR2: ATREADY2 Position */
N#define TPI_ITATBCTR2_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY2_Pos*/)   /*!< TPI ITATBCTR2: ATREADY2 Mask */
N
N#define TPI_ITATBCTR2_ATREADY1_Pos          0U                                         /*!< TPI ITATBCTR2: ATREADY1 Position */
N#define TPI_ITATBCTR2_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY1_Pos*/)   /*!< TPI ITATBCTR2: ATREADY1 Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x1UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x1UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY2_Pos          0U                                         /*!< TPI ITATBCTR0: ATREADY2 Position */
N#define TPI_ITATBCTR0_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY2_Pos*/)   /*!< TPI ITATBCTR0: ATREADY2 Mask */
N
N#define TPI_ITATBCTR0_ATREADY1_Pos          0U                                         /*!< TPI ITATBCTR0: ATREADY1 Position */
N#define TPI_ITATBCTR0_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY1_Pos*/)   /*!< TPI ITATBCTR0: ATREADY1 Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x3UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_SubType_Pos             4U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N#define TPI_DEVTYPE_MajorType_Pos           0U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N#define MPU_TYPE_RALIASES                  4U
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif /* defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U) */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N  \brief    Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
X  volatile uint32_t FPCCR;                   
N  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
X  volatile uint32_t FPCAR;                   
N  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
X  volatile uint32_t FPDSCR;                  
N  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
X  volatile const  uint32_t MVFR0;                   
N  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
X  volatile const  uint32_t MVFR1;                   
N  __IM  uint32_t MVFR2;                  /*!< Offset: 0x018 (R/ )  Media and FP Feature Register 2 */
X  volatile const  uint32_t MVFR2;                   
N} FPU_Type;
N
N/* Floating-Point Context Control Register Definitions */
N#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register Definitions */
N#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register Definitions */
N#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 Definitions */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 Definitions */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/* Media and FP Feature Register 2 Definitions */
N
N#define FPU_MVFR2_VFP_Misc_Pos              4U                                            /*!< MVFR2: VFP Misc bits Position */
N#define FPU_MVFR2_VFP_Misc_Msk             (0xFUL << FPU_MVFR2_VFP_Misc_Pos)              /*!< MVFR2: VFP Misc bits Mask */
N
N/*@} end of group CMSIS_FPU */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N#define FPU_BASE            (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
N#define FPU                 ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N  #define NVIC_GetActive              __NVIC_GetActive
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* The following EXC_RETURN values are saved the LR on exception entry */
N#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
N#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
N#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
N#define EXC_RETURN_HANDLER_FPU     (0xFFFFFFE1UL)     /* return to Handler mode, uses MSP after return, restore floating-point state */
N#define EXC_RETURN_THREAD_MSP_FPU  (0xFFFFFFE9UL)     /* return to Thread mode, uses MSP after return, restore floating-point state  */
N#define EXC_RETURN_THREAD_PSP_FPU  (0xFFFFFFEDUL)     /* return to Thread mode, uses PSP after return, restore floating-point state  */
N
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
X                (PriorityGroupTmp << 8U)  );               
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t __NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    __COMPILER_BARRIER();
X    __memory_changed();
N    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __COMPILER_BARRIER();
X    __memory_changed();
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __DSB();
X    __dsb(0xF);
N    __ISB();
X    __isb(0xF);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetActive(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - 3U)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3U)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)IRQn)]               >> (8U - 3U)));
N  }
N  else
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3U)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3U)) ? (uint32_t)(3U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3U));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3U)) ? (uint32_t)(3U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3U));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N  /* ARM Application Note 321 states that the M4 does not require the architectural barrier */
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
X__declspec(noreturn) static __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  __dsb(0xF);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  MPU functions  #################################### */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N
N#include "mpu_armv7.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\mpu_armv7.h" 1
N/******************************************************************************
N * @file     mpu_armv7.h
N * @brief    CMSIS MPU API for Armv7-M MPU
N * @version  V5.1.2
N * @date     25. May 2020
N ******************************************************************************/
N/*
N * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N 
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header    /* treat file as system include file */
N#endif
N 
N#ifndef ARM_MPU_ARMV7_H
N#define ARM_MPU_ARMV7_H
N
N#define ARM_MPU_REGION_SIZE_32B      ((uint8_t)0x04U) ///!< MPU Region Size 32 Bytes
N#define ARM_MPU_REGION_SIZE_64B      ((uint8_t)0x05U) ///!< MPU Region Size 64 Bytes
N#define ARM_MPU_REGION_SIZE_128B     ((uint8_t)0x06U) ///!< MPU Region Size 128 Bytes
N#define ARM_MPU_REGION_SIZE_256B     ((uint8_t)0x07U) ///!< MPU Region Size 256 Bytes
N#define ARM_MPU_REGION_SIZE_512B     ((uint8_t)0x08U) ///!< MPU Region Size 512 Bytes
N#define ARM_MPU_REGION_SIZE_1KB      ((uint8_t)0x09U) ///!< MPU Region Size 1 KByte
N#define ARM_MPU_REGION_SIZE_2KB      ((uint8_t)0x0AU) ///!< MPU Region Size 2 KBytes
N#define ARM_MPU_REGION_SIZE_4KB      ((uint8_t)0x0BU) ///!< MPU Region Size 4 KBytes
N#define ARM_MPU_REGION_SIZE_8KB      ((uint8_t)0x0CU) ///!< MPU Region Size 8 KBytes
N#define ARM_MPU_REGION_SIZE_16KB     ((uint8_t)0x0DU) ///!< MPU Region Size 16 KBytes
N#define ARM_MPU_REGION_SIZE_32KB     ((uint8_t)0x0EU) ///!< MPU Region Size 32 KBytes
N#define ARM_MPU_REGION_SIZE_64KB     ((uint8_t)0x0FU) ///!< MPU Region Size 64 KBytes
N#define ARM_MPU_REGION_SIZE_128KB    ((uint8_t)0x10U) ///!< MPU Region Size 128 KBytes
N#define ARM_MPU_REGION_SIZE_256KB    ((uint8_t)0x11U) ///!< MPU Region Size 256 KBytes
N#define ARM_MPU_REGION_SIZE_512KB    ((uint8_t)0x12U) ///!< MPU Region Size 512 KBytes
N#define ARM_MPU_REGION_SIZE_1MB      ((uint8_t)0x13U) ///!< MPU Region Size 1 MByte
N#define ARM_MPU_REGION_SIZE_2MB      ((uint8_t)0x14U) ///!< MPU Region Size 2 MBytes
N#define ARM_MPU_REGION_SIZE_4MB      ((uint8_t)0x15U) ///!< MPU Region Size 4 MBytes
N#define ARM_MPU_REGION_SIZE_8MB      ((uint8_t)0x16U) ///!< MPU Region Size 8 MBytes
N#define ARM_MPU_REGION_SIZE_16MB     ((uint8_t)0x17U) ///!< MPU Region Size 16 MBytes
N#define ARM_MPU_REGION_SIZE_32MB     ((uint8_t)0x18U) ///!< MPU Region Size 32 MBytes
N#define ARM_MPU_REGION_SIZE_64MB     ((uint8_t)0x19U) ///!< MPU Region Size 64 MBytes
N#define ARM_MPU_REGION_SIZE_128MB    ((uint8_t)0x1AU) ///!< MPU Region Size 128 MBytes
N#define ARM_MPU_REGION_SIZE_256MB    ((uint8_t)0x1BU) ///!< MPU Region Size 256 MBytes
N#define ARM_MPU_REGION_SIZE_512MB    ((uint8_t)0x1CU) ///!< MPU Region Size 512 MBytes
N#define ARM_MPU_REGION_SIZE_1GB      ((uint8_t)0x1DU) ///!< MPU Region Size 1 GByte
N#define ARM_MPU_REGION_SIZE_2GB      ((uint8_t)0x1EU) ///!< MPU Region Size 2 GBytes
N#define ARM_MPU_REGION_SIZE_4GB      ((uint8_t)0x1FU) ///!< MPU Region Size 4 GBytes
N
N#define ARM_MPU_AP_NONE 0U ///!< MPU Access Permission no access
N#define ARM_MPU_AP_PRIV 1U ///!< MPU Access Permission privileged access only
N#define ARM_MPU_AP_URO  2U ///!< MPU Access Permission unprivileged access read-only
N#define ARM_MPU_AP_FULL 3U ///!< MPU Access Permission full access
N#define ARM_MPU_AP_PRO  5U ///!< MPU Access Permission privileged access read-only
N#define ARM_MPU_AP_RO   6U ///!< MPU Access Permission read-only access
N
N/** MPU Region Base Address Register Value
N*
N* \param Region The region to be configured, number 0 to 15.
N* \param BaseAddress The base address for the region.
N*/
N#define ARM_MPU_RBAR(Region, BaseAddress) \
N  (((BaseAddress) & MPU_RBAR_ADDR_Msk) |  \
N   ((Region) & MPU_RBAR_REGION_Msk)    |  \
N   (MPU_RBAR_VALID_Msk))
X#define ARM_MPU_RBAR(Region, BaseAddress)   (((BaseAddress) & MPU_RBAR_ADDR_Msk) |     ((Region) & MPU_RBAR_REGION_Msk)    |     (MPU_RBAR_VALID_Msk))
N
N/**
N* MPU Memory Access Attributes
N* 
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N*/  
N#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)   \
N  ((((TypeExtField) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                  | \
N   (((IsShareable)  << MPU_RASR_S_Pos)   & MPU_RASR_S_Msk)                    | \
N   (((IsCacheable)  << MPU_RASR_C_Pos)   & MPU_RASR_C_Msk)                    | \
N   (((IsBufferable) << MPU_RASR_B_Pos)   & MPU_RASR_B_Msk))
X#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)     ((((TypeExtField) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                  |    (((IsShareable)  << MPU_RASR_S_Pos)   & MPU_RASR_S_Msk)                    |    (((IsCacheable)  << MPU_RASR_C_Pos)   & MPU_RASR_C_Msk)                    |    (((IsBufferable) << MPU_RASR_B_Pos)   & MPU_RASR_B_Msk))
N
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param AccessAttributes  Memory access attribution, see \ref ARM_MPU_ACCESS_.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/
N#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)    \
N  ((((DisableExec)      << MPU_RASR_XN_Pos)   & MPU_RASR_XN_Msk)                                  | \
N   (((AccessPermission) << MPU_RASR_AP_Pos)   & MPU_RASR_AP_Msk)                                  | \
N   (((AccessAttributes) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk))) | \
N   (((SubRegionDisable) << MPU_RASR_SRD_Pos)  & MPU_RASR_SRD_Msk)                                 | \
N   (((Size)             << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk)                                | \
N   (((MPU_RASR_ENABLE_Msk))))
X#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)      ((((DisableExec)      << MPU_RASR_XN_Pos)   & MPU_RASR_XN_Msk)                                  |    (((AccessPermission) << MPU_RASR_AP_Pos)   & MPU_RASR_AP_Msk)                                  |    (((AccessAttributes) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk))) |    (((SubRegionDisable) << MPU_RASR_SRD_Pos)  & MPU_RASR_SRD_Msk)                                 |    (((Size)             << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk)                                |    (((MPU_RASR_ENABLE_Msk))))
N
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/                         
N#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size) \
N  ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
X#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size)   ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
N
N/**
N* MPU Memory Access Attribute for strongly ordered memory.
N*  - TEX: 000b
N*  - Shareable
N*  - Non-cacheable
N*  - Non-bufferable
N*/ 
N#define ARM_MPU_ACCESS_ORDERED ARM_MPU_ACCESS_(0U, 1U, 0U, 0U)
N
N/**
N* MPU Memory Access Attribute for device memory.
N*  - TEX: 000b (if shareable) or 010b (if non-shareable)
N*  - Shareable or non-shareable
N*  - Non-cacheable
N*  - Bufferable (if shareable) or non-bufferable (if non-shareable)
N*
N* \param IsShareable Configures the device memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_DEVICE(IsShareable) ((IsShareable) ? ARM_MPU_ACCESS_(0U, 1U, 0U, 1U) : ARM_MPU_ACCESS_(2U, 0U, 0U, 0U))
N
N/**
N* MPU Memory Access Attribute for normal memory.
N*  - TEX: 1BBb (reflecting outer cacheability rules)
N*  - Shareable or non-shareable
N*  - Cacheable or non-cacheable (reflecting inner cacheability rules)
N*  - Bufferable or non-bufferable (reflecting inner cacheability rules)
N*
N* \param OuterCp Configures the outer cache policy.
N* \param InnerCp Configures the inner cache policy.
N* \param IsShareable Configures the memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_NORMAL(OuterCp, InnerCp, IsShareable) ARM_MPU_ACCESS_((4U | (OuterCp)), IsShareable, ((InnerCp) >> 1U), ((InnerCp) & 1U))
N
N/**
N* MPU Memory Access Attribute non-cacheable policy.
N*/
N#define ARM_MPU_CACHEP_NOCACHE 0U
N
N/**
N* MPU Memory Access Attribute write-back, write and read allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_WRA 1U
N
N/**
N* MPU Memory Access Attribute write-through, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WT_NWA 2U
N
N/**
N* MPU Memory Access Attribute write-back, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_NWA 3U
N
N
N/**
N* Struct for a single MPU Region
N*/
Ntypedef struct {
N  uint32_t RBAR; //!< The region base address register value (RBAR)
N  uint32_t RASR; //!< The region attribute and size register value (RASR) \ref MPU_RASR
N} ARM_MPU_Region_t;
N    
N/** Enable the MPU.
N* \param MPU_Control Default access permissions for unconfigured regions.
N*/
N__STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control)
Xstatic __inline void ARM_MPU_Enable(uint32_t MPU_Control)
N{
N  __DMB();
X  __dmb(0xF);
N  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL = MPU_Control | (1UL );
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
N  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR |= (1UL << 16U);
N#endif
N  __DSB();
X  __dsb(0xF);
N  __ISB();
X  __isb(0xF);
N}
N
N/** Disable the MPU.
N*/
N__STATIC_INLINE void ARM_MPU_Disable(void)
Xstatic __inline void ARM_MPU_Disable(void)
N{
N  __DMB();
X  __dmb(0xF);
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
N  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR &= ~(1UL << 16U);
N#endif
N  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL  &= ~(1UL );
N  __DSB();
X  __dsb(0xF);
N  __ISB();
X  __isb(0xF);
N}
N
N/** Clear and disable the given MPU region.
N* \param rnr Region number to be cleared.
N*/
N__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
Xstatic __inline void ARM_MPU_ClrRegion(uint32_t rnr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RASR = 0U;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = 0U;
N}
N
N/** Configure an MPU region.
N* \param rbar Value for RBAR register.
N* \param rasr Value for RASR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
N{
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Configure the given MPU region.
N* \param rnr Region number to be configured.
N* \param rbar Value for RBAR register.
N* \param rasr Value for RASR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Memcpy with strictly ordered memory access, e.g. used by code in ARM_MPU_Load().
N* \param dst Destination data is copied to.
N* \param src Source data is copied from.
N* \param len Amount of data words to be copied.
N*/
N__STATIC_INLINE void ARM_MPU_OrderedMemcpy(volatile uint32_t* dst, const uint32_t* __RESTRICT src, uint32_t len)
Xstatic __inline void ARM_MPU_OrderedMemcpy(volatile uint32_t* dst, const uint32_t* __restrict src, uint32_t len)
N{
N  uint32_t i;
N  for (i = 0U; i < len; ++i) 
N  {
N    dst[i] = src[i];
N  }
N}
N
N/** Load the given number of MPU regions from a table.
N* \param table Pointer to the MPU configuration table.
N* \param cnt Amount of regions to be configured.
N*/
N__STATIC_INLINE void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
Xstatic __inline void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
N{
N  const uint32_t rowWordSize = sizeof(ARM_MPU_Region_t)/4U;
N  while (cnt > MPU_TYPE_RALIASES) {
X  while (cnt > 4U) {
N    ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), MPU_TYPE_RALIASES*rowWordSize);
X    ARM_MPU_OrderedMemcpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), 4U*rowWordSize);
N    table += MPU_TYPE_RALIASES;
X    table += 4U;
N    cnt -= MPU_TYPE_RALIASES;
X    cnt -= 4U;
N  }
N  ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), cnt*rowWordSize);
X  ARM_MPU_OrderedMemcpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), cnt*rowWordSize);
N}
N
N#endif
L 1961 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 2
N
N#endif
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N  uint32_t mvfr0;
N
N  mvfr0 = FPU->MVFR0;
X  mvfr0 = ((FPU_Type *) ((0xE000E000UL) + 0x0F30UL) )->MVFR0;
N  if      ((mvfr0 & (FPU_MVFR0_Single_precision_Msk | FPU_MVFR0_Double_precision_Msk)) == 0x020U)
X  if      ((mvfr0 & ((0xFUL << 4U) | (0xFUL << 8U))) == 0x020U)
N  {
N    return 1U;           /* Single precision FPU */
N  }
N  else
N  {
N    return 0U;           /* No FPU */
N  }
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0U == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 3U) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != ((int32_t)0x5AA55AA5U))
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = ((int32_t)0x5AA55AA5U);        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == ((int32_t)0x5AA55AA5U))
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 221 "..\..\..\..\scpu\device\include\Kneron\kneron_mozart.h" 2
N#include "system_ARMCM4.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include\system_ARMCM4.h" 1
N/**************************************************************************//**
N * @file     system_ARMCM4.h
N * @brief    CMSIS Device System Header File for
N *           ARMCM4 Device
N * @version  V5.3.2
N * @date     15. November 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef SYSTEM_ARMCM4_H
N#define SYSTEM_ARMCM4_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N  \brief Exception / Interrupt Handler Function Prototype
N*/
Ntypedef void(*VECTOR_TABLE_Type)(void);
N
N/**
N  \brief System Clock Frequency (Core Clock)
N*/
Nextern uint32_t SystemCoreClock;
N
N/**
N  \brief Setup the microcontroller system.
N
N   Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N
N/**
N  \brief  Update SystemCoreClock variable.
N
N   Updates the SystemCoreClock with current core Clock retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_ARMCM4_H */
L 222 "..\..\..\..\scpu\device\include\Kneron\kneron_mozart.h" 2
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma pop
N#elif defined(__ICCARM__)
X#elif 0L
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#else
S  #warning Not supported compiler type
N#endif
N
N
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N// base on Kneron_bus_v013.xlsx
N/*  ----------------------------   SAHB Peripheral Device    --------------------------------*/
N#define SiRAM_MEM_BASE                              0x10100000
N#define SiRAM_MEM_SIZE                              0x18000/*new*/
N#define SdRAM_MEM_BASE                              0x10200000
N#define SdRAM_MEM_SIZE                              0x18000/*new*/
N#define SPIF_XIP_BASE                               0x18000000
N#define DDR_MEM_BASE                                0x60000000
N#define DDR_MEM_SIZE                                0x40000000/*new*/
N#define SPI_FTSPI020_PA_BASE                        0xA0000000
N#define DMAC_FTDMAC020_PA_BASE                      0xA0100000
N
N/*  ----------------------------   NAHB Peripheral Device    --------------------------------*/
N#define NiRAM_MEM_BASE                              0x28000000/*new*/
N#define NiRAM_MEM_SIZE                              0x10000/*new*/
N#define NdRAM_MEM_BASE                              0x0FFF0000/*new*/
N#define NdRAM_MEM_SIZE                              0x10000/*new*/
N#define NPU_PA_BASE                                 0x30000000
N#define DMAC_FTDMAC020_1_PA_BASE                    0xB0200000
N
N/*  ----------------------------   PAHB Peripheral Device    --------------------------------*/
N#define SDC_FTSDC021_PA_BASE                        0xC0000000
N#define USB_FOTG210_PA_BASE                         0xC0100000
N        
N/*  ----------------------------   APB0 Peripheral Device    --------------------------------*/
N/* IIC */
N#define IIC_FTIIC010_0_PA_BASE                      0xC1000000
N#define IIC_FTIIC010_1_PA_BASE                      0xC1100000
N#define IIC_FTIIC010_2_PA_BASE                      0xC1200000
N#define IIC_FTIIC010_3_PA_BASE                      0xC1300000
N/* UART */
N#define UART_FTUART010_0_PA_BASE                    0xC1400000
N#define UART_FTUART010_1_PA_BASE                    0xC1500000
N#define UART_FTUART010_1_1_PA_BASE                  0xC1600000
N#define UART_FTUART010_1_2_PA_BASE                  0xC1700000
N#define UART_FTUART010_1_3_PA_BASE                  0xC1800000
N/* SSP */
N#define I2S_FTSSP010_0_PA_BASE                      0xC1900000
N#define I2S_FTSSP010_1_PA_BASE                      0xC1A00000
N#define SPI_FTSSP010_0_PA_BASE                      0xC1B00000
N#define SPI_FTSSP010_1_PA_BASE                      0xC1C00000
N/* GPIO */
N#define GPIO_FTGPIO010_PA_BASE                      0xC1D00000
N/* WDT */
N#define WDT_FTWDT010_PA_BASE                        0xC1E00000
N/* PWM/TMR */
N#define PWM_FTPWMTMR010_PA_BASE                     0xC1F00000
N#define TMR_FTPWMTMR010_0_PA_BASE                   0xC2000000
N#define TMR_FTPWMTMR010_1_PA_BASE                   0xC2100000
N/* eFuse */
N#define EFUSE_PA_BASE                               0xC2200000
N/* SCU */
N#define SCU_FTSCU100_PA_BASE                        0xC2300000
N#define RTC_PA_BASE									0xC2300200
N#define SCU_EXTREG_PA_BASE                          0xC2380000
N
N/*  ----------------------------   APB1 Peripheral Device    --------------------------------*/
N/* ADC */
N#define ADC_FTTSC010_0_PA_BASE                      0xC3000000
N/* OTG-PHY */
N#define OTGPHY_FOTG210_0_PA_BASE                    0xC3100000
N/* DDRC */
N#define DDRC_FTDDR3030_PA_BASE                      0xC3200000
N/* LCDC */
N#define LCD_FTLCDC210_PA_BASE                       0xC3300000
N#define SLCD_FTLCDC210_PA_BASE                      0xC3400000
N/* MIPI */
N#define CSIRX_FTCSIRX100_PA_BASE                    0xC3500000
N#define CSIRX_FTCSIRX100_1_PA_BASE                  0xC3600000
N#define MIPIRX_PHY_CSR_PA_BASE                      0xC3700000
N#define MIPIRX_PHY_CSR_1_PA_BASE                    0xC3800000
N#define DPI2AHB_CSR_PA_BASE                         0xC3900000
N#define DPI2AHB_CSR_1_PA_BASE                       0xC3A00000
N#define CSITX_CSR_PA_BASE                           0xC3B00000
N#define DSITX_CSR_PA_BASE                           0xC3C00000
N#define MIPI_TX_PHY_PA_BASE                         0xC3D00000
N
N/*  ----------------------------   APB1 Peripheral Device    --------------------------------*/
N
N//clock
N
N#define APB_CLOCK 100000000     //FPGA:50000000
N//#define LCD_PATGEN
N// total record how much size, then play it
N#define I2S_TOTAL_SIZE          0x2000          
N#define UART_CLOCK              (30000000UL) //kneron
N#define UART_CLOCK_2            (30000000UL) //kneron
N
N//#define MIXING_MODE_OPEN_RENDERER
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif  /* Kneron_Mozart */
N
L 6 "..\..\..\..\scpu\drivers\include\scu_extreg.h" 2
N#include "types.h"
L 1 "..\..\..\..\common\include\types.h" 1
N#ifndef TYPES_H
N#define TYPES_H
N
N#include <stdint.h>
N#include <stdbool.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 6 "..\..\..\..\common\include\types.h" 2
N
N//#if TARGET_SCPU
N#define BS              0x08
N#define ESC				27
N
N#ifndef NULL
S#define NULL    0
N#endif
N
N#ifndef ENABLE
N#define ENABLE  1
N#endif
N
N#ifndef DISABLE
N#define DISABLE 0
N#endif
N
N#ifndef FALSE
N#define FALSE   0
N#endif
N
N#ifndef TRUE
N#define TRUE    1
N#endif
N#if 0
Stypedef int bool;
S#define true 1
S#define false 0
N#endif
N/* type define */
N	typedef unsigned long long 		UINT64;
N	typedef long long 				INT64;
N	typedef	unsigned int			UINT32;
N	typedef	int						INT32;
N	typedef	unsigned short			UINT16;
N	typedef	short					INT16;
N	typedef unsigned char			UINT8;
N	typedef char					INT8;
N	typedef unsigned char			BOOL;
N
N	typedef unsigned char           u8_t;
N	typedef unsigned short          u16_t;
N	typedef unsigned long           u32_t;
N	typedef unsigned long long		u64_t;
N
N	typedef unsigned char 			uchar;
N
N    typedef char                    s8;
N	typedef short                   s16;
N    typedef int                     s32;
N    typedef long long               s64;
N
N    typedef unsigned char           u8;
N	typedef unsigned short          u16;
N    typedef unsigned int            u32;
N    typedef unsigned long long      u64;
N
N#ifndef _SIZE_T
N#define _SIZE_T
Ntypedef unsigned int size_t;
N#endif
N
N#ifndef _SSIZE_T
N#define _SSIZE_T
Ntypedef long ssize_t;
N#endif
N
Ntypedef INT8          INT8S;
Ntypedef UINT8         INT8U;
Ntypedef INT16         INT16S;
Ntypedef UINT16        INT16U;
Ntypedef INT32         INT32S;
Ntypedef UINT32        INT32U;
N
N
Ntypedef unsigned char                   byte;
Ntypedef unsigned short                  word;
Ntypedef unsigned long int               dword;
N
N//#endif
N
N#endif //TYPES_H
L 7 "..\..\..\..\scpu\drivers\include\scu_extreg.h" 2
N#include "io.h"
L 1 "..\..\..\..\scpu\drivers\include\io.h" 1
N#ifndef IO_H
N#define IO_H
N
N
N#define readl(addr)             (*(volatile unsigned int *)(addr))
N#define writel(val, addr)       (*(volatile unsigned int *)(addr) = (val))
N
N#define readw(addr)             (*(volatile unsigned short *)(addr))
N#define writew(val, addr)       (*(volatile unsigned short *)(addr) = (val))
N
N#define readb(addr)             (*(volatile unsigned char *)(addr))
N#define writeb(val, addr)       (*(volatile unsigned char *)(addr) = (val))
N
N#define inl(p)                  readl(p)
N#define outl(v, p)              writel(v, p)
N
N#define inw(port)               readl(port)
N#define outw(port, val)         writel(val, port)
N
N#define inb(port)               readb(port)
N#define outb(port, val)         writeb(val, port)
N
N//#define inhw(port)            readw(port)
N//#define outhw(port, val)      writew(val, port)
N#define inhw(port)              readl(port)
N#define outhw(port, val)        writel(val, port)
N
N#define u32Lib_LeRead32(x)      *((volatile INT32U *)((INT8U * )x)) //bessel:add  (INT8U * )
N#define vLib_LeWrite32(x,y)     *(volatile INT32U *)((INT8U * )x)=(y)  //bessel:add  (INT8U * )
N
N#define masked_outw(port, val, mask)    outw(port, (inw(port) & ~mask) | (val & mask))
N
N#define GET_BIT(port, __bit) \
N    ((inw(port) & BIT##__bit) >> __bit)
X#define GET_BIT(port, __bit)     ((inw(port) & BIT##__bit) >> __bit)
N
N#define GET_BITS(port, __s_bit, __e_bit) \
N    ((inw(port) & (BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) >> __s_bit)
X#define GET_BITS(port, __s_bit, __e_bit)     ((inw(port) & (BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) >> __s_bit)
N
N#define SET_BIT(port, __bit) \
N    outw(port, BIT##__bit)
X#define SET_BIT(port, __bit)     outw(port, BIT##__bit)
N
N#define SET_MASKED_BIT(port, val, __bit) \
N    outw(port, (inw(port) & ~BIT##__bit) | ((val << __bit) & BIT##__bit))
X#define SET_MASKED_BIT(port, val, __bit)     outw(port, (inw(port) & ~BIT##__bit) | ((val << __bit) & BIT##__bit))
N
N#define SET_MASKED_BITS(port, val, __s_bit, __e_bit) \
N    outw(port, ((inw(port) & ~(BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) | (val << __s_bit))); 
X#define SET_MASKED_BITS(port, val, __s_bit, __e_bit)     outw(port, ((inw(port) & ~(BIT##__e_bit | (BIT##__e_bit - BIT##__s_bit))) | (val << __s_bit))); 
N
N
N#endif // IO_H
L 8 "..\..\..\..\scpu\drivers\include\scu_extreg.h" 2
N
N
N/* I/O pinmux mode */
Nenum {
N    PINMUX_MODE0 = 0,
N    PINMUX_MODE1,
N    PINMUX_MODE2,
N    PINMUX_MODE3,
N    PINMUX_MODE4,
N    PINMUX_MODE5,
N    PINMUX_MODE6,
N    PINMUX_MODE7, 
N};
N
N
N#define PINMUX_SET(reg, mode)                       outw(reg, ((inw(reg) & ~(BIT(2) | BIT(1) | BIT(0))) | mode))
N#define PINMUX_CLR(reg)                             outw(reg, (inw(reg) & ~(BIT(2) | BIT(1) | BIT(0))))
N
N
N#define SCU_EXTREG_PLL0_SETTING                             (SCU_EXTREG_PA_BASE + 0x0000)
N#define SCU_EXTREG_PLL1_SETTING                             (SCU_EXTREG_PA_BASE + 0x0004)
N#define SCU_EXTREG_PLL2_SETTING                             (SCU_EXTREG_PA_BASE + 0x0008)
N#define SCU_EXTREG_PLL3_SETTING                             (SCU_EXTREG_PA_BASE + 0x000C)
N#define SCU_EXTREG_PLL4_SETTING                             (SCU_EXTREG_PA_BASE + 0x0010)
N#define SCU_EXTREG_PLL5_SETTING                             (SCU_EXTREG_PA_BASE + 0x003C)
N#define SCU_EXTREG_CLK_EN0                                  (SCU_EXTREG_PA_BASE + 0x0014)
N#define SCU_EXTREG_CLK_EN1                                  (SCU_EXTREG_PA_BASE + 0x0018)
N#define SCU_EXTREG_CLK_EN2                                  (SCU_EXTREG_PA_BASE + 0x001C)
N#define SCU_EXTREG_CLK_MUX_SEL                              (SCU_EXTREG_PA_BASE + 0x0020)
N#define SCU_EXTREG_CLK_DIV0                                 (SCU_EXTREG_PA_BASE + 0x0024)
N#define SCU_EXTREG_CLK_DIV1                                 (SCU_EXTREG_PA_BASE + 0x0028)
N#define SCU_EXTREG_CLK_DIV2                                 (SCU_EXTREG_PA_BASE + 0x002C)
N#define SCU_EXTREG_CLK_DIV3                                 (SCU_EXTREG_PA_BASE + 0x0030)
N#define SCU_EXTREG_CLK_DIV4                                 (SCU_EXTREG_PA_BASE + 0x0034)
N#define SCU_EXTREG_CLK_DIV5                                 (SCU_EXTREG_PA_BASE + 0x0038)
N#define SCU_EXTREG_SWRST_MASK0                              (SCU_EXTREG_PA_BASE + 0x0040)
N#define SCU_EXTREG_SWRST_MASK1                              (SCU_EXTREG_PA_BASE + 0x0044)
N#define SCU_EXTREG_SWRST_MASK2                              (SCU_EXTREG_PA_BASE + 0x0048)
N#define SCU_EXTREG_SWRST                                    (SCU_EXTREG_PA_BASE + 0x004C)
N#define SCU_EXTREG_CM4_NCPU_CTRL                            (SCU_EXTREG_PA_BASE + 0x0068)
N#define SCU_EXTREG_DDR_CTRL                                 (SCU_EXTREG_PA_BASE + 0x0080)
N#define SCU_EXTREG_USB_OTG_CTRL                             (SCU_EXTREG_PA_BASE + 0x008C)
N#define SCU_EXTREG_CSIRX_CTRL0                              (SCU_EXTREG_PA_BASE + 0x0090)
N#define SCU_EXTREG_CSIRX_CTRL1                              (SCU_EXTREG_PA_BASE + 0x0094)
N#define SCU_EXTREG_DPI2AHB_CTRL                             (SCU_EXTREG_PA_BASE + 0x009C)
N#define SCU_EXTREG_MISC                                     (SCU_EXTREG_PA_BASE + 0x00B0)
N#define SCU_EXTREG_CLK_DIV6                                 (SCU_EXTREG_PA_BASE + 0x00D0)
N#define SCU_EXTREG_CLK_DIV7                                 (SCU_EXTREG_PA_BASE + 0x00D4)
N#define SCU_EXTREG_SPI_CS_N                                 (SCU_EXTREG_PA_BASE + 0x0100)
N#define SCU_EXTREG_SPI_CLK                                  (SCU_EXTREG_PA_BASE + 0x0104)
N#define SCU_EXTREG_SPI_DO                                   (SCU_EXTREG_PA_BASE + 0x0108)
N#define SCU_EXTREG_SPI_DI                                   (SCU_EXTREG_PA_BASE + 0x010C)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0110)
N
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL                        (SCU_EXTREG_PA_BASE + 0x0114)
N#define SCU_EXTREG_SWJ_TRST_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0118)
N#define SCU_EXTREG_SWJ_TDI_IOCTRL                           (SCU_EXTREG_PA_BASE + 0x011C)
N#define SCU_EXTREG_SWJ_SWDITMS_IOCTRL                       (SCU_EXTREG_PA_BASE + 0x0120)
N#define SCU_EXTREG_SWJ_SWCLKTCK_IOCTRL                      (SCU_EXTREG_PA_BASE + 0x0124)
N#define SCU_EXTREG_SWJ_TDO_IOCTRL                           (SCU_EXTREG_PA_BASE + 0x0128)
N#define SCU_EXTREG_LC_PCLK_IOCTRL                           (SCU_EXTREG_PA_BASE + 0x012C)
N#define SCU_EXTREG_LC_VS_IOCTRL                             (SCU_EXTREG_PA_BASE + 0x0130)
N#define SCU_EXTREG_LC_HS_IOCTRL                             (SCU_EXTREG_PA_BASE + 0x0134)
N#define SCU_EXTREG_LC_DE_IOCTRL                             (SCU_EXTREG_PA_BASE + 0x0138)
N#define SCU_EXTREG_LC_DATA0_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x013C)
N#define SCU_EXTREG_LC_DATA1_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0140)
N#define SCU_EXTREG_LC_DATA2_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0144)
N#define SCU_EXTREG_LC_DATA3_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0148)
N#define SCU_EXTREG_LC_DATA4_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x014C)
N#define SCU_EXTREG_LC_DATA5_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0150)
N#define SCU_EXTREG_LC_DATA6_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0154)
N#define SCU_EXTREG_LC_DATA7_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0158)
N#define SCU_EXTREG_LC_DATA8_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x015C)
N#define SCU_EXTREG_LC_DATA9_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0160)
N#define SCU_EXTREG_LC_DATA10_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x0164)
N#define SCU_EXTREG_LC_DATA11_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x0168)
N#define SCU_EXTREG_LC_DATA12_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x016C)
N#define SCU_EXTREG_LC_DATA13_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x0170)
N#define SCU_EXTREG_LC_DATA14_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x0174)
N#define SCU_EXTREG_LC_DATA15_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x0178)
N#define SCU_EXTREG_SD_CLK_IOCTRL                            (SCU_EXTREG_PA_BASE + 0x017C)
N#define SCU_EXTREG_SD_CMD_IOCTRL                            (SCU_EXTREG_PA_BASE + 0x0180)
N#define SCU_EXTREG_SD_DATA0_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0184)
N#define SCU_EXTREG_SD_DATA1_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0188)
N#define SCU_EXTREG_SD_DATA2_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x018C)
N#define SCU_EXTREG_SD_DATA3_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0190)
N#define SCU_EXTREG_UART0_RX_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0194)
N#define SCU_EXTREG_UART0_TX_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x0198)
N#define SCU_EXTREG_I2C0_CLK_IOCTRL                          (SCU_EXTREG_PA_BASE + 0x019C)
N#define SCU_EXTREG_I2C0_DATA_IOCTRL                         (SCU_EXTREG_PA_BASE + 0x01A0)
N#define SCU_EXTREG_PWM0_IOCTRL                              (SCU_EXTREG_PA_BASE + 0x01A4)
N#define SCU_EXTREG_OTG_DRV_VBUS_IOCTRL                      (SCU_EXTREG_PA_BASE + 0x01A8)
N#define SCU_EXTREG_SPARE0_IOCTRL                            (SCU_EXTREG_PA_BASE + 0x01B0)
N#define SCU_EXTREG_SPARE1_IOCTRL                            (SCU_EXTREG_PA_BASE + 0x01B4)
N
N
N/* PLL110HH0L */
N/* PLL0 Setting Register (Offset: 0x0000) -- Default power domain */
N/* PLL0 is the clock source of system CM4, system / peripheral bus */
N#define SCU_EXTREG_PLL0_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL0_SETTING, 24, 30)
N#define SCU_EXTREG_PLL0_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL0_SETTING, 16, 20)
N#define SCU_EXTREG_PLL0_SETTING_GET_cc()                    GET_BITS(SCU_EXTREG_PLL0_SETTING, 12, 13)
N#define SCU_EXTREG_PLL0_SETTING_GET_f()                     GET_BITS(SCU_EXTREG_PLL0_SETTING, 8, 9)
N#define SCU_EXTREG_PLL0_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL0_SETTING, 0)
N
N#define SCU_EXTREG_PLL0_SETTING_SET_ns()                    SET_MASKED_BITS(SCU_EXTREG_PLL0_SETTING, 24, 30)
N#define SCU_EXTREG_PLL0_SETTING_SET_ms()                    SET_MASKED_BITS(SCU_EXTREG_PLL0_SETTING, 16, 20)
N#define SCU_EXTREG_PLL0_SETTING_SET_cc()                    SET_MASKED_BITS(SCU_EXTREG_PLL0_SETTING, 12, 13)
N#define SCU_EXTREG_PLL0_SETTING_SET_f()                     SET_MASKED_BITS(SCU_EXTREG_PLL0_SETTING, 8, 9)
N#define SCU_EXTREG_PLL0_SETTING_SET_en()                    SET_MASKED_BIT(SCU_EXTREG_PLL0_SETTING, 0)
N
N/* PLL110HH0L */
N/* PLL1 Setting Register (Offset: 0x0004) -- NPU power domain */
N/* PLL1 is the clock source of neural CM4, and nerual bus */
N#define SCU_EXTREG_PLL1_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL1_SETTING, 24, 30)
N#define SCU_EXTREG_PLL1_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL1_SETTING, 16, 20)
N#define SCU_EXTREG_PLL1_SETTING_GET_cc()                    GET_BITS(SCU_EXTREG_PLL1_SETTING, 12, 13)
N#define SCU_EXTREG_PLL1_SETTING_GET_f()                     GET_BITS(SCU_EXTREG_PLL1_SETTING, 8, 9)
N#define SCU_EXTREG_PLL1_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL1_SETTING, 0)
N
N#define SCU_EXTREG_PLL1_SETTING_SET_ns(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL1_SETTING, val, 24, 30)
N#define SCU_EXTREG_PLL1_SETTING_SET_ms(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL1_SETTING, val, 16, 20)
N#define SCU_EXTREG_PLL1_SETTING_SET_cc(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL1_SETTING, val, 12, 13)
N#define SCU_EXTREG_PLL1_SETTING_SET_f(val)                  SET_MASKED_BITS(SCU_EXTREG_PLL1_SETTING, val, 8, 9)
N#define SCU_EXTREG_PLL1_SETTING_SET_en(val)                 SET_MASKED_BIT(SCU_EXTREG_PLL1_SETTING, val, 0)
N
N/* PLL110HH0L */
N/* PLL2 Setting Register (Offset: 0x0008) -- NPU power domain */
N/* PLL2 is the clock source of DDR controller */
N#define SCU_EXTREG_PLL2_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL2_SETTING, 24, 30)
N#define SCU_EXTREG_PLL2_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL2_SETTING, 16, 20)
N#define SCU_EXTREG_PLL2_SETTING_GET_cc()                    GET_BITS(SCU_EXTREG_PLL2_SETTING, 12, 13)
N#define SCU_EXTREG_PLL2_SETTING_GET_f()                     GET_BITS(SCU_EXTREG_PLL2_SETTING, 8, 9)
N#define SCU_EXTREG_PLL2_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL2_SETTING, 0)
N
N#define SCU_EXTREG_PLL2_SETTING_SET_ns(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL2_SETTING, val, 24, 30)
N#define SCU_EXTREG_PLL2_SETTING_SET_ms(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL2_SETTING, val, 16, 20)
N#define SCU_EXTREG_PLL2_SETTING_SET_cc(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL2_SETTING, val, 12, 13)
N#define SCU_EXTREG_PLL2_SETTING_SET_f(val)                  SET_MASKED_BITS(SCU_EXTREG_PLL2_SETTING, val, 8, 9)
N#define SCU_EXTREG_PLL2_SETTING_SET_en(val)                 SET_MASKED_BIT(SCU_EXTREG_PLL2_SETTING, val, 0)
N
N/* PLL510HH0L */
N/* PLL3 Setting Register (Offset: 0x000C) -- NPU power domain */
N/* PLL3 is the clock source of MIPI CSI RX0 */
N#define SCU_EXTREG_PLL3_SETTING_ps_MASK                     (BIT24|BIT25|BIT26|BIT27|BIT28)
N#define SCU_EXTREG_PLL3_SETTING_ns_MASK                     (BIT12|BIT13|BIT14|BIT15|BIT16|BIT17|BIT18|BIT19|BIT20)
N#define SCU_EXTREG_PLL3_SETTING_ms_MASK                     (BIT8|BIT9|BIT10)
N#define SCU_EXTREG_PLL3_SETTING_is_MASK                     (BIT4|BIT5|BIT6)
N#define SCU_EXTREG_PLL3_SETTING_rs_MASK                     (BIT2|BIT3)
N
N#define SCU_EXTREG_PLL3_SETTING_ps_START                    24
N#define SCU_EXTREG_PLL3_SETTING_ns_START                    12
N#define SCU_EXTREG_PLL3_SETTING_ms_START                    8
N#define SCU_EXTREG_PLL3_SETTING_is_START                    4
N#define SCU_EXTREG_PLL3_SETTING_rs_START                    2
N
N
N#define SCU_EXTREG_PLL3_SETTING_GET_ps()                    GET_BITS(SCU_EXTREG_PLL3_SETTING, 24, 28)
N#define SCU_EXTREG_PLL3_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL3_SETTING, 12, 20)
N#define SCU_EXTREG_PLL3_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL3_SETTING, 8, 10)
N#define SCU_EXTREG_PLL3_SETTING_GET_is()                    GET_BITS(SCU_EXTREG_PLL3_SETTING, 4, 6)
N#define SCU_EXTREG_PLL3_SETTING_GET_rs()                    GET_BITS(SCU_EXTREG_PLL3_SETTING, 2, 3)
N#define SCU_EXTREG_PLL3_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL3_SETTING, 0)
N
N#define SCU_EXTREG_PLL3_SETTING_SET_ps(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL3_SETTING, val, 24, 28)
N#define SCU_EXTREG_PLL3_SETTING_SET_ns(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL3_SETTING, val, 12, 20)
N#define SCU_EXTREG_PLL3_SETTING_SET_ms(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL3_SETTING, val, 8, 10)
N#define SCU_EXTREG_PLL3_SETTING_SET_is(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL3_SETTING, val, 4, 6)
N#define SCU_EXTREG_PLL3_SETTING_SET_rs(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL3_SETTING, val, 2, 3)
N#define SCU_EXTREG_PLL3_SETTING_SET_en(val)                 SET_MASKED_BIT(SCU_EXTREG_PLL3_SETTING, val, 0)
N
N/* PLL510HH0L */
N/* PLL4 Setting Register (Offset: 0x0010) -- Default domain */
N/* PLL4 is the clock source of NPU or audio master clock */
N#define SCU_EXTREG_PLL4_SETTING_GET_ps()                    GET_BITS(SCU_EXTREG_PLL4_SETTING, 24, 28)
N#define SCU_EXTREG_PLL4_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL4_SETTING, 12, 20)
N#define SCU_EXTREG_PLL4_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL4_SETTING, 8, 10)
N#define SCU_EXTREG_PLL4_SETTING_GET_is()                    GET_BITS(SCU_EXTREG_PLL4_SETTING, 4, 6)
N#define SCU_EXTREG_PLL4_SETTING_GET_rs()                    GET_BITS(SCU_EXTREG_PLL4_SETTING, 2, 3)
N#define SCU_EXTREG_PLL4_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL4_SETTING, 0)
N
N#define SCU_EXTREG_PLL4_SETTING_SET_ps(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL4_SETTING, val, 24, 28)
N#define SCU_EXTREG_PLL4_SETTING_SET_ns(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL4_SETTING, val, 12, 20)
N#define SCU_EXTREG_PLL4_SETTING_SET_ms(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL4_SETTING, val, 8, 10)
N#define SCU_EXTREG_PLL4_SETTING_SET_is(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL4_SETTING, val, 4, 6)
N#define SCU_EXTREG_PLL4_SETTING_SET_rs(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL4_SETTING, val, 2, 3)
N#define SCU_EXTREG_PLL4_SETTING_SET_en(val)                 SET_MASKED_BIT(SCU_EXTREG_PLL4_SETTING, val, 0)
N
N/* Clock Enable Register 0 (Offset: 0x0014) */
N#define SCU_EXTREG_CLK_EN0_GET_ncpu_traceclk()              GET_BIT(SCU_EXTREG_CLK_EN0, 24)
N#define SCU_EXTREG_CLK_EN0_GET_scpu_traceclk()              GET_BIT(SCU_EXTREG_CLK_EN0, 23)
N#define SCU_EXTREG_CLK_EN0_GET_ncpu_fclk_src()              GET_BIT(SCU_EXTREG_CLK_EN0, 22)
N#define SCU_EXTREG_CLK_EN0_GET_pll4_fref_pll0()             GET_BIT(SCU_EXTREG_CLK_EN0, 12)
N#define SCU_EXTREG_CLK_EN0_GET_pll5_out2()                  GET_BIT(SCU_EXTREG_CLK_EN0, 9)
N#define SCU_EXTREG_CLK_EN0_GET_pll5_out1()                  GET_BIT(SCU_EXTREG_CLK_EN0, 8)
N#define SCU_EXTREG_CLK_EN0_GET_pll4_out1()                  GET_BIT(SCU_EXTREG_CLK_EN0, 6)
N#define SCU_EXTREG_CLK_EN0_GET_pll3_out2()                  GET_BIT(SCU_EXTREG_CLK_EN0, 5)
N#define SCU_EXTREG_CLK_EN0_GET_pll3_out1()                  GET_BIT(SCU_EXTREG_CLK_EN0, 4)
N#define SCU_EXTREG_CLK_EN0_GET_pll2_out()                   GET_BIT(SCU_EXTREG_CLK_EN0, 2)
N#define SCU_EXTREG_CLK_EN0_GET_pll1_out()                   GET_BIT(SCU_EXTREG_CLK_EN0, 1)
N
N#define SCU_EXTREG_CLK_EN0_SET_ncpu_traceclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 24)
N#define SCU_EXTREG_CLK_EN0_SET_scpu_traceclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 23)
N#define SCU_EXTREG_CLK_EN0_SET_ncpu_fclk_src(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 22)
N#define SCU_EXTREG_CLK_EN0_SET_pll4_fref_pll0(val)          SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 12)
N#define SCU_EXTREG_CLK_EN0_SET_pll5_out2(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 9)
N#define SCU_EXTREG_CLK_EN0_SET_pll5_out1(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 8)
N#define SCU_EXTREG_CLK_EN0_SET_pll4_out1(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 6)
N#define SCU_EXTREG_CLK_EN0_SET_pll3_out2(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 5)
N#define SCU_EXTREG_CLK_EN0_SET_pll3_out1(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 4)
N#define SCU_EXTREG_CLK_EN0_SET_pll2_out(val)                SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 2)
N#define SCU_EXTREG_CLK_EN0_SET_pll1_out(val)                SET_MASKED_BIT(SCU_EXTREG_CLK_EN0, val, 1)
N
N/* Clock Enable Register 1 (Offset: 0x0018) */
N#define SCU_EXTREG_CLK_EN1_GET_spi_clk()                    GET_BIT(SCU_EXTREG_CLK_EN1, 24)
N#define SCU_EXTREG_CLK_EN1_GET_npu()                        GET_BIT(SCU_EXTREG_CLK_EN1, 23)
N#define SCU_EXTREG_CLK_EN1_GET_adcclk()                     GET_BIT(SCU_EXTREG_CLK_EN1, 22)
N#define SCU_EXTREG_CLK_EN1_GET_wdt_extclk()                 GET_BIT(SCU_EXTREG_CLK_EN1, 21)
N#define SCU_EXTREG_CLK_EN1_GET_sdclk()                      GET_BIT(SCU_EXTREG_CLK_EN1, 20)
N#define SCU_EXTREG_CLK_EN1_GET_TxHsPllRefClk()              GET_BIT(SCU_EXTREG_CLK_EN1, 16)
N#define SCU_EXTREG_CLK_EN1_GET_tx_EscClk()                  GET_BIT(SCU_EXTREG_CLK_EN1, 14)
N#define SCU_EXTREG_CLK_EN1_GET_csitx_dsi()                  GET_BIT(SCU_EXTREG_CLK_EN1, 13)
N#define SCU_EXTREG_CLK_EN1_GET_csitx_csi()                  GET_BIT(SCU_EXTREG_CLK_EN1, 12)
N#define SCU_EXTREG_CLK_EN1_GET_csirx1_TxEscClk()            GET_BIT(SCU_EXTREG_CLK_EN1, 10)
N#define SCU_EXTREG_CLK_EN1_GET_csirx1_csi()                 GET_BIT(SCU_EXTREG_CLK_EN1, 9)
N#define SCU_EXTREG_CLK_EN1_GET_csirx1_vc0()                 GET_BIT(SCU_EXTREG_CLK_EN1, 8)
N#define SCU_EXTREG_CLK_EN1_GET_csirx0_TxEscClk()            GET_BIT(SCU_EXTREG_CLK_EN1, 6)
N#define SCU_EXTREG_CLK_EN1_GET_csirx0_csi()                 GET_BIT(SCU_EXTREG_CLK_EN1, 5)
N#define SCU_EXTREG_CLK_EN1_GET_csirx0_vc0()                 GET_BIT(SCU_EXTREG_CLK_EN1, 4)
N#define SCU_EXTREG_CLK_EN1_GET_LC_SCALER()                  GET_BIT(SCU_EXTREG_CLK_EN1, 1)
N#define SCU_EXTREG_CLK_EN1_GET_LC_CLK()                     GET_BIT(SCU_EXTREG_CLK_EN1, 0)
N
N#define SCU_EXTREG_CLK_EN1_SET_spi_clk(val)                 SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 24)
N#define SCU_EXTREG_CLK_EN1_SET_npu(val)                     SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 23)
N#define SCU_EXTREG_CLK_EN1_SET_adcclk(val)                  SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 22)
N#define SCU_EXTREG_CLK_EN1_SET_wdt_extclk(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 21)
N#define SCU_EXTREG_CLK_EN1_SET_sdclk(val)                   SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 20)
N#define SCU_EXTREG_CLK_EN1_SET_TxHsPllRefClk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 16)
N#define SCU_EXTREG_CLK_EN1_SET_tx_EscClk(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 14)
N#define SCU_EXTREG_CLK_EN1_SET_csitx_dsi(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 13)
N#define SCU_EXTREG_CLK_EN1_SET_csitx_csi(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 12)
N#define SCU_EXTREG_CLK_EN1_SET_csirx1_TxEscClk(val)         SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 10)
N#define SCU_EXTREG_CLK_EN1_SET_csirx1_csi(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 9)
N#define SCU_EXTREG_CLK_EN1_SET_csirx1_vc0(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 8)
N#define SCU_EXTREG_CLK_EN1_SET_csirx0_TxEscClk(val)         SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 6)
N#define SCU_EXTREG_CLK_EN1_SET_csirx0_csi(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 5)
N#define SCU_EXTREG_CLK_EN1_SET_csirx0_vc0(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 4)
N#define SCU_EXTREG_CLK_EN1_SET_LC_SCALER(val)               SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 1)
N#define SCU_EXTREG_CLK_EN1_SET_LC_CLK(val)                  SET_MASKED_BIT(SCU_EXTREG_CLK_EN1, val, 0)
N
N/* Clock Enable Register 2 (Offset: 0x001C) */
N#define SCU_EXTREG_CLK_EN2_GET_tmr1_extclk3()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 29)
N#define SCU_EXTREG_CLK_EN2_GET_tmr1_extclk2()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 28)
N#define SCU_EXTREG_CLK_EN2_GET_tmr1_extclk1()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 27)
N#define SCU_EXTREG_CLK_EN2_GET_tmr0_extclk3()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 26)
N#define SCU_EXTREG_CLK_EN2_GET_tmr0_extclk2()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 25)
N#define SCU_EXTREG_CLK_EN2_GET_tmr0_extclk1()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 24)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk6()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 21)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk5()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 20)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk4()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 19)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk3()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 18)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk2()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 17)
N#define SCU_EXTREG_CLK_EN2_GET_pwm_extclk1()                GET_BIT(SCU_EXTREG_PLL2_SETTING, 16)
N#define SCU_EXTREG_CLK_EN2_GET_uart1_3_fref()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 15)
N#define SCU_EXTREG_CLK_EN2_GET_uart1_2_fref()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 14)
N#define SCU_EXTREG_CLK_EN2_GET_uart1_1_fref()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 13)
N#define SCU_EXTREG_CLK_EN2_GET_uart1_0_fref()               GET_BIT(SCU_EXTREG_PLL2_SETTING, 12)
N#define SCU_EXTREG_CLK_EN2_GET_uart0_fref()                 GET_BIT(SCU_EXTREG_PLL2_SETTING, 8)
N#define SCU_EXTREG_CLK_EN2_GET_ssp1_1_sspclk()              GET_BIT(SCU_EXTREG_PLL2_SETTING, 6)
N#define SCU_EXTREG_CLK_EN2_GET_ssp1_0_sspclk()              GET_BIT(SCU_EXTREG_PLL2_SETTING, 4)
N#define SCU_EXTREG_CLK_EN2_GET_ssp0_1_sspclk()              GET_BIT(SCU_EXTREG_PLL2_SETTING, 2)
N#define SCU_EXTREG_CLK_EN2_GET_ssp0_0_sspclk()              GET_BIT(SCU_EXTREG_PLL2_SETTING, 0)
N
N#define SCU_EXTREG_CLK_EN2_SET_tmr1_extclk3(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 29)
N#define SCU_EXTREG_CLK_EN2_SET_tmr1_extclk2(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 28)
N#define SCU_EXTREG_CLK_EN2_SET_tmr1_extclk1(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 27)
N#define SCU_EXTREG_CLK_EN2_SET_tmr0_extclk3(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 26)
N#define SCU_EXTREG_CLK_EN2_SET_tmr0_extclk2(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 25)
N#define SCU_EXTREG_CLK_EN2_SET_tmr0_extclk1(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 24)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk6(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 21)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk5(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 20)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk4(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 19)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk3(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 18)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk2(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 17)
N#define SCU_EXTREG_CLK_EN2_SET_pwm_extclk1(val)             SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 16)
N#define SCU_EXTREG_CLK_EN2_SET_uart1_3_fref(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 15)
N#define SCU_EXTREG_CLK_EN2_SET_uart1_2_fref(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 14)
N#define SCU_EXTREG_CLK_EN2_SET_uart1_1_fref(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 13)
N#define SCU_EXTREG_CLK_EN2_SET_uart1_0_fref(val)            SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 12)
N#define SCU_EXTREG_CLK_EN2_SET_uart0_fref(val)              SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 8)
N#define SCU_EXTREG_CLK_EN2_SET_ssp1_1_sspclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 6)
N#define SCU_EXTREG_CLK_EN2_SET_ssp1_0_sspclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 4)
N#define SCU_EXTREG_CLK_EN2_SET_ssp0_1_sspclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 2)
N#define SCU_EXTREG_CLK_EN2_SET_ssp0_0_sspclk(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_EN2, val, 0)
N
N/* Clock Mux Selection Register (Offset: 0x0020) */
N#define SCU_EXTREG_CLK_MUX_SEL_GET_ncpu_traceclk()          GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 14)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_scpu_traceclk_src()      GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 13)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_csirx1_clk()             GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 12)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_npu_clk()                GET_BITS(SCU_EXTREG_CLK_MUX_SEL, 8, 9)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_pll4_fref()              GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 6)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_uart_0_irda_uclk()       GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 4)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_ssp1_1_sspclk()          GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 3)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_ssp1_0_sspclk()          GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 2)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_ssp0_1_sspclk()          GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 1)
N#define SCU_EXTREG_CLK_MUX_SEL_GET_ssp0_0_sspclk()          GET_BIT(SCU_EXTREG_CLK_MUX_SEL, 0)
N
N#define SCU_EXTREG_CLK_MUX_SEL_SET_ncpu_traceclk(val)       SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 14)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_scpu_traceclk_src(val)   SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 13)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_csirx1_clk(val)          SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 12)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_npu_clk(val)             SET_MASKED_BITS(SCU_EXTREG_CLK_MUX_SEL, val, 8, 9)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_pll4_fref(val)           SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 6)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_uart_0_irda_uclk(val)    SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 4)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_ssp1_1_sspclk(val)       SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 3)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_ssp1_0_sspclk(val)       SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 2)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_ssp0_1_sspclk(val)       SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 1)
N#define SCU_EXTREG_CLK_MUX_SEL_SET_ssp0_0_sspclk(val)       SET_MASKED_BIT(SCU_EXTREG_CLK_MUX_SEL, val, 0)
N
N/* Clock Divider Register 0 (Offset: 0x0024) */
N#define SCU_EXTREG_CLK_DIV0_GET_ncpu_fclk()                 GET_BITS(SCU_EXTREG_CLK_DIV0, 28, 31)
N#define SCU_EXTREG_CLK_DIV0_GET_sdclk2x()                   GET_BITS(SCU_EXTREG_CLK_DIV0, 24, 27)
N#define SCU_EXTREG_CLK_DIV0_GET_spi_clk()                   GET_BITS(SCU_EXTREG_CLK_DIV0, 20, 23)
N#define SCU_EXTREG_CLK_DIV0_GET_pll4_fref_pll0()            GET_BITS(SCU_EXTREG_CLK_DIV0, 8, 12)
N
N#define SCU_EXTREG_CLK_DIV0_SET_ncpu_fclk(val)              SET_MASKED_BITS(SCU_EXTREG_CLK_DIV0, val, 28, 31)
N#define SCU_EXTREG_CLK_DIV0_SET_sdclk2x(val)                SET_MASKED_BITS(SCU_EXTREG_CLK_DIV0, val, 24, 27)
N#define SCU_EXTREG_CLK_DIV0_SET_spi_clk(val)                SET_MASKED_BITS(SCU_EXTREG_CLK_DIV0, val, 20, 23)
N#define SCU_EXTREG_CLK_DIV0_SET_pll4_fref_pll0(val)         SET_MASKED_BITS(SCU_EXTREG_CLK_DIV0, val, 8, 12)
N/* Clock Divider Register 1 (Offset: 0x0028) */
N#define SCU_EXTREG_CLK_DIV1_GET_csirx0_TxEscClk()           GET_BITS(SCU_EXTREG_CLK_DIV1, 28, 31)
N#define SCU_EXTREG_CLK_DIV1_GET_csirx0_csi()                GET_BITS(SCU_EXTREG_CLK_DIV1, 20, 24)
N#define SCU_EXTREG_CLK_DIV1_GET_csirx0_vc0()                GET_BITS(SCU_EXTREG_CLK_DIV1, 12, 16)
N#define SCU_EXTREG_CLK_DIV1_GET_LC_CLK()                    GET_BITS(SCU_EXTREG_CLK_DIV1, 4, 8)
N#define SCU_EXTREG_CLK_DIV1_GET_LC_SCALER_CLK()             GET_BITS(SCU_EXTREG_CLK_DIV1, 0, 3)
N
N#define SCU_EXTREG_CLK_DIV1_SET_csirx0_TxEscClk(val)        SET_MASKED_BITS(SCU_EXTREG_CLK_DIV1, val, 28, 31)
N#define SCU_EXTREG_CLK_DIV1_SET_csirx0_csi(val)             SET_MASKED_BITS(SCU_EXTREG_CLK_DIV1, val, 20, 24)
N#define SCU_EXTREG_CLK_DIV1_SET_csirx0_vc0(val)             SET_MASKED_BITS(SCU_EXTREG_CLK_DIV1, val, 12, 16)
N#define SCU_EXTREG_CLK_DIV1_SET_LC_CLK(val)                 SET_MASKED_BITS(SCU_EXTREG_CLK_DIV1, val, 4, 8)
N#define SCU_EXTREG_CLK_DIV1_SET_LC_SCALER_CLK(val)          SET_MASKED_BITS(SCU_EXTREG_CLK_DIV1, val, 0, 3)
N/* Clock Divider Register 2 (Offset: 0x002C) */
N#define SCU_EXTREG_CLK_DIV2_GET_npu_clk_pll5()              GET_BITS(SCU_EXTREG_CLK_DIV2, 16, 18)
N#define SCU_EXTREG_CLK_DIV2_GET_npu_clk_pll4()              GET_BITS(SCU_EXTREG_CLK_DIV2, 12, 14)
N#define SCU_EXTREG_CLK_DIV2_GET_npu_clk_pll0()              GET_BITS(SCU_EXTREG_CLK_DIV2, 8, 10)
N
N#define SCU_EXTREG_CLK_DIV2_SET_npu_clk_pll5(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV2, val, 16, 18)
N#define SCU_EXTREG_CLK_DIV2_SET_npu_clk_pll4(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV2, val, 12, 14)
N#define SCU_EXTREG_CLK_DIV2_SET_npu_clk_pll0(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV2, val, 8, 10)
N/* Clock Divider Register 3 (Offset: 0x0030) */
N#define SCU_EXTREG_CLK_DIV3_GET_ssp0_1_sspclk_slv()         GET_BITS(SCU_EXTREG_CLK_DIV3, 24, 26) 
N#define SCU_EXTREG_CLK_DIV3_GET_ssp0_1_sspclk_mst()         GET_BITS(SCU_EXTREG_CLK_DIV3, 16, 21)
N#define SCU_EXTREG_CLK_DIV3_GET_ssp0_0_sspclk_slv()         GET_BITS(SCU_EXTREG_CLK_DIV3, 8, 10)
N#define SCU_EXTREG_CLK_DIV3_GET_ssp0_0_sspclk_mst()         GET_BITS(SCU_EXTREG_CLK_DIV3, 0, 5)
N
N#define SCU_EXTREG_CLK_DIV3_SET_ssp0_1_sspclk_slv(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV3, val, 24, 26) 
N#define SCU_EXTREG_CLK_DIV3_SET_ssp0_1_sspclk_mst(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV3, val, 16, 21)
N#define SCU_EXTREG_CLK_DIV3_SET_ssp0_0_sspclk_slv(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV3, val, 8, 10)
N#define SCU_EXTREG_CLK_DIV3_SET_ssp0_0_sspclk_mst(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV3, val, 0, 5)
N/* Clock Divider Register 4 (Offset: 0x0034) */
N#define SCU_EXTREG_CLK_DIV4_GET_ssp1_1_sspclk_slv()         GET_BITS(SCU_EXTREG_CLK_DIV4, 24, 26)
N#define SCU_EXTREG_CLK_DIV4_GET_ssp1_1_sspclk_mst()         GET_BITS(SCU_EXTREG_CLK_DIV4, 16, 21)
N#define SCU_EXTREG_CLK_DIV4_GET_ssp1_0_sspclk_slv()         GET_BITS(SCU_EXTREG_CLK_DIV4, 8, 10)
N#define SCU_EXTREG_CLK_DIV4_GET_ssp1_0_sspclk_mst()         GET_BITS(SCU_EXTREG_CLK_DIV4, 0, 5)
N
N#define SCU_EXTREG_CLK_DIV4_SET_ssp1_1_sspclk_slv(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV4, val, 24, 26)
N#define SCU_EXTREG_CLK_DIV4_SET_ssp1_1_sspclk_mst(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV4, val, 16, 21)
N#define SCU_EXTREG_CLK_DIV4_SET_ssp1_0_sspclk_slv(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV4, val, 8, 10)
N#define SCU_EXTREG_CLK_DIV4_SET_ssp1_0_sspclk_mst(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV4, val, 0, 5)
N
N/* PLL510HH0L */
N/* PLL5 Setting Register (Offset: 0x003C) -- Disp -- NPU Domain */
N/* PLL5 is the clock source of pixel clock, MIPI CSI/DPI TX clock, or MIPI CSI RX1 clock*/
N#define SCU_EXTREG_PLL5_SETTING_ps_MASK                     (BIT24|BIT25|BIT26|BIT27|BIT28)
N#define SCU_EXTREG_PLL5_SETTING_ns_MASK                     (BIT12|BIT13|BIT14|BIT15|BIT16|BIT17|BIT18|BIT19|BIT20)
N#define SCU_EXTREG_PLL5_SETTING_ms_MASK                     (BIT8|BIT9|BIT10)
N#define SCU_EXTREG_PLL5_SETTING_is_MASK                     (BIT4|BIT5|BIT6)
N#define SCU_EXTREG_PLL5_SETTING_rs_MASK                     (BIT2|BIT3)
N
N#define SCU_EXTREG_PLL5_SETTING_ps_START                    24
N#define SCU_EXTREG_PLL5_SETTING_ns_START                    12
N#define SCU_EXTREG_PLL5_SETTING_ms_START                    8
N#define SCU_EXTREG_PLL5_SETTING_is_START                    4
N#define SCU_EXTREG_PLL5_SETTING_rs_START                    2
N
N#define SCU_EXTREG_PLL5_SETTING_GET_ps()                    GET_BITS(SCU_EXTREG_PLL5_SETTING, 24, 28)
N#define SCU_EXTREG_PLL5_SETTING_GET_ns()                    GET_BITS(SCU_EXTREG_PLL5_SETTING, 12, 20)
N#define SCU_EXTREG_PLL5_SETTING_GET_ms()                    GET_BITS(SCU_EXTREG_PLL5_SETTING, 8, 10)
N#define SCU_EXTREG_PLL5_SETTING_GET_is()                    GET_BITS(SCU_EXTREG_PLL5_SETTING, 4, 6)
N#define SCU_EXTREG_PLL5_SETTING_GET_rs()                    GET_BITS(SCU_EXTREG_PLL5_SETTING, 2, 3)
N#define SCU_EXTREG_PLL5_SETTING_GET_en()                    GET_BIT(SCU_EXTREG_PLL5_SETTING, 0)
N
N#define SCU_EXTREG_PLL5_SETTING_SET_ps(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL5_SETTING, val, 24, 28)
N#define SCU_EXTREG_PLL5_SETTING_SET_ns(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL5_SETTING, val, 12, 20)
N#define SCU_EXTREG_PLL5_SETTING_SET_ms(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL5_SETTING, val, 8, 10)
N#define SCU_EXTREG_PLL5_SETTING_SET_is(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL5_SETTING, val, 4, 6)
N#define SCU_EXTREG_PLL5_SETTING_SET_rs(val)                 SET_MASKED_BITS(SCU_EXTREG_PLL5_SETTING, val, 2, 3)
N#define SCU_EXTREG_PLL5_SETTING_SET_en(val)                 SET_MASKED_BIT(SCU_EXTREG_PLL5_SETTING, val, 0)
N
N/* Software Reset mask Register 0 (Offset: 0x0040) */
N#define SCU_EXTREG_SWRST_MASK0_GET_cpu_resetreq_n()         GET_BIT(SCU_EXTREG_SWRST_MASK0, 0)
N
N#define SCU_EXTREG_SWRST_MASK0_SET_cpu_resetreq_n(val)      SET_MASKED_BIT(SCU_EXTREG_SWRST_MASK0, val, 0)
N
N/* Software Reset mask Register 1 (Offset: 0x0044) */
N#define SCU_EXTREG_SWRST_MASK1_lcm_reset_n                  BIT23
N#define SCU_EXTREG_SWRST_MASK1_AResetn_u_FTLCDC210          BIT20
N#define SCU_EXTREG_SWRST_MASK1_PRESETn_u_FTLCDC210          BIT19
N#define SCU_EXTREG_SWRST_MASK1_TV_RSTn_FTLCDC210            BIT18
N#define SCU_EXTREG_SWRST_MASK1_LC_SCALER_RSTn_FTLCDC210     BIT17
N#define SCU_EXTREG_SWRST_MASK1_LC_RSTn_FTLCDC210            BIT16
N
N#define SCU_EXTREG_SWRST_MASK1_GET_lcm_reset_n()            GET_BIT(SCU_EXTREG_PLL5_SETTING, 23)
N#define SCU_EXTREG_SWRST_MASK1_SET_lcm_reset_n(val)         SET_MASKED_BIT(SCU_EXTREG_PLL5_SETTING, val, 23)
N
N/* Software Reset mask Register 2 (Offset: 0x0048) */
N
N
N/* Software Reset Register (Offset: 0x004C) */
N#define SCU_EXTREG_SWRST_GET_NPU_resetn()                   GET_BIT(SCU_EXTREG_SWRST, 2)
N#define SCU_EXTREG_SWRST_GET_PD_NPU_resetn()                GET_BIT(SCU_EXTREG_SWRST, 1)
N#define SCU_EXTREG_SWRST_GET_LCDC_resetn()                  GET_BIT(SCU_EXTREG_SWRST, 0)
N
N#define SCU_EXTREG_SWRST_SET_NPU_resetn(val)                SET_MASKED_BIT(SCU_EXTREG_SWRST, val, 2)
N#define SCU_EXTREG_SWRST_SET_PD_NPU_resetn(val)             SET_MASKED_BIT(SCU_EXTREG_SWRST, val, 1)
N#define SCU_EXTREG_SWRST_SET_LCDC_resetn(val)               SET_MASKED_BIT(SCU_EXTREG_SWRST, val, 0)
N
N/* CM4 NCPU Control Register 0 (Offset: 0x0068) */
N#define SCU_EXTREG_CM4_NCPU_CTRL_GET_wakeup()               GET_BIT(SCU_EXTREG_CM4_NCPU_CTRL, 12)
N#define SCU_EXTREG_CM4_NCPU_CTRL_SET_wakeup(val)            SET_MASKED_BIT(SCU_EXTREG_CM4_NCPU_CTRL, val, 12)
N
N/* DDR CTRL Register 0 (Offset: 0x0080) */
N#define SCU_EXTREG_DDR_CTRL_Dphy_resetn                     BIT29
N#define SCU_EXTREG_DDR_CTRL_wakeup                          BIT28
N#define SCU_EXTREG_DDR_CTRL_SELFBIAS                        BIT15
N
N#define SCU_EXTREG_DDR_CTRL_SET_Dphy_resetn(val)            SET_MASKED_BIT(SCU_EXTREG_DDR_CTRL, val, 29)
N#define SCU_EXTREG_DDR_CTRL_SET_wakeup(val)                 SET_MASKED_BIT(SCU_EXTREG_DDR_CTRL, val, 28)
N#define SCU_EXTREG_DDR_CTRL_SET_SELFBIAS(val)               SET_MASKED_BIT(SCU_EXTREG_DDR_CTRL, val, 15)
N
N/* USB OTG CTRL Register (Offset: 0x008C) */
N#define SCU_EXTREG_USB_OTG_CTRL_GET_EXTCTRL_SUSPENDM()      GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 8)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_u_iddig()               GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 7)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_wakeup()                GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 6)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_l1_wakeup()             GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 5)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_OSCOUTEN()              GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 4)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_PLLALIV()               GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 3)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_XTLSEL()                GET_BITS(SCU_EXTREG_USB_OTG_CTRL, 1, 2)
N#define SCU_EXTREG_USB_OTG_CTRL_GET_OUTCLKSEL()             GET_BIT(SCU_EXTREG_USB_OTG_CTRL, 0)
N
N#define SCU_EXTREG_USB_OTG_CTRL_SET_EXTCTRL_SUSPENDM(val)   SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 8)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_u_iddig(val)            SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 7)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_wakeup(val)             SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 6)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_l1_wakeup(val)          SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 5)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_OSCOUTEN(val)           SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 4)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_PLLALIV(val)            SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 3)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_XTLSEL(val)             SET_MASKED_BITS(SCU_EXTREG_USB_OTG_CTRL, val, 1, 2)
N#define SCU_EXTREG_USB_OTG_CTRL_SET_OUTCLKSEL(val)          SET_MASKED_BIT(SCU_EXTREG_USB_OTG_CTRL, val, 0)
N
N/* CSIRX CTRL Register 0 (Offset: 0x0090) */
N#define SCU_EXTREG_CSIRX_CTRL0_apb_rst_n                    BIT28
N#define SCU_EXTREG_CSIRX_CTRL0_pwr_rst_n                    BIT25
N#define SCU_EXTREG_CSIRX_CTRL0_sys_rst_n                    BIT24
N#define SCU_EXTREG_CSIRX_CTRL0_ClkLnEn                      BIT1
N#define SCU_EXTREG_CSIRX_CTRL0_Enable                       BIT0
N
N#define SCU_EXTREG_CSIRX_CTRL0_GET_apb_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 28)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_pwr_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 25)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_sys_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 24)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DP1()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 17)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DN1()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 16)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DP0()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 15)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DN0()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 14)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_CKP()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 13)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_CKN()            GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 12)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_ClkLnEn()                GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 1)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_Enable()                 GET_BIT(SCU_EXTREG_CSIRX_CTRL0, 0)
N
N#define SCU_EXTREG_CSIRX_CTRL0_SET_apb_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 28)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_pwr_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 25)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_sys_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 24)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_DP1(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 17)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_DN1(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 16)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_DP0(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 15)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_DN0(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 14)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_CKP(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 13)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_CMOS_IE_CKN(val)         SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 12)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_ClkLnEn(val)             SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 1)
N#define SCU_EXTREG_CSIRX_CTRL0_SET_Enable(val)              SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL0, val, 0)
N
N/* CSIRX CTRL Register 1 (Offset: 0x0094) */
N#define SCU_EXTREG_CSIRX_CTRL1_apb_rst_n                    BIT28
N#define SCU_EXTREG_CSIRX_CTRL1_pwr_rst_n                    BIT25
N#define SCU_EXTREG_CSIRX_CTRL1_sys_rst_n                    BIT24
N#define SCU_EXTREG_CSIRX_CTRL1_ClkLnEn                      BIT1
N#define SCU_EXTREG_CSIRX_CTRL1_Enable                       BIT0
N
N#define SCU_EXTREG_CSIRX_CTRL1_GET_apb_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 28)
N#define SCU_EXTREG_CSIRX_CTRL1_GET_pwr_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 25)
N#define SCU_EXTREG_CSIRX_CTRL1_GET_sys_rst_n()              GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 24)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DP1_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 17)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DN1_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 16)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DP0_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 15)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_DN0_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 14)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_CKP_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 13)
N#define SCU_EXTREG_CSIRX_CTRL0_GET_CMOS_IE_CKN_1()          GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 12)
N#define SCU_EXTREG_CSIRX_CTRL1_GET_ClkLnEn()                GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 1)
N#define SCU_EXTREG_CSIRX_CTRL1_GET_Enable()                 GET_BIT(SCU_EXTREG_CSIRX_CTRL1, 0)
N
N#define SCU_EXTREG_CSIRX_CTRL1_SET_apb_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 28)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_pwr_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 25)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_sys_rst_n(val)           SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 24)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_DP1_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 17)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_DN1_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 16)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_DP0_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 15)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_DN0_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 14)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_CKP_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 13)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_CMOS_IE_CKN_1(val)       SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 12)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_ClkLnEn(val)             SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 1)
N#define SCU_EXTREG_CSIRX_CTRL1_SET_Enable(val)              SET_MASKED_BIT(SCU_EXTREG_CSIRX_CTRL1, val, 0)
N
N/* DPIAHB Control Register (Offset: 0x009C) */
N#define SCU_EXTREG_DPI2AHB_CTRL_rst_n_1                     BIT7
N#define SCU_EXTREG_DPI2AHB_CTRL_apb_rst_n_1                 BIT6
N#define SCU_EXTREG_DPI2AHB_CTRL_sys_rst_n_1                 BIT5
N#define SCU_EXTREG_DPI2AHB_CTRL_pwr_rst_n_1                 BIT4
N#define SCU_EXTREG_DPI2AHB_CTRL_rst_n                       BIT3
N#define SCU_EXTREG_DPI2AHB_CTRL_apb_rst_n                   BIT2
N#define SCU_EXTREG_DPI2AHB_CTRL_sys_rst_n                   BIT1
N#define SCU_EXTREG_DPI2AHB_CTRL_pwr_rst_n                   BIT0
N
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_rst_n_1()               GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 7)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_apb_rst_n_1()           GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 6)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_sys_rst_n_1()           GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 5)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_pwr_rst_n_1()           GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 4)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_rst_n()                 GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 3)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_apb_rst_n()             GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 2)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_sys_rst_n()             GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 1)
N#define SCU_EXTREG_DPI2AHB_CTRL_GET_pwr_rst_n()             GET_BIT(SCU_EXTREG_DPI2AHB_CTRL, 0)
N
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_rst_n_1(val)            SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 7)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_apb_rst_n_1(val)        SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 6)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_sys_rst_n_1(val)        SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 5)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_pwr_rst_n_1(val)        SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 4)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_rst_n(val)              SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 3)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_apb_rst_n(val)          SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 2)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_sys_rst_n(val)          SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 1)
N#define SCU_EXTREG_DPI2AHB_CTRL_SET_pwr_rst_n(val)          SET_MASKED_BIT(SCU_EXTREG_DPI2AHB_CTRL, val, 0)
N
N/* Misc Register (Offset: 0x00B0) */
N#define SCU_EXTREG_MISC_GET_smr_por_n()                     GET_BITS(SCU_EXTREG_MISC, 4, 6)
N#define SCU_EXTREG_MISC_GET_lcm_cken()                      GET_BIT(SCU_EXTREG_MISC, 12)
N#define SCU_EXTREG_MISC_SET_lcm_cken(val)                   SET_MASKED_BIT(SCU_EXTREG_MISC, val, 12)
N
N
N#define SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DDRCK      BIT6
N#define SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_NPU        BIT5
N#define SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DEFAULT    BIT4
N#define SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_MASK       (SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DDRCK | \
N                                                             SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_NPU | \
N                                                             SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DEFAULT)
X#define SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_MASK       (SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DDRCK |                                                              SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_NPU |                                                              SCU_EXTREG_MISC_PWR_RESET_RELEASE_DOMAIN_DEFAULT)
N
N/* Clock Divider Register 6 (Offset: 0x00D0) */
N#define SCU_EXTREG_CLK_DIV6_GET_uart1_3_fref()              GET_BITS(SCU_EXTREG_CLK_DIV6, 24, 26)
N#define SCU_EXTREG_CLK_DIV6_GET_uart1_2_fref()              GET_BITS(SCU_EXTREG_CLK_DIV6, 20, 22)
N#define SCU_EXTREG_CLK_DIV6_GET_uart1_1_fref()              GET_BITS(SCU_EXTREG_CLK_DIV6, 16, 18)
N#define SCU_EXTREG_CLK_DIV6_GET_uart1_0_fref()              GET_BITS(SCU_EXTREG_CLK_DIV6, 12, 14)
N#define SCU_EXTREG_CLK_DIV6_GET_uart0_fref()                GET_BITS(SCU_EXTREG_CLK_DIV6, 8, 10)
N#define SCU_EXTREG_CLK_DIV6_GET_uart0_fir_fref()            GET_BITS(SCU_EXTREG_CLK_DIV6, 0, 4)
N
N#define SCU_EXTREG_CLK_DIV6_SET_uart1_3_fref(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 24, 26)
N#define SCU_EXTREG_CLK_DIV6_SET_uart1_2_fref(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 20, 22)
N#define SCU_EXTREG_CLK_DIV6_SET_uart1_1_fref(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 16, 18)
N#define SCU_EXTREG_CLK_DIV6_SET_uart1_0_fref(val)           SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 12, 14)
N#define SCU_EXTREG_CLK_DIV6_SET_uart0_fref(val)             SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 8, 10)
N#define SCU_EXTREG_CLK_DIV6_SET_uart0_fir_fref(val)         SET_MASKED_BITS(SCU_EXTREG_CLK_DIV6, val, 0, 4)
N/* Clock Divider Register 7 (Offset: 0x00D4) */
N#define SCU_EXTREG_CLK_DIV7_csirx1_TxEscClk_pll3_MASK       (BIT16|BIT17|BIT18|BIT19)
N#define SCU_EXTREG_CLK_DIV7_csi1_csi_pll3_MASK              (BIT8|BIT9|BIT10|BIT11|BIT12)
N#define SCU_EXTREG_CLK_DIV7_csi1_vc0_pll3_MASK              (BIT0|BIT1|BIT2|BIT3|BIT4)
N
N#define SCU_EXTREG_CLK_DIV7_csirx1_TxEscClk_pll3_START      16
N#define SCU_EXTREG_CLK_DIV7_csi1_csi_pll3_MASK_START        8
N#define SCU_EXTREG_CLK_DIV7_csi1_vc0_pll3_MASK_START        0
N
N#define SCU_EXTREG_CLK_DIV7_GET_ncpu_traceclk_div()         GET_BITS(SCU_EXTREG_CLK_DIV7, 23, 25)
N#define SCU_EXTREG_CLK_DIV7_GET_scpu_traceclk_div()         GET_BITS(SCU_EXTREG_CLK_DIV7, 20, 22)
N//csirx1_TxEscClk_pll5 / tx_TxEscClk / 
N#define SCU_EXTREG_CLK_DIV7_GET_csirx1_TxEscClk_pll3()      GET_BITS(SCU_EXTREG_CLK_DIV7, 16, 19)
N//csirx1_csi_pll3 / csitx_csi / dsitx_dsi / csirx1_csi_clk_pll5
N#define SCU_EXTREG_CLK_DIV7_GET_csi1_csi_pll3()             GET_BITS(SCU_EXTREG_CLK_DIV7, 8, 12)
N//csirx1_csi_pll3 / csitx_csi / dsitx_dsi / csirx1_csi_clk_pll5
N#define SCU_EXTREG_CLK_DIV7_GET_csi1_vc0_pll3()             GET_BITS(SCU_EXTREG_CLK_DIV7, 0, 4)
N
N#define SCU_EXTREG_CLK_DIV7_SET_ncpu_traceclk_div(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV7, val, 23, 25)
N#define SCU_EXTREG_CLK_DIV7_SET_scpu_traceclk_div(val)      SET_MASKED_BITS(SCU_EXTREG_CLK_DIV7, val, 20, 22)
N#define SCU_EXTREG_CLK_DIV7_SET_csirx1_TxEscClk_pll3(val)   SET_MASKED_BITS(SCU_EXTREG_CLK_DIV7, val, 16, 19)
N#define SCU_EXTREG_CLK_DIV7_SET_csi1_csi_pll3(val)          SET_MASKED_BITS(SCU_EXTREG_CLK_DIV7, val, 8, 12)
N#define SCU_EXTREG_CLK_DIV7_SET_csi1_vc0_pll3(val)          SET_MASKED_BITS(SCU_EXTREG_CLK_DIV7, val, 0, 4)
N
N
N/* SPI_CS_N IO control register (Offset 0x0100) */
N#define SCU_EXTREG_SPI_CS_N_GET_dcsr()                      GET_BITS(SCU_EXTREG_SPI_CS_N, 5, 8)
N#define SCU_EXTREG_SPI_CS_N_GET_pd()                        GET_BIT(SCU_EXTREG_SPI_CS_N, 4)
N#define SCU_EXTREG_SPI_CS_N_GET_pu()                        GET_BIT(SCU_EXTREG_SPI_CS_N, 3)
N
N#define SCU_EXTREG_SPI_CS_N_SET_dcsr(val)                   SET_MASKED_BITS(SCU_EXTREG_SPI_CS_N, val, 5, 8)
N#define SCU_EXTREG_SPI_CS_N_SET_pd(val)                     SET_MASKED_BIT(SCU_EXTREG_SPI_CS_N, 4)
N#define SCU_EXTREG_SPI_CS_N_SET_pu(val)                     SET_MASKED_BIT(SCU_EXTREG_SPI_CS_N, 3)
N
N/* SPI_CLK IO control register (Offset 0x0104) */
N#define SCU_EXTREG_SPI_CLK_GET_dcsr()                       GET_BITS(SCU_EXTREG_SPI_CLK, 5, 8)
N#define SCU_EXTREG_SPI_CLK_GET_pd()                         GET_BIT(SCU_EXTREG_SPI_CLK, 4)
N#define SCU_EXTREG_SPI_CLK_GET_pu()                         GET_BIT(SCU_EXTREG_SPI_CLK, 3)
N#define SCU_EXTREG_SPI_CLK_SET_dcsr(val)                    SET_MASKED_BITS(SCU_EXTREG_SPI_CLK, val, 5, 8)
N#define SCU_EXTREG_SPI_CLK_SET_pd(val)                      SET_MASKED_BIT(SCU_EXTREG_SPI_CLK, 4)
N#define SCU_EXTREG_SPI_CLK_SET_pu(val)                      SET_MASKED_BIT(SCU_EXTREG_SPI_CLK, 3)
N
N/* SPI_CLK IO control register (Offset 0x0108) */
N#define SCU_EXTREG_SPI_DO_GET_dcsr()                        GET_BITS(SCU_EXTREG_SPI_DO, 5, 8)
N#define SCU_EXTREG_SPI_DO_GET_pd()                          GET_BIT(SCU_EXTREG_SPI_DO, 4)
N#define SCU_EXTREG_SPI_DO_GET_pu()                          GET_BIT(SCU_EXTREG_SPI_DO, 3)
N#define SCU_EXTREG_SPI_DO_SET_dcsr(val)                     SET_MASKED_BITS(SCU_EXTREG_SPI_DO, val, 5, 8)
N#define SCU_EXTREG_SPI_DO_SET_pd(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_DO, 4)
N#define SCU_EXTREG_SPI_DO_SET_pu(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_DO, 3)
N
N/* SPI_CLK IO control register (Offset 0x010C) */
N#define SCU_EXTREG_SPI_DI_GET_dcsr()                        GET_BITS(SCU_EXTREG_SPI_DI, 5, 8)
N#define SCU_EXTREG_SPI_DI_GET_pd()                          GET_BIT(SCU_EXTREG_SPI_DI, 4)
N#define SCU_EXTREG_SPI_DI_GET_pu()                          GET_BIT(SCU_EXTREG_SPI_DI, 3)
N#define SCU_EXTREG_SPI_DI_SET_dcsr(val)                     SET_MASKED_BITS(SCU_EXTREG_SPI_DI, val, 5, 8)
N#define SCU_EXTREG_SPI_DI_SET_pd(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_DI, 4)
N#define SCU_EXTREG_SPI_DI_SET_pu(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_DI, 3)
N
N
N/* SPI_CLK IO control register (Offset 0x0110) */
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_GET_dcsr()                        GET_BITS(SCU_EXTREG_SPI_WP_N_IOCTRL, 5, 8)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_GET_pd()                          GET_BIT(SCU_EXTREG_SPI_WP_N_IOCTRL, 4)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_GET_pu()                          GET_BIT(SCU_EXTREG_SPI_WP_N_IOCTRL, 3)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_SET_dcsr(val)                     SET_MASKED_BITS(SCU_EXTREG_SPI_WP_N_IOCTRL, val, 5, 8)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_SET_pd(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_WP_N_IOCTRL, 4)
N#define SCU_EXTREG_SPI_WP_N_IOCTRL_SET_pu(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_WP_N_IOCTRL, 3)
N
N/* SPI_CLK IO control register (Offset 0x0114) */
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_GET_pd()                          GET_BIT(SCU_EXTREG_SPI_HOLD_N_IOCTRL, 4)
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_GET_dcsr()                        GET_BITS(SCU_EXTREG_SPI_HOLD_N_IOCTRL, 5, 8)
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_GET_pu()                          GET_BIT(SCU_EXTREG_SPI_HOLD_N_IOCTRL, 3)
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_SET_dcsr(val)                     SET_MASKED_BITS(SCU_EXTREG_SPI_HOLD_N_IOCTRL, val, 5, 8)
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_SET_pd(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_HOLD_N_IOCTRL, 4)
N#define SCU_EXTREG_SPI_HOLD_N_IOCTRL_SET_pu(val)                       SET_MASKED_BIT(SCU_EXTREG_SPI_HOLD_N_IOCTRL, 3)
N
N
N
N/* LC_DATA6 IO control register (Offset 0x0154) */
N#define SCU_EXTREG_LC_DATA6_GET_dcsr()                      GET_BITS(SCU_EXTREG_LC_DATA6_IOCTRL, 5, 8)
N#define SCU_EXTREG_LC_DATA6_GET_pd()                        GET_BIT(SCU_EXTREG_LC_DATA6_IOCTRL, 4)
N#define SCU_EXTREG_LC_DATA6_GET_pu()                        GET_BIT(SCU_EXTREG_LC_DATA6_IOCTRL, 3)
N#define SCU_EXTREG_LC_DATA6_SET_dcsr(val)                   SET_MASKED_BITS(SCU_EXTREG_LC_DATA6_IOCTRL, val, 5, 8)
N#define SCU_EXTREG_LC_DATA6_SET_pd(val)                     SET_MASKED_BIT(SCU_EXTREG_LC_DATA6_IOCTRL, 4)
N#define SCU_EXTREG_LC_DATA6_SET_pu(val)                     SET_MASKED_BIT(SCU_EXTREG_LC_DATA6_IOCTRL, 3)
N
N/* LC_DATA7 IO control register (Offset 0x0158) */
N#define SCU_EXTREG_LC_DATA7_GET_dcsr()                      GET_BITS(SCU_EXTREG_LC_DATA7_IOCTRL, 5, 8)
N#define SCU_EXTREG_LC_DATA7_GET_pd()                        GET_BIT(SCU_EXTREG_LC_DATA7_IOCTRL, 4)
N#define SCU_EXTREG_LC_DATA7_GET_pu()                        GET_BIT(SCU_EXTREG_LC_DATA7_IOCTRL, 3)
N#define SCU_EXTREG_LC_DATA7_SET_dcsr(val)                   SET_MASKED_BITS(SCU_EXTREG_LC_DATA7_IOCTRL, val, 5, 8)
N#define SCU_EXTREG_LC_DATA7_SET_pd(val)                     SET_MASKED_BIT(SCU_EXTREG_LC_DATA7_IOCTRL, 4)
N#define SCU_EXTREG_LC_DATA7_SET_pu(val)                     SET_MASKED_BIT(SCU_EXTREG_LC_DATA7_IOCTRL, 3)
N
N//LC DATA 15
N#define SCU_EXTREG_LC_DATA15_GET_dcsr()                     GET_BITS(SCU_EXTREG_LC_DATA15_IOCTRL, 5, 8)
N#define SCU_EXTREG_LC_DATA15_SET_dcsr(val)                  SET_MASKED_BITS(SCU_EXTREG_LC_DATA15_IOCTRL, val, 5, 8)
N
Ntypedef struct {
N    volatile unsigned int pll0_setting;
N    volatile unsigned int pll1_setting;
N    volatile unsigned int pll2_setting;
N    volatile unsigned int pll3_setting;
N    volatile unsigned int pll4_setting;
N    volatile unsigned int clk_en0;
N    volatile unsigned int clk_en1;
N    volatile unsigned int clk_en2;
N    volatile unsigned int clk_muxsel;
N    volatile unsigned int clk_div0;
N    volatile unsigned int clk_div1;
N    volatile unsigned int clk_div2;
N    volatile unsigned int clk_div3;
N    volatile unsigned int clk_div4;
N    volatile unsigned int clk_div5;
N    volatile unsigned int reserved01;
N    volatile unsigned int pll5_setting;    
N    volatile unsigned int clk_div6;
N    volatile unsigned int clk_div7;    
N    volatile unsigned int reserved02[10];
N    volatile unsigned int spi_cs_n_io;
N    volatile unsigned int spi_clk_io;
N    volatile unsigned int spi_do_io;
N    volatile unsigned int spi_di_io;
N    volatile unsigned int spi_wp_n_io;
N    volatile unsigned int spi_hold_n_io;
N    volatile unsigned int swj_trst_io;
N    volatile unsigned int swj_tdi_io;
N    volatile unsigned int swj_swditms_io;
N    volatile unsigned int swj_swclktck_io;
N    volatile unsigned int swj_swj_tdo_io;
N    volatile unsigned int lc_pclk_io;
N    /* To Do */
N    
N} kdp520_scu_extreg;
N
N
N#endif
L 15 "..\..\..\..\scpu\drivers\src\kdp520_usbd.c" 2
N#include "kdp_uart.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp_uart.h" 1
N#ifndef __KDP_UART_H__
N#define __KDP_UART_H__
N
N
N#include "types.h"
N#include "base.h"
L 1 "..\..\..\..\common\include\base.h" 1
N/**
N * @file      base.h
N * @brief     Basic utils & struct
N * @copyright (c) 2018 Kneron Inc. All right reserved.
N */
N
N#ifndef __BASE_H__
N#define __BASE_H__
N
N
N#define BIT0                            0x00000001
N#define BIT1                            0x00000002
N#define BIT2                            0x00000004
N#define BIT3                            0x00000008
N#define BIT4                            0x00000010
N#define BIT5                            0x00000020
N#define BIT6                            0x00000040
N#define BIT7                            0x00000080
N#define BIT8                            0x00000100
N#define BIT9                            0x00000200
N#define BIT10                           0x00000400
N#define BIT11                           0x00000800
N#define BIT12                           0x00001000
N#define BIT13                           0x00002000
N#define BIT14                           0x00004000
N#define BIT15                           0x00008000
N#define BIT16                           0x00010000
N#define BIT17                           0x00020000
N#define BIT18                           0x00040000
N#define BIT19                           0x00080000
N#define BIT20                           0x00100000
N#define BIT21                           0x00200000
N#define BIT22                           0x00400000
N#define BIT23                           0x00800000
N#define BIT24                           0x01000000
N#define BIT25                           0x02000000
N#define BIT26                           0x04000000
N#define BIT27                           0x08000000
N#define BIT28                           0x10000000
N#define BIT29                           0x20000000
N#define BIT30                           0x40000000
N#define BIT31                           0x80000000
N
N#ifndef BIT
N#define BIT(x)      (0x01U << (x))
N#endif
N
N#define divRoundDown(n,s)   ((n) / (s))
N#define divRoundUp(n,s)     ((n+s-1)/(s))
N
N#define ARRAY_SIZE(x) 		(sizeof(x) / sizeof((x)[0]))
N
N#define RoundUp(val, units) \
N		((((unsigned long)(val) + ((units) - 1)) / (units)) * (units))
X#define RoundUp(val, units) 		((((unsigned long)(val) + ((units) - 1)) / (units)) * (units))
N#define RoundDown(val, units) \
N		(((unsigned long)(val)/(units))*(units))
X#define RoundDown(val, units) 		(((unsigned long)(val)/(units))*(units))
N    
N#include "io.h"
N        
N#endif
N
N
L 7 "..\..\..\..\scpu\drivers\include\kdp_uart.h" 2
N#include "cmsis_os2.h"
N#include "Driver_USART.h" //cmsis driver
L 1 "..\..\..\..\scpu\device\include\CMSIS\Driver_USART.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        9. Apr 2014
N * $Revision:    V2.01
N *
N * Project:      USART (Universal Synchronous Asynchronous Receiver Transmitter)
N *               Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.01
N *    Removed optional argument parameter from Signal Event
N *  Version 2.00
N *    New simplified driver:
N *      complexity moved to upper layer (especially data handling)
N *      more unified API for different communication interfaces
N *      renamed driver UART -> USART (Asynchronous & Synchronous)
N *    Added modes:
N *      Synchronous
N *      Single-wire
N *      IrDA
N *      Smart Card  
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.01
N *    Added events:
N *      ARM_UART_EVENT_TX_EMPTY,     ARM_UART_EVENT_RX_TIMEOUT
N *      ARM_UART_EVENT_TX_THRESHOLD, ARM_UART_EVENT_RX_THRESHOLD
N *    Added functions: SetTxThreshold, SetRxThreshold
N *    Added "rx_timeout_event" to capabilities
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_USART_H
N#define __DRIVER_USART_H
N
N#include "Driver_Common.h"
L 1 "..\..\..\..\scpu\device\include\CMSIS\Driver_Common.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        2. Jan 2014
N * $Revision:    V2.00
N *
N * Project:      Common Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.00
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Added General return codes definitions
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_COMMON_H
N#define __DRIVER_COMMON_H
N
N#include <stddef.h>
N#include <stdint.h>
N#include <stdbool.h>
N
N#define ARM_DRIVER_VERSION_MAJOR_MINOR(major,minor) (((major) << 8) | (minor))
N
N/**
N\brief Driver Version
N*/
Ntypedef struct _ARM_DRIVER_VERSION {
N  uint16_t api;                         ///< API version
N  uint16_t drv;                         ///< Driver version
N} ARM_DRIVER_VERSION;
N
N/* General return codes */
N#define ARM_DRIVER_OK                 0 ///< Operation succeeded 
N#define ARM_DRIVER_ERROR             -1 ///< Unspecified error
N#define ARM_DRIVER_ERROR_BUSY        -2 ///< Driver is busy
N#define ARM_DRIVER_ERROR_TIMEOUT     -3 ///< Timeout occurred
N#define ARM_DRIVER_ERROR_UNSUPPORTED -4 ///< Operation not supported
N#define ARM_DRIVER_ERROR_PARAMETER   -5 ///< Parameter error
N#define ARM_DRIVER_ERROR_SPECIFIC    -6 ///< Start of driver specific errors 
N
N/**
N\brief General power states
N*/ 
Ntypedef enum _ARM_POWER_STATE {
N  ARM_POWER_OFF,                        ///< Power off: no operation possible
N  ARM_POWER_LOW,                        ///< Low Power mode: retain state, detect and signal wake-up events
N  ARM_POWER_FULL                        ///< Power on: full operation at maximum performance
N} ARM_POWER_STATE;
N
N#endif /* __DRIVER_COMMON_H */
L 58 "..\..\..\..\scpu\device\include\CMSIS\Driver_USART.h" 2
N
N#define ARM_USART_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,01)  /* API version */
N
N
N/****** USART Control Codes *****/
N
N#define ARM_USART_CONTROL_Pos                0
N#define ARM_USART_CONTROL_Msk               (0xFFUL << ARM_USART_CONTROL_Pos)
N
N/*----- USART Control Codes: Mode -----*/
N#define ARM_USART_MODE_ASYNCHRONOUS         (0x01UL << ARM_USART_CONTROL_Pos)   ///< UART (Asynchronous); arg = Baudrate
N#define ARM_USART_MODE_SYNCHRONOUS_MASTER   (0x02UL << ARM_USART_CONTROL_Pos)   ///< Synchronous Master (generates clock signal); arg = Baudrate
N#define ARM_USART_MODE_SYNCHRONOUS_SLAVE    (0x03UL << ARM_USART_CONTROL_Pos)   ///< Synchronous Slave (external clock signal)
N#define ARM_USART_MODE_SINGLE_WIRE          (0x04UL << ARM_USART_CONTROL_Pos)   ///< UART Single-wire (half-duplex); arg = Baudrate
N#define ARM_USART_MODE_IRDA                 (0x05UL << ARM_USART_CONTROL_Pos)   ///< UART IrDA; arg = Baudrate
N#define ARM_USART_MODE_SMART_CARD           (0x06UL << ARM_USART_CONTROL_Pos)   ///< UART Smart Card; arg = Baudrate
N
N/*----- USART Control Codes: Mode Parameters: Data Bits -----*/
N#define ARM_USART_DATA_BITS_Pos              8
N#define ARM_USART_DATA_BITS_Msk             (7UL << ARM_USART_DATA_BITS_Pos)
N#define ARM_USART_DATA_BITS_5               (5UL << ARM_USART_DATA_BITS_Pos)    ///< 5 Data bits
N#define ARM_USART_DATA_BITS_6               (6UL << ARM_USART_DATA_BITS_Pos)    ///< 6 Data bit
N#define ARM_USART_DATA_BITS_7               (7UL << ARM_USART_DATA_BITS_Pos)    ///< 7 Data bits
N#define ARM_USART_DATA_BITS_8               (0UL << ARM_USART_DATA_BITS_Pos)    ///< 8 Data bits (default)
N#define ARM_USART_DATA_BITS_9               (1UL << ARM_USART_DATA_BITS_Pos)    ///< 9 Data bits
N
N/*----- USART Control Codes: Mode Parameters: Parity -----*/
N#define ARM_USART_PARITY_Pos                 12
N#define ARM_USART_PARITY_Msk                (3UL << ARM_USART_PARITY_Pos)
N#define ARM_USART_PARITY_NONE               (0UL << ARM_USART_PARITY_Pos)       ///< No Parity (default)
N#define ARM_USART_PARITY_EVEN               (1UL << ARM_USART_PARITY_Pos)       ///< Even Parity
N#define ARM_USART_PARITY_ODD                (2UL << ARM_USART_PARITY_Pos)       ///< Odd Parity
N
N/*----- USART Control Codes: Mode Parameters: Stop Bits -----*/
N#define ARM_USART_STOP_BITS_Pos              14
N#define ARM_USART_STOP_BITS_Msk             (3UL << ARM_USART_STOP_BITS_Pos)
N#define ARM_USART_STOP_BITS_1               (0UL << ARM_USART_STOP_BITS_Pos)    ///< 1 Stop bit (default)
N#define ARM_USART_STOP_BITS_2               (1UL << ARM_USART_STOP_BITS_Pos)    ///< 2 Stop bits
N#define ARM_USART_STOP_BITS_1_5             (2UL << ARM_USART_STOP_BITS_Pos)    ///< 1.5 Stop bits
N#define ARM_USART_STOP_BITS_0_5             (3UL << ARM_USART_STOP_BITS_Pos)    ///< 0.5 Stop bits
N
N/*----- USART Control Codes: Mode Parameters: Flow Control -----*/
N#define ARM_USART_FLOW_CONTROL_Pos           16
N#define ARM_USART_FLOW_CONTROL_Msk          (3UL << ARM_USART_FLOW_CONTROL_Pos)
N#define ARM_USART_FLOW_CONTROL_NONE         (0UL << ARM_USART_FLOW_CONTROL_Pos) ///< No Flow Control (default)
N#define ARM_USART_FLOW_CONTROL_RTS          (1UL << ARM_USART_FLOW_CONTROL_Pos) ///< RTS Flow Control
N#define ARM_USART_FLOW_CONTROL_CTS          (2UL << ARM_USART_FLOW_CONTROL_Pos) ///< CTS Flow Control
N#define ARM_USART_FLOW_CONTROL_RTS_CTS      (3UL << ARM_USART_FLOW_CONTROL_Pos) ///< RTS/CTS Flow Control
N
N/*----- USART Control Codes: Mode Parameters: Clock Polarity (Synchronous mode) -----*/
N#define ARM_USART_CPOL_Pos                   17
N#define ARM_USART_CPOL_Msk                  (1UL << ARM_USART_CPOL_Pos)
N#define ARM_USART_CPOL0                     (0UL << ARM_USART_CPOL_Pos)         ///< CPOL = 0 (default)
N#define ARM_USART_CPOL1                     (1UL << ARM_USART_CPOL_Pos)         ///< CPOL = 1
N
N/*----- USART Control Codes: Mode Parameters: Clock Phase (Synchronous mode) -----*/
N#define ARM_USART_CPHA_Pos                   18
N#define ARM_USART_CPHA_Msk                  (1UL << ARM_USART_CPHA_Pos)
N#define ARM_USART_CPHA0                     (0UL << ARM_USART_CPHA_Pos)         ///< CPHA = 0 (default)
N#define ARM_USART_CPHA1                     (1UL << ARM_USART_CPHA_Pos)         ///< CPHA = 1
N
N
N/*----- USART Control Codes: Miscellaneous Controls  -----*/
N#define ARM_USART_SET_DEFAULT_TX_VALUE      (0x10UL << ARM_USART_CONTROL_Pos)   ///< Set default Transmit value (Synchronous Receive only); arg = value
N#define ARM_USART_SET_IRDA_PULSE            (0x11UL << ARM_USART_CONTROL_Pos)   ///< Set IrDA Pulse in ns; arg: 0=3/16 of bit period  
N#define ARM_USART_SET_SMART_CARD_GUARD_TIME (0x12UL << ARM_USART_CONTROL_Pos)   ///< Set Smart Card Guard Time; arg = number of bit periods
N#define ARM_USART_SET_SMART_CARD_CLOCK      (0x13UL << ARM_USART_CONTROL_Pos)   ///< Set Smart Card Clock in Hz; arg: 0=Clock not generated
N#define ARM_USART_CONTROL_SMART_CARD_NACK   (0x14UL << ARM_USART_CONTROL_Pos)   ///< Smart Card NACK generation; arg: 0=disabled, 1=enabled
N#define ARM_USART_CONTROL_TX                (0x15UL << ARM_USART_CONTROL_Pos)   ///< Transmitter; arg: 0=disabled, 1=enabled
N#define ARM_USART_CONTROL_RX                (0x16UL << ARM_USART_CONTROL_Pos)   ///< Receiver; arg: 0=disabled, 1=enabled
N#define ARM_USART_CONTROL_BREAK             (0x17UL << ARM_USART_CONTROL_Pos)   ///< Continuous Break transmission; arg: 0=disabled, 1=enabled
N#define ARM_USART_ABORT_SEND                (0x18UL << ARM_USART_CONTROL_Pos)   ///< Abort \ref ARM_USART_Send
N#define ARM_USART_ABORT_RECEIVE             (0x19UL << ARM_USART_CONTROL_Pos)   ///< Abort \ref ARM_USART_Receive
N#define ARM_USART_ABORT_TRANSFER            (0x1AUL << ARM_USART_CONTROL_Pos)   ///< Abort \ref ARM_USART_Transfer
N
N
N
N/****** USART specific error codes *****/
N#define ARM_USART_ERROR_MODE                (ARM_DRIVER_ERROR_SPECIFIC - 1)     ///< Specified Mode not supported
N#define ARM_USART_ERROR_BAUDRATE            (ARM_DRIVER_ERROR_SPECIFIC - 2)     ///< Specified baudrate not supported
N#define ARM_USART_ERROR_DATA_BITS           (ARM_DRIVER_ERROR_SPECIFIC - 3)     ///< Specified number of Data bits not supported
N#define ARM_USART_ERROR_PARITY              (ARM_DRIVER_ERROR_SPECIFIC - 4)     ///< Specified Parity not supported
N#define ARM_USART_ERROR_STOP_BITS           (ARM_DRIVER_ERROR_SPECIFIC - 5)     ///< Specified number of Stop bits not supported
N#define ARM_USART_ERROR_FLOW_CONTROL        (ARM_DRIVER_ERROR_SPECIFIC - 6)     ///< Specified Flow Control not supported
N#define ARM_USART_ERROR_CPOL                (ARM_DRIVER_ERROR_SPECIFIC - 7)     ///< Specified Clock Polarity not supported
N#define ARM_USART_ERROR_CPHA                (ARM_DRIVER_ERROR_SPECIFIC - 8)     ///< Specified Clock Phase not supported
N
N
N/**
N\brief USART Status
N*/
Ntypedef struct _ARM_USART_STATUS {
N  uint32_t tx_busy          : 1;        ///< Transmitter busy flag
N  uint32_t rx_busy          : 1;        ///< Receiver busy flag
N  uint32_t tx_underflow     : 1;        ///< Transmit data underflow detected (cleared on start of next send operation)
N  uint32_t rx_overflow      : 1;        ///< Receive data overflow detected (cleared on start of next receive operation)
N  uint32_t rx_break         : 1;        ///< Break detected on receive (cleared on start of next receive operation)
N  uint32_t rx_framing_error : 1;        ///< Framing error detected on receive (cleared on start of next receive operation)
N  uint32_t rx_parity_error  : 1;        ///< Parity error detected on receive (cleared on start of next receive operation)
N} ARM_USART_STATUS;
N
N/**
N\brief USART Modem Control
N*/
Ntypedef enum _ARM_USART_MODEM_CONTROL {
N  ARM_USART_RTS_CLEAR,                  ///< Deactivate RTS
N  ARM_USART_RTS_SET,                    ///< Activate RTS
N  ARM_USART_DTR_CLEAR,                  ///< Deactivate DTR
N  ARM_USART_DTR_SET                     ///< Activate DTR
N} ARM_USART_MODEM_CONTROL;
N
N/**
N\brief USART Modem Status
N*/
Ntypedef struct _ARM_USART_MODEM_STATUS {
N  uint32_t cts : 1;                     ///< CTS state: 1=Active, 0=Inactive
N  uint32_t dsr : 1;                     ///< DSR state: 1=Active, 0=Inactive
N  uint32_t dcd : 1;                     ///< DCD state: 1=Active, 0=Inactive
N  uint32_t ri  : 1;                     ///< RI  state: 1=Active, 0=Inactive
N} ARM_USART_MODEM_STATUS;
N
N
N/****** USART Event *****/
N#define ARM_USART_EVENT_SEND_COMPLETE       (1UL << 0)  ///< Send completed; however USART may still transmit data
N#define ARM_USART_EVENT_RECEIVE_COMPLETE    (1UL << 1)  ///< Receive completed
N#define ARM_USART_EVENT_TRANSFER_COMPLETE   (1UL << 2)  ///< Transfer completed
N#define ARM_USART_EVENT_TX_COMPLETE         (1UL << 3)  ///< Transmit completed (optional)
N#define ARM_USART_EVENT_TX_UNDERFLOW        (1UL << 4)  ///< Transmit data not available (Synchronous Slave)
N#define ARM_USART_EVENT_RX_OVERFLOW         (1UL << 5)  ///< Receive data overflow
N#define ARM_USART_EVENT_RX_TIMEOUT          (1UL << 6)  ///< Receive character timeout (optional)
N#define ARM_USART_EVENT_RX_BREAK            (1UL << 7)  ///< Break detected on receive
N#define ARM_USART_EVENT_RX_FRAMING_ERROR    (1UL << 8)  ///< Framing error detected on receive
N#define ARM_USART_EVENT_RX_PARITY_ERROR     (1UL << 9)  ///< Parity error detected on receive
N#define ARM_USART_EVENT_CTS                 (1UL << 10) ///< CTS state changed (optional)
N#define ARM_USART_EVENT_DSR                 (1UL << 11) ///< DSR state changed (optional)
N#define ARM_USART_EVENT_DCD                 (1UL << 12) ///< DCD state changed (optional)
N#define ARM_USART_EVENT_RI                  (1UL << 13) ///< RI  state changed (optional)
N
N
N// Function documentation
N/**
N  \fn          ARM_DRIVER_VERSION ARM_USART_GetVersion (void)
N  \brief       Get driver version.
N  \return      \ref ARM_DRIVER_VERSION
N
N  \fn          ARM_USART_CAPABILITIES ARM_USART_GetCapabilities (void)
N  \brief       Get driver capabilities
N  \return      \ref ARM_USART_CAPABILITIES
N
N  \fn          int32_t ARM_USART_Initialize (ARM_USART_SignalEvent_t cb_event)
N  \brief       Initialize USART Interface.
N  \param[in]   cb_event  Pointer to \ref ARM_USART_SignalEvent
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Uninitialize (void)
N  \brief       De-initialize USART Interface.
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_PowerControl (ARM_POWER_STATE state)
N  \brief       Control USART Interface Power.
N  \param[in]   state  Power state
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Send (const void *data, uint32_t num)
N  \brief       Start sending data to USART transmitter.
N  \param[in]   data  Pointer to buffer with data to send to USART transmitter
N  \param[in]   num   Number of data items to send
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Receive (void *data, uint32_t num)
N  \brief       Start receiving data from USART receiver.
N  \param[out]  data  Pointer to buffer for data to receive from USART receiver
N  \param[in]   num   Number of data items to receive
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_USART_Transfer (const void *data_out,
N                                                 void *data_in,
N                                           uint32_t    num)
N  \brief       Start sending/receiving data to/from USART transmitter/receiver.
N  \param[in]   data_out  Pointer to buffer with data to send to USART transmitter
N  \param[out]  data_in   Pointer to buffer for data to receive from USART receiver
N  \param[in]   num       Number of data items to transfer
N  \return      \ref execution_status
N
N  \fn          uint32_t ARM_USART_GetTxCount (void)
N  \brief       Get transmitted data count.
N  \return      number of data items transmitted
N
N  \fn          uint32_t ARM_USART_GetRxCount (void)
N  \brief       Get received data count.
N  \return      number of data items received
N
N  \fn          int32_t ARM_USART_Control (uint32_t control, uint32_t arg)
N  \brief       Control USART Interface.
N  \param[in]   control  Operation
N  \param[in]   arg      Argument of operation (optional)
N  \return      common \ref execution_status and driver specific \ref usart_execution_status
N
N  \fn          ARM_USART_STATUS ARM_USART_GetStatus (void)
N  \brief       Get USART status.
N  \return      USART status \ref ARM_USART_STATUS
N
N  \fn          int32_t ARM_USART_SetModemControl (ARM_USART_MODEM_CONTROL control)
N  \brief       Set USART Modem Control line state.
N  \param[in]   control  \ref ARM_USART_MODEM_CONTROL
N  \return      \ref execution_status 
N
N  \fn          ARM_USART_MODEM_STATUS ARM_USART_GetModemStatus (void)
N  \brief       Get USART Modem Status lines state.
N  \return      modem status \ref ARM_USART_MODEM_STATUS
N
N  \fn          void ARM_USART_SignalEvent (uint32_t event)
N  \brief       Signal USART Events.
N  \param[in]   event  \ref USART_events notification mask
N  \return      none
N*/
N
Ntypedef void (*ARM_USART_SignalEvent_t) (uint32_t event);  ///< Pointer to \ref ARM_USART_SignalEvent : Signal USART Event.
N
N
N/**
N\brief USART Device Driver Capabilities.
N*/
Ntypedef struct _ARM_USART_CAPABILITIES {
N  uint32_t asynchronous       : 1;      ///< supports UART (Asynchronous) mode 
N  uint32_t synchronous_master : 1;      ///< supports Synchronous Master mode
N  uint32_t synchronous_slave  : 1;      ///< supports Synchronous Slave mode
N  uint32_t single_wire        : 1;      ///< supports UART Single-wire mode
N  uint32_t irda               : 1;      ///< supports UART IrDA mode
N  uint32_t smart_card         : 1;      ///< supports UART Smart Card mode
N  uint32_t smart_card_clock   : 1;      ///< Smart Card Clock generator available
N  uint32_t flow_control_rts   : 1;      ///< RTS Flow Control available
N  uint32_t flow_control_cts   : 1;      ///< CTS Flow Control available
N  uint32_t event_tx_complete  : 1;      ///< Transmit completed event: \ref ARM_USART_EVENT_TX_COMPLETE
N  uint32_t event_rx_timeout   : 1;      ///< Signal receive character timeout event: \ref ARM_USART_EVENT_RX_TIMEOUT
N  uint32_t rts                : 1;      ///< RTS Line: 0=not available, 1=available
N  uint32_t cts                : 1;      ///< CTS Line: 0=not available, 1=available
N  uint32_t dtr                : 1;      ///< DTR Line: 0=not available, 1=available
N  uint32_t dsr                : 1;      ///< DSR Line: 0=not available, 1=available
N  uint32_t dcd                : 1;      ///< DCD Line: 0=not available, 1=available
N  uint32_t ri                 : 1;      ///< RI Line: 0=not available, 1=available
N  uint32_t event_cts          : 1;      ///< Signal CTS change event: \ref ARM_USART_EVENT_CTS
N  uint32_t event_dsr          : 1;      ///< Signal DSR change event: \ref ARM_USART_EVENT_DSR
N  uint32_t event_dcd          : 1;      ///< Signal DCD change event: \ref ARM_USART_EVENT_DCD
N  uint32_t event_ri           : 1;      ///< Signal RI change event: \ref ARM_USART_EVENT_RI
N} ARM_USART_CAPABILITIES;
N
N
N/**
N\brief Access structure of the USART Driver.
N*/
Ntypedef struct _ARM_DRIVER_USART {
N  ARM_DRIVER_VERSION     (*GetVersion)      (void);                              ///< Pointer to \ref ARM_USART_GetVersion : Get driver version.
N  ARM_USART_CAPABILITIES (*GetCapabilities) (void);                              ///< Pointer to \ref ARM_USART_GetCapabilities : Get driver capabilities.
N  int32_t                (*Initialize)      (ARM_USART_SignalEvent_t cb_event);  ///< Pointer to \ref ARM_USART_Initialize : Initialize USART Interface.
N  int32_t                (*Uninitialize)    (void);                              ///< Pointer to \ref ARM_USART_Uninitialize : De-initialize USART Interface.
N  int32_t                (*PowerControl)    (ARM_POWER_STATE state);             ///< Pointer to \ref ARM_USART_PowerControl : Control USART Interface Power.
N  int32_t                (*Send)            (const void *data, uint32_t num);    ///< Pointer to \ref ARM_USART_Send : Start sending data to USART transmitter.
N  int32_t                (*Receive)         (      void *data, uint32_t num);    ///< Pointer to \ref ARM_USART_Receive : Start receiving data from USART receiver.
N  int32_t                (*Transfer)        (const void *data_out,
N                                                   void *data_in,
N                                             uint32_t    num);                   ///< Pointer to \ref ARM_USART_Transfer : Start sending/receiving data to/from USART.
N  uint32_t               (*GetTxCount)      (void);                              ///< Pointer to \ref ARM_USART_GetTxCount : Get transmitted data count.
N  uint32_t               (*GetRxCount)      (void);                              ///< Pointer to \ref ARM_USART_GetRxCount : Get received data count.
N  int32_t                (*Control)         (uint32_t control, uint32_t arg);    ///< Pointer to \ref ARM_USART_Control : Control USART Interface.
N  ARM_USART_STATUS       (*GetStatus)       (void);                              ///< Pointer to \ref ARM_USART_GetStatus : Get USART status.
N  int32_t                (*SetModemControl) (ARM_USART_MODEM_CONTROL control);   ///< Pointer to \ref ARM_USART_SetModemControl : Set USART Modem Control line state.
N  ARM_USART_MODEM_STATUS (*GetModemStatus)  (void);                              ///< Pointer to \ref ARM_USART_GetModemStatus : Get USART Modem Status lines state.
N} const ARM_DRIVER_USART;
N
N#endif /* __DRIVER_USART_H */
L 9 "..\..\..\..\scpu\drivers\include\kdp_uart.h" 2
N
N
N#define UART_CLOCK                     (30000000UL) //kneron
N#define BAUD_1500000                   (UART_CLOCK / 24000000)  //Verification
N#define BAUD_921600                    (UART_CLOCK / 14745600)
N#define BAUD_460800                    (UART_CLOCK / 7372800)
N#define BAUD_230400                    (UART_CLOCK / 3686400)
N#define BAUD_115200                    (UART_CLOCK / 1843200)
N#define BAUD_57600                     (UART_CLOCK / 921600)
N#define BAUD_38400                     (UART_CLOCK / 614400)
N#define BAUD_19200                     (UART_CLOCK / 307200)
N#define BAUD_14400                     (UART_CLOCK / 230400)
N#define BAUD_9600                      (UART_CLOCK / 153600)
N#define BAUD_4800                      (UART_CLOCK / 76800)
N#define BAUD_2400                      (UART_CLOCK / 38400)
N#define BAUD_1200                      (UART_CLOCK / 19200)
N
Ntypedef enum {
N    DRVUART_PORT0=0,
N    DRVUART_PORT1=1,
N    DRVUART_PORT2=2,
N    DRVUART_PORT3=3,
N    DRVUART_PORT4=4,
N} DRVUART_PORT;
N
N#define SERIAL_THR                     0x00             /*  Transmitter Holding Register(Write).*/
N#define SERIAL_RBR                     0x00             /*  Receive Buffer register (Read).*/
N#define SERIAL_IER                     0x04             /*  Interrupt Enable register.*/
N#define SERIAL_IIR                     0x08             /*  Interrupt Identification register(Read).*/
N#define SERIAL_FCR                     0x08             /*  FIFO control register(Write).*/
N#define SERIAL_LCR                     0x0C             /*  Line Control register.*/
N#define SERIAL_MCR                     0x10             /*  Modem Control Register.*/
N#define SERIAL_LSR                     0x14             /*  Line status register(Read) .*/
N#define SERIAL_MSR                     0x18             /*  Modem Status register (Read).*/
N#define SERIAL_SPR                     0x1C         /*  Scratch pad register */
N#define SERIAL_DLL                     0x0          /*  Divisor Register LSB */
N#define SERIAL_DLM                     0x4          /*  Divisor Register MSB */
N#define SERIAL_PSR                     0x8             /* Prescale Divison Factor */
N
N#define SERIAL_MDR                     0x20
N#define SERIAL_ACR                     0x24
N#define SERIAL_TXLENL                  0x28
N#define SERIAL_TXLENH                  0x2C
N#define SERIAL_MRXLENL                 0x30
N#define SERIAL_MRXLENH                 0x34
N#define SERIAL_PLR                     0x38
N#define SERIAL_FMIIR_PIO               0x3C
N#define SERIAL_FEATURE                 0x68
N
N/* IER Register */
N#define SERIAL_IER_DR                  0x1          /* Data ready Enable */
N#define SERIAL_IER_TE                  0x2          /* THR Empty Enable */
N#define SERIAL_IER_RLS                 0x4          /* Receive Line Status Enable */
N#define SERIAL_IER_MS                  0x8          /* Modem Staus Enable */
N
N/* IIR Register */
N#define SERIAL_IIR_NONE                0x1            /* No interrupt pending */
N#define SERIAL_IIR_RLS                 0x6            /* Receive Line Status */
N#define SERIAL_IIR_DR                  0x4            /* Receive Data Ready */
N#define SERIAL_IIR_TIMEOUT             0xc            /* Receive Time Out */
N#define SERIAL_IIR_TE                  0x2            /* THR Empty */
N#define SERIAL_IIR_MODEM               0x0            /* Modem Status */
N
N/* FCR Register */
N#define SERIAL_FCR_FE                  0x1              /* FIFO Enable */
N#define SERIAL_FCR_RXFR                0x2              /* Rx FIFO Reset */
N#define SERIAL_FCR_TXFR                0x4              /* Tx FIFO Reset */
N
N/* LCR Register */
N#define SERIAL_LCR_LEN5                0x0
N#define SERIAL_LCR_LEN6                0x1
N#define SERIAL_LCR_LEN7                0x2
N#define SERIAL_LCR_LEN8                0x3
N
N#define SERIAL_LCR_STOP                0x4
N#define SERIAL_LCR_EVEN                0x18          /* Even Parity */
N#define SERIAL_LCR_ODD                 0x8          /* Odd Parity */
N#define SERIAL_LCR_PE                  0x8            /* Parity Enable */
N#define SERIAL_LCR_SETBREAK            0x40             /* Set Break condition */
N#define SERIAL_LCR_STICKPARITY         0x20             /* Stick Parity Enable */
N#define SERIAL_LCR_DLAB                0x80         /* Divisor Latch Access Bit */
N
N/* LSR Register */
N#define SERIAL_LSR_DR                  0x1          /* Data Ready */
N#define SERIAL_LSR_OE                  0x2          /* Overrun Error */
N#define SERIAL_LSR_PE                  0x4          /* Parity Error */
N#define SERIAL_LSR_FE                  0x8          /* Framing Error */
N#define SERIAL_LSR_BI                  0x10         /* Break Interrupt */
N#define SERIAL_LSR_THRE                0x20         /* THR Empty */
N#define SERIAL_LSR_TE                  0x40         /* Transmitte Empty */
N#define SERIAL_LSR_DE                  0x80         /* FIFO Data Error */
N
N/* MCR Register */
N#define SERIAL_MCR_DTR                 0x1        /* Data Terminal Ready */
N#define SERIAL_MCR_RTS                 0x2        /* Request to Send */
N#define SERIAL_MCR_OUT1                0x4        /* output    1 */
N#define SERIAL_MCR_OUT2                0x8        /* output2 or global interrupt enable */
N#define SERIAL_MCR_LPBK                0x10         /* loopback mode */
N
N
N/* MSR Register */
N#define SERIAL_MSR_DELTACTS            0x1        /* Delta CTS */
N#define SERIAL_MSR_DELTADSR            0x2        /* Delta DSR */
N#define SERIAL_MSR_TERI                0x4        /* Trailing Edge RI */
N#define SERIAL_MSR_DELTACD             0x8        /* Delta CD */
N#define SERIAL_MSR_CTS                 0x10         /* Clear To Send */
N#define SERIAL_MSR_DSR                 0x20         /* Data Set Ready */
N#define SERIAL_MSR_RI                  0x40         /* Ring Indicator */
N#define SERIAL_MSR_DCD                 0x80         /* Data Carrier Detect */
N
N
N/* MDR register */
N#define SERIAL_MDR_MODE_SEL            0x03
N#define SERIAL_MDR_UART                0x0
N#define SERIAL_MDR_SIR                 0x1
N#define SERIAL_MDR_FIR                 0x2
N
N/* ACR register */
N#define SERIAL_ACR_TXENABLE            0x1
N#define SERIAL_ACR_RXENABLE            0x2
N#define SERIAL_ACR_SET_EOT             0x4
N
N#ifndef PARITY_NONE
N#define PARITY_NONE             0
N#endif
N
N#ifndef PARITY_ODD
N#define PARITY_ODD              1
N#endif
N
N#ifndef PARITY_EVEN
N#define PARITY_EVEN             2
N#endif
N
N#ifndef PARITY_MARK
N#define PARITY_MARK             3
N#endif
N
N#ifndef PARITY_SPACE
N#define PARITY_SPACE            4
N#endif
N
N#define BACKSP_KEY 0x08
N#define RETURN_KEY 0x0D
N#define DELETE_KEY 0x7F
N#define BELL       0x07
N
N
N#define MAX_UART_INST  5  //max uart instance
N#define MAX_BUF_LEN   512 //max buffer len for every individual UART port
N#define NO_FIFO 0
N
N#define UART_SUCCESS  0
N#define UART_FAIL     -1
N
N#define SERIAL_RX_FIFO_COUNT      0x5C 
N
N#define SERIAL_FIFO_DEPTH_REG     0x68
N
N#define SERIAL_FIFO_DEPTH_16B     0x1
N#define SERIAL_FIFO_DEPTH_32B     0x2
N#define SERIAL_FIFO_DEPTH_64B     0x4
N#define SERIAL_FIFO_DEPTH_128B    0x8
N
N#define SERIAL_FIFO_TRIG_LVEL_1   0x0
N#define SERIAL_FIFO_TRIG_LVEL_4   0x1
N#define SERIAL_FIFO_TRIG_LVEL_8   0x2
N#define SERIAL_FIFO_TRIG_LVEL_14  0x3
N
N#define DEFAULT_SYNC_TIMEOUT_CHARS_TIME  512     //for UART_SYNC_MODE: correspond to 512 chars transmission time 
N
Ntypedef int kdp_uart_hdl_t;
Ntypedef void(*uart_isr_t)(void);
Ntypedef void(*kdp_uart_callback_t)(uint32_t event);
N
N/**
N * UART driver status
N */
Ntypedef enum
N{
N    KDP_UART_STATUS_OK,     /**< UART driver status : OK*/
N    KDP_UART_STATUS_ERROR,  /**< UART driver status : ERROR */
N    KDP_UART_STATUS_BUSY    /**< UART driver status : BUSY */
N} KDP_UART_DRV_STATUS_t;
N
N/**
N * UART initialization structure
N*/
Ntypedef struct KDP_UART_CONFIG
N{
N    uint32_t baudrate;
N    uint8_t  data_bits;
N    uint8_t  frame_length;
N    uint8_t  stop_bits;
N    uint8_t  parity_mode;
N    uint8_t  fifo_en;
N} KDP_UART_CONFIG_t;
N
N/**
N\brief KDP UART Device Driver Capabilities. This capability covers ARM_USART_CAPABILITIES
N*/
Ntypedef struct _KDP_USART_CAPABILITIES {
N    uint32_t asynchronous : 1;      ///< supports UART (Asynchronous) mode 
N    uint32_t synchronous_master : 1;///< supports Synchronous Master mode
N    uint32_t synchronous_slave : 1; ///< supports Synchronous Slave mode
N    uint32_t serial_irda : 1;       ///< supports SIR (Serial IrDA mode)
N    uint32_t fast_irda : 1;         ///< supports FIR (Fast IrDA mode)
N    uint32_t flow_control_rts : 1;  ///< RTS Flow Control available
N    uint32_t flow_control_cts : 1;  ///< CTS Flow Control available
N    uint32_t event_tx_complete : 1; ///< Transmit completed event: \ref ARM_USART_EVENT_TX_COMPLETE
N    uint32_t event_rx_timeout : 1;  ///< Signal receive character timeout event: \ref ARM_USART_EVENT_RX_TIMEOUT
N    uint32_t rts : 1;               ///< RTS Line: 0=not available, 1=available
N    uint32_t cts : 1;               ///< CTS Line: 0=not available, 1=available
N    uint32_t dtr : 1;               ///< DTR Line: 0=not available, 1=available
N    uint32_t dsr : 1;               ///< DSR Line: 0=not available, 1=available
N    uint32_t dcd : 1;               ///< DCD Line: 0=not available, 1=available
N    uint32_t ri : 1;                ///< RI Line: 0=not available, 1=available
N    uint32_t event_cts : 1;         ///< Signal CTS change event: \ref ARM_USART_EVENT_CTS
N    uint32_t event_dsr : 1;         ///< Signal DSR change event: \ref ARM_USART_EVENT_DSR
N    uint32_t event_dcd : 1;         ///< Signal DCD change event: \ref ARM_USART_EVENT_DCD
N    uint32_t event_ri : 1;          ///< Signal RI change event: \ref ARM_USART_EVENT_RI
N} KDP_USART_CAPABILITIES;
N
N// UART flags
N
N#define     UART_INITIALIZED          (1 << 0)
N#define     UART_POWERED              (1 << 1)
N#define     UART_BASIC_CONFIGURED     (1 << 2)
N#define     UART_FIFO_RX_CONFIGURED   (1 << 3)
N#define     UART_FIFO_TX_CONFIGURED   (1 << 4)
N#define     UART_TX_ENABLED           (1 << 5)
N#define     UART_RX_ENABLED           (1 << 6)
N#define     UART_LOOPBACK_ENABLED     (1 << 7)
N
N#define     UART_MODE_ASYN_RX  (1 << 0)
N#define     UART_MODE_ASYN_TX  (1 << 1)
N#define     UART_MODE_SYNC_RX  (1 << 2)
N#define     UART_MODE_SYNC_TX  (1 << 3)
N#define     SIR_MODE_ASYN      (1 << 4)
N#define     FIR_MODE_ASYN      (1 << 5)
N
N
N// UART Transfer Information (Run-Time)
Ntypedef struct UART_TRANSFER_INFO
N{
N    volatile uint32_t                rx_num;        // Total number of data to be received
N    volatile uint32_t                tx_num;        // Total number of data to be send
N    volatile uint8_t                 *rx_buf;       // Pointer to in data buffer
N    volatile uint8_t                 *tx_buf;       // Pointer to out data buffer
N    volatile uint32_t                rx_cnt;        // Number of data received
N    volatile uint32_t                tx_cnt;        // Number of data sent
N    volatile uint32_t                write_idx;     // Write index
N    volatile uint32_t                read_idx;      // Read index
N} UART_TRANSFER_INFO_t;
N
Ntypedef struct
N{
N    volatile uint8_t tx_busy;             // Transmitter busy flag
N    volatile uint8_t rx_busy;             // Receiver busy flag
N    uint8_t tx_underflow;                 // Transmit data underflow detected (cleared on start of next send operation)
N    uint8_t rx_overflow;                  // Receive data overflow detected (cleared on start of next receive operation)
N    uint8_t rx_break;                     // Break detected on receive (cleared on start of next receive operation)
N    uint8_t rx_framing_error;             // Framing error detected on receive (cleared on start of next receive operation)
N    uint8_t rx_parity_error;              // Parity error detected on receive (cleared on start of next receive operation)
N} UART_STATUS_t;
N
N// UART Information (Run-Time)
Ntypedef struct
N{
N    ARM_USART_SignalEvent_t cb_event;           // Event callback
N    UART_STATUS_t           status;             // Status flags
N    UART_TRANSFER_INFO_t    xfer;               // Transfer information
N    uint32_t                flags;              // UART driver flags: UART_FLAG_T
N    uint32_t                mode;               // UART mode
N} UART_INFO_T;
N
N
N// UART Resources definitions
Ntypedef struct
N{
N    uint32_t               irq_num;                    // UART TX IRQ Number
N    uart_isr_t             isr;                        // ISR route
N    uint32_t               fifo_depth;                 //16/32/64/128 depth, set by UART_CTRL_CONFIG
N    uint32_t               tx_fifo_threshold;          // FIFO tx trigger threshold
N    uint32_t               rx_fifo_threshold;          // FIFO rx trigger threshold
N    uint32_t               fifo_len;                   // FIFO tx buffer len
N    uint32_t               clock;                      //clock
N    uint32_t               hw_base;                    // hardware base address
N} UART_RESOURCES_T;
N
Ntypedef enum {
N    UART_UNINIT,
N    UART_INIT_DONE,
N    UART_WORKING,
N    UART_CLOSED
N}kdp_uart_drv_state_t;
N
Ntypedef enum {
N    UART0_DEV,
N    UART1_DEV,
N    UART2_DEV,
N    UART3_DEV,
N    UART4_DEV,
N    TOTAL_UART_DEV
N} kdp_uart_dev_id;
N
Ntypedef struct {
N    bool     bEnFifo;
X    _Bool     bEnFifo;
N    uint8_t  fifo_trig_level;
N} kdp_uart_fifo_cfg_t;
N
Ntypedef enum {
N    UART_CTRL_CONFIG,      //param: KDP_UART_CONFIG_t
N    UART_CTRL_FIFO_RX,     //param: kdp_uart_fifo_cfg_t
N    UART_CTRL_FIFO_TX,     //param: kdp_uart_fifo_cfg_t
N    UART_CTRL_LOOPBACK,
N    UART_CTRL_TX_EN,
N    UART_CTRL_RX_EN,
N    UART_CTRL_RTS_EN,
N    UART_CTRL_DTR_EN,
N    UART_CTRL_ABORT_TX,
N    UART_CTRL_ABORT_RX,
N    UART_CTRL_TIMEOUT_RX,
N    UART_CTRL_TIMEOUT_TX
N}kdp_uart_ctrl_t;
N
N/* driver instance handle */
Ntypedef struct {
N    uint32_t                 uart_port;
N    kdp_uart_drv_state_t     state;
N    KDP_USART_CAPABILITIES   *pCap;
N    KDP_UART_CONFIG_t        config;
N    UART_INFO_T              info;
N    UART_RESOURCES_T         res;
N    int32_t                  nTimeOutTx;       //Tx timeout (ms) for UART_SYNC_MODE
N    int32_t                  nTimeOutRx;       //Rx timeout (ms) for UART_SYNC_MODE
N    uint32_t                 iir;              //store IIR register value (IIR register will be reset once it is 
N                                               //read once, need to store for further process)
N} kdp_driver_hdl_t;
N
Ntypedef struct {
N    int8_t             total_open_uarts;
N    bool               active_dev[TOTAL_UART_DEV];
X    _Bool               active_dev[TOTAL_UART_DEV];
N    kdp_driver_hdl_t   *uart_dev[MAX_UART_INST];
X    kdp_driver_hdl_t   *uart_dev[5];
N
N} kdp_uart_drv_ctx_t;
N
N/******** kdp_uart_api_sts_t *********/
Ntypedef uint32_t kdp_uart_api_sts_t;
N
N#define UART_API_RETURN_SUCCESS     0
N#define UART_API_NOT_POWRERED       (1<<0)
N#define UART_API_TX_BUSY            (1<<1)
N#define UART_API_RX_BUSY            (1<<2)
N#define UART_API_INVALID_PARAM      (1<<3)
N#define UART_API_ERROR              (1<<4)
N#define UART_API_TIMEOUT            (1<<5)
N
N/*************************************/
N
N/* Init the UART device driver, it shall be called once in lifecycle
N*/
Nvoid kdp_uart_init(void);
N
N/*
N  Open one UART port
NInput:
N  com_port: UART port id
N  cb: callback function
N
NOutput:
N  return device handle: >=0 means success; -1 means open fail
N*/
Nkdp_uart_hdl_t kdp_uart_open(uint8_t com_port, uint32_t mode, kdp_uart_callback_t cb);
N
N/*
N Query capability
NInput:
N handle: driver handle
N
NOutput:
N capability of the UART port
N*/
N
NKDP_USART_CAPABILITIES* kdp_uart_get_capability(kdp_uart_hdl_t hanle);
N
N/*
NSet control for the device
NInput:
N    handle: device handle
N    prop: control enumeration
N    val: pointer to control value/structure
Nreturn:
N    error code
N*/
Nint32_t kdp_uart_control(kdp_uart_hdl_t handle, kdp_uart_ctrl_t prop, uint8_t * val);
N
N/*
NQuery driver status
NInput:
N    handle: driver handle
N
NOutput:
N    driver status
N*/
NUART_STATUS_t* kdp_uart_get_status(kdp_uart_hdl_t hanle);
N
N/*
NWrite data to Mozart device, such as command, parameters, but not suitable for chunk data
NInput:
N    hdl: device handle
N    buf: data buffer
N    len: data buffer length
Nreturn:
N    driver status
N*/
Nkdp_uart_api_sts_t kdp_uart_write(kdp_uart_hdl_t hdl, uint8_t *buf, uint32_t len);
N
N/*
NRead data from Mozart device
NInput:
N    handle: device handle
N    buf: data buffer
N    len: data buffer length
Nreturn:
N    driver status
N*/
Nkdp_uart_api_sts_t kdp_uart_read(kdp_uart_hdl_t handle, uint8_t *buf, uint32_t len);
N
N/*
NPower control
NInput:
N    handle: driver handle
N    pwr_set: power status expected to be set
N
NOutput:
N    success or fail
N*/
Nint32_t kdp_uart_power_control(kdp_uart_hdl_t handle, ARM_POWER_STATE pwr_st);
N
N
N/* close the device
NInput:
N    handle: device handle
Nreturn:
N    0 - success; -1 - failure
N*/
Nint32_t kdp_uart_close(kdp_uart_hdl_t handle);
N
N/* get char number in Rx buffer 
NInput:
N    handle: device handle
NReturn:
N    Received bytes 
N*/
Nuint32_t kdp_uart_GetRxCount(kdp_uart_hdl_t handle);
N
N/* get char number in Tx buffer 
NInput:
N    handle: device handle
NReturn:
N    Sent bytes
N*/
Nuint32_t kdp_uart_GetTxCount(kdp_uart_hdl_t handle);
N
Nuint32_t kdp_uart_GetRxBufSize(kdp_uart_hdl_t handle);
Nuint32_t kdp_uart_GetWriteIndex(kdp_uart_hdl_t handle);
Nuint32_t kdp_uart_GetReadIndex(kdp_uart_hdl_t handle);
Nuint32_t kdp_uart_SetWriteIndex(kdp_uart_hdl_t handle, uint32_t index);
Nuint32_t kdp_uart_SetReadIndex(kdp_uart_hdl_t handle, uint32_t index);
N
Nchar kdp_getchar(DRVUART_PORT port_no);
Nint kdp_gets(DRVUART_PORT port_no, char *buf);
Nvoid kdp_uart_rx_busy_clear(kdp_uart_hdl_t handle);
Nextern void kdp_uart_print_register(uint8_t port_no);
N
N#endif  //__KDP_UART_H__
L 16 "..\..\..\..\scpu\drivers\src\kdp520_usbd.c" 2
N
N//#include "kdp_io.h"
N#include "kdp520_usbd.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp520_usbd.h" 1
N/********************************************************************
N * Copyright (c) 2020 Kneron, Inc. All Rights Reserved.
N *
N * The information contained herein is property of Kneron, Inc.
N * Terms and conditions of usage are described in detail in Kneron
N * STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information.
N * NO WARRANTY of ANY KIND is provided. This heading must NOT be removed
N * from the file.
N ********************************************************************/
N
N/**@addtogroup  KDRV_USBD
N * @{
N * @brief       Kneron USB device mode driver
N * @copyright   Copyright (C) 2020 Kneron, Inc. All rights reserved.
N */
N
N#ifndef __KDRV_USBD_H__
N#define __KDRV_USBD_H__
N
N#pragma anon_unions
N#include "kdp520_usbd_status.h"
L 1 "..\..\..\..\scpu\drivers\include\kdp520_usbd_status.h" 1
N/********************************************************************
N * Copyright (c) 2020 Kneron, Inc. All Rights Reserved.
N *
N * The information contained herein is property of Kneron, Inc.
N * Terms and conditions of usage are described in detail in Kneron
N * STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information.
N * NO WARRANTY of ANY KIND is provided. This heading must NOT be removed
N * from the file.
N ********************************************************************/
N
N#ifndef __KDRV_STATUS_H__
N#define __KDRV_STATUS_H__
N
N#include <stdbool.h> // for type 'bool', ture and false.
Ntypedef enum
N{
N    KDRV_STATUS_OK = 0,                       /**< driver status OK */
N    KDRV_STATUS_ERROR,                        /**< driver status error */
N    KDRV_STATUS_INVALID_PARAM,                /**< driver invalid parameters */
N    KDRV_STATUS_I2C_BUS_BUSY,                 /**< I2C : bus is busy */
N    KDRV_STATUS_I2C_DEVICE_NACK,              /**< I2C : slave device does not send ACK */
N    KDRV_STATUS_I2C_TIMEOUT,                  /**< I2C : transfer timeout */
N    KDRV_STATUS_USBD_INVALID_ENDPOINT,        /**< USBD : invalid endpoint */
N    KDRV_STATUS_USBD_TRANSFER_TIMEOUT,        /**< USBD : transfer timeout */
N    KDRV_STATUS_USBD_INVALID_TRANSFER,        /**< USBD : invalid transfer operation */
N    KDRV_STATUS_USBD_TRANSFER_IN_PROGRESS,    /**< USBD : transfer is in progress */
N    KDRV_STATUS_GDMA_ERROR_NO_RESOURCE,       /**< GDMA : DMA channel is not available */
N    KDRV_STATUS_TIMER_ID_NOT_IN_USED,         /**< Timer: TIMER Id NOT in used */
N    KDRV_STATUS_TIMER_ID_IN_USED,             /**< Timer: TIMER Id in used */
N    KDRV_STATUS_TIMER_ID_NOT_AVAILABLE,       /**< Timer: TIMER Id is NOT available */
N    KDRV_STATUS_TIMER_INVALID_TIMER_ID,       /**< Timer: TIMER Id is invalid */
N    KDRV_STATUS_UART_TX_RX_BUSY,              /**< UART: TX or RX is busy */
N    KDRV_STATUS_UART_TIMEOUT,                 /**< UART: timeout */
N} kdrv_status_t;
N
N#endif
L 24 "..\..\..\..\scpu\drivers\include\kdp520_usbd.h" 2
N
N#define MAX_USBD_CONFIG 1    /**< maximum number of configuration descriptor */
N#define MAX_USBD_INTERFACE 1 /**< maximum number of interface descriptor */
N#define MAX_USBD_ENDPOINT 4  /**< maximum number of endpoint descriptor */
N
N/** 8-byte setup packet struct */
Ntypedef struct __attribute__((__packed__))
N{
N    uint8_t bmRequestType;
N    uint8_t bRequest;
N    uint16_t wValue;
N    uint16_t wIndex;
N    uint16_t wLength;
N} kdrv_usbd_setup_packet_t;
N
N/** Endpoint descriptor */
Ntypedef struct __attribute__((__packed__))
N{
N    uint8_t bLength;
N    uint8_t bDescriptorType;
N    uint8_t bEndpointAddress;
N    uint8_t bmAttributes;
N    uint16_t wMaxPacketSize;
N    uint8_t bInterval;
N} kdrv_usbd_endpoint_descriptor_t;
N
N/** Interface descriptor */
Ntypedef struct __attribute__((__packed__))
N{
N    uint8_t bLength;
N    uint8_t bDescriptorType;
N    uint8_t bInterfaceNumber;
N    uint8_t bAlternateSetting;
N    uint8_t bNumEndpoints;
N    uint8_t bInterfaceClass;
N    uint8_t bInterfaceSubClass;
N    uint8_t bInterfaceProtocol;
N    uint8_t iInterface;
N
N    kdrv_usbd_endpoint_descriptor_t *endpoint[MAX_USBD_ENDPOINT];
X    kdrv_usbd_endpoint_descriptor_t *endpoint[4];
N
N} kdrv_usbd_interface_descriptor_t;
N
N/** Configuration descriptor */
Ntypedef struct __attribute__((__packed__))
N{
N    uint8_t bLength;
N    uint8_t bDescriptorType;
N    uint16_t wTotalLength;
N    uint8_t bNumInterfaces;
N    uint8_t bConfigurationValue;
N    uint8_t iConfiguration;
N    uint8_t bmAttributes;
N    uint8_t MaxPower;
N
N    kdrv_usbd_interface_descriptor_t *interface[MAX_USBD_INTERFACE];
X    kdrv_usbd_interface_descriptor_t *interface[1];
N
N} kdrv_usbd_config_descriptor_t;
N
N/** Device descriptor */
Ntypedef struct __attribute__((__packed__))
N{
N    uint8_t bLength;
N    uint8_t bDescriptorType;
N    uint16_t bcdUSB;
N    uint8_t bDeviceClass;
N    uint8_t bDeviceSubClass;
N    uint8_t bDeviceProtocol;
N    uint8_t bMaxPacketSize0;
N    uint16_t idVendor;
N    uint16_t idProduct;
N    uint16_t bcdDevice;
N    uint8_t iManufacturer;
N    uint8_t iProduct;
N    uint8_t iSerialNumber;
N    uint8_t bNumConfigurations;
N
N    kdrv_usbd_config_descriptor_t *config[MAX_USBD_CONFIG];
X    kdrv_usbd_config_descriptor_t *config[1];
N
N} kdrv_usbd_device_descriptor_t;
N
N/** Device qualifier descriptor */
Ntypedef struct __attribute__((__packed__))
N{
N    uint8_t bLength;
N    uint8_t bDescriptorType;
N    uint16_t bcdUSB;
N    uint8_t bDeviceClass;
N    uint8_t bDeviceSubClass;
N    uint8_t bDeviceProtocol;
N    uint8_t bMaxPacketSize0;
N    uint8_t bNumConfigurations;
N    uint8_t bReserved;
N} kdrv_usbd_device_qualifier_descriptor_t;
N
N/** Device string descriptor */
Ntypedef struct __attribute__((__packed__))
N{
N    uint8_t bLength;
N    uint8_t bDescriptorType;
N    uint8_t bString[32];
N} kdrv_usbd_prd_string_descriptor_t;
N
Ntypedef struct __attribute__((__packed__))
N{
N    uint8_t bLength;
N    uint8_t bDescriptorType;
N    uint16_t bLanguageID;
N    kdrv_usbd_prd_string_descriptor_t* desc[3];
N    
N} kdrv_usbd_string_descriptor_t;
N
N/** Connection speed */
Ntypedef enum
N{
N    KDRV_USBD_HIGH_SPEED,
N    KDRV_USBD_FULL_SPEED /**< not supported yet */
N} kdrv_usbd_speed_t;
N
N/** USB event name type */
Ntypedef enum
N{
N    KDRV_USBD_EVENT_BUS_RESET = 1,
N    KDRV_USBD_EVENT_BUS_SUSPEND,
N    KDRV_USBD_EVENT_BUS_RESUME,
N    KDRV_USBD_EVENT_SETUP_PACKET,
N    KDRV_USBD_EVENT_DEV_CONFIGURED,
N    KDRV_USBD_EVENT_TRANSFER_BUF_FULL,
N    KDRV_USBD_EVENT_TRANSFER_DONE,
N    KDRV_USBD_EVENT_TRANSFER_OUT,
N    KDRV_USBD_EVENT_TRANSFER_TERMINATED,
N    KDRV_USBD_EVENT_DMA_ERROR,
N} kdrv_usbd_event_name_t;
N
N/** USB event, it includes kdrv_usbd_event_name_t and related data */
Ntypedef struct
N{
N    kdrv_usbd_event_name_t ename;
N    union {
N        kdrv_usbd_setup_packet_t setup;
N        struct
N        {
N            uint32_t data1;
N            uint32_t data2;
N        };
N    };
N
N} kdrv_usbd_event_t;
N
N/** Code for response to host in control transfer */
Ntypedef enum
N{
N    KDRV_USBD_RESPOND_OK,   /** send ACK in the status stage */
N    KDRV_USBD_RESPOND_ERROR /** send STALL in the status stage */
N} kdrv_usbd_status_respond_t;
N
N/**
N * @brief           USB device mode driver initialization
N *
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_initialize(void);
N
N/**
N * @brief           USB device mode driver uninitialization
N *
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_uninitialize(void);
N
N/**
N * @brief           reset device and then it can be re-enumerated by host
N *
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_reset_device(void);
N
N/**
N * @brief           configure device manufacturer, product , serial number
N * @param[in]       dev_desc              device string descriptor
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_set_string_descriptor(
N    kdrv_usbd_string_descriptor_t *dev_str_desc);
N
N/**
N * @brief           configure device descriptor including configuration, interface and all endpoints descriptors
N *
N * @param[in]       speed                 speed want to run, now support only High-Speed
N * @param[in]       dev_desc              user crated device descriptor, this must be kept during device enumeration
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_set_device_descriptor(
N    kdrv_usbd_speed_t speed,
N    kdrv_usbd_device_descriptor_t *dev_desc);
N
N/**
N * @brief           configure device qualifier descriptor, this is optional
N *
N * @param[in]       speed                 speed want to run, now support only High-Speed
N * @param[in]       dev_qual_desc         user crated device qualifier descriptor, this must be kept during device enumeration
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_set_device_qualifier_descriptor(
N    kdrv_usbd_speed_t speed,
N    kdrv_usbd_device_qualifier_descriptor_t *dev_qual_desc);
N
N/**
N * @brief           register user thread ID and thread flag for notifications including events or transfer completion/errors
N *
N * @param[in]       tid                   CMSIS-RTOS v2 thread ID
N * @param[in]       tflag                 user defined thread flag to be notified by osThreadFlagsSet()
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_register_thread_notification(osThreadId_t tid, uint32_t tflag);
N
N/**
N * @brief           set enable/disabale of USB device mode, host can enumerate this device only if device is enabled
N *
N * @param[in]       enable                true to enable, false to disable
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_set_enable(bool enable);
Xextern kdrv_status_t kdrv_usbd_set_enable(_Bool enable);
N
N/**
N * @brief           check if device is enumerated and configured by a host
N *
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern bool kdrv_usbd_is_dev_configured(void);
Xextern _Bool kdrv_usbd_is_dev_configured(void);
N
N// get an usb event from internal event queue
N
N/**
N * @brief           get a usbd event, this is a blocking function for sync mode usage of USBD APIs
N *
N * @param[in]       uevent                usbd event to be notified of
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_get_event(kdrv_usbd_event_t *uevent);
N
N/**
N * @brief           Control-IN transfer, send data to host through the control endpont
N * @details         for a user-defined vendor reqeust & control IN & wLength > 0,
N *                  user should use this function to send data to host,
N *                  or respond an error via kdrv_usbd_control_respond(KDRV_USBD_RESPOND_ERROR) to claim STALL
N * 
N * @param[in]       buf                   data to be sent to host
N * @param[in]       size                  number of bytes to be transfered
N * @param[in]       timeout_ms            timeout in millisecond
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_control_send(
N    uint8_t *buf,
N    uint32_t size,
N    uint32_t timeout_ms);
N
N/**
N * @brief           Control-OUT transfer, receive data from host through the control endpont
N * @details         for a user-defined vendor reqeust & control OUT & wLength > 0,
N *                  user should use this function to receive data from host,
N *                  or respond an error via kdrv_usbd_control_respond(KDRV_USBD_RESPOND_ERROR) to claim STALL
N * 
N * @param[out]      buf                   buffer for receiving data
N * @param[in]       size                  buffer length
N * @param[in]       timeout_ms            timeout in millisecond
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_control_receive(
N    uint8_t *buf,
N    uint32_t *size,
N    uint32_t timeout_ms);
N
N// to report status for a user-defined vendor request
N
N/**
N * @brief           respond to host through control transfer in the status stage
N * @details         this function is used as response function to report status for a user-defined vendor request
N * 
N * @param[in]       status                status
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_control_respond(kdrv_usbd_status_respond_t status);
N
N/**
N * @brief           reset specified endpoint
N * 
N * @param[in]       status                status
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_reset_endpoint(uint32_t endpoint);
N
N/**
N * @brief           Bulk-IN transfser, send data to host through a bulk-in endpont in blocking mode
N * 
N * @param[in]       endpoint              a bulk-in endpoint address, should be the value from bEndpointAddress
N * @param[in]       buf                   data to be sent to host
N * @param[in]       txLen                 number of bytes to be transfered
N * @param[in]       timeout_ms            timeout in millisecond
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_bulk_send(
N    uint32_t endpoint,
N    uint32_t *buf,
N    uint32_t txLen,
N    uint32_t timeout_ms);
N
N/**
N * @brief           Bulk-IN transfser, send data to host through a bulk-in endpont in non-blocking mode
N * @details         user can commit a buffer for Bulk In transfer, and then wait for KDRV_USBD_EVENT_TRANSFER_DONE 
N *                  to be notified that the transfer is done or some error code if failed.
N *                  This function works with kdrv_usbd_get_event().
N * 
N * @param[in]       endpoint              a bulk-in endpoint address, should be the value from bEndpointAddress
N * @param[in]       buf                   data to be sent to host
N * @param[in]       txLen                 number of bytes to be transfered
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_bulk_send_async(
N    uint32_t endpoint, // should be the value from bEndpointAddress
N    uint32_t *buf,     // memory addres to be read from
N    uint32_t txLen);   // transfer length
N
N/**
N * @brief           Bulk-OUT transfser, receive data from the host through a bulk-out endpoint in blocking mode
N * 
N * @param[in]       endpoint              a bulk-out endpoint address, should be the value from bEndpointAddress
N * @param[out]      buf                   buffer for receiving data
N * @param[in,out]   blen                  buffer length for input, actual transfered length for output
N * @param[in]       timeout_ms            timeout in millisecond
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_bulk_receive(
N    uint32_t endpoint,
N    uint32_t *buf,
N    uint32_t *blen,
N    uint32_t timeout_ms);
N
N/**
N * @brief           Bulk-OUT transfser, receive data from the host through a bulk-out endpoint in non-blocking mode
N * @details         this works with kdrv_usbd_get_event(), when receiving a 'KDRV_USBD_EVENT_TRANSFER_OUT' event,
N *                  user should commit a buffer for Bulk Out transfer through this function.
N *                  when transfer is done by usbd, eihter a 'KDRV_USBD_EVENT_TRANSFER_DONE' or 'KDRV_USBD_EVENT_TRANSFER_BUF_FULL' event
N *                  will be sent to user.
N * 
N * @param[in]       endpoint              a bulk-out endpoint address, should be the value from bEndpointAddress
N * @param[in]       buf                   buffer for receiving data
N * @param[in]       blen                  buffer length
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_bulk_receive_async(
N    uint32_t endpoint,
N    uint32_t *buf,
N    uint32_t blen
N);
N
N/**
N * @brief           Interrupt-IN transfer in blocking mode
N * @details         Immediately write data to the FIFO buffer for periodic interrupt-in transfer.
N *                  Note even while the old data is not yet read by host, this function will overwrite it.
N * 
N * @param[in]       endpoint              a interrupt-in endpoint address, should be the value from bEndpointAddress
N * @param[in]       buf                   data to be sent to host
N * @param[in]       txLen                 transfer length, shoudl be less then MaxPacketSize
N * @param[in]       timeout_ms            timeout in millisecond
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_interrupt_send(
N    uint32_t endpoint,
N    uint32_t *buf,
N    uint32_t txLen,
N    uint32_t timeout_ms);
N
N/**
N * @brief           Interrupt-OUT transfer in blocking mode
N * 
N * @param[in]       endpoint              a interrupt-out endpoint address, should be the value from bEndpointAddress
N * @param[out]      buf                   buffer for receiving data
N * @param[in,out]   rxLen                 buffer length for input, actual transfered length for output, should be less than MaxPacketSize
N * @param[in]       timeout_ms            timeout in millisecond
N * @return          kdrv_status_t         see @ref kdrv_status_t
N */
Nextern kdrv_status_t kdrv_usbd_interrupt_receive(
N    uint32_t endpoint, // should be the value from bEndpointAddress
N    uint32_t *buf,
N    uint32_t *rxLen,
N    uint32_t timeout_ms);
N
N#endif
L 19 "..\..\..\..\scpu\drivers\src\kdp520_usbd.c" 2
N
N// OTG Control Status Register (0x80)
N#define REG_OTG_CSR 0x80
N#define VBUS_VLD_RO BIT19
N#define B_SESS_END_RO BIT16
N
N// OTG Interrupt Stauts Register (0x84)
N// OTG Interrupt Enable Register (0x88)
N#define REG_OTG_ISR 0x84
N#define REG_OTG_IER 0x88
N#define OTG_APLGRMV_RW1C BIT12
N#define OTG_A_WAIT_CON_RW1C BIT11
N#define OTG_OVC_RW1C BIT10
N#define OTG_IDCHG_RW1C BIT9
N#define OTG_RLCHG_RW1C BIT8
N#define OTG_B_SESS_END_RW1C BIT6
N#define OTG_A_VBUS_ERR_RW1C BIT5
N#define OTG_A_SRP_DET_RW1C BIT4
N#define OTG_B_SRP_DN_RW1C BIT0
N
N// Global HC/OTG/DEV Interrupt Status Register (0xC0)
N// Global Mask of HC/OTG/DEV Interrupt Register (0xC4)
N#define REG_GLB_ISR 0xC0
N#define REG_GLB_INT 0xC4
N#define INT_POLARITY BIT3
N#define OTG_INT BIT1
N#define DEV_INT BIT0
N
N// Device Main Control Register (0x100)
N#define REG_DEV_CTL 0x100
N
N// Device Address register (0x104)
N#define REG_DEV_ADR 0x104
N#define AFT_CONF BIT7
N
N// Device Test Register (0x108)
N#define REG_DEV_TST 0x108
N#define TST_CLRFF BIT0
N
N// Device SOF Mask Timer Register (0x110)
N#define REG_DEV_SMT 0x110
N
N// PHY Test Mode Selector Register (0x114)
N#define REG_PHY_TST 0x114
N#define TST_JSTA BIT0
N
N// Device CX configuration adn FIFO empty status (0x120)
N#define REG_CXCFE 0x120
N#define F_EMP_0 BIT8
N#define CX_CLR BIT3
N#define CX_STL BIT2
N#define CX_DONE BIT0
N
N// Device Idle Counter Register (0x124)
N#define REG_DEV_ICR 0x124
N
N// Group total interrupt mask (0x130)
N// Group total interrupt status (0x140)
N#define REG_DEV_MIGR 0x130
N#define REG_DEV_IGR 0x140
N#define GX_INT_G3_RO BIT3
N#define GX_INT_G2_RO BIT2
N#define GX_INT_G1_RO BIT1
N#define GX_INT_G0_RO BIT0
N
N// Group 0 interrupt mask (0x134)
N// Group 0 interrupt status (0x144)
N// control transfer
N#define REG_DEV_MISG0 0x134
N#define REG_DEV_ISG0 0x144
N#define G0_CX_COMABT_INT_RW1C BIT5
N#define G0_CX_COMFAIL_INT_RO BIT4
N#define G0_CX_COMEND_INT_RO BIT3
N#define G0_CX_OUT_INT_RO BIT2
N#define G0_CX_IN_INT_RO BIT1
N#define G0_CX_SETUP_INT_RO BIT0
N
N// Group 1 interrupt mask (0x138)
N// Group 1 interrupt status (0x148)
N// FIFO interrupts
N#define REG_DEV_MISG1 0x138
N#define REG_DEV_ISG1 0x148
N#define MF0_IN_INT BIT16
N#define MF0_SPK_INT BIT1
N#define MF0_OUT_INT BIT0
N
N// Group 1 interrupts (0x148)
N#define G1_F3_IN_INT_RO BIT19
N#define G1_F2_IN_INT_RO BIT18
N#define G1_F1_IN_INT_RO BIT17
N#define G1_F0_IN_INT_RO BIT16
N#define G1_F3_SPK_INT_RO BIT7
N#define G1_F3_OUT_INT_RO BIT6
N#define G1_F2_SPK_INT_RO BIT5
N#define G1_F2_OUT_INT_RO BIT4
N#define G1_F1_SPK_INT_RO BIT3
N#define G1_F1_OUT_INT_RO BIT2
N#define G1_F0_SPK_INT_RO BIT1
N#define G1_F0_OUT_INT_RO BIT0
N
N// Group 2 interrupt mask (0x13C)
N// Group 2 interrupt source (0x14C)
N#define REG_DEV_MISG2 0x13C
N#define REG_DEV_ISG2 0x14C
N#define G2_Dev_Wakeup_byVbus_RO BIT10
N#define G2_Dev_Idle_RO BIT9
N#define G2_DMA_ERROR_RW1C BIT8
N#define G2_DMA_CMPLT_RW1C BIT7
N#define G2_RX0BYTE_INT_RW1C BIT6
N#define G2_TX0BYTE_INT_RW1C BIT5
N#define G2_ISO_SEQ_ABORT_INT_RW1C BIT4
N#define G2_ISO_SEQ_ERR_INT_RW1C BIT3
N#define G2_RESM_INT_RW1C BIT2
N#define G2_SUSP_INT_RW1C BIT1
N#define G2_USBRST_INT_RW1C BIT0
N
N// Devcie Receive Zero-Length Data Packet Register (0x150)
N#define REG_DEV_RXZ 0x150
N#define RX0BYTE_EP1 BIT0
N
N// Device IN endpoint & MaxPacketSize (0x160 + 4(n-1))
N#define REG_DEV_INMPS_1 0x160
N#define TX0BYTE_IEPn BIT15
N#define RSTG_IEPn BIT12
N#define STL_IEPn BIT11
N
N// Device IN endpoint & MaxPacketSize (0x180 + 4(n-1))
N#define REG_DEV_OUTMPS_1 0x180
N#define RSTG_OEPn BIT12
N#define STL_IEPn BIT11
N
N// Device Endpoint 1~4 Map Register (0x1A0)
N#define REG_DEV_EPMAP0 0x1A0
N
N// Device Endpoint 5~8 Map Register (0x1A4)
N#define REG_DEV_EPMAP1 0x1A4
N
N// Device FIFO Map Register (0x1A8)
N#define REG_DEV_FMAP 0x1A8
N
N// Device FIFO Configuration Register (0x1AC)
N#define REG_DEV_FCFG 0x1AC
N
N// Device FIFO Byte Count Register (0x1B0 + 4(fno-1))
N#define FFRST BIT12
N#define BC_Fn 0x7ff
N
N// DMA Target FIFO register (0x1C0)
N#define REG_DMA_TFN 0x1C0
N#define DMA_TARGET_ACC_CXF BIT4
N#define DMA_TARGET_ACC_F3 BIT3
N#define DMA_TARGET_ACC_F2 BIT2
N#define DMA_TARGET_ACC_F1 BIT1
N#define DMA_TARGET_ACC_F0 BIT0
N#define DMA_TARGET_ACC_NONE 0x0
N
N// DMA Controller Param 1 (0x1C8)
N#define REG_DMA_CPS1 0x1C8
N#define DMA_TYPE BIT1
N#define DMA_START BIT0
N
N// DMA Controller Param 2 (0x1CC)
N#define REG_DMA_CPS2 0x1CC
N
N// DMA Controller Param 3 (0x1D0)
N// setup packet 8 bytes direct DMA read
N#define REG_DMA_CPS3 0x1D0
N
N#define FIFO_NUM 4 // we have 4 FIFOs, each has 1-KB
N
N#define UsbRegRead(reg_offset) inw(USB_FOTG210_PA_BASE + (reg_offset))
N#define UsbRegWrite(reg_offset, val) outw(USB_FOTG210_PA_BASE + (reg_offset), (val))
N#define UsbRegMaskedSet(reg_offset, val) masked_outw(USB_FOTG210_PA_BASE + (reg_offset), (val), (val))
N#define UsbRegMaskedClr(reg_offset, val) masked_outw(USB_FOTG210_PA_BASE + (reg_offset), 0, (val))
N
N#define MIN(x, y) (((x) < (y)) ? (x) : (y))
N
Nenum
N{
N    CONFIG_DEFAULT_STATE = 0,
N    CONFIG_ADDRESS_STATE,
N    CONFIG_CONFIGURED_STATE,
N};
N
N// for FIFO_Ctrl:transferType
Nenum
N{
N    TXFER_CONTROL = 0,
N    TXFER_ISO,
N    TXFER_BULK,
N    TXFER_INT,
N};
N
N// for SETUP packet request
Nenum
N{
N    RESP_NACK = 1, /* busy now */
N    RESP_ACK,      /* reqeust is done */
N    RESP_STALL,    /* request is not supported */
N};
N
N// a data struct for FIFO and DMA control
Ntypedef struct
N{
N    // below are initialized once when endpoint is configured
N    uint8_t enabled;          // indicate that this FIFO is enabled
N    uint8_t enpNo;            // endpoint no (without direction bit)
N    uint32_t endpointAddress; // endpoint address (with direction bit)
N    uint32_t maxPacketSize;   // the wMaxPacketSize
N    uint8_t transferType;     // Control/Iso/Bulk/Interrupt
N    uint32_t byteCntReg;      // FIFO byte count register address
N
N    // below are used while transferring data
N    uint8_t isTransferring;   // indicate it is in transferring progress
N    uint32_t user_buf_addr;   // user commited buffer address for transfer
N    uint32_t user_buf_len;    // user buffer length
N    uint32_t received_length; // for Out only
N
N    // below variable represents short packet is coming for bulk out
N    // or zero-length packet for bulk in
N    // 1: True, 0: False
N    uint8_t short_or_zl_packet;
N
N    uint8_t isBlockingCall;
N    kdrv_usbd_event_name_t cur_event; // internal use for blocking API
N} FIFO_Ctrl;
N
N// define usb device mode control block
Ntypedef struct
N{
N    osThreadId_t notifyTid;
N    osEventFlagsId_t evt_id; // internal use for blocking API
N    uint32_t notifyFlag;
N    bool ep0_halted;
X    _Bool ep0_halted;
N    kdrv_usbd_device_descriptor_t *dev_desc;
N    kdrv_usbd_device_qualifier_descriptor_t *dev_qual_desc; // is it necessary ?
N    kdrv_usbd_string_descriptor_t* dev_string_desc;
N    uint32_t config_state;
N    FIFO_Ctrl fifo_cbs[FIFO_NUM]; // FIFO control blocks
X    FIFO_Ctrl fifo_cbs[4]; 
N} Ctrl_Block;
N
Nenum
N{
N    READ_FIFO = 0,
N    WRITE_FIFO = 1,
N};
N
N// an usb device mode object for internal use
NCtrl_Block cb =
N    {
N        .notifyTid = 0,
N        .notifyFlag = 0,
N        .ep0_halted = false,
X        .ep0_halted = 0,
N        .dev_desc = NULL,
X        .dev_desc = 0,
N        .dev_string_desc = NULL,
X        .dev_string_desc = 0,
N        .config_state = CONFIG_DEFAULT_STATE,
N};
N
N#define QLEN 30
Nstatic kdrv_usbd_event_t event_queue[QLEN]; // a fifo ring queue
Xstatic kdrv_usbd_event_t event_queue[30]; 
Nstatic int eqWriteIdx = 0;
Nstatic int eqReadIdx = 0;
Nstatic osSemaphoreId_t empty_id = 0;
Nstatic osSemaphoreId_t filled_id = 0;
N
Nstatic bool dma_is_busy()
Xstatic _Bool dma_is_busy()
N{
N    return (UsbRegRead(REG_DMA_TFN) != DMA_TARGET_ACC_NONE);
X    return ((*(volatile unsigned int *)(0xC0100000 + (0x1C0))) != 0x0);
N}
N
N//  for data SRAM, the address must be remapped
Nstatic uint32_t dma_remap_addr(uint32_t addr)
N{
N    uint32_t tmp;
N
N    if ((addr & (SdRAM_MEM_BASE)) == SdRAM_MEM_BASE)
X    if ((addr & (0x10200000)) == 0x10200000)
N    {
N        tmp = ((addr) & (~0x10000000)) | 0x20000000;
N        return tmp;
N    }
N    return addr;
N}
N
N// fifo to memory or memory to fifo transfer
N// fifo_dir = 1 : memory -> fifo
N// fifo_dir = 0 : fifo -> memory
N// dma polling way
Nstatic bool dma_fifo_transfer_sync(uint32_t *addr, uint32_t len, uint32_t fifo_sel, uint8_t fifo_dir)
Xstatic _Bool dma_fifo_transfer_sync(uint32_t *addr, uint32_t len, uint32_t fifo_sel, uint8_t fifo_dir)
N{
N    if (dma_is_busy())
N        return false;
X        return 0;
N
N    bool status = false;
X    _Bool status = 0;
N
N    // set DMA FIFO selection to accuire DMA
N    // FIXME: better use mutex stuff to occupy DMA resource !!
N    UsbRegWrite(REG_DMA_TFN, fifo_sel);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C0)) = ((fifo_sel)));
N
N    // temporarily disable DMA complt interrupt
N    // because we will poll it here
N    UsbRegMaskedSet(REG_DEV_MISG2, G2_DMA_CMPLT_RW1C);
X    (*(volatile unsigned int *)(0xC0100000 + (0x13C)) = (((*(volatile unsigned int *)(0xC0100000 + (0x13C))) & ~(0x00000080)) | ((0x00000080) & (0x00000080))));
N
N    // set DMA address
N    UsbRegWrite(REG_DMA_CPS2, dma_remap_addr((uint32_t)addr));
X    (*(volatile unsigned int *)(0xC0100000 + (0x1CC)) = ((dma_remap_addr((uint32_t)addr))));
N
N    // set DMA transfer size
N    UsbRegWrite(REG_DMA_CPS1, len << 8);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C8)) = ((len << 8)));
N
N    if (fifo_dir == WRITE_FIFO)
N        UsbRegMaskedSet(REG_DMA_CPS1, BIT1);
X        (*(volatile unsigned int *)(0xC0100000 + (0x1C8)) = (((*(volatile unsigned int *)(0xC0100000 + (0x1C8))) & ~(0x00000002)) | ((0x00000002) & (0x00000002))));
N
N    // start DMA
N    UsbRegMaskedSet(REG_DMA_CPS1, DMA_START);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C8)) = (((*(volatile unsigned int *)(0xC0100000 + (0x1C8))) & ~(0x00000001)) | ((0x00000001) & (0x00000001))));
N
N    int i;
N    // FIXME: why 500 ? just to prevent from being dead forever
N    for (i = 0; i < 500; i++)
N    {
N        // polling DMA completion status
N        if (UsbRegRead(REG_DEV_ISG2) & G2_DMA_CMPLT_RW1C)
X        if ((*(volatile unsigned int *)(0xC0100000 + (0x14C))) & 0x00000080)
N        {
N            UsbRegMaskedSet(REG_DEV_ISG2, G2_DMA_CMPLT_RW1C);
X            (*(volatile unsigned int *)(0xC0100000 + (0x14C)) = (((*(volatile unsigned int *)(0xC0100000 + (0x14C))) & ~(0x00000080)) | ((0x00000080) & (0x00000080))));
N            status = true;
X            status = 1;
N            break;
N        }
N    }
N
N    // re-enable DMA complt interrupt
N    UsbRegMaskedClr(REG_DEV_MISG2, G2_DMA_CMPLT_RW1C);
X    (*(volatile unsigned int *)(0xC0100000 + (0x13C)) = (((*(volatile unsigned int *)(0xC0100000 + (0x13C))) & ~(0x00000080)) | (0 & (0x00000080))));
N
N    // clear DMA FIFO selection
N    UsbRegWrite(REG_DMA_TFN, DMA_TARGET_ACC_NONE);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C0)) = ((0x0)));
N
N    return status;
N}
N
Nstatic bool dma_fifo_transfer_sync_try(uint32_t *addr, uint32_t len, uint32_t fifo_sel, uint8_t fifo_dir, uint32_t try_count)
Xstatic _Bool dma_fifo_transfer_sync_try(uint32_t *addr, uint32_t len, uint32_t fifo_sel, uint8_t fifo_dir, uint32_t try_count)
N{
N    bool status = false;
X    _Bool status = 0;
N    for (int i = 0; i < try_count; i++)
N        if (dma_fifo_transfer_sync(addr, len, fifo_sel, fifo_dir))
N        {
N            status = true;
X            status = 1;
N            break;
N        }
N    return status;
N}
N
N// out transfer
N// configure DMA settings for fifo-to-memory for non-control transfer
N// this implementation follows FOTG210 data sheet : 6.2.4 "Programming DMA"
Nstatic bool dma_start_fifo_to_mem(uint32_t fno, FIFO_Ctrl *fifocb)
Xstatic _Bool dma_start_fifo_to_mem(uint32_t fno, FIFO_Ctrl *fifocb)
N{
N    if (dma_is_busy())
N        return false;
X        return 0;
N
N    // select FIFO for DMA
N    UsbRegWrite(REG_DMA_TFN, 0x1 << fno);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C0)) = ((0x1 << fno)));
N
N    uint32_t fifo_bytecnt = UsbRegRead(fifocb->byteCntReg) & BC_Fn;
X    uint32_t fifo_bytecnt = (*(volatile unsigned int *)(0xC0100000 + (fifocb->byteCntReg))) & 0x7ff;
N    // can transfer only minimum size betwwen FIFO byte count and user buffer residual size
N    uint32_t transfer_size = MIN(fifo_bytecnt, fifocb->user_buf_len);
X    uint32_t transfer_size = (((fifo_bytecnt) < (fifocb->user_buf_len)) ? (fifo_bytecnt) : (fifocb->user_buf_len));
N
N    // set DMA memory addr
N    UsbRegWrite(REG_DMA_CPS2, fifocb->user_buf_addr);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1CC)) = ((fifocb->user_buf_addr)));
N
N    // set DMA_LEN and DMA_TYPE = FIFO_to_Memory
N    UsbRegWrite(REG_DMA_CPS1, transfer_size << 8);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C8)) = ((transfer_size << 8)));
N
N    // start DMA
N    UsbRegMaskedSet(REG_DMA_CPS1, DMA_START);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C8)) = (((*(volatile unsigned int *)(0xC0100000 + (0x1C8))) & ~(0x00000001)) | ((0x00000001) & (0x00000001))));
N
N    fifocb->user_buf_addr += transfer_size;
N    fifocb->user_buf_len -= transfer_size;
N    fifocb->received_length += transfer_size;
N
N    return true;
X    return 1;
N}
N
N// in trasnfer
N// configure DMA settings for memory-to-fifo for non-control transfer
N// this implementation follows FOTG210 data sheet : 6.2.4 "Programming DMA"
Nstatic bool dma_start_mem_to_fifo(uint32_t fno, FIFO_Ctrl *fifocb)
Xstatic _Bool dma_start_mem_to_fifo(uint32_t fno, FIFO_Ctrl *fifocb)
N{
N    if (dma_is_busy())
N        return false;
X        return 0;
N
N    // select FIFO for DMA
N    UsbRegWrite(REG_DMA_TFN, 0x1 << fno);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C0)) = ((0x1 << fno)));
N
N    // can transfer only minimum size betwwen MaxPacketSize and user buffer residual size
N    uint32_t transfer_size = MIN(fifocb->maxPacketSize, fifocb->user_buf_len);
X    uint32_t transfer_size = (((fifocb->maxPacketSize) < (fifocb->user_buf_len)) ? (fifocb->maxPacketSize) : (fifocb->user_buf_len));
N
N    // set DMA memory addr
N    UsbRegWrite(REG_DMA_CPS2, fifocb->user_buf_addr);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1CC)) = ((fifocb->user_buf_addr)));
N
N    // set DMA_LEN and DMA_TYPE = Memory_to_FIFO
N    UsbRegWrite(REG_DMA_CPS1, (transfer_size << 8) | 0x2);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C8)) = (((transfer_size << 8) | 0x2)));
N
N    // start DMA
N    UsbRegMaskedSet(REG_DMA_CPS1, DMA_START);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C8)) = (((*(volatile unsigned int *)(0xC0100000 + (0x1C8))) & ~(0x00000001)) | ((0x00000001) & (0x00000001))));
N
N    fifocb->user_buf_addr += transfer_size;
N    fifocb->user_buf_len -= transfer_size;
N
N    return true;
X    return 1;
N}
N
N/* this function must not be used in ISR */
Nstatic void reset_event_queue()
N{
N    osStatus_t sts = osOK;
N
N    if (empty_id != 0)
N        sts = osSemaphoreRelease(empty_id);
N
N    if (sts == osOK)
N        empty_id = osSemaphoreNew(QLEN, QLEN, NULL);
X        empty_id = osSemaphoreNew(30, 30, 0);
N
N    if (filled_id != 0)
N        sts = osSemaphoreRelease(filled_id);
N
N    if (sts == osOK)
N        filled_id = osSemaphoreNew(QLEN, 0, NULL);
X        filled_id = osSemaphoreNew(30, 0, 0);
N
N    // reset read/write indices
N    eqWriteIdx = 0;
N    eqReadIdx = 0;
N}
N
Nstatic void clean_event_queue()
N{
N    if (empty_id != 0)
N        osSemaphoreRelease(empty_id);
N    empty_id = 0;
N
N    if (filled_id != 0)
N        osSemaphoreRelease(filled_id);
N    filled_id = 0;
N}
N
Nstatic int push_event_to_queue(kdrv_usbd_event_t event)
N{
N    osStatus_t sts;
N
N    sts = osSemaphoreAcquire(empty_id, 0);
N    if (sts != osOK)
N        // not overwrite event queue
N        return 0;
N
N    event_queue[eqWriteIdx] = event;
N    ++eqWriteIdx;
N    if (eqWriteIdx >= QLEN)
X    if (eqWriteIdx >= 30)
N        eqWriteIdx = 0;
N
N    osSemaphoreRelease(filled_id);
N    return 1;
N}
N
Nstatic int pop_event_from_queue(kdrv_usbd_event_t *event)
N{
N    osStatus_t sts;
N
N    sts = osSemaphoreAcquire(filled_id, 0);
N    // queue is empty
N    if (sts != osOK)
N        return 0;
N
N    *event = event_queue[eqReadIdx];
N    ++eqReadIdx;
N    if (eqReadIdx >= QLEN)
X    if (eqReadIdx >= 30)
N        eqReadIdx = 0;
N
N    osSemaphoreRelease(empty_id);
N    return 1;
N}
N
N// put usb events to an event queue and notify user via thread flag
Nstatic void notify_event_to_user(kdrv_usbd_event_name_t ename, uint32_t data1, uint32_t data2)
N{
N    kdrv_usbd_event_t uevent;
N    uevent.ename = ename;
N    uevent.data1 = data1;
N    uevent.data2 = data2;
N    push_event_to_queue(uevent);
N
N    if (cb.notifyTid)
N        osThreadFlagsSet(cb.notifyTid, cb.notifyFlag);
N}
N
Nstatic void bus_reset_work()
N{
N    // clear SET_CONFIG state and usb device address
N    UsbRegWrite(REG_DEV_ADR, 0x0);
X    (*(volatile unsigned int *)(0xC0100000 + (0x104)) = ((0x0)));
N
N    // clear EP0 STALL bit
N    UsbRegMaskedClr(REG_CXCFE, CX_STL);
X    (*(volatile unsigned int *)(0xC0100000 + (0x120)) = (((*(volatile unsigned int *)(0xC0100000 + (0x120))) & ~(0x00000004)) | (0 & (0x00000004))));
N
N    // disable (mask) all FIFOs interrupts
N    UsbRegWrite(REG_DEV_MISG1, 0xFFFFFFFF);
X    (*(volatile unsigned int *)(0xC0100000 + (0x138)) = ((0xFFFFFFFF)));
N
N    // clear all FIFO
N    UsbRegMaskedSet(REG_DEV_TST, TST_CLRFF);
X    (*(volatile unsigned int *)(0xC0100000 + (0x108)) = (((*(volatile unsigned int *)(0xC0100000 + (0x108))) & ~(0x00000001)) | ((0x00000001) & (0x00000001))));
N
N    // clear this interrupt bit
N    UsbRegMaskedSet(REG_DEV_ISG2, G2_USBRST_INT_RW1C);
X    (*(volatile unsigned int *)(0xC0100000 + (0x14C)) = (((*(volatile unsigned int *)(0xC0100000 + (0x14C))) & ~(0x00000001)) | ((0x00000001) & (0x00000001))));
N
N    // reset all endpoints, FIXME: better place to do this ?
N    {
N        FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
N        for (int fno = 0; fno < FIFO_NUM; fno++)
X        for (int fno = 0; fno < 4; fno++)
N            if (fifo_cb[fno].enabled)
N            {
N                kdrv_usbd_reset_endpoint(fifo_cb[fno].endpointAddress);
N            }
N    }
N
N    notify_event_to_user(KDRV_USBD_EVENT_BUS_RESET, 0, 0);
N}
N
Nstatic void handle_dma_error()
N{
N    // clear this interrupt bit
N    UsbRegMaskedSet(REG_DEV_ISG2, G2_DMA_ERROR_RW1C);
X    (*(volatile unsigned int *)(0xC0100000 + (0x14C)) = (((*(volatile unsigned int *)(0xC0100000 + (0x14C))) & ~(0x00000100)) | ((0x00000100) & (0x00000100))));
N
N    // check which fifo-endpoint is responsible for this
N
N    uint32_t fifoSel = UsbRegRead(REG_DMA_TFN);
X    uint32_t fifoSel = (*(volatile unsigned int *)(0xC0100000 + (0x1C0)));
N
N    // clear FIFO sel
N    UsbRegWrite(REG_DMA_TFN, DMA_TARGET_ACC_NONE);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C0)) = ((0x0)));
N
N    uint32_t fno;
N    for (fno = 0; fno < FIFO_NUM; fno++)
X    for (fno = 0; fno < 4; fno++)
N        if (fifoSel & (0x1 << fno))
N            break;
N
N    FIFO_Ctrl *fifo_cb = &(cb.fifo_cbs[fno]);
N
N    // reset the endpoint due to DMA error
N    kdrv_usbd_reset_endpoint(fifo_cb->endpointAddress);
N
N    // also notify user the DMA_ERROR
N    notify_event_to_user(KDRV_USBD_EVENT_DMA_ERROR, 0, 0);
N}
N
Nstatic void bus_suspend_work()
N{
N    // clear this interrupt bit
N    UsbRegMaskedSet(REG_DEV_ISG2, G2_SUSP_INT_RW1C);
X    (*(volatile unsigned int *)(0xC0100000 + (0x14C)) = (((*(volatile unsigned int *)(0xC0100000 + (0x14C))) & ~(0x00000002)) | ((0x00000002) & (0x00000002))));
N
N    // FIXME: should do something here ?
N
N    notify_event_to_user(KDRV_USBD_EVENT_BUS_SUSPEND, 0, 0);
N}
N
Nstatic void bus_resume_work()
N{
N    // clear this interrupt bit
N    UsbRegMaskedSet(REG_DEV_ISG2, G2_RESM_INT_RW1C);
X    (*(volatile unsigned int *)(0xC0100000 + (0x14C)) = (((*(volatile unsigned int *)(0xC0100000 + (0x14C))) & ~(0x00000004)) | ((0x00000004) & (0x00000004))));
N
N    // FIXME: should do something here ?
N
N    notify_event_to_user(KDRV_USBD_EVENT_BUS_SUSPEND, 0, 0);
N}
N
Nstatic int8_t endpoint_to_fifo(uint32_t endpoint)
N{
N    // check fifo ctrl blocks to get fifo no
N    int8_t fno;
N    for (fno = 0; fno < FIFO_NUM; fno++)
X    for (fno = 0; fno < 4; fno++)
N        if (cb.fifo_cbs[fno].endpointAddress == endpoint)
N            break;
N
N    return (fno < 4) ? fno : -1;
N}
N
Nstatic void clean_fifo_cb(FIFO_Ctrl *fifo_cb)
N{
N    fifo_cb->user_buf_addr = 0;
N    fifo_cb->user_buf_len = 0;
N    fifo_cb->isTransferring = false;
X    fifo_cb->isTransferring = 0;
N    fifo_cb->short_or_zl_packet = false;
X    fifo_cb->short_or_zl_packet = 0;
N}
N
Nstatic inline void handle_fifo_short_pkt_interrupts(uint32_t interrupt_bits)
N{
N    for (int fno = 0; fno < FIFO_NUM; fno++)
X    for (int fno = 0; fno < 4; fno++)
N    {
N        if (interrupt_bits & (G1_F0_SPK_INT_RO << (fno * 2)))
X        if (interrupt_bits & (0x00000002 << (fno * 2)))
N        {
N
N            // with a short packet coming means data is less than MaxPacketSize
N            // and it is the last packet transferd by host
N            // this will be handled in DMA completeion time
N            cb.fifo_cbs[fno].short_or_zl_packet = true;
X            cb.fifo_cbs[fno].short_or_zl_packet = 1;
N
N            // disable short packet interrupt
N            // shoudl be re-enabled at next DMA completeion time
N            UsbRegMaskedSet(REG_DEV_MISG1, MF0_SPK_INT << (fno * 2));
X            (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~(0x00000002 << (fno * 2))) | ((0x00000002 << (fno * 2)) & (0x00000002 << (fno * 2)))));
N
N            break;
N        }
N    }
N}
N
Nstatic inline void handle_fifo_out_interrupts(uint32_t interrupt_bits)
N{
N    FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
N
N    for (int fno = 0; fno < FIFO_NUM; fno++)
X    for (int fno = 0; fno < 4; fno++)
N    {
N        // handle interrupts for each fifo
N        if (interrupt_bits & (G1_F0_OUT_INT_RO << (fno * 2)))
X        if (interrupt_bits & (0x00000001 << (fno * 2)))
N        {
N            // if no user buffer is commited, means that this is a start of OUT transfer
N            if (fifo_cb[fno].user_buf_addr == 0)
N            {
N                // disable this OUT interrrupt
N                // it should be re-enabled once user commits a buffer for DMA
N                UsbRegMaskedSet(REG_DEV_MISG1, MF0_OUT_INT << (fno * 2));
X                (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~(0x00000001 << (fno * 2))) | ((0x00000001 << (fno * 2)) & (0x00000001 << (fno * 2)))));
N
N                // then should notify an event to user
N                notify_event_to_user(KDRV_USBD_EVENT_TRANSFER_OUT, fifo_cb[fno].enpNo, 0);
N            }
N            else // configure DMA transfer for FIFO to user buffer
N            {
N                if (fifo_cb[fno].user_buf_len > 0 &&
N                    dma_start_fifo_to_mem(fno, &fifo_cb[fno]) == true)
X                    dma_start_fifo_to_mem(fno, &fifo_cb[fno]) == 1)
N                {
N                    // DMA has been started, disable this OUT interrupt
N                    // and re-enable the interrupt at DMA completion
N                    UsbRegMaskedSet(REG_DEV_MISG1, MF0_OUT_INT << (fno * 2));
X                    (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~(0x00000001 << (fno * 2))) | ((0x00000001 << (fno * 2)) & (0x00000001 << (fno * 2)))));
N                }
N            }
N        }
N    }
N}
N
Nstatic inline void handle_fifo_in_interrupts(uint32_t interrupt_bits)
N{
N    // this handles only one fifo interrupt
N
N    FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
N
N    uint32_t fno;
N    for (fno = 0; fno < FIFO_NUM; fno++)
X    for (fno = 0; fno < 4; fno++)
N        if (interrupt_bits & (G1_F0_IN_INT_RO << fno))
X        if (interrupt_bits & (0x00010000 << fno))
N            break;
N
N    // disable (mask) the FIFO IN interrupt immediately to prevent from interrupt re-trigger
N    UsbRegMaskedSet(REG_DEV_MISG1, MF0_IN_INT << fno);
X    (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~(0x00010000 << fno)) | ((0x00010000 << fno) & (0x00010000 << fno))));
N
N    if (fifo_cb[fno].user_buf_len > 0)
N    {
N        if (dma_start_mem_to_fifo(fno, &fifo_cb[fno]) == false)
X        if (dma_start_mem_to_fifo(fno, &fifo_cb[fno]) == 0)
N        {
N            // re-enable the interrupt for next try
N            UsbRegMaskedClr(REG_DEV_MISG1, MF0_IN_INT << fno);
X            (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~(0x00010000 << fno)) | (0 & (0x00010000 << fno))));
N        }
N    }
N    else
N    {
N        // FIFO is empty and no more data to send, in other words, the bulk-in transfer is done
N
N        // send zero-length packet if needed
N        if (fifo_cb[fno].short_or_zl_packet)
N        {
N            UsbRegMaskedSet(REG_DEV_INMPS_1 + 4 * (fifo_cb[fno].enpNo - 1), TX0BYTE_IEPn);
X            (*(volatile unsigned int *)(0xC0100000 + (0x160 + 4 * (fifo_cb[fno]. enpNo - 1))) = (((*(volatile unsigned int *)(0xC0100000 + (0x160 + 4 * (fifo_cb[fno]. enpNo - 1)))) & ~(0x00008000)) | ((0x00008000) & (0x00008000))));
N            // FIXME: should check G2_TX0BYTE_INT_RW1C in later interrupts
N        }
N
N        // notify transfer done to user
N        if (fifo_cb[fno].isBlockingCall)
N        {
N            fifo_cb[fno].cur_event = KDRV_USBD_EVENT_TRANSFER_DONE;
N            osEventFlagsSet(cb.evt_id, 0x1 << fno);
N        }
N        else
N        {
N            clean_fifo_cb(&fifo_cb[fno]);
N            notify_event_to_user(KDRV_USBD_EVENT_TRANSFER_DONE, fifo_cb[fno].endpointAddress, 0);
N        }
N    }
N}
N
N#define FIFO_SHORT_PKT_INTERRUPTS (G1_F0_SPK_INT_RO | G1_F1_SPK_INT_RO | G1_F2_SPK_INT_RO | G1_F3_SPK_INT_RO)
N#define FIFO_OUT_INTERRUPTS (G1_F0_OUT_INT_RO | G1_F1_OUT_INT_RO | G1_F2_OUT_INT_RO | G1_F3_OUT_INT_RO)
N#define FIFO_IN_INTERRUPTS (G1_F0_IN_INT_RO | G1_F1_IN_INT_RO | G1_F2_IN_INT_RO | G1_F3_IN_INT_RO)
N
Nstatic void handle_fifo_interrupts()
N{
N    uint32_t fifo_interrupts = UsbRegRead(REG_DEV_ISG1) & ~(UsbRegRead(REG_DEV_MISG1));
X    uint32_t fifo_interrupts = (*(volatile unsigned int *)(0xC0100000 + (0x148))) & ~((*(volatile unsigned int *)(0xC0100000 + (0x138))));
N
N    // handle OUT short packets interrupts for short packets
N    if (fifo_interrupts & FIFO_SHORT_PKT_INTERRUPTS)
X    if (fifo_interrupts & (0x00000002 | 0x00000008 | 0x00000020 | 0x00000080))
N        handle_fifo_short_pkt_interrupts(fifo_interrupts);
N
N    // handle OUT FIFO interrupts
N    if (fifo_interrupts & FIFO_OUT_INTERRUPTS)
X    if (fifo_interrupts & (0x00000001 | 0x00000004 | 0x00000010 | 0x00000040))
N        handle_fifo_out_interrupts(fifo_interrupts);
N
N    // handle IN FIFO interrupts
N    if (fifo_interrupts & FIFO_IN_INTERRUPTS)
X    if (fifo_interrupts & (0x00010000 | 0x00020000 | 0x00040000 | 0x00080000))
N        handle_fifo_in_interrupts(fifo_interrupts);
N}
N
N// FIXME: this does not handle CX DMA complete
Nstatic void handle_dma_complete_interrupt()
N{
N    // this handles only one DMA complete interrupt
N    uint32_t fno;
N    uint32_t fifoSel = UsbRegRead(REG_DMA_TFN);
X    uint32_t fifoSel = (*(volatile unsigned int *)(0xC0100000 + (0x1C0)));
N    uint32_t dmaCPS1 = UsbRegRead(REG_DMA_CPS1);
X    uint32_t dmaCPS1 = (*(volatile unsigned int *)(0xC0100000 + (0x1C8)));
N
N    // clear FIFO selection
N    UsbRegWrite(REG_DMA_TFN, DMA_TARGET_ACC_NONE);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C0)) = ((0x0)));
N
N    // clear DMA completion interrupt
N    UsbRegMaskedSet(REG_DEV_ISG2, G2_DMA_CMPLT_RW1C);
X    (*(volatile unsigned int *)(0xC0100000 + (0x14C)) = (((*(volatile unsigned int *)(0xC0100000 + (0x14C))) & ~(0x00000080)) | ((0x00000080) & (0x00000080))));
N
N    for (fno = 0; fno < FIFO_NUM; fno++)
X    for (fno = 0; fno < 4; fno++)
N        if (fifoSel & (0x1 << fno))
N            break;
N
N    // check DMA-FIFO direction
N    if (dmaCPS1 & DMA_TYPE)
X    if (dmaCPS1 & 0x00000002)
N    {
N
N        // Memory-to-FIFO, is IN transfer
N        // re-enable (unmask) the FIFO IN interrupt here
N        // because DMA completion does not mean bulk-in transfer is done
N        UsbRegMaskedClr(REG_DEV_MISG1, MF0_IN_INT << fno);
X        (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~(0x00010000 << fno)) | (0 & (0x00010000 << fno))));
N    }
N    else
N    {
N        // FIFO-to-Memory, is OUT transfer
N
N        FIFO_Ctrl *fifo_cb = &(cb.fifo_cbs[fno]);
N
N        {
N            // re-enable OUT interrupts whatever fifo or short packet
N            UsbRegMaskedClr(REG_DEV_MISG1, (MF0_OUT_INT | MF0_SPK_INT) << (fno * 2));
X            (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~((0x00000001 | 0x00000002) << (fno * 2))) | (0 & ((0x00000001 | 0x00000002) << (fno * 2)))));
N
N            if (fifo_cb->short_or_zl_packet)
N            {
N                // this transfer is a short packet, so transfer is done
N                // notify transfer done to user
N                if (fifo_cb->isBlockingCall)
N                {
N                    fifo_cb->cur_event = KDRV_USBD_EVENT_TRANSFER_DONE;
N                    osEventFlagsSet(cb.evt_id, 0x1 << fno);
N                }
N                else
N                {
N                    clean_fifo_cb(fifo_cb);
N                    notify_event_to_user(KDRV_USBD_EVENT_TRANSFER_DONE, fifo_cb->endpointAddress, fifo_cb->received_length);
N                }
N            }
N        }
N    }
N}
N
Nstatic void handle_zero_length_packet_interrupt()
N{
N    uint32_t zl_endp_interrupts = UsbRegRead(REG_DEV_RXZ);
X    uint32_t zl_endp_interrupts = (*(volatile unsigned int *)(0xC0100000 + (0x150)));
N    uint32_t enpNo;
N    for (enpNo = 1; enpNo <= 8; enpNo++)
N        if (zl_endp_interrupts & (0x1 << (enpNo - 1)))
N            break;
N
N    // clean corresponding endpoint's rx zero-length interrupt
N    UsbRegMaskedSet(REG_DEV_RXZ, RX0BYTE_EP1 << (enpNo - 1));
X    (*(volatile unsigned int *)(0xC0100000 + (0x150)) = (((*(volatile unsigned int *)(0xC0100000 + (0x150))) & ~(0x00000001 << (enpNo - 1))) | ((0x00000001 << (enpNo - 1)) & (0x00000001 << (enpNo - 1)))));
N
N    // clear global rx zero-length interrupt
N    UsbRegMaskedSet(REG_DEV_ISG2, G2_RX0BYTE_INT_RW1C);
X    (*(volatile unsigned int *)(0xC0100000 + (0x14C)) = (((*(volatile unsigned int *)(0xC0100000 + (0x14C))) & ~(0x00000040)) | ((0x00000040) & (0x00000040))));
N
N    int8_t fno = endpoint_to_fifo(enpNo);
N
N    FIFO_Ctrl *fifo_cb = &(cb.fifo_cbs[fno]);
N    if (fifo_cb->isTransferring)
N    {
N
N        // re-enable OUT interrupts whatever fifo or short packet
N        UsbRegMaskedClr(REG_DEV_MISG1, (MF0_OUT_INT | MF0_SPK_INT) << (fno * 2));
X        (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~((0x00000001 | 0x00000002) << (fno * 2))) | (0 & ((0x00000001 | 0x00000002) << (fno * 2)))));
N
N        // received a zero-length packet, notify transfer do to user
N        // notify transfer done to user
N        if (fifo_cb->isBlockingCall)
N        {
N            fifo_cb->cur_event = KDRV_USBD_EVENT_TRANSFER_DONE;
N            osEventFlagsSet(cb.evt_id, 0x1 << fno);
N        }
N        else
N        {
N            clean_fifo_cb(fifo_cb);
N            notify_event_to_user(KDRV_USBD_EVENT_TRANSFER_DONE, fifo_cb->endpointAddress, fifo_cb->received_length);
N        }
N
N        return;
N    }
N}
N
Nstatic void handle_cmd_abort()
N{
N    // according to datasheet, this could happen
N    // when a new SETUP comes before last one is complete
N    // handle it first or the FIFO will be frozen
N
N    // clear the abort status
N    UsbRegMaskedSet(REG_DEV_ISG0, G0_CX_COMABT_INT_RW1C);
X    (*(volatile unsigned int *)(0xC0100000 + (0x144)) = (((*(volatile unsigned int *)(0xC0100000 + (0x144))) & ~(0x00000020)) | ((0x00000020) & (0x00000020))));
N}
N
Nstatic int8_t send_host_string_descriptor(kdrv_usbd_setup_packet_t *setup,uint8_t type)
N{
N    kdrv_usbd_string_descriptor_t* desc=cb.dev_string_desc;
N
N    kdrv_usbd_prd_string_descriptor_t** desc_str=&cb.dev_string_desc->desc[0];
N
N    uint16_t txLen =0;
N    bool sts=false;
X    _Bool sts=0;
N    if(type==0)//language id
N    {
N        txLen = MIN(desc->bLength, setup->wLength);
X        txLen = (((desc->bLength) < (setup->wLength)) ? (desc->bLength) : (setup->wLength));
N        sts = dma_fifo_transfer_sync_try((uint32_t *)desc, txLen, DMA_TARGET_ACC_CXF, WRITE_FIFO, 50);
X        sts = dma_fifo_transfer_sync_try((uint32_t *)desc, txLen, 0x00000010, WRITE_FIFO, 50);
N    }
N    else if(type==1 || type==2 || type==3)//iManufacturer,iProduct,iSerialNumber
N    {
N        txLen = MIN(desc_str[type-1]->bLength, setup->wLength);
X        txLen = (((desc_str[type - 1]->bLength) < (setup->wLength)) ? (desc_str[type - 1]->bLength) : (setup->wLength));
N        sts = dma_fifo_transfer_sync_try((uint32_t *)desc_str[type-1], txLen, DMA_TARGET_ACC_CXF, WRITE_FIFO, 50);
X        sts = dma_fifo_transfer_sync_try((uint32_t *)desc_str[type-1], txLen, 0x00000010, WRITE_FIFO, 50);
N    }
N
N    if (sts)
N    {
N        return RESP_ACK;
N    }
N    else
N    {
N        return RESP_NACK;
N    }
N}
N
Nstatic int8_t send_host_device_descriptor(kdrv_usbd_setup_packet_t *setup)
N{
N    kdrv_usbd_device_descriptor_t *desc = cb.dev_desc;
N
N    // some error checking
N    if (!desc)
N    {
N        return RESP_STALL;
N    }
N
N    uint16_t txLen = MIN(desc->bLength, setup->wLength);
X    uint16_t txLen = (((desc->bLength) < (setup->wLength)) ? (desc->bLength) : (setup->wLength));
N    bool sts = dma_fifo_transfer_sync_try((uint32_t *)desc, txLen, DMA_TARGET_ACC_CXF, WRITE_FIFO, 50);
X    _Bool sts = dma_fifo_transfer_sync_try((uint32_t *)desc, txLen, 0x00000010, WRITE_FIFO, 50);
N    if (sts)
N        return RESP_ACK;
N    else
N        return RESP_NACK;
N}
N
Nstatic int8_t send_host_device_qual_descriptor(kdrv_usbd_setup_packet_t *setup)
N{
N    kdrv_usbd_device_qualifier_descriptor_t *desc = cb.dev_qual_desc;
N
N    // some error checking
N    if (!desc)
N    {
N        return RESP_STALL;
N    }
N
N    uint16_t txLen = MIN(desc->bLength, setup->wLength);
X    uint16_t txLen = (((desc->bLength) < (setup->wLength)) ? (desc->bLength) : (setup->wLength));
N    bool sts = dma_fifo_transfer_sync_try((uint32_t *)desc, txLen, DMA_TARGET_ACC_CXF, WRITE_FIFO, 50);
X    _Bool sts = dma_fifo_transfer_sync_try((uint32_t *)desc, txLen, 0x00000010, WRITE_FIFO, 50);
N    if (sts)
N        return RESP_ACK;
N    else
N        return RESP_NACK;
N}
N
Nstatic int8_t send_host_configuration_descriptors(kdrv_usbd_setup_packet_t *setup)
N{
N    kdrv_usbd_device_descriptor_t *dev_desc = cb.dev_desc;
N    uint32_t confIdx = setup->wValue & 0xFF;
N
N    // some error checking
N    if (!dev_desc ||
N        dev_desc->bNumConfigurations > MAX_USBD_CONFIG ||
X        dev_desc->bNumConfigurations > 1 ||
N        confIdx >= MAX_USBD_CONFIG)
X        confIdx >= 1)
N    {
N        return RESP_STALL;
N    }
N
N    kdrv_usbd_config_descriptor_t *conf_desc = dev_desc->config[confIdx];
N
N    // create an temp buffer for combining all sub-descriptors
N    uint8_t *buf_desc = malloc(conf_desc->wTotalLength);
N
N    uint16_t txLen = MIN(conf_desc->wTotalLength, setup->wLength);
X    uint16_t txLen = (((conf_desc->wTotalLength) < (setup->wLength)) ? (conf_desc->wTotalLength) : (setup->wLength));
N
N    // collect all sub-descriptos int one memory
N    uint8_t offset = 0;
N    memcpy(buf_desc, conf_desc, conf_desc->bLength);
N    offset += conf_desc->bLength;
N
N    for (int i = 0; i < conf_desc->bNumInterfaces; i++)
N    {
N        kdrv_usbd_interface_descriptor_t *intf_desc = conf_desc->interface[i];
N        memcpy(buf_desc + offset, intf_desc, intf_desc->bLength);
N        offset += intf_desc->bLength;
N        for (int j = 0; j < intf_desc->bNumEndpoints; j++)
N        {
N            kdrv_usbd_endpoint_descriptor_t *endp_desc = intf_desc->endpoint[j];
N            memcpy(buf_desc + offset, endp_desc, endp_desc->bLength);
N            offset += endp_desc->bLength;
N        }
N    }
N
N    bool sts = dma_fifo_transfer_sync_try((uint32_t *)buf_desc, txLen, DMA_TARGET_ACC_CXF, WRITE_FIFO, 50);
X    _Bool sts = dma_fifo_transfer_sync_try((uint32_t *)buf_desc, txLen, 0x00000010, WRITE_FIFO, 50);
N
N    free(buf_desc);
N
N    if (sts)
N        return RESP_ACK;
N    else
N        return RESP_NACK;
N}
N
Nstatic void init_fifo_configurations(kdrv_usbd_interface_descriptor_t *intf)
N{
N    uint32_t fifo_map_val = 0x0;         // for 0x1A8
N    uint32_t endp_map0_val = 0x0;        // for 0x1A0
N    uint32_t endp_map1_val = 0x0;        // for 0x1A4
N    uint32_t fifo_config_val = 0x0;      // for 0x1AC
N    uint32_t fifo_int_mask = 0xFFFFFFFF; // for 0x138, default disable all interrupts
N
N    // also need to init fifo-dma control blocks
N    for (int fifo = 0; fifo < FIFO_NUM; fifo++)
X    for (int fifo = 0; fifo < 4; fifo++)
N        cb.fifo_cbs[fifo].enabled = false;
X        cb.fifo_cbs[fifo].enabled = 0;
N
N    // here assume endpoint number order is ascending
N    for (int i = 0; i < intf->bNumEndpoints; i++)
N    {
N        uint8_t bEndpointAddress = intf->endpoint[i]->bEndpointAddress;
N        uint8_t bmAttributes = intf->endpoint[i]->bmAttributes;
N        uint16_t wMaxPacketSize = intf->endpoint[i]->wMaxPacketSize;
N
N        // i value implies FIFO number
N        uint32_t fifo = i;
N        uint8_t isIn = !!(bEndpointAddress & 0x80);
N        uint8_t enpNo = bEndpointAddress & 0xF; // retrieve endpoint no without direction
N        uint32_t bitfield;
N
N        // set FIFO's direction and corresponding endpoint no.
N        bitfield = (isIn << 4) | enpNo;
N        fifo_map_val |= (bitfield << (fifo * 8));
N
N        // set endpoint's FIFO no.
N        bitfield = isIn ? fifo : (fifo << 4);
N        if (enpNo <= 4)
N            endp_map0_val |= (bitfield << ((enpNo - 1) * 8));
N        else // 5~8
N            endp_map1_val |= (bitfield << ((enpNo - 5) * 8));
N
N        // enable the corresponding FIFO and set transfer type
N        fifo_config_val |= (BIT5 | (bmAttributes & 0x3)) << (fifo * 8);
X        fifo_config_val |= (0x00000020 | (bmAttributes & 0x3)) << (fifo * 8);
N
N        // set max packet size & reset toggle bit
N        if (isIn)
N        {
N            // for IN endpoints
N            UsbRegWrite(REG_DEV_INMPS_1 + 4 * (enpNo - 1), wMaxPacketSize & 0x7ff);
X            (*(volatile unsigned int *)(0xC0100000 + (0x160 + 4 * (enpNo - 1))) = ((wMaxPacketSize & 0x7ff)));
N            UsbRegMaskedSet(REG_DEV_INMPS_1 + 4 * (enpNo - 1), RSTG_IEPn);
X            (*(volatile unsigned int *)(0xC0100000 + (0x160 + 4 * (enpNo - 1))) = (((*(volatile unsigned int *)(0xC0100000 + (0x160 + 4 * (enpNo - 1)))) & ~(0x00001000)) | ((0x00001000) & (0x00001000))));
N            UsbRegMaskedClr(REG_DEV_INMPS_1 + 4 * (enpNo - 1), RSTG_IEPn);
X            (*(volatile unsigned int *)(0xC0100000 + (0x160 + 4 * (enpNo - 1))) = (((*(volatile unsigned int *)(0xC0100000 + (0x160 + 4 * (enpNo - 1)))) & ~(0x00001000)) | (0 & (0x00001000))));
N
N            // disable interrupt for IN endpoint
N            // because when IN fifo is empty, interrupt will be asserted
N            // we could enable IN interrupt only when need to watch it
N            fifo_int_mask |= (MF0_IN_INT << fifo);
X            fifo_int_mask |= (0x00010000 << fifo);
N        }
N        else
N        {
N            // for OUT endpoints
N            UsbRegWrite(REG_DEV_OUTMPS_1 + 4 * (enpNo - 1), wMaxPacketSize & 0x7ff);
X            (*(volatile unsigned int *)(0xC0100000 + (0x180 + 4 * (enpNo - 1))) = ((wMaxPacketSize & 0x7ff)));
N            UsbRegMaskedSet(REG_DEV_OUTMPS_1 + 4 * (enpNo - 1), RSTG_OEPn);
X            (*(volatile unsigned int *)(0xC0100000 + (0x180 + 4 * (enpNo - 1))) = (((*(volatile unsigned int *)(0xC0100000 + (0x180 + 4 * (enpNo - 1)))) & ~(0x00001000)) | ((0x00001000) & (0x00001000))));
N            UsbRegMaskedClr(REG_DEV_OUTMPS_1 + 4 * (enpNo - 1), RSTG_OEPn);
X            (*(volatile unsigned int *)(0xC0100000 + (0x180 + 4 * (enpNo - 1))) = (((*(volatile unsigned int *)(0xC0100000 + (0x180 + 4 * (enpNo - 1)))) & ~(0x00001000)) | (0 & (0x00001000))));
N
N            // enable interrupt for OUT endpoint
N            fifo_int_mask &= ~((MF0_SPK_INT | MF0_OUT_INT) << (fifo * 2));
X            fifo_int_mask &= ~((0x00000002 | 0x00000001) << (fifo * 2));
N        }
N
N        // init fifo dma control blocks for each enabled fifo
N        cb.fifo_cbs[fifo].enabled = true;
X        cb.fifo_cbs[fifo].enabled = 1;
N        cb.fifo_cbs[fifo].enpNo = enpNo;
N        cb.fifo_cbs[fifo].endpointAddress = bEndpointAddress;
N        cb.fifo_cbs[fifo].maxPacketSize = wMaxPacketSize;
N        cb.fifo_cbs[fifo].transferType = bmAttributes & 0x3;
N        cb.fifo_cbs[fifo].byteCntReg = 0x1B0 + 4 * fifo;
N        cb.fifo_cbs[fifo].isTransferring = false;
X        cb.fifo_cbs[fifo].isTransferring = 0;
N        cb.fifo_cbs[fifo].user_buf_addr = 0;
N        cb.fifo_cbs[fifo].user_buf_len = 0;
N        cb.fifo_cbs[fifo].short_or_zl_packet = false;
X        cb.fifo_cbs[fifo].short_or_zl_packet = 0;
N    }
N
N    // clear all FIFO
N    UsbRegMaskedSet(REG_DEV_TST, TST_CLRFF);
X    (*(volatile unsigned int *)(0xC0100000 + (0x108)) = (((*(volatile unsigned int *)(0xC0100000 + (0x108))) & ~(0x00000001)) | ((0x00000001) & (0x00000001))));
N
N    // set FIFO interrupt mask
N    UsbRegWrite(REG_DEV_MISG1, fifo_int_mask);
X    (*(volatile unsigned int *)(0xC0100000 + (0x138)) = ((fifo_int_mask)));
N
N    // endpoint map 0
N    UsbRegWrite(REG_DEV_EPMAP0, endp_map0_val);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1A0)) = ((endp_map0_val)));
N
N    // endpoint map1
N    UsbRegWrite(REG_DEV_EPMAP1, endp_map1_val);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1A4)) = ((endp_map1_val)));
N
N    // fifo map
N    UsbRegWrite(REG_DEV_FMAP, fifo_map_val);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1A8)) = ((fifo_map_val)));
N
N    // fifo config / enable
N    UsbRegWrite(REG_DEV_FCFG, fifo_config_val);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1AC)) = ((fifo_config_val)));
N
N    // set Device SOF Mask Timer value as data sheet recommended for HS
N    UsbRegWrite(REG_DEV_SMT, 0x44C);
X    (*(volatile unsigned int *)(0xC0100000 + (0x110)) = ((0x44C)));
N
N    // set configuration set bit, now allow HW to handle endpoint transfer
N    UsbRegMaskedSet(REG_DEV_ADR, AFT_CONF);
X    (*(volatile unsigned int *)(0xC0100000 + (0x104)) = (((*(volatile unsigned int *)(0xC0100000 + (0x104))) & ~(0x00000080)) | ((0x00000080) & (0x00000080))));
N}
N
Nstatic int8_t set_configuration(kdrv_usbd_setup_packet_t *setup)
N{
N    int8_t resp = RESP_STALL;
N
N    uint8_t config_val = setup->wValue & 0xFF;
N    if (config_val == 0)
N    {
N        cb.config_state = CONFIG_ADDRESS_STATE;
N        // clear configuration set bit
N        UsbRegMaskedClr(REG_DEV_ADR, AFT_CONF);
X        (*(volatile unsigned int *)(0xC0100000 + (0x104)) = (((*(volatile unsigned int *)(0xC0100000 + (0x104))) & ~(0x00000080)) | (0 & (0x00000080))));
N        resp = RESP_ACK;
N
N        // FIXME clear FIFO-endpoint mapping ?
N    }
N    else
N    {
N        kdrv_usbd_config_descriptor_t *config;
N
N        // compare with all configuration descriptos
N        for (int i = 0; i < cb.dev_desc->bNumConfigurations; i++)
N        {
N            config = cb.dev_desc->config[i];
N            if (config->bConfigurationValue == config_val)
N            {
N                cb.config_state = CONFIG_CONFIGURED_STATE;
N                resp = RESP_ACK;
N                break;
N            }
N        }
N
N        // FIXME? for only-one interface, should set up FIFO-endpont mapping now
N        if (resp == RESP_ACK && config->bNumInterfaces == 1)
N            init_fifo_configurations(config->interface[0]);
N
N        if (resp == RESP_ACK)
N            notify_event_to_user(KDRV_USBD_EVENT_DEV_CONFIGURED, config_val, 0);
N    }
N
N    return resp;
N}
N
Nstatic int8_t handle_standard_request(kdrv_usbd_setup_packet_t *setup)
N{
N    int8_t resp = RESP_STALL;
N
N    // handle requests which are not affected by ep0 halt
N    switch (setup->bRequest)
N    {
N    case 0x0: // GET_STATUS
N        break;
N    case 0x1: // CLEAR_FEATURE
N    {
N        if (setup->wValue == 0x0)
N        {
N            // endpoint halt
N            kdrv_usbd_reset_endpoint(setup->wIndex);
N            resp = RESP_ACK;
N        }
N        break;
N    }
N    case 0x3: // SET_FEATURE
N        break;
N    }
N
N    // if ep0 is halted, some requests should not be done
N    if (cb.ep0_halted)
N        return RESP_STALL;
N
N    switch (setup->bRequest)
N    {
N    case 0x5: // SET_ADDRESS
N    {
N        // USB2.0 spec says should not be greaten than 127
N        if (setup->wValue <= 127)
N        {
N            // set DEVADR and also clear AFT_CONF
N            UsbRegWrite(REG_DEV_ADR, setup->wValue);
X            (*(volatile unsigned int *)(0xC0100000 + (0x104)) = ((setup->wValue)));
N            resp = RESP_ACK;
N        }
N    }
N    break;
N    case 0x6: // GET_DESCRIPTOR
N    {
N        // low byte: index of specified descriptor type
N        uint8_t descp_idx = (setup->wValue & 0xFF);
N
N        // high byte: descriptor type
N        switch (setup->wValue >> 8)
N        {
N        case 1: // DEVICE descriptor
N            resp = send_host_device_descriptor(setup);
N            break;
N        case 2: // CONFIGURATION descriptor
N            resp = send_host_configuration_descriptors(setup);
N            break;
N        case 3: // STRING descriptor
N            resp = send_host_string_descriptor(setup,descp_idx);
N            break;
N        case 4: // INTERFACE descriptor
N            break;
N        case 5: // ENDPOINT descriptor
N            break;
N        case 6: // DEVICE_QUALIFIER descriptor
N            resp = send_host_device_qual_descriptor(setup);
N            break;
N        case 7: // OTHER_SPEED_CONFIGURATION descriptor
N            break;
N        case 8: // INTERFACE_POWER descriptor
N            break;
N        }
N    }
N    break;
N    case 0x7: // SET_DESCRIPTOR
N        break;
N    case 0x8: // GET_CONFIGURATION
N        break;
N    case 0x9: // SET_CONFIGURATION
N        resp = set_configuration(setup);
N        break;
N    }
N
N    return resp;
N}
N
Nstatic void handle_control_transfer()
N{
N    // ready to read out 8 bytes setup packet
N    kdrv_usbd_setup_packet_t setup = {0};
N    uint8_t *temp = (uint8_t *)&setup;
N
N    // if DMA is busy now, do nothing and will handle in later interrupts
N    if (dma_is_busy())
N    {
N        return;
N    }
N
N    // set DMA FIFO selection to CXF
N    UsbRegWrite(REG_DMA_TFN, DMA_TARGET_ACC_CXF);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C0)) = ((0x00000010)));
N
N    // directly read DMA_CPS3 twice to get 8-byte setup packet
N    *((uint32_t *)temp) = UsbRegRead(REG_DMA_CPS3);
X    *((uint32_t *)temp) = (*(volatile unsigned int *)(0xC0100000 + (0x1D0)));
N    *((uint32_t *)(temp + 4)) = UsbRegRead(REG_DMA_CPS3);
X    *((uint32_t *)(temp + 4)) = (*(volatile unsigned int *)(0xC0100000 + (0x1D0)));
N
N    // clear DMA FIFO selection
N    UsbRegWrite(REG_DMA_TFN, DMA_TARGET_ACC_NONE);
X    (*(volatile unsigned int *)(0xC0100000 + (0x1C0)) = ((0x0)));
N
N    // parsing bmRequestType to find out which kind of reqeusts
N    int8_t resp = RESP_NACK;
N    uint8_t bmRequestType_type = ((setup.bmRequestType & 0x60) >> 5);
N    switch (bmRequestType_type)
N    {
N    case 0: // Standard request
N        resp = handle_standard_request(&setup);
N        break;
N    case 1: // Class request
N    case 2: // Vendor request
N        notify_event_to_user(KDRV_USBD_EVENT_SETUP_PACKET,
N                             *((uint32_t *)temp), *((uint32_t *)(temp + 4)));
N        break;
N    }
N
N    if (resp == RESP_ACK)
N        // indicate an OK request to host
N        UsbRegMaskedSet(REG_CXCFE, CX_DONE);
X        (*(volatile unsigned int *)(0xC0100000 + (0x120)) = (((*(volatile unsigned int *)(0xC0100000 + (0x120))) & ~(0x00000001)) | ((0x00000001) & (0x00000001))));
N    else if (resp == RESP_STALL)
N    {
N        // indicate a request error to host
N        UsbRegMaskedSet(REG_CXCFE, CX_STL | CX_DONE);
X        (*(volatile unsigned int *)(0xC0100000 + (0x120)) = (((*(volatile unsigned int *)(0xC0100000 + (0x120))) & ~(0x00000004 | 0x00000001)) | ((0x00000004 | 0x00000001) & (0x00000004 | 0x00000001))));
N    }
N    else
N    {
N        // NACK, do nothing for now
N    }
N}
N
Nstatic void handle_device_interrupts()
N{
N    uint32_t grp_x_int_status = UsbRegRead(REG_DEV_IGR);
X    uint32_t grp_x_int_status = (*(volatile unsigned int *)(0xC0100000 + (0x140)));
N    uint32_t grp_0_interrupts = (UsbRegRead(REG_DEV_ISG0) & ~(UsbRegRead(REG_DEV_MISG0)));
X    uint32_t grp_0_interrupts = ((*(volatile unsigned int *)(0xC0100000 + (0x144))) & ~((*(volatile unsigned int *)(0xC0100000 + (0x134)))));
N    uint32_t grp_2_interrupts = (UsbRegRead(REG_DEV_ISG2) & ~(UsbRegRead(REG_DEV_MISG2)));
X    uint32_t grp_2_interrupts = ((*(volatile unsigned int *)(0xC0100000 + (0x14C))) & ~((*(volatile unsigned int *)(0xC0100000 + (0x13C)))));
N
N    if (grp_x_int_status & GX_INT_G1_RO)
X    if (grp_x_int_status & 0x00000002)
N        handle_fifo_interrupts();
N
N    if (grp_x_int_status & GX_INT_G2_RO)
X    if (grp_x_int_status & 0x00000004)
N    {
N        if (grp_2_interrupts & G2_DMA_CMPLT_RW1C)
X        if (grp_2_interrupts & 0x00000080)
N            handle_dma_complete_interrupt();
N        else if (grp_2_interrupts & G2_RX0BYTE_INT_RW1C)
X        else if (grp_2_interrupts & 0x00000040)
N            handle_zero_length_packet_interrupt();
N        else if (grp_2_interrupts & G2_DMA_ERROR_RW1C)
X        else if (grp_2_interrupts & 0x00000100)
N            handle_dma_error();
N        else if (grp_2_interrupts & G2_SUSP_INT_RW1C)
X        else if (grp_2_interrupts & 0x00000002)
N            bus_suspend_work();
N        else if (grp_2_interrupts & G2_RESM_INT_RW1C)
X        else if (grp_2_interrupts & 0x00000004)
N            bus_resume_work();
N        else if (grp_2_interrupts & G2_USBRST_INT_RW1C)
X        else if (grp_2_interrupts & 0x00000001)
N            bus_reset_work();
N    }
N
N    if (grp_x_int_status & GX_INT_G0_RO)
X    if (grp_x_int_status & 0x00000001)
N    {
N        if (grp_0_interrupts & G0_CX_COMABT_INT_RW1C)
X        if (grp_0_interrupts & 0x00000020)
N            // first priority
N            handle_cmd_abort();
N        else if (grp_0_interrupts & G0_CX_SETUP_INT_RO)
X        else if (grp_0_interrupts & 0x00000001)
N            handle_control_transfer();
N    }
N}
N
N// USB ISR
Nstatic void usbd_isr(void)
N{
N    handle_device_interrupts();
N}
N
Nstatic void init_reg_isr(void)
N{
N    SCU_EXTREG_USB_OTG_CTRL_SET_EXTCTRL_SUSPENDM(1);
X    (*(volatile unsigned int *)((0xC2380000 + 0x008C)) = (((*(volatile unsigned int *)((0xC2380000 + 0x008C))) & ~0x00000100) | ((1 << 8) & 0x00000100)));
N    SCU_EXTREG_USB_OTG_CTRL_SET_u_iddig(1);
X    (*(volatile unsigned int *)((0xC2380000 + 0x008C)) = (((*(volatile unsigned int *)((0xC2380000 + 0x008C))) & ~0x00000080) | ((1 << 7) & 0x00000080)));
N    SCU_EXTREG_USB_OTG_CTRL_SET_wakeup(0);
X    (*(volatile unsigned int *)((0xC2380000 + 0x008C)) = (((*(volatile unsigned int *)((0xC2380000 + 0x008C))) & ~0x00000040) | ((0 << 6) & 0x00000040)));
N    SCU_EXTREG_USB_OTG_CTRL_SET_l1_wakeup(0);
X    (*(volatile unsigned int *)((0xC2380000 + 0x008C)) = (((*(volatile unsigned int *)((0xC2380000 + 0x008C))) & ~0x00000020) | ((0 << 5) & 0x00000020)));
N    SCU_EXTREG_USB_OTG_CTRL_SET_OSCOUTEN(0);
X    (*(volatile unsigned int *)((0xC2380000 + 0x008C)) = (((*(volatile unsigned int *)((0xC2380000 + 0x008C))) & ~0x00000010) | ((0 << 4) & 0x00000010)));
N    SCU_EXTREG_USB_OTG_CTRL_SET_PLLALIV(0);
X    (*(volatile unsigned int *)((0xC2380000 + 0x008C)) = (((*(volatile unsigned int *)((0xC2380000 + 0x008C))) & ~0x00000008) | ((0 << 3) & 0x00000008)));
N    SCU_EXTREG_USB_OTG_CTRL_SET_XTLSEL(0);
X    (*(volatile unsigned int *)((0xC2380000 + 0x008C)) = ((((*(volatile unsigned int *)((0xC2380000 + 0x008C))) & ~(0x00000004 | (0x00000004 - 0x00000002))) | (0 << 1))));;
N    SCU_EXTREG_USB_OTG_CTRL_SET_OUTCLKSEL(0);
X    (*(volatile unsigned int *)((0xC2380000 + 0x008C)) = (((*(volatile unsigned int *)((0xC2380000 + 0x008C))) & ~0x00000001) | ((0 << 0) & 0x00000001)));
N
N    // disable all OTG interrupts
N    UsbRegWrite(REG_OTG_IER, ~(0x0));
X    (*(volatile unsigned int *)(0xC0100000 + (0x88)) = ((~(0x0))));
N
N    // enable only Device interrupt (no Host or OTG)
N    UsbRegWrite(REG_GLB_INT, ~(INT_POLARITY | DEV_INT) & 0xF);
X    (*(volatile unsigned int *)(0xC0100000 + (0xC4)) = ((~(0x00000008 | 0x00000001) & 0xF)));
N
N    // listen all 4 groups for 0x140
N    UsbRegWrite(REG_DEV_MIGR, 0x0);
X    (*(volatile unsigned int *)(0xC0100000 + (0x130)) = ((0x0)));
N
N    // grop 0 interrupt mask
N    // FIXME: should care about mroe interrupts
N    UsbRegWrite(REG_DEV_MISG0,
N                ~(G0_CX_SETUP_INT_RO |
N                  G0_CX_COMFAIL_INT_RO |
N                  G0_CX_COMABT_INT_RW1C));
X    (*(volatile unsigned int *)(0xC0100000 + (0x134)) = ((~(0x00000001 | 0x00000010 | 0x00000020))));
N
N    // listen no group 1 interrrupts for 0x148
N    UsbRegWrite(REG_DEV_MISG1, 0xFFFFFFFF);
X    (*(volatile unsigned int *)(0xC0100000 + (0x138)) = ((0xFFFFFFFF)));
N
N    // enable interested interrupts in group 2 0x14C
N    UsbRegWrite(REG_DEV_MISG2,
N                ~(G2_RX0BYTE_INT_RW1C |
N                  G2_DMA_ERROR_RW1C |
N                  G2_SUSP_INT_RW1C |
N                  G2_RESM_INT_RW1C |
N                  G2_USBRST_INT_RW1C));
X    (*(volatile unsigned int *)(0xC0100000 + (0x13C)) = ((~(0x00000040 | 0x00000100 | 0x00000002 | 0x00000004 | 0x00000001))));
N
N    // set device idle counter = 7ms
N    UsbRegWrite(REG_DEV_ICR, 0x7);
X    (*(volatile unsigned int *)(0xC0100000 + (0x124)) = ((0x7)));
N    // device soft reset
N    UsbRegMaskedSet(REG_DEV_CTL, BIT4);
X    (*(volatile unsigned int *)(0xC0100000 + (0x100)) = (((*(volatile unsigned int *)(0xC0100000 + (0x100))) & ~(0x00000010)) | ((0x00000010) & (0x00000010))));
N    // clear all FIFO counter
N    UsbRegMaskedSet(REG_DEV_TST, BIT0);
X    (*(volatile unsigned int *)(0xC0100000 + (0x108)) = (((*(volatile unsigned int *)(0xC0100000 + (0x108))) & ~(0x00000001)) | ((0x00000001) & (0x00000001))));
N    // enable chip
N    UsbRegMaskedSet(REG_DEV_CTL, BIT5);
X    (*(volatile unsigned int *)(0xC0100000 + (0x100)) = (((*(volatile unsigned int *)(0xC0100000 + (0x100))) & ~(0x00000020)) | ((0x00000020) & (0x00000020))));
N
N    // clear all interrupts status for RW1C bits
N    UsbRegWrite(REG_OTG_ISR, 0xFFFFFFFF);
X    (*(volatile unsigned int *)(0xC0100000 + (0x84)) = ((0xFFFFFFFF)));
N    UsbRegWrite(REG_DEV_ISG0, 0xFFFFFFFF);
X    (*(volatile unsigned int *)(0xC0100000 + (0x144)) = ((0xFFFFFFFF)));
N    UsbRegWrite(REG_DEV_ISG2, 0xFFFFFFFF);
X    (*(volatile unsigned int *)(0xC0100000 + (0x14C)) = ((0xFFFFFFFF)));
N
N    // global interrupt enable
N    UsbRegMaskedSet(REG_DEV_CTL, BIT2);
X    (*(volatile unsigned int *)(0xC0100000 + (0x100)) = (((*(volatile unsigned int *)(0xC0100000 + (0x100))) & ~(0x00000004)) | ((0x00000004) & (0x00000004))));
N
N    NVIC_SetVector(OTG_SBS_3_IRQ, (uint32_t)usbd_isr);
X    __NVIC_SetVector(OTG_SBS_3_IRQ, (uint32_t)usbd_isr);
N
N    // Clear and Enable SAI IRQ
N    NVIC_ClearPendingIRQ(OTG_SBS_3_IRQ);
X    __NVIC_ClearPendingIRQ(OTG_SBS_3_IRQ);
N    NVIC_EnableIRQ(OTG_SBS_3_IRQ);
X    __NVIC_EnableIRQ(OTG_SBS_3_IRQ);
N}
N
Nstatic kdrv_status_t bulk_in_send(uint32_t endpoint, uint32_t *buf, uint32_t txLen, int8_t isBlockingCall)
N{
N    FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
N
N    // find out which FIFO no for the IN endpoint address
N    int8_t fno = endpoint_to_fifo(endpoint);
N
N    // below do some error checking
N    {
N        if (fno == -1)
N            return KDRV_STATUS_USBD_INVALID_ENDPOINT;
N
N        if (fifo_cb[fno].transferType != TXFER_BULK)
N            return KDRV_STATUS_USBD_INVALID_TRANSFER;
N
N        if (fifo_cb[fno].isTransferring)
N            return KDRV_STATUS_USBD_TRANSFER_IN_PROGRESS;
N    }
N
N    // set up fifo cb
N    fifo_cb[fno].isTransferring = true;
X    fifo_cb[fno].isTransferring = 1;
N    fifo_cb[fno].user_buf_addr = dma_remap_addr((uint32_t)buf);
N    fifo_cb[fno].user_buf_len = txLen;
N    // check if need to send a zero-length packet at the end of transfer
N    fifo_cb[fno].short_or_zl_packet = ((txLen & (fifo_cb[fno].maxPacketSize - 1)) == 0) ? true : false;
X    fifo_cb[fno].short_or_zl_packet = ((txLen & (fifo_cb[fno].maxPacketSize - 1)) == 0) ? 1 : 0;
N    fifo_cb[fno].isBlockingCall = isBlockingCall;
N
N	// there is a risk of race condition with IRQ when different endponts are working
N    NVIC_DisableIRQ(OTG_SBS_3_IRQ);
X    __NVIC_DisableIRQ(OTG_SBS_3_IRQ);
N	{
N
N	    // reset FIFO content before transmission
N	    UsbRegMaskedSet(fifo_cb[fno].byteCntReg, FFRST);
X	    (*(volatile unsigned int *)(0xC0100000 + (fifo_cb[fno]. byteCntReg)) = (((*(volatile unsigned int *)(0xC0100000 + (fifo_cb[fno]. byteCntReg))) & ~(0x00001000)) | ((0x00001000) & (0x00001000))));
N
N	    // enable (unmask) the FIFO IN interrupt
N	    UsbRegMaskedClr(REG_DEV_MISG1, MF0_IN_INT << fno);
X	    (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~(0x00010000 << fno)) | (0 & (0x00010000 << fno))));
N
N    }
N	NVIC_EnableIRQ(OTG_SBS_3_IRQ);
X	__NVIC_EnableIRQ(OTG_SBS_3_IRQ);
N
N    // now leave and let interrupt handler do the transfer work
N
N    return KDRV_STATUS_OK;
N}
N
Nstatic kdrv_status_t bulk_out_receive(uint32_t endpoint, uint32_t *buf, uint32_t blen, int8_t isBlockingCall)
N{
N    FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
N
N    // find out which FIFO no for the IN endpoint address
N    int8_t fno = endpoint_to_fifo(endpoint);
N
N    // below do some error checking
N    {
N        if (fno == -1)
N            return KDRV_STATUS_USBD_INVALID_ENDPOINT;
N
N        if (fifo_cb[fno].transferType != TXFER_BULK)
N            return KDRV_STATUS_USBD_INVALID_TRANSFER;
N
N        if (fifo_cb[fno].isTransferring)
N            return KDRV_STATUS_USBD_TRANSFER_IN_PROGRESS;
N    }
N
N    // set up fifo cb
N    fifo_cb[fno].isTransferring = true;
X    fifo_cb[fno].isTransferring = 1;
N    fifo_cb[fno].user_buf_addr = dma_remap_addr((uint32_t)buf);
N    fifo_cb[fno].user_buf_len = blen;
N    fifo_cb[fno].received_length = 0;
N    fifo_cb[fno].isBlockingCall = isBlockingCall;
N
N    // there is a risk of race condition with IRQ when different endponts are working
N    NVIC_DisableIRQ(OTG_SBS_3_IRQ);
X    __NVIC_DisableIRQ(OTG_SBS_3_IRQ);
N    {
N	    // the OUT interrupts should have been disabled earlier, re-enable it since buffer is commited
N	    UsbRegMaskedClr(REG_DEV_MISG1, MF0_OUT_INT << (fno * 2));
X	    (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~(0x00000001 << (fno * 2))) | (0 & (0x00000001 << (fno * 2)))));
N    }
N    NVIC_EnableIRQ(OTG_SBS_3_IRQ);
X    __NVIC_EnableIRQ(OTG_SBS_3_IRQ);
N
N    return KDRV_STATUS_OK;
N}
N
N////////////////// below are API ////////////////////
N
Nkdrv_status_t kdrv_usbd_initialize(void)
N{
N    cb.notifyTid = 0;
N    cb.notifyFlag = 0x0;
N    cb.ep0_halted = false;
X    cb.ep0_halted = 0;
N    cb.dev_desc = NULL;
X    cb.dev_desc = 0;
N
N    reset_event_queue();
N
N    cb.evt_id = osEventFlagsNew(NULL);
X    cb.evt_id = osEventFlagsNew(0);
N
N    init_reg_isr();
N
N    return KDRV_STATUS_OK;
N}
N
Nkdrv_status_t kdrv_usbd_uninitialize(void)
N{
N    clean_event_queue();
N
N    osEventFlagsDelete(cb.evt_id);
N
N    return KDRV_STATUS_OK;
N}
N
Nkdrv_status_t kdrv_usbd_reset_device()
N{
N    // if it is not configured, no need to reset
N    if (!kdrv_usbd_is_dev_configured())
N        return KDRV_STATUS_ERROR;
N
N    // disable bus
N    kdrv_usbd_set_enable(false);
X    kdrv_usbd_set_enable(0);
N
N    // first reset all endpoints and terminate all in-progress transfer
N    FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
N    for (int fno = 0; fno < FIFO_NUM; fno++)
X    for (int fno = 0; fno < 4; fno++)
N        if (fifo_cb[fno].enabled)
N        {
N            kdrv_usbd_reset_endpoint(fifo_cb[fno].endpointAddress);
N        }
N
N    // some delay for USB bus, FIXME ?
N    osDelay(100);
N
N    cb.ep0_halted = false;
X    cb.ep0_halted = 0;
N    cb.config_state = CONFIG_DEFAULT_STATE;
N
N    // re-init registers and isr
N    init_reg_isr();
N
N    reset_event_queue();
N
N    // re-enable bus
N    kdrv_usbd_set_enable(true);
X    kdrv_usbd_set_enable(1);
N
N    return KDRV_STATUS_OK;
N}
Nkdrv_status_t kdrv_usbd_set_string_descriptor(kdrv_usbd_string_descriptor_t *dev_str_desc)
N{
N    cb.dev_string_desc = dev_str_desc;
N    return KDRV_STATUS_OK;
N}
N
Nkdrv_status_t kdrv_usbd_set_device_descriptor(
N    kdrv_usbd_speed_t speed,
N    kdrv_usbd_device_descriptor_t *dev_desc)
N{
N    // for now support high speed only, FIXME
N    if (speed != KDRV_USBD_HIGH_SPEED)
N        return KDRV_STATUS_ERROR;
N
N    if (dev_desc->bNumConfigurations > 1)
N        return KDRV_STATUS_ERROR;
N
N    cb.dev_desc = dev_desc;
N
N    return KDRV_STATUS_OK;
N}
N
Nkdrv_status_t kdrv_usbd_set_device_qualifier_descriptor(
N    kdrv_usbd_speed_t speed,
N    kdrv_usbd_device_qualifier_descriptor_t *dev_qual_desc)
N{
N    cb.dev_qual_desc = dev_qual_desc;
N    return KDRV_STATUS_OK;
N}
N
Nkdrv_status_t kdrv_usbd_set_enable(bool enable)
Xkdrv_status_t kdrv_usbd_set_enable(_Bool enable)
N{
N    if (enable)
N        // Make PHY work properly, FIXME ?
N        UsbRegMaskedClr(REG_PHY_TST, TST_JSTA);
X        (*(volatile unsigned int *)(0xC0100000 + (0x114)) = (((*(volatile unsigned int *)(0xC0100000 + (0x114))) & ~(0x00000001)) | (0 & (0x00000001))));
N    else
N        // Make PHY not work, FIXME ?
N        UsbRegMaskedSet(REG_PHY_TST, TST_JSTA);
X        (*(volatile unsigned int *)(0xC0100000 + (0x114)) = (((*(volatile unsigned int *)(0xC0100000 + (0x114))) & ~(0x00000001)) | ((0x00000001) & (0x00000001))));
N
N    return KDRV_STATUS_OK;
N}
N
Nbool kdrv_usbd_is_dev_configured(void)
X_Bool kdrv_usbd_is_dev_configured(void)
N{
N    if (cb.config_state == CONFIG_CONFIGURED_STATE)
N        return true;
X        return 1;
N    else
N        return false;
X        return 0;
N}
N
Nkdrv_status_t kdrv_usbd_get_event(kdrv_usbd_event_t *uevent)
N{
N    int ret = pop_event_from_queue(uevent);
N
N    if (ret)
N        return KDRV_STATUS_OK;
N    else
N        return KDRV_STATUS_ERROR;
N}
N
Nkdrv_status_t kdrv_usbd_register_thread_notification(osThreadId_t tid, uint32_t tflag)
N{
N    cb.notifyTid = tid;
N    cb.notifyFlag = tflag;
N    return KDRV_STATUS_OK;
N}
N
Nkdrv_status_t kdrv_usbd_control_send(uint8_t *buf, uint32_t size, uint32_t timeout_ms)
N{
N    uint32_t left_send = size;
N    const uint32_t cx_fifo_size = 64;
N    uint32_t tryMs = 0;
N    bool first_written = true;
X    _Bool first_written = 1;
N
N    // to make sure cx fifo is empty
N    UsbRegMaskedSet(REG_CXCFE, CX_CLR);
X    (*(volatile unsigned int *)(0xC0100000 + (0x120)) = (((*(volatile unsigned int *)(0xC0100000 + (0x120))) & ~(0x00000008)) | ((0x00000008) & (0x00000008))));
N
N    while (left_send > 0)
N    {
N        bool doTxfer = false;
X        _Bool doTxfer = 0;
N
N        if (first_written || (UsbRegRead(REG_DEV_ISG0) & G0_CX_IN_INT_RO))
X        if (first_written || ((*(volatile unsigned int *)(0xC0100000 + (0x144))) & 0x00000002))
N        {
N            uint32_t transfer_size = MIN(cx_fifo_size, left_send);
X            uint32_t transfer_size = (((cx_fifo_size) < (left_send)) ? (cx_fifo_size) : (left_send));
N            // note: there is no G0_CX_IN_INT_RO for first 64-byte write
N            // so we need to write it first
N            if (dma_fifo_transfer_sync_try((uint32_t *)buf, transfer_size, DMA_TARGET_ACC_CXF, WRITE_FIFO, 500))
X            if (dma_fifo_transfer_sync_try((uint32_t *)buf, transfer_size, 0x00000010, WRITE_FIFO, 500))
N            {
N                doTxfer = true;
X                doTxfer = 1;
N                tryMs = 0;
N                left_send -= transfer_size;
N                buf += transfer_size;
N                first_written = false;
X                first_written = 0;
N            }
N        }
N
N        if (!doTxfer)
N        {
N            osDelay(1);
N            ++tryMs;
N            if (tryMs >= timeout_ms)
N                return KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
N        }
N    }
N
N    return KDRV_STATUS_OK;
N}
N
Nkdrv_status_t kdrv_usbd_control_receive(uint8_t *buf, uint32_t *size, uint32_t timeout_ms)
N{
N    uint32_t wanted_size = *size;
N    uint32_t tryMs = 0;
N    *size = 0;
N
N    while (wanted_size > 0)
N    {
N        bool doTxfer = false;
X        _Bool doTxfer = 0;
N
N        if (UsbRegRead(REG_DEV_ISG0) & G0_CX_OUT_INT_RO)
X        if ((*(volatile unsigned int *)(0xC0100000 + (0x144))) & 0x00000004)
N        {
N            uint32_t fifo_bytes = (UsbRegRead(REG_CXCFE) >> 24) & 0x7F;
X            uint32_t fifo_bytes = ((*(volatile unsigned int *)(0xC0100000 + (0x120))) >> 24) & 0x7F;
N            uint32_t transfer_size = MIN(fifo_bytes, wanted_size);
X            uint32_t transfer_size = (((fifo_bytes) < (wanted_size)) ? (fifo_bytes) : (wanted_size));
N
N            if (dma_fifo_transfer_sync_try((uint32_t *)buf, transfer_size, DMA_TARGET_ACC_CXF, READ_FIFO, 500))
X            if (dma_fifo_transfer_sync_try((uint32_t *)buf, transfer_size, 0x00000010, READ_FIFO, 500))
N            {
N                doTxfer = true;
X                doTxfer = 1;
N                tryMs = 0;
N                wanted_size -= transfer_size;
N                buf += transfer_size;
N                *size += transfer_size;
N            }
N        }
N
N        if (!doTxfer)
N        {
N            osDelay(1);
N            ++tryMs;
N            if (tryMs >= timeout_ms)
N                return KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
N        }
N    }
N
N    return KDRV_STATUS_OK;
N}
N
Nkdrv_status_t kdrv_usbd_control_respond(kdrv_usbd_status_respond_t status)
N{
N    if (status == KDRV_USBD_RESPOND_OK)
N        // respond ACK
N        UsbRegMaskedSet(REG_CXCFE, CX_DONE);
X        (*(volatile unsigned int *)(0xC0100000 + (0x120)) = (((*(volatile unsigned int *)(0xC0100000 + (0x120))) & ~(0x00000001)) | ((0x00000001) & (0x00000001))));
N    else if (status == KDRV_USBD_RESPOND_ERROR)
N        // respond STALL
N        UsbRegMaskedSet(REG_CXCFE, CX_STL | CX_DONE);
X        (*(volatile unsigned int *)(0xC0100000 + (0x120)) = (((*(volatile unsigned int *)(0xC0100000 + (0x120))) & ~(0x00000004 | 0x00000001)) | ((0x00000004 | 0x00000001) & (0x00000004 | 0x00000001))));
N    else
N    {
N        return KDRV_STATUS_ERROR;
N    }
N
N    return KDRV_STATUS_OK;
N}
N
Nkdrv_status_t kdrv_usbd_bulk_send(uint32_t endpoint, uint32_t *buf, uint32_t txLen, uint32_t timeout_ms)
N{
N    kdrv_status_t status = bulk_in_send(endpoint, buf, txLen, true);
X    kdrv_status_t status = bulk_in_send(endpoint, buf, txLen, 1);
N
N    if (status != KDRV_STATUS_OK)
N        return status;
N
N    FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
N    int8_t fno = endpoint_to_fifo(endpoint);
N
N    if (timeout_ms == 0)
N        timeout_ms = osWaitForever;
X        timeout_ms = 0xFFFFFFFFU;
N
N    uint32_t flags = osEventFlagsWait(cb.evt_id, (0x1 << fno), osFlagsWaitAny, timeout_ms);
X    uint32_t flags = osEventFlagsWait(cb.evt_id, (0x1 << fno), 0x00000000U, timeout_ms);
N    if (flags == osFlagsErrorTimeout)
X    if (flags == 0xFFFFFFFEU)
N    {
N        clean_fifo_cb(&fifo_cb[fno]);
N        status = KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
N    }
N    else
N    {
N        if (fifo_cb[fno].cur_event == KDRV_USBD_EVENT_TRANSFER_DONE)
N            status = KDRV_STATUS_OK;
N        else
N            status = KDRV_STATUS_ERROR;
N    }
N
N    clean_fifo_cb(&fifo_cb[fno]);
N    return status;
N}
N
Nkdrv_status_t kdrv_usbd_reset_endpoint(uint32_t endpoint)
N{
N    int8_t fno = endpoint_to_fifo(endpoint);
N
N    if (fno == -1)
N        return KDRV_STATUS_USBD_INVALID_ENDPOINT;
N
N    FIFO_Ctrl *fifo_cb = &cb.fifo_cbs[fno];
N
N    UsbRegMaskedSet(fifo_cb->byteCntReg, FFRST);
X    (*(volatile unsigned int *)(0xC0100000 + (fifo_cb->byteCntReg)) = (((*(volatile unsigned int *)(0xC0100000 + (fifo_cb->byteCntReg))) & ~(0x00001000)) | ((0x00001000) & (0x00001000))));
N
N    if (fifo_cb->transferType == TXFER_BULK)
N    {
N        if (fifo_cb->isTransferring)
N        {
N            // notify transfer done to user
N            if (fifo_cb->isBlockingCall)
N            {
N                fifo_cb->cur_event = KDRV_USBD_EVENT_TRANSFER_TERMINATED;
N                osEventFlagsSet(cb.evt_id, 0x1 << fno);
N            }
N            else
N            {
N                notify_event_to_user(KDRV_USBD_EVENT_TRANSFER_TERMINATED, fifo_cb->endpointAddress, 0);
N            }
N            fifo_cb->isTransferring = false;
X            fifo_cb->isTransferring = 0;
N        }
N
N        uint8_t enpNo = fifo_cb->enpNo;
N        if (fifo_cb->endpointAddress & 0x80)
N        {
N            // for IN endpoints
N            UsbRegMaskedSet(REG_DEV_INMPS_1 + 4 * (enpNo - 1), RSTG_IEPn);
X            (*(volatile unsigned int *)(0xC0100000 + (0x160 + 4 * (enpNo - 1))) = (((*(volatile unsigned int *)(0xC0100000 + (0x160 + 4 * (enpNo - 1)))) & ~(0x00001000)) | ((0x00001000) & (0x00001000))));
N            UsbRegMaskedClr(REG_DEV_INMPS_1 + 4 * (enpNo - 1), RSTG_IEPn);
X            (*(volatile unsigned int *)(0xC0100000 + (0x160 + 4 * (enpNo - 1))) = (((*(volatile unsigned int *)(0xC0100000 + (0x160 + 4 * (enpNo - 1)))) & ~(0x00001000)) | (0 & (0x00001000))));
N            UsbRegMaskedSet(REG_DEV_MISG1, MF0_IN_INT << fno);
X            (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~(0x00010000 << fno)) | ((0x00010000 << fno) & (0x00010000 << fno))));
N        }
N        else
N        {
N            // for OUT endpoints
N            UsbRegMaskedSet(REG_DEV_OUTMPS_1 + 4 * (enpNo - 1), RSTG_OEPn);
X            (*(volatile unsigned int *)(0xC0100000 + (0x180 + 4 * (enpNo - 1))) = (((*(volatile unsigned int *)(0xC0100000 + (0x180 + 4 * (enpNo - 1)))) & ~(0x00001000)) | ((0x00001000) & (0x00001000))));
N            UsbRegMaskedClr(REG_DEV_OUTMPS_1 + 4 * (enpNo - 1), RSTG_OEPn);
X            (*(volatile unsigned int *)(0xC0100000 + (0x180 + 4 * (enpNo - 1))) = (((*(volatile unsigned int *)(0xC0100000 + (0x180 + 4 * (enpNo - 1)))) & ~(0x00001000)) | (0 & (0x00001000))));
N            UsbRegMaskedClr(REG_DEV_MISG1, (MF0_SPK_INT | MF0_OUT_INT) << (fno * 2));
X            (*(volatile unsigned int *)(0xC0100000 + (0x138)) = (((*(volatile unsigned int *)(0xC0100000 + (0x138))) & ~((0x00000002 | 0x00000001) << (fno * 2))) | (0 & ((0x00000002 | 0x00000001) << (fno * 2)))));
N        }
N        clean_fifo_cb(fifo_cb);
N    }
N    return KDRV_STATUS_OK;
N}
N
Nkdrv_status_t kdrv_usbd_bulk_send_async(uint32_t endpoint, uint32_t *buf, uint32_t txLen)
N{
N    return bulk_in_send(endpoint, buf, txLen, false);
X    return bulk_in_send(endpoint, buf, txLen, 0);
N}
N
Nkdrv_status_t kdrv_usbd_bulk_receive(uint32_t endpoint, uint32_t *buf, uint32_t *blen, uint32_t timeout_ms)
N{
N    kdrv_status_t status = bulk_out_receive(endpoint, buf, *blen, true);
X    kdrv_status_t status = bulk_out_receive(endpoint, buf, *blen, 1);
N
N    if (status != KDRV_STATUS_OK)
N        return status;
N
N    FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
N    int8_t fno = endpoint_to_fifo(endpoint);
N
N    if (timeout_ms == 0)
N        timeout_ms = osWaitForever;
X        timeout_ms = 0xFFFFFFFFU;
N
N    uint32_t flags = osEventFlagsWait(cb.evt_id, (0x1 << fno), osFlagsWaitAny, timeout_ms);
X    uint32_t flags = osEventFlagsWait(cb.evt_id, (0x1 << fno), 0x00000000U, timeout_ms);
N    if (flags == osFlagsErrorTimeout)
X    if (flags == 0xFFFFFFFEU)
N    {
N        status = KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
N    }
N    else
N    {
N        *blen = fifo_cb[fno].received_length;
N        if (fifo_cb[fno].cur_event == KDRV_USBD_EVENT_TRANSFER_DONE)
N            status = KDRV_STATUS_OK;
N        else
N            status = KDRV_STATUS_ERROR;
N    }
N
N    clean_fifo_cb(&fifo_cb[fno]);
N    return status;
N}
N
Nkdrv_status_t kdrv_usbd_bulk_receive_async(uint32_t endpoint, uint32_t *buf, uint32_t blen)
N{
N    return bulk_out_receive(endpoint, buf, blen, false);
X    return bulk_out_receive(endpoint, buf, blen, 0);
N}
N
Nkdrv_status_t kdrv_usbd_interrupt_send(uint32_t endpoint, uint32_t *buf, uint32_t txLen, uint32_t timeout_ms)
N{
N    FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
N
N    // find out which FIFO no for the IN endpoint address
N    int8_t fno = endpoint_to_fifo(endpoint);
N
N    // below do some error checking
N    {
N        if (fno == -1)
N            return KDRV_STATUS_USBD_INVALID_ENDPOINT;
N
N        if (fifo_cb[fno].transferType != TXFER_INT)
N            return KDRV_STATUS_USBD_INVALID_TRANSFER;
N    }
N
N    // try to wait some time for FIFO empty
N    // FIXME: 3000 ?
N    for (uint32_t try = 0; try <= 3000; try ++)
N        if (UsbRegRead(REG_CXCFE) & (F_EMP_0 << fno))
X        if ((*(volatile unsigned int *)(0xC0100000 + (0x120))) & (0x00000100 << fno))
N            break;
N
N    // directly clear FIFO content before transmission
N    UsbRegMaskedSet(fifo_cb[fno].byteCntReg, FFRST);
X    (*(volatile unsigned int *)(0xC0100000 + (fifo_cb[fno]. byteCntReg)) = (((*(volatile unsigned int *)(0xC0100000 + (fifo_cb[fno]. byteCntReg))) & ~(0x00001000)) | ((0x00001000) & (0x00001000))));
N
N    uint32_t tryMs = 0;
N    while (1)
N    {
N        if (true == dma_fifo_transfer_sync_try(buf, txLen, 0x1 << fno, WRITE_FIFO, 500))
X        if (1 == dma_fifo_transfer_sync_try(buf, txLen, 0x1 << fno, WRITE_FIFO, 500))
N            break;
N
N        if (timeout_ms != 0 && tryMs >= timeout_ms)
N            return KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
N
N        osDelay(1);
N        ++tryMs;
N    }
N
N    return KDRV_STATUS_OK;
N}
N
Nkdrv_status_t kdrv_usbd_interrupt_receive(uint32_t endpoint, uint32_t *buf, uint32_t *rxLen, uint32_t timeout_ms)
N{
N    FIFO_Ctrl *fifo_cb = cb.fifo_cbs;
N
N    // find out which FIFO no for the IN endpoint address
N    int8_t fno = endpoint_to_fifo(endpoint);
N
N    // below do some error checking
N    {
N        if (fno == -1)
N            return KDRV_STATUS_USBD_INVALID_ENDPOINT;
N
N        if (fifo_cb[fno].transferType != TXFER_INT)
N            return KDRV_STATUS_USBD_INVALID_TRANSFER;
N    }
N
N    uint32_t fifo_bytecnt = UsbRegRead(fifo_cb[fno].byteCntReg) & BC_Fn;
X    uint32_t fifo_bytecnt = (*(volatile unsigned int *)(0xC0100000 + (fifo_cb[fno]. byteCntReg))) & 0x7ff;
N    // can transfer only minimum size betwwen FIFO byte count and user buffer residual size
N    uint32_t transfer_size = MIN(fifo_bytecnt, *rxLen);
X    uint32_t transfer_size = (((fifo_bytecnt) < (*rxLen)) ? (fifo_bytecnt) : (*rxLen));
N
N    uint32_t tryMs = 0;
N    while (1)
N    {
N        if (true == dma_fifo_transfer_sync_try(buf, transfer_size, 0x1 << fno, READ_FIFO, 500))
X        if (1 == dma_fifo_transfer_sync_try(buf, transfer_size, 0x1 << fno, READ_FIFO, 500))
N            break;
N
N        if (timeout_ms != 0 && tryMs >= timeout_ms)
N            return KDRV_STATUS_USBD_TRANSFER_TIMEOUT;
N
N        osDelay(1);
N        ++tryMs;
N    }
N
N    return KDRV_STATUS_OK;
N}
N
N#endif
