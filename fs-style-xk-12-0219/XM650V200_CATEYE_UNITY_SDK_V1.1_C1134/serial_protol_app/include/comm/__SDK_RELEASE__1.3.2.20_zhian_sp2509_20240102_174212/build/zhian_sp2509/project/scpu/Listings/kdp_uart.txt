; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\kdp_uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\kdp_uart.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\kdp_uart.crf ..\..\..\..\scpu\drivers\src\kdp_uart.c]
                          THUMB

                          AREA ||i.IsDataReady||, CODE, READONLY, ALIGN=1

                  IsDataReady PROC
;;;87     
;;;88     UINT32 IsDataReady(UINT32 status)
000000  07c0              LSLS     r0,r0,#31
;;;89     {
000002  d000              BEQ      |L1.6|
;;;90         if((status & SERIAL_IER_DR)==SERIAL_IER_DR)
;;;91             return TRUE;
000004  2001              MOVS     r0,#1
                  |L1.6|
;;;92         else
;;;93             return FALSE;
;;;94     
;;;95     }
000006  4770              BX       lr
;;;96     
                          ENDP


                          AREA ||i.UART0_ISR||, CODE, READONLY, ALIGN=1

                  UART0_ISR PROC
;;;692    
;;;693    void UART0_ISR(void)
000000  2000              MOVS     r0,#0
;;;694    {
;;;695        UART_ISR(0);
000002  f7ffbffe          B.W      UART_ISR
;;;696    }
;;;697    
                          ENDP


                          AREA ||i.UART1_ISR||, CODE, READONLY, ALIGN=1

                  UART1_ISR PROC
;;;697    
;;;698    void UART1_ISR(void)
000000  2001              MOVS     r0,#1
;;;699    {
;;;700        UART_ISR(1);
000002  f7ffbffe          B.W      UART_ISR
;;;701    }
;;;702    
                          ENDP


                          AREA ||i.UART2_ISR||, CODE, READONLY, ALIGN=1

                  UART2_ISR PROC
;;;702    
;;;703    void UART2_ISR(void)
000000  2002              MOVS     r0,#2
;;;704    {
;;;705        UART_ISR(2);
000002  f7ffbffe          B.W      UART_ISR
;;;706    }
;;;707    
                          ENDP


                          AREA ||i.UART3_ISR||, CODE, READONLY, ALIGN=1

                  UART3_ISR PROC
;;;707    
;;;708    void UART3_ISR(void)
000000  2003              MOVS     r0,#3
;;;709    {
;;;710        UART_ISR(3);
000002  f7ffbffe          B.W      UART_ISR
;;;711    }
;;;712    
                          ENDP


                          AREA ||i.UART4_ISR||, CODE, READONLY, ALIGN=1

                  UART4_ISR PROC
;;;712    
;;;713    void UART4_ISR(void)
000000  2004              MOVS     r0,#4
;;;714    {
;;;715        UART_ISR(4);
000002  f7ffbffe          B.W      UART_ISR
;;;716    }
;;;717    
                          ENDP


                          AREA ||i.UART_ISR||, CODE, READONLY, ALIGN=2

                  UART_ISR PROC
;;;601    
;;;602    void UART_ISR(uint8_t port_no)
000000  b570              PUSH     {r4-r6,lr}
;;;603    {
000002  4605              MOV      r5,r0
;;;604        kdp_driver_hdl_t *pHdl = kdp_uart_get_drv_hdl(port_no);
000004  f7fffffe          BL       kdp_uart_get_drv_hdl
;;;605    
;;;606        uint32_t ww = inw(UART_PORT[port_no] + SERIAL_IIR);
000008  4926              LDR      r1,|L7.164|
00000a  4604              MOV      r4,r0                 ;604
00000c  f8510025          LDR      r0,[r1,r5,LSL #2]
000010  6880              LDR      r0,[r0,#8]
;;;607    
;;;608        pHdl->iir = ww;
;;;609    
;;;610        if ((ww & IIR_CODE_MASK) == SERIAL_IIR_RLS)   // errors: overrun/parity/framing/break
000012  6760              STR      r0,[r4,#0x74]
000014  f000000f          AND      r0,r0,#0xf
000018  2806              CMP      r0,#6
00001a  d006              BEQ      |L7.42|
;;;611        {
;;;612            ww = inw(UART_PORT[port_no] + SERIAL_LSR);   //Read LSR to reset interrupt
;;;613    
;;;614            if (ww & SERIAL_LSR_OE)
;;;615            {
;;;616                pHdl->info.status.rx_overflow = 1;
;;;617            }
;;;618    
;;;619            if (ww & SERIAL_LSR_PE)
;;;620            {
;;;621                pHdl->info.status.rx_parity_error = 1;
;;;622            }
;;;623    
;;;624            if (ww & SERIAL_LSR_BI)
;;;625            {
;;;626                pHdl->info.status.rx_break = 1;
;;;627            }
;;;628    
;;;629            if (ww & SERIAL_LSR_FE)
;;;630            {
;;;631                pHdl->info.status.rx_framing_error = 1;
;;;632            }
;;;633    
;;;634            if (pHdl->info.status.rx_busy)
;;;635            {
;;;636    //            UART_RX_ISR(pHdl);
;;;637                UART_RX_ISR_new(pHdl);
;;;638            }
;;;639    
;;;640            if (pHdl->info.status.tx_busy)
;;;641            {
;;;642                UART_TX_ISR(pHdl);
;;;643            }
;;;644    
;;;645        }
;;;646        else if (((ww & IIR_CODE_MASK) == SERIAL_IIR_DR)            // Rx data ready in FIFO
00001c  2804              CMP      r0,#4
00001e  d01e              BEQ      |L7.94|
;;;647            || ((ww & IIR_CODE_MASK) == SERIAL_IIR_TIMEOUT))       // Character Reception Timeout 
000020  280c              CMP      r0,#0xc
000022  d01c              BEQ      |L7.94|
;;;648        {
;;;649            if (pHdl->info.status.rx_busy)
;;;650            {
;;;651    //            UART_RX_ISR(pHdl);
;;;652                UART_RX_ISR_new(pHdl);
;;;653            }
;;;654            else
;;;655            {
;;;656                ww = inw(UART_PORT[port_no] + SERIAL_RBR);   //Read RBR to reset interrupt
;;;657            }
;;;658    
;;;659            if (pHdl->info.status.tx_busy)
;;;660            {
;;;661                UART_TX_ISR(pHdl);
;;;662            }
;;;663    
;;;664        }
;;;665        else if ((ww & IIR_CODE_MASK) == SERIAL_IIR_TE)  // Transmitter Holding Register Empty
000024  2802              CMP      r0,#2
000026  d030              BEQ      |L7.138|
000028  e01f              B        |L7.106|
                  |L7.42|
00002a  f8510025          LDR      r0,[r1,r5,LSL #2]     ;612
00002e  6940              LDR      r0,[r0,#0x14]         ;612
000030  f04f0101          MOV      r1,#1                 ;616
000034  0782              LSLS     r2,r0,#30             ;614
000036  d500              BPL      |L7.58|
000038  77e1              STRB     r1,[r4,#0x1f]         ;616
                  |L7.58|
00003a  0742              LSLS     r2,r0,#29             ;619
00003c  d501              BPL      |L7.66|
00003e  f8841022          STRB     r1,[r4,#0x22]         ;621
                  |L7.66|
000042  06c2              LSLS     r2,r0,#27             ;624
000044  d501              BPL      |L7.74|
000046  f8841020          STRB     r1,[r4,#0x20]         ;626
                  |L7.74|
00004a  0700              LSLS     r0,r0,#28             ;629
00004c  d501              BPL      |L7.82|
00004e  f8841021          STRB     r1,[r4,#0x21]         ;631
                  |L7.82|
000052  7f60              LDRB     r0,[r4,#0x1d]         ;634
000054  b148              CBZ      r0,|L7.106|
                  |L7.86|
000056  4620              MOV      r0,r4                 ;637
000058  f7fffffe          BL       UART_RX_ISR_new
00005c  e005              B        |L7.106|
                  |L7.94|
00005e  7f60              LDRB     r0,[r4,#0x1d]         ;649
000060  2800              CMP      r0,#0                 ;649
000062  d1f8              BNE      |L7.86|
000064  f8510025          LDR      r0,[r1,r5,LSL #2]     ;656
000068  6800              LDR      r0,[r0,#0]            ;656
                  |L7.106|
;;;666        {
;;;667            if (pHdl->info.status.tx_busy)
;;;668            {
;;;669                UART_TX_ISR(pHdl);
;;;670            }
;;;671    
;;;672            if (pHdl->info.status.rx_busy)
;;;673            {
;;;674    //            UART_RX_ISR(pHdl);
;;;675                UART_RX_ISR_new(pHdl);
;;;676            }
;;;677    
;;;678        }
;;;679        else
;;;680        {
;;;681            if (pHdl->info.status.tx_busy)
00006a  7f20              LDRB     r0,[r4,#0x1c]
00006c  b110              CBZ      r0,|L7.116|
;;;682            {
;;;683                UART_TX_ISR(pHdl);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       UART_TX_ISR
                  |L7.116|
;;;684            }
;;;685        }
;;;686    
;;;687        NVIC_ClearPendingIRQ((IRQn_Type)pHdl->res.irq_num);
000074  f8140f4c          LDRB     r0,[r4,#0x4c]!
000078  b240              SXTB     r0,r0
00007a  f7fffffe          BL       __NVIC_ClearPendingIRQ
;;;688        NVIC_EnableIRQ((IRQn_Type)pHdl->res.irq_num);
00007e  7820              LDRB     r0,[r4,#0]
000080  e8bd4070          POP      {r4-r6,lr}
000084  b240              SXTB     r0,r0
000086  f7ffbffe          B.W      __NVIC_EnableIRQ
                  |L7.138|
00008a  7f20              LDRB     r0,[r4,#0x1c]         ;667
00008c  b110              CBZ      r0,|L7.148|
00008e  4620              MOV      r0,r4                 ;669
000090  f7fffffe          BL       UART_TX_ISR
                  |L7.148|
000094  7f60              LDRB     r0,[r4,#0x1d]         ;672
000096  2800              CMP      r0,#0                 ;672
000098  d0ec              BEQ      |L7.116|
00009a  4620              MOV      r0,r4                 ;675
00009c  f7fffffe          BL       UART_RX_ISR_new
0000a0  e7e8              B        |L7.116|
;;;689    
;;;690    }
;;;691    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L7.164|
                          DCD      ||.data||+0x38

                          AREA ||i.UART_RX_ISR_new||, CODE, READONLY, ALIGN=2

                  UART_RX_ISR_new PROC
;;;537    #endif
;;;538    static void UART_RX_ISR_new(kdp_driver_hdl_t *const uart)
000000  b5f0              PUSH     {r4-r7,lr}
;;;539    {
;;;540        uint32_t ww;
;;;541        uint16_t port_no;
;;;542        uint8_t lsr;
;;;543        port_no = uart->uart_port;
000002  8801              LDRH     r1,[r0,#0]
;;;544        while(1)
;;;545        {
;;;546            ww = (uint8_t)inw(UART_PORT[port_no] + SERIAL_IIR);
000004  f05f0500          MOVS.W   r5,#0
000008  b28b              UXTH     r3,r1                 ;543
00000a  4925              LDR      r1,|L8.160|
                  |L8.12|
00000c  f8514023          LDR      r4,[r1,r3,LSL #2]
000010  68a2              LDR      r2,[r4,#8]
000012  b2d2              UXTB     r2,r2
;;;547    
;;;548            if( (ww & SERIAL_IIR_RLS) == SERIAL_IIR_RLS ) //iir 0x06
000014  f3c20641          UBFX     r6,r2,#1,#2
000018  2e03              CMP      r6,#3
00001a  d111              BNE      |L8.64|
;;;549            {
;;;550                lsr = inw(UART_PORT[port_no] + SERIAL_LSR);
00001c  6966              LDR      r6,[r4,#0x14]
;;;551                if( (lsr&0x01) == 0x01 )
00001e  07f6              LSLS     r6,r6,#31
000020  d00e              BEQ      |L8.64|
;;;552                {
;;;553                    uart->info.xfer.rx_buf[uart->info.xfer.write_idx] = (uint8_t)inw(UART_PORT[port_no] + SERIAL_RBR);
000022  6824              LDR      r4,[r4,#0]
000024  6bc7              LDR      r7,[r0,#0x3c]
000026  6ac6              LDR      r6,[r0,#0x2c]
000028  55f4              STRB     r4,[r6,r7]
;;;554                    uart->info.xfer.write_idx++;
00002a  6bc4              LDR      r4,[r0,#0x3c]
00002c  1c64              ADDS     r4,r4,#1
00002e  63c4              STR      r4,[r0,#0x3c]
;;;555                    if(uart->info.xfer.write_idx >= uart->info.xfer.rx_num) uart->info.xfer.write_idx = 0;
000030  6bc4              LDR      r4,[r0,#0x3c]
000032  6a46              LDR      r6,[r0,#0x24]
000034  42b4              CMP      r4,r6
000036  d300              BCC      |L8.58|
000038  63c5              STR      r5,[r0,#0x3c]
                  |L8.58|
;;;556                    uart->info.xfer.rx_cnt++;
00003a  6b44              LDR      r4,[r0,#0x34]
00003c  1c64              ADDS     r4,r4,#1
00003e  6344              STR      r4,[r0,#0x34]
                  |L8.64|
;;;557                }
;;;558            }
;;;559    
;;;560            if( (ww & 0x0F /*SERIAL_IIR_DR*/) == SERIAL_IIR_DR ) //iir 0x04
000040  f002040f          AND      r4,r2,#0xf
000044  2c04              CMP      r4,#4
000046  d016              BEQ      |L8.118|
;;;561            {
;;;562    
;;;563                UINT8 aa = inw(UART_PORT[port_no] + SERIAL_LSR);
;;;564                {
;;;565                    uart->info.xfer.rx_buf[uart->info.xfer.write_idx] = (uint8_t)inw(UART_PORT[port_no] + SERIAL_RBR);
;;;566                    uart->info.xfer.write_idx++;
;;;567                    if(uart->info.xfer.write_idx >= uart->info.xfer.rx_num) uart->info.xfer.write_idx = 0;
;;;568                    uart->info.xfer.rx_cnt++;
;;;569                }
;;;570                uart->info.status.rx_busy = 1;
;;;571                continue;
;;;572            }
;;;573    
;;;574            if((ww & 0x0F /*SERIAL_IIR_TIMEOUT*/ ) == SERIAL_IIR_TIMEOUT)    //to  0x0C
000048  f002020f          AND      r2,r2,#0xf
00004c  2a0c              CMP      r2,#0xc
00004e  d111              BNE      |L8.116|
;;;575            {
;;;576    
;;;577                UINT8 cc = inw(UART_PORT[port_no] + SERIAL_LSR);
000050  f8511023          LDR      r1,[r1,r3,LSL #2]
000054  694a              LDR      r2,[r1,#0x14]
;;;578                uart->info.xfer.rx_buf[uart->info.xfer.write_idx] = (uint8_t)inw(UART_PORT[port_no] + SERIAL_RBR);
000056  6809              LDR      r1,[r1,#0]
000058  6bc3              LDR      r3,[r0,#0x3c]
00005a  6ac2              LDR      r2,[r0,#0x2c]
00005c  54d1              STRB     r1,[r2,r3]
;;;579                uart->info.xfer.write_idx++;
00005e  6bc1              LDR      r1,[r0,#0x3c]
000060  1c49              ADDS     r1,r1,#1
000062  63c1              STR      r1,[r0,#0x3c]
;;;580                if(uart->info.xfer.write_idx >= uart->info.xfer.rx_num) uart->info.xfer.write_idx = 0;
000064  6bc1              LDR      r1,[r0,#0x3c]
000066  6a42              LDR      r2,[r0,#0x24]
000068  4291              CMP      r1,r2
00006a  d300              BCC      |L8.110|
00006c  63c5              STR      r5,[r0,#0x3c]
                  |L8.110|
;;;581                uart->info.xfer.rx_cnt++;
00006e  6b41              LDR      r1,[r0,#0x34]
000070  1c49              ADDS     r1,r1,#1
000072  6341              STR      r1,[r0,#0x34]
                  |L8.116|
;;;582    
;;;583                break;
;;;584            }
;;;585            else
;;;586            {
;;;587    
;;;588                //do nothing
;;;589                break;
;;;590            }
;;;591        }
;;;592    
;;;593    
;;;594    
;;;595    
;;;596    }
000074  bdf0              POP      {r4-r7,pc}
                  |L8.118|
000076  f8512023          LDR      r2,[r1,r3,LSL #2]     ;563
00007a  6954              LDR      r4,[r2,#0x14]         ;563
00007c  6812              LDR      r2,[r2,#0]            ;565
00007e  6bc6              LDR      r6,[r0,#0x3c]         ;565
000080  6ac4              LDR      r4,[r0,#0x2c]         ;565
000082  55a2              STRB     r2,[r4,r6]            ;565
000084  6bc2              LDR      r2,[r0,#0x3c]         ;566
000086  1c52              ADDS     r2,r2,#1              ;566
000088  63c2              STR      r2,[r0,#0x3c]         ;566
00008a  6bc2              LDR      r2,[r0,#0x3c]         ;567
00008c  6a44              LDR      r4,[r0,#0x24]         ;567
00008e  42a2              CMP      r2,r4                 ;567
000090  d300              BCC      |L8.148|
000092  63c5              STR      r5,[r0,#0x3c]         ;567
                  |L8.148|
000094  6b42              LDR      r2,[r0,#0x34]         ;568
000096  1c52              ADDS     r2,r2,#1              ;568
000098  6342              STR      r2,[r0,#0x34]         ;568
00009a  2201              MOVS     r2,#1                 ;570
00009c  7742              STRB     r2,[r0,#0x1d]         ;570
00009e  e7b5              B        |L8.12|
;;;597    
                          ENDP

                  |L8.160|
                          DCD      ||.data||+0x38

                          AREA ||i.UART_TX_ISR||, CODE, READONLY, ALIGN=2

                  UART_TX_ISR PROC
;;;398    */
;;;399    static void UART_TX_ISR(kdp_driver_hdl_t *const uart)
000000  b430              PUSH     {r4,r5}
;;;400    {
;;;401        int16_t  tx;
;;;402        UINT32   status;
;;;403        uint32_t ww;
;;;404        uint16_t port_no;
;;;405        bool     bFifo;
;;;406    
;;;407        ww = uart->iir;
000002  f8901074          LDRB     r1,[r0,#0x74]
;;;408        bFifo = ((ww & 0xc0) != 0) ? TRUE : FALSE;
000006  f01101c0          ANDS     r1,r1,#0xc0
00000a  d000              BEQ      |L9.14|
00000c  2101              MOVS     r1,#1
                  |L9.14|
;;;409        port_no = uart->uart_port;
00000e  8802              LDRH     r2,[r0,#0]
;;;410    
;;;411        if (uart->info.xfer.tx_num > uart->info.xfer.tx_cnt)
000010  6a84              LDR      r4,[r0,#0x28]
000012  b293              UXTH     r3,r2                 ;409
000014  6b85              LDR      r5,[r0,#0x38]
;;;412        {
;;;413            if (bFifo == FALSE)     //NO FIFO
;;;414            {
;;;415                do
;;;416                {
;;;417                    status = inw(UART_PORT[port_no] + SERIAL_LSR);
000016  4a24              LDR      r2,|L9.168|
000018  42ac              CMP      r4,r5                 ;411
00001a  d91e              BLS      |L9.90|
00001c  f8524023          LDR      r4,[r2,r3,LSL #2]
000020  b381              CBZ      r1,|L9.132|
                  |L9.34|
;;;418                } while (!((status & SERIAL_LSR_THRE) == SERIAL_LSR_THRE));    // wait until Tx ready
;;;419                outw(UART_PORT[port_no] + SERIAL_THR, *(uart->info.xfer.tx_buf++));
;;;420                uart->info.xfer.tx_cnt++;
;;;421    
;;;422            }
;;;423            else     //FIFO mode
;;;424            {
;;;425                do
;;;426                {
;;;427                    status = inw(UART_PORT[port_no] + SERIAL_LSR);
000022  6961              LDR      r1,[r4,#0x14]
;;;428                } while (!((status & SERIAL_LSR_THRE) == SERIAL_LSR_THRE));    // wait until Tx ready
000024  0689              LSLS     r1,r1,#26
000026  d5fc              BPL      |L9.34|
;;;429    
;;;430                tx = uart->info.xfer.tx_num - uart->info.xfer.tx_cnt;
000028  6a81              LDR      r1,[r0,#0x28]
00002a  6b84              LDR      r4,[r0,#0x38]
00002c  1b09              SUBS     r1,r1,r4
00002e  b209              SXTH     r1,r1
;;;431                if (tx <= 0) tx = 0;
000030  2900              CMP      r1,#0
000032  dc00              BGT      |L9.54|
000034  2100              MOVS     r1,#0
                  |L9.54|
;;;432    
;;;433                if (tx > uart->res.fifo_len) {
000036  6e04              LDR      r4,[r0,#0x60]
000038  428c              CMP      r4,r1
00003a  d20c              BCS      |L9.86|
;;;434                    tx = 16;
00003c  2110              MOVS     r1,#0x10
                  |L9.62|
;;;435                }
;;;436    
;;;437                while (tx > 0)
;;;438                {
;;;439                    uart->info.xfer.tx_cnt++;
00003e  6b84              LDR      r4,[r0,#0x38]
000040  1c64              ADDS     r4,r4,#1
000042  6384              STR      r4,[r0,#0x38]
;;;440                    outw(UART_PORT[port_no] + SERIAL_THR, *(uart->info.xfer.tx_buf++));
000044  6b04              LDR      r4,[r0,#0x30]
000046  1c65              ADDS     r5,r4,#1
000048  6305              STR      r5,[r0,#0x30]
00004a  7824              LDRB     r4,[r4,#0]
00004c  f8525023          LDR      r5,[r2,r3,LSL #2]
000050  602c              STR      r4,[r5,#0]
000052  1e49              SUBS     r1,r1,#1
;;;441                    tx--;
000054  b209              SXTH     r1,r1
                  |L9.86|
000056  2900              CMP      r1,#0                 ;437
000058  dcf1              BGT      |L9.62|
                  |L9.90|
;;;442                }
;;;443    
;;;444            }
;;;445    
;;;446        }
;;;447    
;;;448        if (uart->info.xfer.tx_num == uart->info.xfer.tx_cnt)
00005a  6a81              LDR      r1,[r0,#0x28]
00005c  6b84              LDR      r4,[r0,#0x38]
00005e  42a1              CMP      r1,r4
000060  d11f              BNE      |L9.162|
;;;449        {
;;;450            // need to add: determine if TX fifo is empty
;;;451            status = inw(UART_PORT[port_no] + SERIAL_LSR);
000062  f8521023          LDR      r1,[r2,r3,LSL #2]
000066  694a              LDR      r2,[r1,#0x14]
;;;452            if ((status & SERIAL_LSR_THRE) == SERIAL_LSR_THRE)    //TX empty to make sure FIFO data to tranmit shift
000068  0692              LSLS     r2,r2,#26
00006a  d51a              BPL      |L9.162|
;;;453            {
;;;454                uint32_t ww = inw(UART_PORT[port_no] + SERIAL_IER);
00006c  684a              LDR      r2,[r1,#4]
;;;455                ww &= ~SERIAL_IER_TE;                         // disable Tx empty interrupt
00006e  f0220202          BIC      r2,r2,#2
;;;456                outw(UART_PORT[port_no] + SERIAL_IER, ww);
000072  604a              STR      r2,[r1,#4]
;;;457    
;;;458                // Clear TX busy flag
;;;459                uart->info.status.tx_busy = 0;
000074  2100              MOVS     r1,#0
000076  7701              STRB     r1,[r0,#0x1c]
;;;460                if (uart->info.cb_event) uart->info.cb_event(ARM_USART_EVENT_SEND_COMPLETE);
000078  6981              LDR      r1,[r0,#0x18]
00007a  2900              CMP      r1,#0
00007c  d011              BEQ      |L9.162|
00007e  bc30              POP      {r4,r5}
000080  2001              MOVS     r0,#1
000082  4708              BX       r1
                  |L9.132|
000084  e7ff              B        |L9.134|
                  |L9.134|
000086  6961              LDR      r1,[r4,#0x14]         ;417
000088  0689              LSLS     r1,r1,#26             ;418
00008a  d5fc              BPL      |L9.134|
00008c  6b01              LDR      r1,[r0,#0x30]         ;419
00008e  1c4c              ADDS     r4,r1,#1              ;419
000090  6304              STR      r4,[r0,#0x30]         ;419
000092  7809              LDRB     r1,[r1,#0]            ;419
000094  f8524023          LDR      r4,[r2,r3,LSL #2]     ;419
000098  6021              STR      r1,[r4,#0]            ;419
00009a  6b81              LDR      r1,[r0,#0x38]         ;420
00009c  1c49              ADDS     r1,r1,#1              ;420
00009e  6381              STR      r1,[r0,#0x38]         ;420
0000a0  e7db              B        |L9.90|
                  |L9.162|
;;;461            }
;;;462        }
;;;463    }
0000a2  bc30              POP      {r4,r5}
0000a4  4770              BX       lr
;;;464    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L9.168|
                          DCD      ||.data||+0x38

                          AREA ||i.__NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_ClearPendingIRQ PROC
;;;1774    */
;;;1775   __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1776   {
000002  db09              BLT      |L10.24|
;;;1777     if ((int32_t)(IRQn) >= 0)
;;;1778     {
;;;1779       NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01280          STR      r1,[r0,#0x280]
                  |L10.24|
;;;1780     }
;;;1781   }
000018  4770              BX       lr
;;;1782   
                          ENDP


                          AREA ||i.__NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_EnableIRQ PROC
;;;1683    */
;;;1684   __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1685   {
000002  db09              BLT      |L11.24|
;;;1686     if ((int32_t)(IRQn) >= 0)
;;;1687     {
;;;1688       __COMPILER_BARRIER();
;;;1689       NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01100          STR      r1,[r0,#0x100]
                  |L11.24|
;;;1690       __COMPILER_BARRIER();
;;;1691     }
;;;1692   }
000018  4770              BX       lr
;;;1693   
                          ENDP


                          AREA ||i._check_rx_status||, CODE, READONLY, ALIGN=1

                  _check_rx_status PROC
;;;105    
;;;106    void _check_rx_status(DRVUART_PORT port_no)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
                  |L12.4|
;;;108        UINT32 Status;
;;;109        do {
;;;110            Status = _get_uart_status(port_no);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       _get_uart_status
;;;111            if(IsDataReady(Status)) break;
00000a  f7fffffe          BL       IsDataReady
00000e  2800              CMP      r0,#0
000010  d103              BNE      |L12.26|
;;;112            else osDelay(20);
000012  2014              MOVS     r0,#0x14
000014  f7fffffe          BL       osDelay
000018  e7f4              B        |L12.4|
                  |L12.26|
;;;113        } while (1);    // wait until Rx ready
;;;114    }
00001a  bd10              POP      {r4,pc}
;;;115    
                          ENDP


                          AREA ||i._check_tx_status||, CODE, READONLY, ALIGN=1

                  _check_tx_status PROC
;;;115    
;;;116    void _check_tx_status(DRVUART_PORT port_no)
000000  b500              PUSH     {lr}
;;;117    {
000002  4602              MOV      r2,r0
                  |L13.4|
;;;118        UINT32 Status;
;;;119        do
;;;120        {
;;;121            Status = _get_uart_status(port_no);
000004  4610              MOV      r0,r2
000006  f7fffffe          BL       _get_uart_status
;;;122        }while (!_is_thr_empty(Status));    // wait until Tx ready
00000a  f7fffffe          BL       _is_thr_empty
00000e  2800              CMP      r0,#0
000010  d0f8              BEQ      |L13.4|
;;;123    }
000012  bd00              POP      {pc}
;;;124    
                          ENDP


                          AREA ||i._get_uart_status||, CODE, READONLY, ALIGN=2

                  _get_uart_status PROC
;;;80     
;;;81     UINT32 _get_uart_status(DRVUART_PORT port_no)
000000  4902              LDR      r1,|L14.12|
;;;82     {
;;;83         UINT32 status;
;;;84         status=inw(UART_PORT[port_no]+SERIAL_LSR);
000002  f8510020          LDR      r0,[r1,r0,LSL #2]
000006  6940              LDR      r0,[r0,#0x14]
;;;85         return status;
;;;86     }
000008  4770              BX       lr
;;;87     
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      ||.data||+0x38

                          AREA ||i._is_thr_empty||, CODE, READONLY, ALIGN=1

                  _is_thr_empty PROC
;;;96     
;;;97     UINT32 _is_thr_empty(UINT32 status)
000000  0680              LSLS     r0,r0,#26
;;;98     {
000002  d501              BPL      |L15.8|
;;;99         //if (((status & SERIAL_LSR_THRE)==SERIAL_LSR_THRE) && ((status & SERIAL_LSR_TE)==SERIAL_LSR_TE))
;;;100        if ((status & SERIAL_LSR_THRE)==SERIAL_LSR_THRE)
;;;101            return TRUE;
000004  2001              MOVS     r0,#1
;;;102        else
;;;103            return FALSE;
;;;104    }
000006  4770              BX       lr
                  |L15.8|
000008  2000              MOVS     r0,#0                 ;103
00000a  4770              BX       lr
;;;105    
                          ENDP


                          AREA ||i.kdp_calculate_fifo_cfg||, CODE, READONLY, ALIGN=1

                  kdp_calculate_fifo_cfg PROC
;;;348    */
;;;349    static int32_t kdp_calculate_fifo_cfg(kdp_driver_hdl_t *const pDrv, uint32_t val, kdp_uart_fifo_cfg_t *pCfg)
000000  b510              PUSH     {r4,lr}
;;;350    {
000002  b142              CBZ      r2,|L16.22|
;;;351        #define TRIGGER_LEVEL_MAX_IS_LEVEL_8 (NO)
;;;352        int32_t depth;
;;;353    
;;;354        if (pCfg == NULL)
;;;355        {
;;;356            //dbg_msg("Error: invalid parameter pCfg\n");
;;;357            return UART_FAIL;
;;;358        }
;;;359    
;;;360        if (pCfg->bEnFifo == FALSE)
000004  7814              LDRB     r4,[r2,#0]
000006  2300              MOVS     r3,#0
000008  b11c              CBZ      r4,|L16.18|
;;;361        {
;;;362            pCfg->fifo_trig_level = SERIAL_FIFO_TRIG_LVEL_1;
;;;363            return UART_SUCCESS;
;;;364        }
;;;365    
;;;366        depth = pDrv->res.fifo_depth;
00000a  6d40              LDR      r0,[r0,#0x54]
;;;367    
;;;368        if (val <= depth * 4)
00000c  ebb10f80          CMP      r1,r0,LSL #2
000010  d804              BHI      |L16.28|
                  |L16.18|
000012  7053              STRB     r3,[r2,#1]            ;362
000014  e009              B        |L16.42|
                  |L16.22|
000016  f04f30ff          MOV      r0,#0xffffffff        ;357
;;;369        {
;;;370            pCfg->fifo_trig_level = SERIAL_FIFO_TRIG_LVEL_1;
;;;371        }
;;;372        else if ((val > depth * 4) && (val <= depth * 8))
;;;373        {
;;;374            pCfg->fifo_trig_level = SERIAL_FIFO_TRIG_LVEL_4;
;;;375        }
;;;376        #if TRIGGER_LEVEL_MAX_IS_LEVEL_8 == YES
;;;377        else
;;;378        {
;;;379            pCfg->fifo_trig_level = SERIAL_FIFO_TRIG_LVEL_8;
;;;380        }
;;;381        #else
;;;382        else if ((val > depth * 8) && (val <= depth * 14))
;;;383        {
;;;384            pCfg->fifo_trig_level = SERIAL_FIFO_TRIG_LVEL_8;
;;;385        }
;;;386        else if (val > depth * 14)
;;;387        {
;;;388            pCfg->fifo_trig_level = SERIAL_FIFO_TRIG_LVEL_14;
;;;389        }
;;;390        #endif
;;;391        return UART_SUCCESS;
;;;392    }
00001a  bd10              POP      {r4,pc}
                  |L16.28|
00001c  ebb10fc0          CMP      r1,r0,LSL #3          ;372
000020  d801              BHI      |L16.38|
000022  2001              MOVS     r0,#1                 ;374
000024  e000              B        |L16.40|
                  |L16.38|
000026  2002              MOVS     r0,#2                 ;379
                  |L16.40|
000028  7050              STRB     r0,[r2,#1]            ;374
                  |L16.42|
00002a  2000              MOVS     r0,#0                 ;391
00002c  bd10              POP      {r4,pc}
;;;393    
                          ENDP


                          AREA ||i.kdp_get_serial_char||, CODE, READONLY, ALIGN=2

                  kdp_get_serial_char PROC
;;;155    
;;;156    char kdp_get_serial_char(DRVUART_PORT port_no)
000000  4904              LDR      r1,|L17.20|
;;;157    {
;;;158        char Ch;
;;;159        UINT32 status;
;;;160    
;;;161           do
;;;162        {
;;;163             status=inw(UART_PORT[port_no]+SERIAL_LSR);
000002  f8510020          LDR      r0,[r1,r0,LSL #2]
                  |L17.6|
000006  6941              LDR      r1,[r0,#0x14]
;;;164        }
;;;165        while (!((status & SERIAL_LSR_DR)==SERIAL_LSR_DR));    // wait until Rx ready
000008  07c9              LSLS     r1,r1,#31
00000a  d0fc              BEQ      |L17.6|
;;;166        Ch = inw(UART_PORT[port_no] + SERIAL_RBR);
00000c  6800              LDR      r0,[r0,#0]
00000e  b2c0              UXTB     r0,r0
;;;167        return (Ch);
;;;168    }
000010  4770              BX       lr
;;;169    void kdp_serial_init (DRVUART_PORT port_no, UINT32 baudrate, UINT32 parity,UINT32 num,UINT32 len, UINT32 interruptMode)
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      ||.data||+0x38

                          AREA ||i.kdp_getchar||, CODE, READONLY, ALIGN=2

                  kdp_getchar PROC
;;;124    
;;;125    char kdp_getchar(DRVUART_PORT port_no)
000000  b510              PUSH     {r4,lr}
;;;126    {
000002  4604              MOV      r4,r0
;;;127        char Ch;
;;;128    
;;;129        _check_rx_status(port_no);
000004  f7fffffe          BL       _check_rx_status
;;;130        Ch = inw(UART_PORT[port_no]+SERIAL_RBR);
000008  4802              LDR      r0,|L18.20|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  6800              LDR      r0,[r0,#0]
000010  b2c0              UXTB     r0,r0
;;;131        return (Ch);
;;;132    }
000012  bd10              POP      {r4,pc}
;;;133    
                          ENDP

                  |L18.20|
                          DCD      ||.data||+0x38

                          AREA ||i.kdp_gets||, CODE, READONLY, ALIGN=2

                  kdp_gets PROC
;;;222    }
;;;223    int kdp_gets(DRVUART_PORT port_no, char *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;224    {
;;;225        char    *cp;
;;;226        char    data;
;;;227        UINT32  count;
;;;228        count = 0;
000004  2400              MOVS     r4,#0
000006  4680              MOV      r8,r0                 ;224
;;;229        cp = buf;
000008  460d              MOV      r5,r1
00000a  4627              MOV      r7,r4
                  |L19.12|
;;;230    
;;;231        do
;;;232        {
;;;233            data = kdp_getchar(port_no);
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       kdp_getchar
000012  4606              MOV      r6,r0
;;;234    
;;;235            switch(data)
000014  2808              CMP      r0,#8
000016  d019              BEQ      |L19.76|
000018  2e0d              CMP      r6,#0xd
00001a  d00f              BEQ      |L19.60|
00001c  2e7f              CMP      r6,#0x7f
00001e  d015              BEQ      |L19.76|
;;;236            {
;;;237                case RETURN_KEY:
;;;238                    if(count < 256)
;;;239                    {
;;;240                        *cp = '\0';
;;;241                        kdp_putchar(port_no, '\n');
;;;242                    }
;;;243                    break;
;;;244                case BACKSP_KEY:
;;;245                case DELETE_KEY:
;;;246                    if(count)
;;;247                    {
;;;248                        count--;
;;;249                        *(--cp) = '\0';
;;;250                        kdp_putstr(port_no, "\b \b");
;;;251                    }
;;;252                    break;
;;;253                default:
;;;254                    if( data > 0x1F && data < 0x7F && count < 256)
000020  f1a60020          SUB      r0,r6,#0x20
000024  285f              CMP      r0,#0x5f
000026  d2f1              BCS      |L19.12|
000028  2cff              CMP      r4,#0xff
00002a  d8ef              BHI      |L19.12|
;;;255                    {
;;;256                        *cp = (char)data;
00002c  f8056b01          STRB     r6,[r5],#1
;;;257                        cp++;
;;;258                        count++;
;;;259                        kdp_putchar(port_no, data);
000030  4631              MOV      r1,r6
000032  4640              MOV      r0,r8
000034  1c64              ADDS     r4,r4,#1
000036  f7fffffe          BL       kdp_putchar
00003a  e7e7              B        |L19.12|
                  |L19.60|
00003c  2cff              CMP      r4,#0xff              ;238
00003e  d80f              BHI      |L19.96|
000040  702f              STRB     r7,[r5,#0]            ;240
000042  210a              MOVS     r1,#0xa               ;241
000044  4640              MOV      r0,r8                 ;241
000046  f7fffffe          BL       kdp_putchar
00004a  e009              B        |L19.96|
                  |L19.76|
00004c  b134              CBZ      r4,|L19.92|
00004e  f8057d01          STRB     r7,[r5,#-1]!          ;249
000052  a105              ADR      r1,|L19.104|
000054  4640              MOV      r0,r8                 ;250
000056  1e64              SUBS     r4,r4,#1              ;250
000058  f7fffffe          BL       kdp_putstr
                  |L19.92|
;;;260                    }
;;;261                    break;
;;;262            }
;;;263        } while(data != RETURN_KEY);
00005c  2e0d              CMP      r6,#0xd
00005e  d1d5              BNE      |L19.12|
                  |L19.96|
;;;264    
;;;265      return (count);
000060  4620              MOV      r0,r4
;;;266    }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;267    /***********************************************************************************
                          ENDP

000066  0000              DCW      0x0000
                  |L19.104|
000068  08200800          DCB      "\b \b",0

                          AREA ||i.kdp_putchar||, CODE, READONLY, ALIGN=2

                  kdp_putchar PROC
;;;133    
;;;134    void kdp_putchar(DRVUART_PORT port_no, char Ch)
000000  b530              PUSH     {r4,r5,lr}
;;;135    {
000002  000b              MOVS     r3,r1
000004  4604              MOV      r4,r0
000006  d00e              BEQ      |L20.38|
;;;136        if(Ch!='\0')
;;;137        {
;;;138            _check_tx_status(port_no);
000008  f7fffffe          BL       _check_tx_status
;;;139            outw(UART_PORT[port_no]+SERIAL_THR,Ch);
00000c  4d06              LDR      r5,|L20.40|
00000e  f8550024          LDR      r0,[r5,r4,LSL #2]
000012  6003              STR      r3,[r0,#0]
;;;140        }
;;;141    
;;;142        if (Ch == '\n')
000014  2b0a              CMP      r3,#0xa
000016  d106              BNE      |L20.38|
;;;143        {
;;;144            _check_tx_status(port_no);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       _check_tx_status
;;;145            outw(UART_PORT[port_no]+SERIAL_THR,'\r');
00001e  f8551024          LDR      r1,[r5,r4,LSL #2]
000022  200d              MOVS     r0,#0xd
000024  6008              STR      r0,[r1,#0]
                  |L20.38|
;;;146        }
;;;147    }
000026  bd30              POP      {r4,r5,pc}
;;;148    
                          ENDP

                  |L20.40|
                          DCD      ||.data||+0x38

                          AREA ||i.kdp_putstr||, CODE, READONLY, ALIGN=1

                  kdp_putstr PROC
;;;148    
;;;149    void kdp_putstr(DRVUART_PORT port_no, char *str)
000000  b530              PUSH     {r4,r5,lr}
;;;150    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;151        char *cp;
;;;152        for(cp = str; *cp != 0; cp++)
000006  e003              B        |L21.16|
                  |L21.8|
;;;153            kdp_putchar(port_no, *cp);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       kdp_putchar
00000e  1c64              ADDS     r4,r4,#1
                  |L21.16|
000010  7821              LDRB     r1,[r4,#0]            ;152
000012  2900              CMP      r1,#0                 ;152
000014  d1f8              BNE      |L21.8|
;;;154    }
000016  bd30              POP      {r4,r5,pc}
;;;155    
                          ENDP


                          AREA ||i.kdp_serial_init||, CODE, READONLY, ALIGN=2

                  kdp_serial_init PROC
;;;168    }
;;;169    void kdp_serial_init (DRVUART_PORT port_no, UINT32 baudrate, UINT32 parity,UINT32 num,UINT32 len, UINT32 interruptMode)
000000  b5f0              PUSH     {r4-r7,lr}
;;;170    {
;;;171        UINT32 lcr;
;;;172    
;;;173        lcr = inw(UART_PORT[port_no] + SERIAL_LCR) & ~SERIAL_LCR_DLAB;
000002  4d1c              LDR      r5,|L22.116|
000004  e9dd4e05          LDRD     r4,lr,[sp,#0x14]      ;170
000008  f8556020          LDR      r6,[r5,r0,LSL #2]
00000c  68f7              LDR      r7,[r6,#0xc]
;;;174        // kdp_printf("uart fifo depth=%u\n", inw(UART_PORT[port_no] + SERIAL_FEATURE)  & 0xF);
;;;175        /* Set DLAB=1 */
;;;176        outw(UART_PORT[port_no] + SERIAL_LCR,SERIAL_LCR_DLAB);
00000e  f04f0c80          MOV      r12,#0x80
000012  f8c6c00c          STR      r12,[r6,#0xc]
;;;177        /* Set baud rate */
;;;178        outw(UART_PORT[port_no] + SERIAL_DLM, ((baudrate & 0xff00) >> 8)); //ycmo090930
000016  f855c020          LDR      r12,[r5,r0,LSL #2]
00001a  f3c12607          UBFX     r6,r1,#8,#8
00001e  f8cc6004          STR      r6,[r12,#4]
;;;179        outw(UART_PORT[port_no] + SERIAL_DLL, (baudrate & 0xff));
000022  f8556020          LDR      r6,[r5,r0,LSL #2]
000026  b2c9              UXTB     r1,r1
000028  6031              STR      r1,[r6,#0]
;;;180        // outw(UART_PORT[port_no] + SERIAL_DLM, 0x0); //ycmo090930 0x0
;;;181        // outw(UART_PORT[port_no] + SERIAL_DLL, 0x10);  //legend: 0xD
;;;182        //while(1);
;;;183        //clear orignal parity setting
;;;184        lcr &= 0xc0;
00002a  f0070140          AND      r1,r7,#0x40
;;;185    
;;;186        switch (parity)
00002e  2a05              CMP      r2,#5
000030  d20f              BCS      |L22.82|
000032  e8dff002          TBB      [pc,r2]
000036  0e03              DCB      0x0e,0x03
000038  06090c00          DCB      0x06,0x09,0x0c,0x00
;;;187        {
;;;188            case PARITY_NONE:
;;;189                //do nothing
;;;190                break;
;;;191            case PARITY_ODD:
;;;192                lcr|=SERIAL_LCR_ODD;
00003c  f0410108          ORR      r1,r1,#8
;;;193                    break;
000040  e007              B        |L22.82|
;;;194            case PARITY_EVEN:
;;;195                lcr|=SERIAL_LCR_EVEN;
000042  f0410118          ORR      r1,r1,#0x18
;;;196                break;
000046  e004              B        |L22.82|
;;;197            case PARITY_MARK:
;;;198                lcr|=(SERIAL_LCR_STICKPARITY|SERIAL_LCR_ODD);
000048  f0410128          ORR      r1,r1,#0x28
;;;199                break;
00004c  e001              B        |L22.82|
;;;200            case PARITY_SPACE:
;;;201                lcr|=(SERIAL_LCR_STICKPARITY|SERIAL_LCR_EVEN);
00004e  f0410138          ORR      r1,r1,#0x38
                  |L22.82|
;;;202                break;
;;;203    
;;;204            default:
;;;205                break;
;;;206        }
;;;207    
;;;208        if(num==2)
000052  2b02              CMP      r3,#2
000054  d101              BNE      |L22.90|
;;;209            lcr|=SERIAL_LCR_STOP;
000056  f0410104          ORR      r1,r1,#4
                  |L22.90|
;;;210    
;;;211        len-=5;
;;;212    
;;;213        lcr|=len;
;;;214    
;;;215        outw(UART_PORT[port_no]+SERIAL_LCR,lcr);
00005a  f8552020          LDR      r2,[r5,r0,LSL #2]
00005e  1f64              SUBS     r4,r4,#5              ;209
000060  4321              ORRS     r1,r1,r4              ;213
000062  60d1              STR      r1,[r2,#0xc]
;;;216        if (1 == interruptMode)
000064  f1be0f01          CMP      lr,#1
000068  d103              BNE      |L22.114|
;;;217            outw(UART_PORT[port_no] + SERIAL_FCR, SERIAL_FCR_FE);
00006a  f8550020          LDR      r0,[r5,r0,LSL #2]
00006e  2101              MOVS     r1,#1
000070  6081              STR      r1,[r0,#8]
                  |L22.114|
;;;218    }
000072  bdf0              POP      {r4-r7,pc}
;;;219    void kdp_set_serial_int(DRVUART_PORT port_no, UINT32 IntMask)
                          ENDP

                  |L22.116|
                          DCD      ||.data||+0x38

                          AREA ||i.kdp_set_serial_int||, CODE, READONLY, ALIGN=2

                  kdp_set_serial_int PROC
;;;218    }
;;;219    void kdp_set_serial_int(DRVUART_PORT port_no, UINT32 IntMask)
000000  4a02              LDR      r2,|L23.12|
;;;220    {
;;;221        outw(UART_PORT[port_no] + SERIAL_IER, IntMask);
000002  f8520020          LDR      r0,[r2,r0,LSL #2]
000006  6041              STR      r1,[r0,#4]
;;;222    }
000008  4770              BX       lr
;;;223    int kdp_gets(DRVUART_PORT port_no, char *buf)
                          ENDP

00000a  0000              DCW      0x0000
                  |L23.12|
                          DCD      ||.data||+0x38

                          AREA ||i.kdp_uart_GetReadIndex||, CODE, READONLY, ALIGN=2

                  kdp_uart_GetReadIndex PROC
;;;1703   
;;;1704   uint32_t kdp_uart_GetReadIndex(kdp_uart_hdl_t handle)
000000  2805              CMP      r0,#5
;;;1705   {
000002  d208              BCS      |L24.22|
;;;1706       uint32_t com_port = handle;
;;;1707   
;;;1708       if (com_port >= TOTAL_UART_DEV) {
;;;1709           //dbg_msg("Invalid parameter\n");
;;;1710           return UART_API_INVALID_PARAM;
;;;1711       }
;;;1712   
;;;1713       if (gDrvCtx.active_dev[com_port] == FALSE)
000004  4905              LDR      r1,|L24.28|
000006  180a              ADDS     r2,r1,r0
000008  7852              LDRB     r2,[r2,#1]
00000a  b122              CBZ      r2,|L24.22|
;;;1714       {
;;;1715           //dbg_msg("This UART device is not active\n");
;;;1716           return UART_API_INVALID_PARAM;
;;;1717       }
;;;1718   
;;;1719       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
00000c  eb010080          ADD      r0,r1,r0,LSL #2
000010  6880              LDR      r0,[r0,#8]
;;;1720       return pDrv->info.xfer.read_idx;
000012  6c00              LDR      r0,[r0,#0x40]
;;;1721   }
000014  4770              BX       lr
                  |L24.22|
000016  2008              MOVS     r0,#8                 ;1716
000018  4770              BX       lr
;;;1722   
                          ENDP

00001a  0000              DCW      0x0000
                  |L24.28|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_GetRxBufSize||, CODE, READONLY, ALIGN=2

                  kdp_uart_GetRxBufSize PROC
;;;1665   
;;;1666   uint32_t kdp_uart_GetRxBufSize(kdp_uart_hdl_t handle)
000000  2805              CMP      r0,#5
;;;1667   {
000002  d208              BCS      |L25.22|
;;;1668       uint32_t com_port = handle;
;;;1669   
;;;1670       if (com_port >= TOTAL_UART_DEV) {
;;;1671           //dbg_msg("Invalid parameter\n");
;;;1672           return UART_API_INVALID_PARAM;
;;;1673       }
;;;1674   
;;;1675       if (gDrvCtx.active_dev[com_port] == FALSE)
000004  4905              LDR      r1,|L25.28|
000006  180a              ADDS     r2,r1,r0
000008  7852              LDRB     r2,[r2,#1]
00000a  b122              CBZ      r2,|L25.22|
;;;1676       {
;;;1677           //dbg_msg("This UART device is not active\n");
;;;1678           return UART_API_INVALID_PARAM;
;;;1679       }
;;;1680   
;;;1681       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
00000c  eb010080          ADD      r0,r1,r0,LSL #2
000010  6880              LDR      r0,[r0,#8]
;;;1682       return pDrv->info.xfer.rx_num;
000012  6a40              LDR      r0,[r0,#0x24]
;;;1683   }
000014  4770              BX       lr
                  |L25.22|
000016  2008              MOVS     r0,#8                 ;1678
000018  4770              BX       lr
;;;1684   
                          ENDP

00001a  0000              DCW      0x0000
                  |L25.28|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_GetRxCount||, CODE, READONLY, ALIGN=2

                  kdp_uart_GetRxCount PROC
;;;1616   */
;;;1617   uint32_t kdp_uart_GetRxCount(kdp_uart_hdl_t handle)
000000  2805              CMP      r0,#5
;;;1618   {
000002  d208              BCS      |L26.22|
;;;1619       uint32_t data;
;;;1620       uint32_t com_port = handle;
;;;1621   
;;;1622       if (com_port >= TOTAL_UART_DEV) {
;;;1623           //dbg_msg("Invalid parameter\n");
;;;1624           return UART_API_INVALID_PARAM;
;;;1625       }
;;;1626   
;;;1627       if (gDrvCtx.active_dev[com_port] == FALSE)
000004  4905              LDR      r1,|L26.28|
000006  180a              ADDS     r2,r1,r0
000008  7852              LDRB     r2,[r2,#1]
00000a  b122              CBZ      r2,|L26.22|
;;;1628       {
;;;1629           //dbg_msg("This UART device is not active\n");
;;;1630           return UART_API_INVALID_PARAM;
;;;1631       }
;;;1632   
;;;1633       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
00000c  eb010080          ADD      r0,r1,r0,LSL #2
000010  6880              LDR      r0,[r0,#8]
;;;1634       data = pDrv->info.xfer.rx_cnt;
000012  6b40              LDR      r0,[r0,#0x34]
;;;1635       return data;
;;;1636   }
000014  4770              BX       lr
                  |L26.22|
000016  2008              MOVS     r0,#8                 ;1630
000018  4770              BX       lr
;;;1637   
                          ENDP

00001a  0000              DCW      0x0000
                  |L26.28|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_GetTxCount||, CODE, READONLY, ALIGN=2

                  kdp_uart_GetTxCount PROC
;;;1643   */
;;;1644   uint32_t kdp_uart_GetTxCount(kdp_uart_hdl_t handle)
000000  2805              CMP      r0,#5
;;;1645   {
000002  d208              BCS      |L27.22|
;;;1646       uint32_t data;
;;;1647       uint32_t com_port = handle;
;;;1648   
;;;1649       if (com_port >= TOTAL_UART_DEV) {
;;;1650           //dbg_msg("Invalid parameter\n");
;;;1651           return UART_API_INVALID_PARAM;
;;;1652       }
;;;1653   
;;;1654       if (gDrvCtx.active_dev[com_port] == FALSE)
000004  4905              LDR      r1,|L27.28|
000006  180a              ADDS     r2,r1,r0
000008  7852              LDRB     r2,[r2,#1]
00000a  b122              CBZ      r2,|L27.22|
;;;1655       {
;;;1656           //dbg_msg("This UART device is not active\n");
;;;1657           return UART_API_INVALID_PARAM;
;;;1658       }
;;;1659   
;;;1660       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
00000c  eb010080          ADD      r0,r1,r0,LSL #2
000010  6880              LDR      r0,[r0,#8]
;;;1661       data = pDrv->info.xfer.tx_cnt;
000012  6b80              LDR      r0,[r0,#0x38]
;;;1662       return data;
;;;1663   
;;;1664   }
000014  4770              BX       lr
                  |L27.22|
000016  2008              MOVS     r0,#8                 ;1657
000018  4770              BX       lr
;;;1665   
                          ENDP

00001a  0000              DCW      0x0000
                  |L27.28|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_GetWriteIndex||, CODE, READONLY, ALIGN=2

                  kdp_uart_GetWriteIndex PROC
;;;1684   
;;;1685   uint32_t kdp_uart_GetWriteIndex(kdp_uart_hdl_t handle)
000000  2805              CMP      r0,#5
;;;1686   {
000002  d208              BCS      |L28.22|
;;;1687       uint32_t com_port = handle;
;;;1688   
;;;1689       if (com_port >= TOTAL_UART_DEV) {
;;;1690           //dbg_msg("Invalid parameter\n");
;;;1691           return UART_API_INVALID_PARAM;
;;;1692       }
;;;1693   
;;;1694       if (gDrvCtx.active_dev[com_port] == FALSE)
000004  4905              LDR      r1,|L28.28|
000006  180a              ADDS     r2,r1,r0
000008  7852              LDRB     r2,[r2,#1]
00000a  b122              CBZ      r2,|L28.22|
;;;1695       {
;;;1696           //dbg_msg("This UART device is not active\n");
;;;1697           return UART_API_INVALID_PARAM;
;;;1698       }
;;;1699   
;;;1700       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
00000c  eb010080          ADD      r0,r1,r0,LSL #2
000010  6880              LDR      r0,[r0,#8]
;;;1701       return pDrv->info.xfer.write_idx;
000012  6bc0              LDR      r0,[r0,#0x3c]
;;;1702   }
000014  4770              BX       lr
                  |L28.22|
000016  2008              MOVS     r0,#8                 ;1697
000018  4770              BX       lr
;;;1703   
                          ENDP

00001a  0000              DCW      0x0000
                  |L28.28|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_SetReadIndex||, CODE, READONLY, ALIGN=2

                  kdp_uart_SetReadIndex PROC
;;;1742   
;;;1743   uint32_t kdp_uart_SetReadIndex(kdp_uart_hdl_t handle, uint32_t index)
000000  2805              CMP      r0,#5
;;;1744   {
000002  d209              BCS      |L29.24|
;;;1745       uint32_t com_port = handle;
;;;1746   
;;;1747       if (com_port >= TOTAL_UART_DEV) {
;;;1748           //dbg_msg("Invalid parameter\n");
;;;1749           return UART_API_INVALID_PARAM;
;;;1750       }
;;;1751   
;;;1752       if (gDrvCtx.active_dev[com_port] == FALSE)
000004  4a05              LDR      r2,|L29.28|
000006  1813              ADDS     r3,r2,r0
000008  785b              LDRB     r3,[r3,#1]
00000a  b12b              CBZ      r3,|L29.24|
;;;1753       {
;;;1754           //dbg_msg("This UART device is not active\n");
;;;1755           return UART_API_INVALID_PARAM;
;;;1756       }
;;;1757   
;;;1758       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
00000c  eb020080          ADD      r0,r2,r0,LSL #2
000010  6880              LDR      r0,[r0,#8]
;;;1759       pDrv->info.xfer.read_idx = index;
000012  6401              STR      r1,[r0,#0x40]
;;;1760       return UART_API_RETURN_SUCCESS;
000014  2000              MOVS     r0,#0
;;;1761   }
000016  4770              BX       lr
                  |L29.24|
000018  2008              MOVS     r0,#8                 ;1755
00001a  4770              BX       lr
;;;1762   
                          ENDP

                  |L29.28|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_SetWriteIndex||, CODE, READONLY, ALIGN=2

                  kdp_uart_SetWriteIndex PROC
;;;1722   
;;;1723   uint32_t kdp_uart_SetWriteIndex(kdp_uart_hdl_t handle, uint32_t index)
000000  2805              CMP      r0,#5
;;;1724   {
000002  d209              BCS      |L30.24|
;;;1725       uint32_t com_port = handle;
;;;1726   
;;;1727       if (com_port >= TOTAL_UART_DEV) {
;;;1728           //dbg_msg("Invalid parameter\n");
;;;1729           return UART_API_INVALID_PARAM;
;;;1730       }
;;;1731   
;;;1732       if (gDrvCtx.active_dev[com_port] == FALSE)
000004  4a05              LDR      r2,|L30.28|
000006  1813              ADDS     r3,r2,r0
000008  785b              LDRB     r3,[r3,#1]
00000a  b12b              CBZ      r3,|L30.24|
;;;1733       {
;;;1734           //dbg_msg("This UART device is not active\n");
;;;1735           return UART_API_INVALID_PARAM;
;;;1736       }
;;;1737   
;;;1738       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
00000c  eb020080          ADD      r0,r2,r0,LSL #2
000010  6880              LDR      r0,[r0,#8]
;;;1739       pDrv->info.xfer.write_idx = index;
000012  63c1              STR      r1,[r0,#0x3c]
;;;1740       return UART_API_RETURN_SUCCESS;
000014  2000              MOVS     r0,#0
;;;1741   }
000016  4770              BX       lr
                  |L30.24|
000018  2008              MOVS     r0,#8                 ;1735
00001a  4770              BX       lr
;;;1742   
                          ENDP

                  |L30.28|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_close||, CODE, READONLY, ALIGN=2

                  kdp_uart_close PROC
;;;820    */
;;;821    int32_t kdp_uart_close(kdp_uart_hdl_t handle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;822    {
;;;823        uint32_t com_port = handle;
000004  4601              MOV      r1,r0
;;;824    
;;;825        if (com_port >= TOTAL_UART_DEV) {
;;;826            //dbg_msg("Invalid parameter\n");
;;;827            return UART_FAIL;
000006  f04f30ff          MOV      r0,#0xffffffff
00000a  2905              CMP      r1,#5                 ;825
00000c  d20b              BCS      |L31.38|
;;;828        }
;;;829    
;;;830        if (gDrvCtx.active_dev[com_port] == FALSE)
00000e  4c0d              LDR      r4,|L31.68|
000010  1866              ADDS     r6,r4,r1
000012  7872              LDRB     r2,[r6,#1]
000014  2a00              CMP      r2,#0
000016  d006              BEQ      |L31.38|
;;;831        {
;;;832            //dbg_msg("This UART device has been closed\n");
;;;833            return UART_FAIL;
;;;834        }
;;;835    
;;;836        kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
000018  eb040581          ADD      r5,r4,r1,LSL #2
;;;837    
;;;838        if ((pDrv->info.flags & UART_POWERED) == 0)
00001c  68a8              LDR      r0,[r5,#8]
00001e  6c41              LDR      r1,[r0,#0x44]
000020  078a              LSLS     r2,r1,#30
000022  d402              BMI      |L31.42|
;;;839        {
;;;840            // UART is not powered 
;;;841            return UART_API_NOT_POWRERED;
000024  2001              MOVS     r0,#1
                  |L31.38|
;;;842        }
;;;843    
;;;844        if (pDrv->info.flags == 0) {
;;;845            // Driver not initialized
;;;846            return UART_SUCCESS;
;;;847        }
;;;848    
;;;849        // Reset USART status flags
;;;850        pDrv->info.flags = 0;
;;;851    
;;;852        free(gDrvCtx.uart_dev[com_port]);
;;;853        gDrvCtx.uart_dev[com_port] = NULL;
;;;854        gDrvCtx.active_dev[com_port] = FALSE;
;;;855        gDrvCtx.total_open_uarts--;
;;;856        return UART_SUCCESS;
;;;857    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L31.42|
00002a  b149              CBZ      r1,|L31.64|
00002c  2700              MOVS     r7,#0                 ;850
00002e  6447              STR      r7,[r0,#0x44]         ;852
000030  68a8              LDR      r0,[r5,#8]            ;852
000032  f7fffffe          BL       free
000036  60af              STR      r7,[r5,#8]            ;854
000038  7077              STRB     r7,[r6,#1]            ;854
00003a  7820              LDRB     r0,[r4,#0]            ;855  ; gDrvCtx
00003c  1e40              SUBS     r0,r0,#1              ;855
00003e  7020              STRB     r0,[r4,#0]            ;855
                  |L31.64|
000040  2000              MOVS     r0,#0                 ;846
000042  e7f0              B        |L31.38|
;;;858    
                          ENDP

                  |L31.68|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_control||, CODE, READONLY, ALIGN=2

                  kdp_uart_control PROC
;;;895    */
;;;896    int32_t kdp_uart_control(kdp_uart_hdl_t handle, kdp_uart_ctrl_t prop, uint8_t *pVal)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;897    {
;;;898        uint32_t com_port = handle;
000004  4603              MOV      r3,r0
;;;899    
;;;900        if (com_port >= TOTAL_UART_DEV) {
;;;901            //dbg_msg("Invalid parameter\n");
;;;902            return UART_FAIL;
000006  f04f30ff          MOV      r0,#0xffffffff
00000a  2b05              CMP      r3,#5                 ;900
00000c  d20b              BCS      |L32.38|
;;;903        }
;;;904    
;;;905        if (gDrvCtx.active_dev[com_port] == FALSE)
00000e  4c75              LDR      r4,|L32.484|
000010  18e5              ADDS     r5,r4,r3
000012  786d              LDRB     r5,[r5,#1]
000014  2d00              CMP      r5,#0
000016  d006              BEQ      |L32.38|
;;;906        {
;;;907            //dbg_msg("This UART device has been closed\n");
;;;908            return UART_FAIL;
;;;909        }
;;;910    
;;;911        kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
000018  eb040083          ADD      r0,r4,r3,LSL #2
;;;912    
;;;913        if ((pDrv->info.flags & UART_POWERED) == 0)
00001c  6884              LDR      r4,[r0,#8]
00001e  6c60              LDR      r0,[r4,#0x44]
000020  0783              LSLS     r3,r0,#30
000022  d402              BMI      |L32.42|
;;;914        {
;;;915            // UART is not powered 
;;;916            return UART_API_NOT_POWRERED;
000024  2001              MOVS     r0,#1
                  |L32.38|
;;;917        }
;;;918    
;;;919        if ((pDrv->info.flags & UART_INITIALIZED) == 0) {
;;;920            // Return error, if USART is not initialized
;;;921            return UART_API_ERROR;
;;;922        }
;;;923    
;;;924        DRVUART_PORT port_no = (DRVUART_PORT)pDrv->uart_port;
;;;925        switch (prop)
;;;926        {
;;;927        case UART_CTRL_CONFIG:
;;;928        {
;;;929            KDP_UART_CONFIG_t cfg = *(KDP_UART_CONFIG_t *)pVal;
;;;930            UINT32 baudrate = cfg.baudrate;
;;;931            UINT32 parity = cfg.parity_mode;
;;;932            UINT32 num = cfg.stop_bits;
;;;933            UINT32 len = cfg.data_bits;
;;;934    
;;;935            kdp_serial_init(port_no, baudrate, parity, num, len, 0);
;;;936    
;;;937            pDrv->config.baudrate = baudrate;
;;;938            pDrv->config.data_bits = cfg.data_bits;
;;;939            pDrv->config.stop_bits = num;
;;;940            pDrv->config.parity_mode = parity;
;;;941            pDrv->config.fifo_en = cfg.fifo_en;
;;;942    
;;;943            pDrv->res.tx_fifo_threshold = 0;
;;;944            pDrv->res.rx_fifo_threshold = 0;
;;;945    
;;;946            pDrv->nTimeOutTx = kdp_uart_get_default_timeout(baudrate);
;;;947            pDrv->nTimeOutRx = kdp_uart_get_default_timeout(baudrate);
;;;948    
;;;949            pDrv->info.flags |= UART_BASIC_CONFIGURED;
;;;950    
;;;951            pDrv->state = UART_INIT_DONE;
;;;952            break;
;;;953        }
;;;954    
;;;955        case UART_CTRL_TX_EN:
;;;956        {
;;;957            uint32_t ww = inw(UART_PORT[port_no] + SERIAL_IER);
;;;958            if (*pVal == 0)
;;;959            {
;;;960                ww &= ~SERIAL_IER_TE;                    // disable TX
;;;961                outw(UART_PORT[port_no] + SERIAL_IER, ww);
;;;962                pDrv->info.flags &= ~UART_TX_ENABLED;
;;;963            }
;;;964            else
;;;965            {
;;;966                ww |= SERIAL_IER_TE;                    // enable TX
;;;967                outw(UART_PORT[port_no] + SERIAL_IER, ww);
;;;968                pDrv->info.flags |= UART_TX_ENABLED;
;;;969            }
;;;970    
;;;971            break;
;;;972        }
;;;973    
;;;974        case UART_CTRL_RX_EN:
;;;975        {
;;;976            uint32_t ww = inw(UART_PORT[port_no] + SERIAL_IER);
;;;977            if (*pVal == 0)
;;;978            {
;;;979                ww &= ~SERIAL_IER_DR;                    // disable Rx
;;;980                outw(UART_PORT[port_no] + SERIAL_IER, ww);
;;;981                pDrv->info.flags &= ~UART_RX_ENABLED;
;;;982            }
;;;983            else
;;;984            {
;;;985                ww |= SERIAL_IER_DR;                    // enable Rx
;;;986                outw(UART_PORT[port_no] + SERIAL_IER, ww);
;;;987                pDrv->info.flags |= UART_RX_ENABLED;
;;;988            }
;;;989    
;;;990            break;
;;;991        }
;;;992    
;;;993        case UART_CTRL_ABORT_TX:
;;;994        {
;;;995            /* disable Tx interrupt */
;;;996            uint32_t ww = inw(UART_PORT[port_no] + SERIAL_IER);
;;;997            ww &= ~SERIAL_IER_TE;
;;;998            outw(UART_PORT[port_no] + SERIAL_IER, ww);
;;;999    
;;;1000           /* reset Tx FIFO */
;;;1001           ww = inw(UART_PORT[port_no] + SERIAL_FCR);
;;;1002           ww |= (SERIAL_FCR_TXFR | SERIAL_FCR_FE);
;;;1003           outw(UART_PORT[port_no] + SERIAL_FCR, ww);
;;;1004   
;;;1005           pDrv->info.status.tx_busy = 0;
;;;1006   
;;;1007           break;
;;;1008       }
;;;1009   
;;;1010       case UART_CTRL_ABORT_RX:
;;;1011       {
;;;1012           /* disable Rx interrupt */
;;;1013           uint32_t ww = inw(UART_PORT[port_no] + SERIAL_IER);
;;;1014           ww &= ~SERIAL_IER_DR;
;;;1015           outw(UART_PORT[port_no] + SERIAL_IER, ww);
;;;1016   
;;;1017           /* reset Rx FIFO */
;;;1018           ww = inw(UART_PORT[port_no] + SERIAL_FCR);
;;;1019           ww |= (SERIAL_FCR_RXFR | SERIAL_FCR_FE);
;;;1020           outw(UART_PORT[port_no] + SERIAL_FCR, ww);
;;;1021   
;;;1022           pDrv->info.status.rx_busy = 0;
;;;1023   
;;;1024           break;
;;;1025       }
;;;1026   
;;;1027       case UART_CTRL_FIFO_RX:
;;;1028       {
;;;1029           uint32_t ww;
;;;1030           kdp_uart_fifo_cfg_t *pCfg = (kdp_uart_fifo_cfg_t *)pVal;
;;;1031           uint8_t trig_lvl = 0x3 & pCfg->fifo_trig_level;
;;;1032   
;;;1033           pDrv->res.rx_fifo_threshold = trig_lvl;
;;;1034   
;;;1035           if (pCfg->bEnFifo) {
;;;1036               ww = inw(UART_PORT[port_no] + SERIAL_FCR);
;;;1037               ww &= ~(0x3 << 6);
;;;1038               ww |= (trig_lvl << 6) | SERIAL_FCR_RXFR | SERIAL_FCR_FE;  // val + reset + enable
;;;1039               outw(UART_PORT[port_no] + SERIAL_FCR, ww);
;;;1040           }
;;;1041           else {
;;;1042               /*
;;;1043                 becasue RX/TX FIFO can only be enable/disabled simutanously,
;;;1044                 cannot be set individually, so set trigger val to 0 for FIFO disable
;;;1045               */
;;;1046               ww = inw(UART_PORT[port_no] + SERIAL_FCR);
;;;1047               ww &= ~(0x3 << 6);
;;;1048               ww |= (0 << 6) | SERIAL_FCR_RXFR | SERIAL_FCR_FE;  // val + reset + enable
;;;1049               outw(UART_PORT[port_no] + SERIAL_FCR, ww);
;;;1050           }
;;;1051   
;;;1052           pDrv->info.flags |= UART_FIFO_RX_CONFIGURED;
;;;1053   
;;;1054           break;
;;;1055       }
;;;1056   
;;;1057       case UART_CTRL_FIFO_TX:
;;;1058       {
;;;1059           uint32_t ww;
;;;1060           kdp_uart_fifo_cfg_t *pCfg = (kdp_uart_fifo_cfg_t *)pVal;
;;;1061           uint8_t trig_lvl = 0x3 & pCfg->fifo_trig_level;
;;;1062   
;;;1063           pDrv->res.tx_fifo_threshold = trig_lvl;
;;;1064   
;;;1065           if (pCfg->bEnFifo) {
;;;1066               ww = inw(UART_PORT[port_no] + SERIAL_FCR);
;;;1067               ww &= ~(0x3 << 4);
;;;1068               ww |= (trig_lvl << 4) | SERIAL_FCR_TXFR | SERIAL_FCR_FE;  // val + reset + enable
;;;1069               outw(UART_PORT[port_no] + SERIAL_FCR, ww);
;;;1070           }
;;;1071           else
;;;1072           {
;;;1073               /*
;;;1074                 becasue RX/TX FIFO can only be enable/disabled simutanously,
;;;1075                 cannot be set individually, so set trigger val to 0 for FIFO disable
;;;1076               */
;;;1077               ww = inw(UART_PORT[port_no] + SERIAL_FCR);
;;;1078               ww &= ~(0x3 << 4);
;;;1079               ww |= (0 << 4) | SERIAL_FCR_TXFR | SERIAL_FCR_FE;  // val + reset + enable
;;;1080               outw(UART_PORT[port_no] + SERIAL_FCR, ww);
;;;1081           }
;;;1082   
;;;1083           pDrv->info.flags |= UART_FIFO_TX_CONFIGURED;
;;;1084   
;;;1085           break;
;;;1086       }
;;;1087   
;;;1088       case UART_CTRL_LOOPBACK:
;;;1089       {
;;;1090           uint32_t ww = inw(UART_PORT[port_no] + SERIAL_MCR);
;;;1091           if (*pVal == 0)
;;;1092           {
;;;1093               ww &= ~SERIAL_MCR_LPBK;                    // disable loopback
;;;1094               outw(UART_PORT[port_no] + SERIAL_MCR, ww);
;;;1095           }
;;;1096           else
;;;1097           {
;;;1098               ww |= SERIAL_MCR_LPBK;                    // enable loopback
;;;1099               outw(UART_PORT[port_no] + SERIAL_MCR, ww);
;;;1100           }
;;;1101   
;;;1102           pDrv->info.flags |= UART_LOOPBACK_ENABLED;
;;;1103   
;;;1104           break;
;;;1105       }
;;;1106   
;;;1107       case UART_CTRL_RTS_EN:
;;;1108       {
;;;1109           uint32_t ww = inw(UART_PORT[port_no] + SERIAL_MCR);
;;;1110           if (*pVal == 0)
;;;1111           {
;;;1112               ww &= ~SERIAL_MCR_RTS;                    // disable RTS
;;;1113               outw(UART_PORT[port_no] + SERIAL_MCR, ww);
;;;1114           }
;;;1115           else
;;;1116           {
;;;1117               ww |= SERIAL_MCR_RTS;                    // enable RTS
;;;1118               outw(UART_PORT[port_no] + SERIAL_MCR, ww);
;;;1119           }
;;;1120   
;;;1121           break;
;;;1122       }
;;;1123   
;;;1124       case UART_CTRL_DTR_EN:
;;;1125       {
;;;1126           uint32_t ww = inw(UART_PORT[port_no] + SERIAL_MCR);
;;;1127           if (*pVal == 0)
;;;1128           {
;;;1129               ww &= ~SERIAL_MCR_DTR;                    // disable DTR
;;;1130               outw(UART_PORT[port_no] + SERIAL_MCR, ww);
;;;1131           }
;;;1132           else
;;;1133           {
;;;1134               ww |= SERIAL_MCR_DTR;                    // enable DTR
;;;1135               outw(UART_PORT[port_no] + SERIAL_MCR, ww);
;;;1136           }
;;;1137   
;;;1138           break;
;;;1139       }
;;;1140   
;;;1141       case UART_CTRL_TIMEOUT_RX:
;;;1142       {
;;;1143           pDrv->nTimeOutRx = (int32_t)*pVal;
;;;1144   
;;;1145           break;
;;;1146       }
;;;1147   
;;;1148       case UART_CTRL_TIMEOUT_TX:
;;;1149       {
;;;1150           pDrv->nTimeOutTx = (int32_t)*pVal;
;;;1151   
;;;1152           break;
;;;1153       }
;;;1154   
;;;1155       default:
;;;1156   			break;
;;;1157       }
;;;1158       return UART_API_RETURN_SUCCESS;
;;;1159   }
000026  e8bd87fc          POP      {r2-r10,pc}
                  |L32.42|
00002a  07c0              LSLS     r0,r0,#31             ;919
00002c  d00d              BEQ      |L32.74|
00002e  f894c000          LDRB     r12,[r4,#0]           ;924
000032  2500              MOVS     r5,#0                 ;924
000034  486c              LDR      r0,|L32.488|
000036  290c              CMP      r1,#0xc               ;925
000038  d233              BCS      |L32.162|
00003a  e8dff001          TBB      [pc,r1]               ;925
00003e  0876              DCB      0x08,0x76
000040  8ea63346          DCB      0x8e,0xa6,0x33,0x46
000044  b5c05a68          DCB      0xb5,0xc0,0x5a,0x68
000048  cccf              DCB      0xcc,0xcf
                  |L32.74|
00004a  2010              MOVS     r0,#0x10              ;921
00004c  e7eb              B        |L32.38|
00004e  e9d26000          LDRD     r6,r0,[r2,#0]
000052  f892a008          LDRB     r10,[r2,#8]           ;929
000056  f3c04107          UBFX     r1,r0,#16,#8          ;929
00005a  b2c7              UXTB     r7,r0                 ;932
00005c  ea4f6910          LSR      r9,r0,#24             ;929
000060  e9cd7500          STRD     r7,r5,[sp,#0]         ;935
000064  4688              MOV      r8,r1                 ;932
000066  460b              MOV      r3,r1                 ;935
000068  464a              MOV      r2,r9                 ;935
00006a  4631              MOV      r1,r6                 ;935
00006c  4660              MOV      r0,r12                ;935
00006e  f7fffffe          BL       kdp_serial_init
000072  60e6              STR      r6,[r4,#0xc]          ;938
000074  7427              STRB     r7,[r4,#0x10]         ;938
000076  f8848012          STRB     r8,[r4,#0x12]         ;939
00007a  f8849013          STRB     r9,[r4,#0x13]         ;940
00007e  f884a014          STRB     r10,[r4,#0x14]        ;941
000082  65a5              STR      r5,[r4,#0x58]         ;944
000084  4630              MOV      r0,r6                 ;946
000086  65e5              STR      r5,[r4,#0x5c]         ;946
000088  f7fffffe          BL       kdp_uart_get_default_timeout
00008c  66e0              STR      r0,[r4,#0x6c]         ;947
00008e  4630              MOV      r0,r6                 ;947
000090  f7fffffe          BL       kdp_uart_get_default_timeout
000094  6720              STR      r0,[r4,#0x70]         ;949
000096  6c60              LDR      r0,[r4,#0x44]         ;949
000098  f0400004          ORR      r0,r0,#4              ;949
00009c  6460              STR      r0,[r4,#0x44]         ;951
00009e  2001              MOVS     r0,#1                 ;951
0000a0  7120              STRB     r0,[r4,#4]            ;951
                  |L32.162|
0000a2  e09d              B        |L32.480|
0000a4  f850002c          LDR      r0,[r0,r12,LSL #2]    ;957
0000a8  6841              LDR      r1,[r0,#4]            ;957
0000aa  7812              LDRB     r2,[r2,#0]            ;958
0000ac  b132              CBZ      r2,|L32.188|
0000ae  f0410102          ORR      r1,r1,#2              ;966
0000b2  6041              STR      r1,[r0,#4]            ;967
0000b4  6c60              LDR      r0,[r4,#0x44]         ;968
0000b6  f0400020          ORR      r0,r0,#0x20           ;968
0000ba  e011              B        |L32.224|
                  |L32.188|
0000bc  f0210102          BIC      r1,r1,#2              ;960
0000c0  6041              STR      r1,[r0,#4]            ;961
0000c2  6c60              LDR      r0,[r4,#0x44]         ;962
0000c4  f0200020          BIC      r0,r0,#0x20           ;962
0000c8  e00a              B        |L32.224|
0000ca  f850002c          LDR      r0,[r0,r12,LSL #2]    ;976
0000ce  6841              LDR      r1,[r0,#4]            ;976
0000d0  7812              LDRB     r2,[r2,#0]            ;977
0000d2  b13a              CBZ      r2,|L32.228|
0000d4  f0410101          ORR      r1,r1,#1              ;985
0000d8  6041              STR      r1,[r0,#4]            ;986
0000da  6c60              LDR      r0,[r4,#0x44]         ;987
0000dc  f0400040          ORR      r0,r0,#0x40           ;987
                  |L32.224|
0000e0  6460              STR      r0,[r4,#0x44]         ;981
0000e2  e07d              B        |L32.480|
                  |L32.228|
0000e4  f0210101          BIC      r1,r1,#1              ;979
0000e8  6041              STR      r1,[r0,#4]            ;980
0000ea  6c60              LDR      r0,[r4,#0x44]         ;981
0000ec  f0200040          BIC      r0,r0,#0x40           ;981
0000f0  e7f6              B        |L32.224|
0000f2  f850102c          LDR      r1,[r0,r12,LSL #2]    ;996
0000f6  684a              LDR      r2,[r1,#4]            ;996
0000f8  f0220202          BIC      r2,r2,#2              ;997
0000fc  604a              STR      r2,[r1,#4]            ;998
0000fe  f850002c          LDR      r0,[r0,r12,LSL #2]    ;1001
000102  6881              LDR      r1,[r0,#8]            ;1001
000104  f0410105          ORR      r1,r1,#5              ;1002
000108  6081              STR      r1,[r0,#8]            ;1003
00010a  7725              STRB     r5,[r4,#0x1c]         ;1005
00010c  e068              B        |L32.480|
00010e  f850102c          LDR      r1,[r0,r12,LSL #2]    ;1013
000112  684a              LDR      r2,[r1,#4]            ;1013
000114  f0220201          BIC      r2,r2,#1              ;1014
000118  604a              STR      r2,[r1,#4]            ;1015
00011a  f850002c          LDR      r0,[r0,r12,LSL #2]    ;1018
00011e  6881              LDR      r1,[r0,#8]            ;1018
000120  f0410103          ORR      r1,r1,#3              ;1019
000124  6081              STR      r1,[r0,#8]            ;1020
000126  7765              STRB     r5,[r4,#0x1d]         ;1022
000128  e05a              B        |L32.480|
00012a  7851              LDRB     r1,[r2,#1]            ;1031
00012c  f0010103          AND      r1,r1,#3              ;1031
000130  65e1              STR      r1,[r4,#0x5c]         ;1035
000132  7812              LDRB     r2,[r2,#0]            ;1035
000134  f850002c          LDR      r0,[r0,r12,LSL #2]    ;1046
000138  b12a              CBZ      r2,|L32.326|
00013a  6882              LDR      r2,[r0,#8]            ;1036
00013c  f02202c0          BIC      r2,r2,#0xc0           ;1037
000140  ea421181          ORR      r1,r2,r1,LSL #6       ;1038
000144  e002              B        |L32.332|
                  |L32.326|
000146  6881              LDR      r1,[r0,#8]            ;1046
000148  f02101c0          BIC      r1,r1,#0xc0           ;1047
                  |L32.332|
00014c  f0410103          ORR      r1,r1,#3              ;1048
000150  6081              STR      r1,[r0,#8]            ;1049
000152  6c60              LDR      r0,[r4,#0x44]         ;1052
000154  f0400008          ORR      r0,r0,#8              ;1052
000158  e7c2              B        |L32.224|
00015a  7851              LDRB     r1,[r2,#1]            ;1061
00015c  f0010103          AND      r1,r1,#3              ;1061
000160  65a1              STR      r1,[r4,#0x58]         ;1065
000162  7812              LDRB     r2,[r2,#0]            ;1065
000164  f850002c          LDR      r0,[r0,r12,LSL #2]    ;1077
000168  b12a              CBZ      r2,|L32.374|
00016a  6882              LDR      r2,[r0,#8]            ;1066
00016c  f0220230          BIC      r2,r2,#0x30           ;1067
000170  ea421101          ORR      r1,r2,r1,LSL #4       ;1068
000174  e002              B        |L32.380|
                  |L32.374|
000176  6881              LDR      r1,[r0,#8]            ;1077
000178  f0210130          BIC      r1,r1,#0x30           ;1078
                  |L32.380|
00017c  f0410105          ORR      r1,r1,#5              ;1079
000180  6081              STR      r1,[r0,#8]            ;1080
000182  6c60              LDR      r0,[r4,#0x44]         ;1083
000184  f0400010          ORR      r0,r0,#0x10           ;1083
000188  e7aa              B        |L32.224|
00018a  f850002c          LDR      r0,[r0,r12,LSL #2]    ;1090
00018e  6901              LDR      r1,[r0,#0x10]         ;1090
000190  7812              LDRB     r2,[r2,#0]            ;1091
000192  b132              CBZ      r2,|L32.418|
000194  f0410110          ORR      r1,r1,#0x10           ;1098
                  |L32.408|
000198  6101              STR      r1,[r0,#0x10]         ;1099
00019a  6c60              LDR      r0,[r4,#0x44]         ;1102
00019c  f0400080          ORR      r0,r0,#0x80           ;1102
0001a0  e79e              B        |L32.224|
                  |L32.418|
0001a2  f0210110          BIC      r1,r1,#0x10           ;1093
0001a6  e7f7              B        |L32.408|
0001a8  f850002c          LDR      r0,[r0,r12,LSL #2]    ;1109
0001ac  6901              LDR      r1,[r0,#0x10]         ;1109
0001ae  7812              LDRB     r2,[r2,#0]            ;1110
0001b0  b112              CBZ      r2,|L32.440|
0001b2  f0410102          ORR      r1,r1,#2              ;1117
0001b6  e009              B        |L32.460|
                  |L32.440|
0001b8  f0210102          BIC      r1,r1,#2              ;1112
0001bc  e006              B        |L32.460|
0001be  f850002c          LDR      r0,[r0,r12,LSL #2]    ;1126
0001c2  6901              LDR      r1,[r0,#0x10]         ;1126
0001c4  7812              LDRB     r2,[r2,#0]            ;1127
0001c6  b11a              CBZ      r2,|L32.464|
0001c8  f0410101          ORR      r1,r1,#1              ;1134
                  |L32.460|
0001cc  6101              STR      r1,[r0,#0x10]         ;1130
0001ce  e007              B        |L32.480|
                  |L32.464|
0001d0  f0210101          BIC      r1,r1,#1              ;1129
0001d4  e7fa              B        |L32.460|
0001d6  7810              LDRB     r0,[r2,#0]            ;1143
0001d8  6720              STR      r0,[r4,#0x70]         ;1145
0001da  e001              B        |L32.480|
0001dc  7810              LDRB     r0,[r2,#0]            ;1150
0001de  66e0              STR      r0,[r4,#0x6c]         ;1150
                  |L32.480|
0001e0  2000              MOVS     r0,#0                 ;1158
0001e2  e720              B        |L32.38|
;;;1160   
                          ENDP

                  |L32.484|
                          DCD      ||.bss||
                  |L32.488|
                          DCD      ||.data||+0x38

                          AREA ||i.kdp_uart_get_capability||, CODE, READONLY, ALIGN=2

                  kdp_uart_get_capability PROC
;;;867    
;;;868    KDP_USART_CAPABILITIES * kdp_uart_get_capability(kdp_uart_hdl_t handle)
000000  2805              CMP      r0,#5
;;;869    {
000002  d208              BCS      |L33.22|
;;;870        uint32_t com_port = handle;
;;;871    
;;;872        if (com_port >= TOTAL_UART_DEV) {
;;;873            //dbg_msg("Invalid parameter\n");
;;;874            return NULL;
;;;875        }
;;;876    
;;;877        if (gDrvCtx.active_dev[com_port] == FALSE)
000004  4905              LDR      r1,|L33.28|
000006  180a              ADDS     r2,r1,r0
000008  7852              LDRB     r2,[r2,#1]
00000a  b122              CBZ      r2,|L33.22|
;;;878        {
;;;879            //dbg_msg("This UART device is not active\n");
;;;880            return NULL;
;;;881        }
;;;882    
;;;883        kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
00000c  eb010080          ADD      r0,r1,r0,LSL #2
000010  6880              LDR      r0,[r0,#8]
;;;884        return pDrv->pCap;
000012  6880              LDR      r0,[r0,#8]
;;;885    }
000014  4770              BX       lr
                  |L33.22|
000016  2000              MOVS     r0,#0                 ;880
000018  4770              BX       lr
;;;886    
                          ENDP

00001a  0000              DCW      0x0000
                  |L33.28|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_get_default_timeout||, CODE, READONLY, ALIGN=1

                  kdp_uart_get_default_timeout PROC
;;;269    ************************************************************************************/
;;;270    static int32_t kdp_uart_get_default_timeout(uint32_t baud)
000000  2861              CMP      r0,#0x61
;;;271    {
;;;272        int32_t timeout;
;;;273        switch (baud)
000002  d02b              BEQ      |L34.92|
000004  dc0c              BGT      |L34.32|
000006  2810              CMP      r0,#0x10
000008  d022              BEQ      |L34.80|
00000a  dc04              BGT      |L34.22|
00000c  2802              CMP      r0,#2
00000e  d01b              BEQ      |L34.72|
000010  2804              CMP      r0,#4
000012  d116              BNE      |L34.66|
000014  e01a              B        |L34.76|
                  |L34.22|
000016  2820              CMP      r0,#0x20
000018  d01c              BEQ      |L34.84|
00001a  2830              CMP      r0,#0x30
00001c  d111              BNE      |L34.66|
00001e  e01b              B        |L34.88|
                  |L34.32|
000020  f5b07fc3          CMP      r0,#0x186
000024  d023              BEQ      |L34.110|
000026  dc04              BGT      |L34.50|
000028  2882              CMP      r0,#0x82
00002a  d01a              BEQ      |L34.98|
00002c  28c3              CMP      r0,#0xc3
00002e  d108              BNE      |L34.66|
000030  e01a              B        |L34.104|
                  |L34.50|
000032  f5a07040          SUB      r0,r0,#0x300
000036  380d              SUBS     r0,r0,#0xd
000038  d01c              BEQ      |L34.116|
00003a  f5a07040          SUB      r0,r0,#0x300
00003e  380d              SUBS     r0,r0,#0xd
000040  d01a              BEQ      |L34.120|
                  |L34.66|
;;;274        {
;;;275        case BAUD_921600:
;;;276        {
;;;277            timeout = (DEFAULT_SYNC_TIMEOUT_CHARS_TIME * 100) / 9216;
;;;278            break;
;;;279        }
;;;280        case BAUD_460800:
;;;281        {
;;;282            timeout = (DEFAULT_SYNC_TIMEOUT_CHARS_TIME * 100) / 4608;
;;;283            break;
;;;284        }
;;;285        case BAUD_115200:
;;;286        {
;;;287            timeout = (DEFAULT_SYNC_TIMEOUT_CHARS_TIME * 100) / 1152;
;;;288            break;
;;;289        }
;;;290        case BAUD_57600:
;;;291        {
;;;292            timeout = (DEFAULT_SYNC_TIMEOUT_CHARS_TIME * 100) / 576;
;;;293            break;
;;;294        }
;;;295        case BAUD_38400:
;;;296        {
;;;297            timeout = (DEFAULT_SYNC_TIMEOUT_CHARS_TIME * 100) / 384;
;;;298            break;
;;;299        }
;;;300        case BAUD_19200:
;;;301        {
;;;302            timeout = (DEFAULT_SYNC_TIMEOUT_CHARS_TIME * 100) / 192;
;;;303            break;
;;;304        }
;;;305        case BAUD_14400:
;;;306        {
;;;307            timeout = (DEFAULT_SYNC_TIMEOUT_CHARS_TIME * 100) / 144;
;;;308            break;
;;;309        }
;;;310        case BAUD_9600:
;;;311        {
;;;312            timeout = (DEFAULT_SYNC_TIMEOUT_CHARS_TIME * 100) / 96;
;;;313            break;
;;;314        }
;;;315        case BAUD_4800:
;;;316        {
;;;317            timeout = (DEFAULT_SYNC_TIMEOUT_CHARS_TIME * 100) / 48;
;;;318            break;
;;;319        }
;;;320        case BAUD_2400:
;;;321        {
;;;322            timeout = (DEFAULT_SYNC_TIMEOUT_CHARS_TIME * 100) / 240;
;;;323            break;
;;;324        }
;;;325        case BAUD_1200:
;;;326        {
;;;327            timeout = (DEFAULT_SYNC_TIMEOUT_CHARS_TIME * 100) / 12;
;;;328            break;
;;;329        }
;;;330        default:
;;;331            timeout = DEFAULT_SYNC_TIMEOUT_CHARS_TIME;
000042  f44f7000          MOV      r0,#0x200
;;;332        }
;;;333        return timeout;
;;;334    }
000046  4770              BX       lr
                  |L34.72|
000048  2005              MOVS     r0,#5                 ;277
00004a  4770              BX       lr
                  |L34.76|
00004c  200b              MOVS     r0,#0xb               ;282
00004e  4770              BX       lr
                  |L34.80|
000050  202c              MOVS     r0,#0x2c              ;287
000052  4770              BX       lr
                  |L34.84|
000054  2058              MOVS     r0,#0x58              ;292
000056  4770              BX       lr
                  |L34.88|
000058  2085              MOVS     r0,#0x85              ;297
00005a  4770              BX       lr
                  |L34.92|
00005c  f44f7085          MOV      r0,#0x10a             ;302
000060  4770              BX       lr
                  |L34.98|
000062  f2401063          MOV      r0,#0x163             ;307
000066  4770              BX       lr
                  |L34.104|
000068  f2402015          MOV      r0,#0x215             ;312
00006c  4770              BX       lr
                  |L34.110|
00006e  f240402a          MOV      r0,#0x42a             ;317
000072  4770              BX       lr
                  |L34.116|
000074  20d5              MOVS     r0,#0xd5              ;322
000076  4770              BX       lr
                  |L34.120|
000078  f24100aa          MOV      r0,#0x10aa            ;327
00007c  4770              BX       lr
;;;335    
                          ENDP


                          AREA ||i.kdp_uart_get_drv_hdl||, CODE, READONLY, ALIGN=2

                  kdp_uart_get_drv_hdl PROC
;;;335    
;;;336    static kdp_driver_hdl_t * kdp_uart_get_drv_hdl(uint16_t port)
000000  2805              CMP      r0,#5
;;;337    {
000002  d301              BCC      |L35.8|
;;;338        if (port >= MAX_UART_INST)
;;;339        {
;;;340            //dbg_msg("Error: invalid port number\n");
;;;341            return NULL;
000004  2000              MOVS     r0,#0
;;;342        }
;;;343        return gDrvCtx.uart_dev[port];
;;;344    }
000006  4770              BX       lr
                  |L35.8|
000008  4902              LDR      r1,|L35.20|
00000a  eb010080          ADD      r0,r1,r0,LSL #2       ;343
00000e  6880              LDR      r0,[r0,#8]            ;343
000010  4770              BX       lr
;;;345    
                          ENDP

000012  0000              DCW      0x0000
                  |L35.20|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_get_status||, CODE, READONLY, ALIGN=2

                  kdp_uart_get_status PROC
;;;1168   */
;;;1169   UART_STATUS_t *kdp_uart_get_status(kdp_uart_hdl_t handle)
000000  2805              CMP      r0,#5
;;;1170   {
000002  d208              BCS      |L36.22|
;;;1171       uint32_t com_port = handle;
;;;1172   
;;;1173       if (com_port >= TOTAL_UART_DEV) {
;;;1174           //dbg_msg("Invalid parameter\n");
;;;1175           return NULL;
;;;1176       }
;;;1177   
;;;1178       if (gDrvCtx.active_dev[com_port] == FALSE)
000004  4905              LDR      r1,|L36.28|
000006  180a              ADDS     r2,r1,r0
000008  7852              LDRB     r2,[r2,#1]
00000a  b122              CBZ      r2,|L36.22|
;;;1179       {
;;;1180           //dbg_msg("This UART device has been closed\n");
;;;1181           return NULL;
;;;1182       }
;;;1183   
;;;1184       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
00000c  eb010080          ADD      r0,r1,r0,LSL #2
000010  6880              LDR      r0,[r0,#8]
000012  301c              ADDS     r0,r0,#0x1c
;;;1185       return &pDrv->info.status;
;;;1186   }
000014  4770              BX       lr
                  |L36.22|
000016  2000              MOVS     r0,#0                 ;1181
000018  4770              BX       lr
;;;1187   
                          ENDP

00001a  0000              DCW      0x0000
                  |L36.28|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_init||, CODE, READONLY, ALIGN=2

                  kdp_uart_init PROC
;;;720    */
;;;721    void kdp_uart_init(void)
000000  b510              PUSH     {r4,lr}
;;;722    {
;;;723        if (gDriverInitialized == FALSE)
000002  4c05              LDR      r4,|L37.24|
000004  7820              LDRB     r0,[r4,#0]  ; gDriverInitialized
000006  2800              CMP      r0,#0                 ;722
000008  d105              BNE      |L37.22|
;;;724        {
;;;725            memset(&gDrvCtx, 0, sizeof(gDrvCtx));
00000a  211c              MOVS     r1,#0x1c
00000c  4803              LDR      r0,|L37.28|
00000e  f7fffffe          BL       __aeabi_memclr4
;;;726            gDriverInitialized = TRUE;
000012  2001              MOVS     r0,#1
000014  7020              STRB     r0,[r4,#0]
                  |L37.22|
;;;727        }
;;;728    }
000016  bd10              POP      {r4,pc}
;;;729    
                          ENDP

                  |L37.24|
                          DCD      ||.data||
                  |L37.28|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_open||, CODE, READONLY, ALIGN=2

                  kdp_uart_open PROC
;;;740    */
;;;741    kdp_uart_hdl_t kdp_uart_open(uint8_t com_port, uint32_t mode, kdp_uart_callback_t cb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;742    {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  4604              MOV      r4,r0
;;;743        uint32_t ww;
;;;744    
;;;745        if (com_port >= TOTAL_UART_DEV) 
;;;746        {
;;;747            //dbg_msg("Invalid com_port\n");
;;;748            return UART_FAIL;
00000a  f04f37ff          MOV      r7,#0xffffffff
00000e  2805              CMP      r0,#5                 ;745
000010  d302              BCC      |L38.24|
                  |L38.18|
000012  4638              MOV      r0,r7
                  |L38.20|
;;;749        }
;;;750    /*
;;;751        if (gDrvCtx.active_dev[com_port] == TRUE)
;;;752        {
;;;753            //dbg_msg("This UART device has been opened\n");
;;;754            return UART_FAIL;
;;;755        }
;;;756    */
;;;757        kdp_driver_hdl_t * pDrv = (kdp_driver_hdl_t *)malloc(sizeof(kdp_driver_hdl_t));
;;;758        if (pDrv == NULL) {
;;;759            err_msg("Error: memory alloc failed\n");
;;;760            return UART_FAIL;
;;;761        }
;;;762    
;;;763    //    if (((mode & UART_MODE_ASYN_TX) || (mode & UART_MODE_ASYN_RX)) && (cb == NULL))
;;;764    //    {
;;;765    //        err_msg("Error: Async mode needs callback function\n");
;;;766    //        return UART_FAIL;
;;;767    //    }
;;;768    
;;;769        gDrvCtx.uart_dev[com_port] = pDrv;
;;;770    
;;;771        pDrv->uart_port = com_port;
;;;772        pDrv->state = UART_UNINIT;
;;;773        // now use a common capbilities for all UARTs, may introduce an array if diff UART has diff capbilities
;;;774        pDrv->pCap = &DriverCapabilities;      
;;;775        pDrv->info.cb_event = cb;
;;;776        pDrv->info.mode = mode;
;;;777        pDrv->info.status.tx_busy = 0;
;;;778        pDrv->info.status.rx_busy = 0;
;;;779        pDrv->info.status.tx_underflow = 0;
;;;780        pDrv->info.status.rx_overflow = 0;
;;;781        pDrv->info.status.rx_break = 0;
;;;782        pDrv->info.status.rx_framing_error = 0;
;;;783        pDrv->info.status.rx_parity_error = 0;
;;;784    
;;;785        pDrv->info.xfer.tx_num = 0;
;;;786        pDrv->info.xfer.rx_num = 0;
;;;787        pDrv->info.xfer.tx_cnt = 0;
;;;788        pDrv->info.xfer.rx_cnt = 0;
;;;789        pDrv->info.xfer.write_idx = 0;
;;;790        pDrv->info.xfer.read_idx = 0;
;;;791    
;;;792        pDrv->res.irq_num = gUartIRQTbl[com_port];
;;;793        pDrv->res.isr = gUartISRs[com_port];
;;;794    
;;;795        ww = inw(UART_PORT[com_port] + SERIAL_FIFO_DEPTH_REG);
;;;796        ww &= 0x0f;
;;;797        pDrv->res.fifo_depth = ww;
;;;798    
;;;799        pDrv->res.fifo_len = 16 * ww;
;;;800    
;;;801        pDrv->res.hw_base = UART_PORT[com_port];
;;;802        pDrv->res.clock = gUartClk[com_port];
;;;803    
;;;804        pDrv->nTimeOutRx = DEFAULT_SYNC_TIMEOUT_CHARS_TIME;   //suppose default baud = 115200
;;;805        pDrv->nTimeOutTx = DEFAULT_SYNC_TIMEOUT_CHARS_TIME;   //suppose default baud = 115200
;;;806    
;;;807        gDrvCtx.total_open_uarts++;
;;;808        gDrvCtx.active_dev[com_port] = TRUE;
;;;809    
;;;810        pDrv->info.flags |= UART_INITIALIZED;
;;;811    
;;;812        return (kdp_uart_hdl_t)com_port;
;;;813    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L38.24|
000018  2078              MOVS     r0,#0x78              ;757
00001a  f7fffffe          BL       malloc
00001e  b3e0              CBZ      r0,|L38.154|
000020  4a23              LDR      r2,|L38.176|
000022  4b24              LDR      r3,|L38.180|
000024  eb020184          ADD      r1,r2,r4,LSL #2       ;769
000028  6088              STR      r0,[r1,#8]            ;771
00002a  c010              STM      r0!,{r4}              ;771
00002c  2100              MOVS     r1,#0                 ;772
00002e  7001              STRB     r1,[r0,#0]            ;772
000030  6446              STR      r6,[r0,#0x44]         ;777
000032  6145              STR      r5,[r0,#0x14]         ;777
000034  6043              STR      r3,[r0,#4]            ;777
000036  7601              STRB     r1,[r0,#0x18]         ;777
000038  7641              STRB     r1,[r0,#0x19]         ;778
00003a  7681              STRB     r1,[r0,#0x1a]         ;779
00003c  76c1              STRB     r1,[r0,#0x1b]         ;780
00003e  7701              STRB     r1,[r0,#0x1c]         ;781
000040  7741              STRB     r1,[r0,#0x1d]         ;782
000042  7781              STRB     r1,[r0,#0x1e]         ;783
000044  6241              STR      r1,[r0,#0x24]         ;785
000046  6201              STR      r1,[r0,#0x20]         ;786
000048  6341              STR      r1,[r0,#0x34]         ;787
00004a  6301              STR      r1,[r0,#0x30]         ;788
00004c  6381              STR      r1,[r0,#0x38]         ;789
00004e  63c1              STR      r1,[r0,#0x3c]         ;790
000050  1d19              ADDS     r1,r3,#4              ;792
000052  5709              LDRSB    r1,[r1,r4]            ;792
000054  6481              STR      r1,[r0,#0x48]         ;793
000056  f103010c          ADD      r1,r3,#0xc            ;793
00005a  3334              ADDS     r3,r3,#0x34           ;795
00005c  f8511024          LDR      r1,[r1,r4,LSL #2]     ;793
000060  64c1              STR      r1,[r0,#0x4c]         ;795
000062  f8531024          LDR      r1,[r3,r4,LSL #2]     ;795
000066  6e89              LDR      r1,[r1,#0x68]         ;795
000068  f001010f          AND      r1,r1,#0xf            ;796
00006c  6501              STR      r1,[r0,#0x50]         ;799
00006e  0109              LSLS     r1,r1,#4              ;799
000070  65c1              STR      r1,[r0,#0x5c]         ;801
000072  f8531024          LDR      r1,[r3,r4,LSL #2]     ;801
000076  6641              STR      r1,[r0,#0x64]         ;802
000078  f1a30114          SUB      r1,r3,#0x14           ;802
00007c  f8511024          LDR      r1,[r1,r4,LSL #2]     ;802
000080  6601              STR      r1,[r0,#0x60]         ;804
000082  f44f7100          MOV      r1,#0x200             ;804
000086  66c1              STR      r1,[r0,#0x6c]         ;805
000088  6681              STR      r1,[r0,#0x68]         ;807
00008a  7811              LDRB     r1,[r2,#0]            ;807  ; gDrvCtx
00008c  1c49              ADDS     r1,r1,#1              ;807
00008e  7011              STRB     r1,[r2,#0]            ;807
000090  4422              ADD      r2,r2,r4              ;808
000092  2101              MOVS     r1,#1                 ;808
000094  7051              STRB     r1,[r2,#1]            ;808
000096  6c01              LDR      r1,[r0,#0x40]         ;810
000098  e000              B        |L38.156|
                  |L38.154|
00009a  e004              B        |L38.166|
                  |L38.156|
00009c  f0410101          ORR      r1,r1,#1              ;810
0000a0  6401              STR      r1,[r0,#0x40]         ;812
0000a2  4620              MOV      r0,r4                 ;812
0000a4  e7b6              B        |L38.20|
                  |L38.166|
0000a6  a104              ADR      r1,|L38.184|
0000a8  2002              MOVS     r0,#2                 ;759
0000aa  f7fffffe          BL       kdp_level_printf
0000ae  e7b0              B        |L38.18|
;;;814    
                          ENDP

                  |L38.176|
                          DCD      ||.bss||
                  |L38.180|
                          DCD      ||.data||+0x4
                  |L38.184|
0000b8  4572726f          DCB      "Error: memory alloc failed\n",0
0000bc  723a206d
0000c0  656d6f72
0000c4  7920616c
0000c8  6c6f6320
0000cc  6661696c
0000d0  65640a00

                          AREA ||i.kdp_uart_power_control||, CODE, READONLY, ALIGN=2

                  kdp_uart_power_control PROC
;;;1403   */
;;;1404   int32_t kdp_uart_power_control(kdp_uart_hdl_t handle, ARM_POWER_STATE state)
000000  b538              PUSH     {r3-r5,lr}
;;;1405   {
;;;1406       uint32_t data;
;;;1407       uint32_t com_port = handle;
000002  4605              MOV      r5,r0
;;;1408   
;;;1409       if (com_port >= TOTAL_UART_DEV) {
000004  2805              CMP      r0,#5
000006  d212              BCS      |L39.46|
;;;1410           //dbg_msg("Invalid parameter\n");
;;;1411           return UART_API_INVALID_PARAM;
;;;1412       }
;;;1413   
;;;1414       if (gDrvCtx.active_dev[com_port] == FALSE)
000008  487f              LDR      r0,|L39.520|
00000a  1942              ADDS     r2,r0,r5
00000c  7852              LDRB     r2,[r2,#1]
00000e  b172              CBZ      r2,|L39.46|
;;;1415       {
;;;1416           //dbg_msg("This UART device is not active\n");
;;;1417           return UART_API_INVALID_PARAM;
;;;1418       }
;;;1419   
;;;1420       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
000010  eb000085          ADD      r0,r0,r5,LSL #2
;;;1421   
;;;1422       if (pDrv->info.status.rx_busy == 1) {
000014  6884              LDR      r4,[r0,#8]
000016  7f60              LDRB     r0,[r4,#0x1d]
000018  2801              CMP      r0,#1
00001a  d00a              BEQ      |L39.50|
;;;1423           // Receive busy
;;;1424           return UART_API_RX_BUSY;
;;;1425       }
;;;1426   
;;;1427       if (pDrv->info.status.tx_busy == 1) {
00001c  7f20              LDRB     r0,[r4,#0x1c]
00001e  2801              CMP      r0,#1
000020  d009              BEQ      |L39.54|
;;;1428           // transmit busy
;;;1429           return UART_API_TX_BUSY;
;;;1430       }
;;;1431   
;;;1432       if (state == ARM_POWER_FULL)
;;;1433       {
;;;1434           if ((pDrv->info.flags & UART_INITIALIZED) == 0U)
;;;1435           {
;;;1436               return UART_API_ERROR;
;;;1437           }
;;;1438   
;;;1439           if ((pDrv->info.flags & UART_POWERED) != 0U)
;;;1440           {
;;;1441               return UART_API_RETURN_SUCCESS;
;;;1442           }
;;;1443   
;;;1444           /* power on UART */
;;;1445           switch (pDrv->uart_port)
;;;1446           {
;;;1447           case UART0_DEV:
;;;1448   
;;;1449   
;;;1450               break;
;;;1451   
;;;1452           case UART1_DEV:
;;;1453   
;;;1454               data = inw(0xc238001c);
000022  4a7a              LDR      r2,|L39.524|
000024  2902              CMP      r1,#2                 ;1432
000026  d008              BEQ      |L39.58|
;;;1455               outw(0xc238001c, data | 0x1000);
;;;1456               PINMUX_LC_DATA2_SET(4);
;;;1457               PINMUX_LC_DATA3_SET(4);
;;;1458               SCU_EXTREG_CLK_EN2_SET_uart1_0_fref(1);
;;;1459   
;;;1460               break;
;;;1461   
;;;1462           case UART2_DEV:
;;;1463       
;;;1464               data = inw(SCU_EXTREG_PA_BASE + 0x154);
;;;1465               data &= 0xFFFFFFF8;		//clear low 3bit
;;;1466               data &= 0xFFFFFFE7;		//clear bit 3 and bit4
;;;1467               
;;;1468               outw(SCU_EXTREG_PA_BASE + 0x154, data | 0x1 | 1<<4 );
;;;1469   
;;;1470               data = inw(SCU_EXTREG_PA_BASE + 0x158);
;;;1471               data &= 0xFFFFFFF8;		//clear low 3bit
;;;1472               data &= 0xFFFFFFE7;		//clear bit 3 and bit4
;;;1473               
;;;1474               outw(SCU_EXTREG_PA_BASE + 0x158, data | 0x1 | 1<<4 );
;;;1475   
;;;1476               SCU_EXTREG_CLK_EN2_SET_uart1_1_fref(1);
;;;1477   
;;;1478               break;
;;;1479   
;;;1480           case UART3_DEV:
;;;1481   
;;;1482               data = inw(0xc238001c);
;;;1483               outw(0xc238001c, data | 0x4000);
;;;1484               PINMUX_SD_DATA0_SET(6);
;;;1485               PINMUX_SD_DATA1_SET(6);
;;;1486               SCU_EXTREG_CLK_EN2_SET_uart1_2_fref(1);
;;;1487   
;;;1488               break;
;;;1489   
;;;1490           case UART4_DEV:
;;;1491   
;;;1492               data = inw(0xc238001c);
;;;1493               outw(0xc238001c, data | 0x8000);
;;;1494               PINMUX_SD_DATA2_SET(6);
;;;1495               PINMUX_SD_DATA3_SET(6);
;;;1496   
;;;1497               SCU_EXTREG_CLK_EN2_SET_uart1_3_fref(1);
;;;1498   
;;;1499               break;
;;;1500   
;;;1501           default:
;;;1502   						break;
;;;1503           }
;;;1504   
;;;1505           /* set power on flag */
;;;1506           pDrv->info.flags |= UART_POWERED;
;;;1507   
;;;1508           kdp_uart_fifo_cfg_t cfg;
;;;1509   
;;;1510           /* config FIFO trigger value with default value or client set via control API*/
;;;1511           cfg.fifo_trig_level = pDrv->res.rx_fifo_threshold;
;;;1512           cfg.bEnFifo = pDrv->config.fifo_en;
;;;1513           kdp_uart_control(com_port, UART_CTRL_FIFO_RX, (void *)&cfg);
;;;1514   
;;;1515           cfg.fifo_trig_level = pDrv->res.tx_fifo_threshold;
;;;1516           cfg.bEnFifo = (cfg.fifo_trig_level == 0) ? FALSE : TRUE;
;;;1517           kdp_uart_control(com_port, UART_CTRL_FIFO_TX, (void *)&cfg);
;;;1518   
;;;1519           NVIC_ClearPendingIRQ((IRQn_Type)pDrv->res.irq_num);
;;;1520       }
;;;1521       else if (state == ARM_POWER_OFF)
000028  2900              CMP      r1,#0
00002a  d07c              BEQ      |L39.294|
00002c  e0ea              B        |L39.516|
                  |L39.46|
00002e  2008              MOVS     r0,#8                 ;1417
;;;1522       {
;;;1523   
;;;1524           if ((pDrv->info.flags & UART_POWERED) == 0U)
;;;1525           {
;;;1526               return UART_API_RETURN_SUCCESS;
;;;1527           }
;;;1528   
;;;1529           /* power off UART */
;;;1530           switch (pDrv->uart_port)
;;;1531           {
;;;1532           case UART0_DEV:
;;;1533   
;;;1534   
;;;1535               break;
;;;1536   
;;;1537           case UART1_DEV:
;;;1538   
;;;1539               data = inw(0xc238001c);
;;;1540               outw(0xc238001c, data | 0x0000);
;;;1541               data = inw(0xc2380144);
;;;1542               outw(0xc2380144, data | 0x0);
;;;1543               data = inw(0xc2380148);
;;;1544               outw(0xc2380148, data | 0x0);
;;;1545               SCU_EXTREG_CLK_EN2_SET_uart1_0_fref(0);
;;;1546   
;;;1547               break;
;;;1548   
;;;1549           case UART2_DEV:
;;;1550   
;;;1551               data = inw(0xc238001c);
;;;1552               outw(0xc238001c, data | 0x0000);
;;;1553               data = inw(0xc238017c);
;;;1554               outw(0xc238017c, data | 0x0);
;;;1555               data = inw(0xc2380180);
;;;1556               outw(0xc2380180, data | 0x0);
;;;1557   
;;;1558               SCU_EXTREG_CLK_EN2_SET_uart1_1_fref(0);
;;;1559   
;;;1560               break;
;;;1561   
;;;1562           case UART3_DEV:
;;;1563   
;;;1564               data = inw(0xc238001c);
;;;1565               outw(0xc238001c, data | 0x0000);
;;;1566               data = inw(0xc2380184);
;;;1567               outw(0xc2380184, data | 0x0);
;;;1568               data = inw(0xc2380188);
;;;1569               outw(0xc2380188, data | 0x0);
;;;1570               SCU_EXTREG_CLK_EN2_SET_uart1_2_fref(0);
;;;1571   
;;;1572               break;
;;;1573   
;;;1574           case UART4_DEV:
;;;1575   
;;;1576               data = inw(0xc238001c);
;;;1577               outw(0xc238001c, data | 0x0000);
;;;1578               data = inw(0xc238018c);
;;;1579               outw(0xc238018c, data | 0x0);
;;;1580               data = inw(0xc2380190);
;;;1581               outw(0xc2380190, data | 0x0);
;;;1582   
;;;1583               SCU_EXTREG_CLK_EN2_SET_uart1_3_fref(0);
;;;1584   
;;;1585               break;
;;;1586   
;;;1587           default:
;;;1588   						break;
;;;1589           }
;;;1590   
;;;1591           NVIC_ClearPendingIRQ((IRQn_Type)pDrv->res.irq_num);
;;;1592   
;;;1593           /* disable Tx/Rx interrupts */
;;;1594           uint32_t ww = inw(pDrv->uart_port + SERIAL_IER);
;;;1595           ww &= ~(SERIAL_IER_DR | SERIAL_IER_TE);
;;;1596           outw(UART_PORT[com_port] + SERIAL_IER, ww);
;;;1597   
;;;1598           /* set power on flag */
;;;1599           pDrv->info.flags &= ~UART_POWERED;
;;;1600       }
;;;1601       else
;;;1602       {
;;;1603           return UART_API_ERROR;
;;;1604       }
;;;1605   
;;;1606       return UART_API_RETURN_SUCCESS;
;;;1607   
;;;1608   }
000030  bd38              POP      {r3-r5,pc}
                  |L39.50|
000032  2004              MOVS     r0,#4                 ;1424
000034  bd38              POP      {r3-r5,pc}
                  |L39.54|
000036  2002              MOVS     r0,#2                 ;1429
000038  bd38              POP      {r3-r5,pc}
                  |L39.58|
00003a  6c60              LDR      r0,[r4,#0x44]         ;1434
00003c  07c1              LSLS     r1,r0,#31             ;1434
00003e  d073              BEQ      |L39.296|
000040  0780              LSLS     r0,r0,#30             ;1439
000042  d46f              BMI      |L39.292|
000044  6820              LDR      r0,[r4,#0]            ;1445
000046  2805              CMP      r0,#5                 ;1445
000048  d246              BCS      |L39.216|
00004a  e8dff000          TBB      [pc,r0]               ;1445
00004e  4503              DCB      0x45,0x03
000050  192f6e00          DCB      0x19,0x2f,0x6e,0x00
000054  69d0              LDR      r0,[r2,#0x1c]         ;1454
000056  f4405080          ORR      r0,r0,#0x1000         ;1455
00005a  61d0              STR      r0,[r2,#0x1c]         ;1455
00005c  f8d20144          LDR      r0,[r2,#0x144]        ;1456
000060  f0200007          BIC      r0,r0,#7              ;1456
000064  1d00              ADDS     r0,r0,#4              ;1456
000066  f8c20144          STR      r0,[r2,#0x144]        ;1456
00006a  f8d20148          LDR      r0,[r2,#0x148]        ;1457
00006e  f0200007          BIC      r0,r0,#7              ;1457
000072  1d00              ADDS     r0,r0,#4              ;1457
000074  f8c20148          STR      r0,[r2,#0x148]        ;1457
000078  69d0              LDR      r0,[r2,#0x1c]         ;1458
00007a  f4405080          ORR      r0,r0,#0x1000         ;1458
00007e  e02a              B        |L39.214|
000080  f8d20154          LDR      r0,[r2,#0x154]        ;1464
000084  f020001f          BIC      r0,r0,#0x1f           ;1466
000088  f0400011          ORR      r0,r0,#0x11           ;1468
00008c  f8c20154          STR      r0,[r2,#0x154]        ;1468
000090  f8d20158          LDR      r0,[r2,#0x158]        ;1470
000094  f020001f          BIC      r0,r0,#0x1f           ;1472
000098  f0400011          ORR      r0,r0,#0x11           ;1474
00009c  f8c20158          STR      r0,[r2,#0x158]        ;1474
0000a0  f8520f1c          LDR      r0,[r2,#0x1c]!        ;1476
0000a4  f4405000          ORR      r0,r0,#0x2000         ;1476
0000a8  6010              STR      r0,[r2,#0]            ;1476
0000aa  e015              B        |L39.216|
0000ac  69d0              LDR      r0,[r2,#0x1c]         ;1482
0000ae  f4404080          ORR      r0,r0,#0x4000         ;1483
0000b2  61d0              STR      r0,[r2,#0x1c]         ;1483
0000b4  f8d20184          LDR      r0,[r2,#0x184]        ;1484
0000b8  f0200007          BIC      r0,r0,#7              ;1484
0000bc  1d80              ADDS     r0,r0,#6              ;1484
0000be  f8c20184          STR      r0,[r2,#0x184]        ;1484
0000c2  f8d20188          LDR      r0,[r2,#0x188]        ;1485
0000c6  f0200007          BIC      r0,r0,#7              ;1485
0000ca  1d80              ADDS     r0,r0,#6              ;1485
0000cc  f8c20188          STR      r0,[r2,#0x188]        ;1485
0000d0  69d0              LDR      r0,[r2,#0x1c]         ;1486
0000d2  f4404080          ORR      r0,r0,#0x4000         ;1486
                  |L39.214|
0000d6  61d0              STR      r0,[r2,#0x1c]         ;1458
                  |L39.216|
0000d8  6c60              LDR      r0,[r4,#0x44]         ;1506
0000da  f0400002          ORR      r0,r0,#2              ;1506
0000de  6460              STR      r0,[r4,#0x44]         ;1511
0000e0  f894005c          LDRB     r0,[r4,#0x5c]         ;1511
0000e4  f88d0001          STRB     r0,[sp,#1]            ;1511
0000e8  7d20              LDRB     r0,[r4,#0x14]         ;1512
0000ea  b100              CBZ      r0,|L39.238|
0000ec  2001              MOVS     r0,#1                 ;1512
                  |L39.238|
0000ee  f88d0000          STRB     r0,[sp,#0]            ;1512
0000f2  466a              MOV      r2,sp                 ;1513
0000f4  2101              MOVS     r1,#1                 ;1513
0000f6  4628              MOV      r0,r5                 ;1513
0000f8  f7fffffe          BL       kdp_uart_control
0000fc  f8940058          LDRB     r0,[r4,#0x58]         ;1515
000100  f01000ff          ANDS     r0,r0,#0xff           ;1515
000104  f88d0001          STRB     r0,[sp,#1]            ;1515
000108  d000              BEQ      |L39.268|
00010a  2001              MOVS     r0,#1                 ;1516
                  |L39.268|
00010c  f88d0000          STRB     r0,[sp,#0]            ;1516
000110  466a              MOV      r2,sp                 ;1517
000112  2102              MOVS     r1,#2                 ;1517
000114  4628              MOV      r0,r5                 ;1517
000116  f7fffffe          BL       kdp_uart_control
00011a  f894004c          LDRB     r0,[r4,#0x4c]         ;1519
00011e  b240              SXTB     r0,r0                 ;1519
000120  f7fffffe          BL       __NVIC_ClearPendingIRQ
                  |L39.292|
000124  e050              B        |L39.456|
                  |L39.294|
000126  e016              B        |L39.342|
                  |L39.296|
000128  e06c              B        |L39.516|
00012a  69d0              LDR      r0,[r2,#0x1c]         ;1492
00012c  f4404000          ORR      r0,r0,#0x8000         ;1493
000130  61d0              STR      r0,[r2,#0x1c]         ;1493
000132  f8d2018c          LDR      r0,[r2,#0x18c]        ;1494
000136  f0200007          BIC      r0,r0,#7              ;1494
00013a  1d80              ADDS     r0,r0,#6              ;1494
00013c  f8c2018c          STR      r0,[r2,#0x18c]        ;1494
000140  f8d20190          LDR      r0,[r2,#0x190]        ;1495
000144  f0200007          BIC      r0,r0,#7              ;1495
000148  1d80              ADDS     r0,r0,#6              ;1495
00014a  f8c20190          STR      r0,[r2,#0x190]        ;1495
00014e  69d0              LDR      r0,[r2,#0x1c]         ;1497
000150  f4404000          ORR      r0,r0,#0x8000         ;1497
000154  e7bf              B        |L39.214|
                  |L39.342|
000156  f8940044          LDRB     r0,[r4,#0x44]         ;1524
00015a  0780              LSLS     r0,r0,#30             ;1524
00015c  d534              BPL      |L39.456|
00015e  6820              LDR      r0,[r4,#0]            ;1530
000160  2805              CMP      r0,#5                 ;1530
000162  d220              BCS      |L39.422|
000164  e8dff000          TBB      [pc,r0]               ;1530
000168  1f031132          DCB      0x1f,0x03,0x11,0x32
00016c  4000              DCB      0x40,0x00
00016e  69d0              LDR      r0,[r2,#0x1c]         ;1539
000170  61d0              STR      r0,[r2,#0x1c]         ;1540
000172  f8d20144          LDR      r0,[r2,#0x144]        ;1541
000176  f8c20144          STR      r0,[r2,#0x144]        ;1542
00017a  f8d20148          LDR      r0,[r2,#0x148]        ;1543
00017e  f8c20148          STR      r0,[r2,#0x148]        ;1544
000182  69d0              LDR      r0,[r2,#0x1c]         ;1545
000184  f4205080          BIC      r0,r0,#0x1000         ;1545
000188  e00c              B        |L39.420|
00018a  69d0              LDR      r0,[r2,#0x1c]         ;1551
00018c  61d0              STR      r0,[r2,#0x1c]         ;1552
00018e  f8d2017c          LDR      r0,[r2,#0x17c]        ;1553
000192  f8c2017c          STR      r0,[r2,#0x17c]        ;1554
000196  f8d20180          LDR      r0,[r2,#0x180]        ;1555
00019a  f8c20180          STR      r0,[r2,#0x180]        ;1556
00019e  69d0              LDR      r0,[r2,#0x1c]         ;1558
0001a0  f4205000          BIC      r0,r0,#0x2000         ;1558
                  |L39.420|
0001a4  61d0              STR      r0,[r2,#0x1c]         ;1545
                  |L39.422|
0001a6  f894004c          LDRB     r0,[r4,#0x4c]         ;1591
0001aa  b240              SXTB     r0,r0                 ;1591
0001ac  f7fffffe          BL       __NVIC_ClearPendingIRQ
0001b0  6820              LDR      r0,[r4,#0]            ;1594
0001b2  6840              LDR      r0,[r0,#4]            ;1594
0001b4  4916              LDR      r1,|L39.528|
0001b6  f0200003          BIC      r0,r0,#3              ;1595
0001ba  f8511025          LDR      r1,[r1,r5,LSL #2]     ;1596
0001be  6048              STR      r0,[r1,#4]            ;1596
0001c0  6c60              LDR      r0,[r4,#0x44]         ;1599
0001c2  f0200002          BIC      r0,r0,#2              ;1599
0001c6  6460              STR      r0,[r4,#0x44]         ;1599
                  |L39.456|
0001c8  2000              MOVS     r0,#0                 ;1606
0001ca  bd38              POP      {r3-r5,pc}
0001cc  69d0              LDR      r0,[r2,#0x1c]         ;1564
0001ce  61d0              STR      r0,[r2,#0x1c]         ;1565
0001d0  f8d20184          LDR      r0,[r2,#0x184]        ;1566
0001d4  f8c20184          STR      r0,[r2,#0x184]        ;1567
0001d8  f8d20188          LDR      r0,[r2,#0x188]        ;1568
0001dc  f8c20188          STR      r0,[r2,#0x188]        ;1569
0001e0  69d0              LDR      r0,[r2,#0x1c]         ;1570
0001e2  f4204080          BIC      r0,r0,#0x4000         ;1570
0001e6  e7dd              B        |L39.420|
0001e8  69d0              LDR      r0,[r2,#0x1c]         ;1576
0001ea  61d0              STR      r0,[r2,#0x1c]         ;1577
0001ec  f8d2018c          LDR      r0,[r2,#0x18c]        ;1578
0001f0  f8c2018c          STR      r0,[r2,#0x18c]        ;1579
0001f4  f8d20190          LDR      r0,[r2,#0x190]        ;1580
0001f8  f8c20190          STR      r0,[r2,#0x190]        ;1581
0001fc  69d0              LDR      r0,[r2,#0x1c]         ;1583
0001fe  f4204000          BIC      r0,r0,#0x8000         ;1583
000202  e7cf              B        |L39.420|
                  |L39.516|
000204  2010              MOVS     r0,#0x10              ;1603
000206  bd38              POP      {r3-r5,pc}
;;;1609   
                          ENDP

                  |L39.520|
                          DCD      ||.bss||
                  |L39.524|
                          DCD      0xc2380000
                  |L39.528|
                          DCD      ||.data||+0x38

                          AREA ||i.kdp_uart_print_register||, CODE, READONLY, ALIGN=2

                  kdp_uart_print_register PROC
;;;1762   
;;;1763   void kdp_uart_print_register(uint8_t port_no)
000000  b570              PUSH     {r4-r6,lr}
;;;1764   {
000002  4604              MOV      r4,r0
;;;1765       kdp_driver_hdl_t *pHdl = kdp_uart_get_drv_hdl(port_no);
000004  f7fffffe          BL       kdp_uart_get_drv_hdl
;;;1766   
;;;1767       uint32_t ww = inw(UART_PORT[port_no] + SERIAL_RBR);
000008  4d2e              LDR      r5,|L40.196|
00000a  f8550024          LDR      r0,[r5,r4,LSL #2]
00000e  6801              LDR      r1,[r0,#0]
;;;1768       kdp_printf("SERIAL_RBR(0x00) = 0x%x\n", ww);
000010  a02d              ADR      r0,|L40.200|
000012  f7fffffe          BL       kdp_printf
;;;1769   
;;;1770       ww = inw(UART_PORT[port_no] + SERIAL_IER);
000016  f8550024          LDR      r0,[r5,r4,LSL #2]
00001a  6841              LDR      r1,[r0,#4]
;;;1771       kdp_printf("SERIAL_IER(0x04) = 0x%x\n", ww);
00001c  a031              ADR      r0,|L40.228|
00001e  f7fffffe          BL       kdp_printf
;;;1772   
;;;1773       ww = inw(UART_PORT[port_no] + SERIAL_IIR);
000022  f8550024          LDR      r0,[r5,r4,LSL #2]
000026  6881              LDR      r1,[r0,#8]
;;;1774       kdp_printf("SERIAL_IIR(0x08) = 0x%x\n", ww);
000028  a035              ADR      r0,|L40.256|
00002a  f7fffffe          BL       kdp_printf
;;;1775   
;;;1776       ww = inw(UART_PORT[port_no] + SERIAL_LCR);
00002e  f8550024          LDR      r0,[r5,r4,LSL #2]
000032  68c1              LDR      r1,[r0,#0xc]
;;;1777       kdp_printf("SERIAL_LCR(0x0C) = 0x%x\n", ww);
000034  a039              ADR      r0,|L40.284|
000036  f7fffffe          BL       kdp_printf
;;;1778   
;;;1779       ww = inw(UART_PORT[port_no] + SERIAL_MCR);
00003a  f8550024          LDR      r0,[r5,r4,LSL #2]
00003e  6901              LDR      r1,[r0,#0x10]
;;;1780       kdp_printf("SERIAL_MCR(0x10) = 0x%x\n", ww);
000040  a03d              ADR      r0,|L40.312|
000042  f7fffffe          BL       kdp_printf
;;;1781   
;;;1782       ww = inw(UART_PORT[port_no] + SERIAL_LSR);
000046  f8550024          LDR      r0,[r5,r4,LSL #2]
00004a  6941              LDR      r1,[r0,#0x14]
;;;1783       kdp_printf("SERIAL_LSR(0x14) = 0x%x\n", ww);
00004c  a041              ADR      r0,|L40.340|
00004e  f7fffffe          BL       kdp_printf
;;;1784   
;;;1785       ww = inw(UART_PORT[port_no] + SERIAL_MSR);
000052  f8550024          LDR      r0,[r5,r4,LSL #2]
000056  6981              LDR      r1,[r0,#0x18]
;;;1786       kdp_printf("SERIAL_MSR(0x18) = 0x%x\n", ww);
000058  a045              ADR      r0,|L40.368|
00005a  f7fffffe          BL       kdp_printf
;;;1787   
;;;1788       ww = inw(UART_PORT[port_no] + 0x20);
00005e  f8550024          LDR      r0,[r5,r4,LSL #2]
000062  6a01              LDR      r1,[r0,#0x20]
;;;1789       kdp_printf("UART2(0x20) = 0x%x\n", ww);
000064  a049              ADR      r0,|L40.396|
000066  f7fffffe          BL       kdp_printf
;;;1790   
;;;1791       ww = inw(UART_PORT[port_no] + 0x30);
00006a  f8550024          LDR      r0,[r5,r4,LSL #2]
00006e  6b01              LDR      r1,[r0,#0x30]
;;;1792       kdp_printf("UART2(0x30) = 0x%x\n", ww);
000070  a04b              ADR      r0,|L40.416|
000072  f7fffffe          BL       kdp_printf
;;;1793   
;;;1794       ww = inw(UART_PORT[port_no] + 0x34);
000076  f8550024          LDR      r0,[r5,r4,LSL #2]
00007a  6b41              LDR      r1,[r0,#0x34]
;;;1795       kdp_printf("UART2(0x34) = 0x%x\n", ww);
00007c  a04d              ADR      r0,|L40.436|
00007e  f7fffffe          BL       kdp_printf
;;;1796   
;;;1797       ww = inw(UART_PORT[port_no] + 0x44);
000082  f8550024          LDR      r0,[r5,r4,LSL #2]
000086  6c41              LDR      r1,[r0,#0x44]
;;;1798       kdp_printf("UART2(0x44) = 0x%x\n", ww);
000088  a04f              ADR      r0,|L40.456|
00008a  f7fffffe          BL       kdp_printf
;;;1799   
;;;1800       ww = inw(UART_PORT[port_no] + 0x48);
00008e  f8550024          LDR      r0,[r5,r4,LSL #2]
000092  6c81              LDR      r1,[r0,#0x48]
;;;1801       kdp_printf("UART2(0x48) = 0x%x\n", ww);
000094  a051              ADR      r0,|L40.476|
000096  f7fffffe          BL       kdp_printf
;;;1802   
;;;1803       ww = inw(UART_PORT[port_no] + 0x4C);
00009a  f8550024          LDR      r0,[r5,r4,LSL #2]
00009e  6cc1              LDR      r1,[r0,#0x4c]
;;;1804       kdp_printf("UART2(0x4C) = 0x%x\n", ww);
0000a0  a053              ADR      r0,|L40.496|
0000a2  f7fffffe          BL       kdp_printf
;;;1805   
;;;1806       ww = inw(UART_PORT[port_no] + 0x5C);
0000a6  f8550024          LDR      r0,[r5,r4,LSL #2]
0000aa  6dc1              LDR      r1,[r0,#0x5c]
;;;1807       kdp_printf("UART2(0x5C) = 0x%x\n", ww);
0000ac  a055              ADR      r0,|L40.516|
0000ae  f7fffffe          BL       kdp_printf
;;;1808   
;;;1809       ww = inw(UART_PORT[port_no] + 0x68);
0000b2  f8550024          LDR      r0,[r5,r4,LSL #2]
0000b6  6e81              LDR      r1,[r0,#0x68]
;;;1810       kdp_printf("UART2(0x68) = 0x%x\n", ww);
0000b8  e8bd4070          POP      {r4-r6,lr}
0000bc  a056              ADR      r0,|L40.536|
0000be  f7ffbffe          B.W      kdp_printf
;;;1811   }
;;;1812   void kdp_uart_rx_busy_clear(kdp_uart_hdl_t handle)
                          ENDP

0000c2  0000              DCW      0x0000
                  |L40.196|
                          DCD      ||.data||+0x38
                  |L40.200|
0000c8  53455249          DCB      "SERIAL_RBR(0x00) = 0x%x\n",0
0000cc  414c5f52
0000d0  42522830
0000d4  78303029
0000d8  203d2030
0000dc  7825780a
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L40.228|
0000e4  53455249          DCB      "SERIAL_IER(0x04) = 0x%x\n",0
0000e8  414c5f49
0000ec  45522830
0000f0  78303429
0000f4  203d2030
0000f8  7825780a
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L40.256|
000100  53455249          DCB      "SERIAL_IIR(0x08) = 0x%x\n",0
000104  414c5f49
000108  49522830
00010c  78303829
000110  203d2030
000114  7825780a
000118  00      
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L40.284|
00011c  53455249          DCB      "SERIAL_LCR(0x0C) = 0x%x\n",0
000120  414c5f4c
000124  43522830
000128  78304329
00012c  203d2030
000130  7825780a
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
                  |L40.312|
000138  53455249          DCB      "SERIAL_MCR(0x10) = 0x%x\n",0
00013c  414c5f4d
000140  43522830
000144  78313029
000148  203d2030
00014c  7825780a
000150  00      
000151  00                DCB      0
000152  00                DCB      0
000153  00                DCB      0
                  |L40.340|
000154  53455249          DCB      "SERIAL_LSR(0x14) = 0x%x\n",0
000158  414c5f4c
00015c  53522830
000160  78313429
000164  203d2030
000168  7825780a
00016c  00      
00016d  00                DCB      0
00016e  00                DCB      0
00016f  00                DCB      0
                  |L40.368|
000170  53455249          DCB      "SERIAL_MSR(0x18) = 0x%x\n",0
000174  414c5f4d
000178  53522830
00017c  78313829
000180  203d2030
000184  7825780a
000188  00      
000189  00                DCB      0
00018a  00                DCB      0
00018b  00                DCB      0
                  |L40.396|
00018c  55415254          DCB      "UART2(0x20) = 0x%x\n",0
000190  32283078
000194  32302920
000198  3d203078
00019c  25780a00
                  |L40.416|
0001a0  55415254          DCB      "UART2(0x30) = 0x%x\n",0
0001a4  32283078
0001a8  33302920
0001ac  3d203078
0001b0  25780a00
                  |L40.436|
0001b4  55415254          DCB      "UART2(0x34) = 0x%x\n",0
0001b8  32283078
0001bc  33342920
0001c0  3d203078
0001c4  25780a00
                  |L40.456|
0001c8  55415254          DCB      "UART2(0x44) = 0x%x\n",0
0001cc  32283078
0001d0  34342920
0001d4  3d203078
0001d8  25780a00
                  |L40.476|
0001dc  55415254          DCB      "UART2(0x48) = 0x%x\n",0
0001e0  32283078
0001e4  34382920
0001e8  3d203078
0001ec  25780a00
                  |L40.496|
0001f0  55415254          DCB      "UART2(0x4C) = 0x%x\n",0
0001f4  32283078
0001f8  34432920
0001fc  3d203078
000200  25780a00
                  |L40.516|
000204  55415254          DCB      "UART2(0x5C) = 0x%x\n",0
000208  32283078
00020c  35432920
000210  3d203078
000214  25780a00
                  |L40.536|
000218  55415254          DCB      "UART2(0x68) = 0x%x\n",0
00021c  32283078
000220  36382920
000224  3d203078
000228  25780a00

                          AREA ||i.kdp_uart_read||, CODE, READONLY, ALIGN=2

                  kdp_uart_read PROC
;;;1296   */
;;;1297   kdp_uart_api_sts_t kdp_uart_read(kdp_uart_hdl_t handle, uint8_t *data, uint32_t len)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1298   {
000002  4613              MOV      r3,r2
000004  460a              MOV      r2,r1
;;;1299       uint32_t com_port = handle;
000006  4605              MOV      r5,r0
;;;1300   
;;;1301       kdp_uart_rx_busy_clear( handle );
000008  f7fffffe          BL       kdp_uart_rx_busy_clear
;;;1302   
;;;1303       if (com_port >= TOTAL_UART_DEV) {
00000c  2d05              CMP      r5,#5
00000e  d20e              BCS      |L41.46|
;;;1304           //dbg_msg("Invalid parameter\n");
;;;1305           return UART_API_INVALID_PARAM;
;;;1306       }
;;;1307   
;;;1308       if (gDrvCtx.active_dev[com_port] == FALSE)
000010  4831              LDR      r0,|L41.216|
000012  1941              ADDS     r1,r0,r5
000014  7849              LDRB     r1,[r1,#1]
000016  b151              CBZ      r1,|L41.46|
;;;1309       {
;;;1310           //dbg_msg("This UART device has been closed\n");
;;;1311           return UART_API_INVALID_PARAM;
;;;1312       }
;;;1313   
;;;1314       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
000018  eb000085          ADD      r0,r0,r5,LSL #2
;;;1315   
;;;1316       if ((data == NULL) || (len == 0))
00001c  6884              LDR      r4,[r0,#8]
00001e  b132              CBZ      r2,|L41.46|
000020  b12b              CBZ      r3,|L41.46|
;;;1317       {
;;;1318           // Invalid parameters
;;;1319           return UART_API_INVALID_PARAM;
;;;1320       }
;;;1321   
;;;1322       if ((pDrv->info.flags & UART_POWERED) == 0)
000022  f8940044          LDRB     r0,[r4,#0x44]
000026  0780              LSLS     r0,r0,#30
000028  d403              BMI      |L41.50|
;;;1323       {
;;;1324           // UART is not powered
;;;1325           return UART_API_NOT_POWRERED;
00002a  2001              MOVS     r0,#1
;;;1326       }
;;;1327   
;;;1328       // Check if receiver is busy
;;;1329       if (pDrv->info.status.rx_busy == 1)
;;;1330       {
;;;1331           return UART_API_RX_BUSY;
;;;1332       }
;;;1333   
;;;1334       // Clear RX status
;;;1335       pDrv->info.status.rx_break = 0;
;;;1336       pDrv->info.status.rx_framing_error = 0;
;;;1337       pDrv->info.status.rx_overflow = 0;
;;;1338       pDrv->info.status.rx_parity_error = 0;
;;;1339   
;;;1340       // Save receive buffer info
;;;1341       pDrv->info.xfer.rx_buf = (uint8_t *)data;
;;;1342       pDrv->info.xfer.rx_cnt = 0;
;;;1343       pDrv->info.xfer.write_idx = 0;
;;;1344       pDrv->info.xfer.read_idx = 0;
;;;1345       // Save number of data to be received
;;;1346       pDrv->info.xfer.rx_num = len;
;;;1347   
;;;1348   
;;;1349       /* setup RX FIFO trigger level based on buf len*/
;;;1350       if (pDrv->config.fifo_en == TRUE)
;;;1351       {
;;;1352           kdp_uart_fifo_cfg_t cfg;
;;;1353           cfg.bEnFifo = TRUE;
;;;1354           cfg.fifo_trig_level = 0;      // init with 0
;;;1355           kdp_calculate_fifo_cfg(pDrv, len, &cfg);
;;;1356           kdp_uart_control(com_port, UART_CTRL_FIFO_RX, (uint8_t *)&cfg);
;;;1357       }
;;;1358   
;;;1359       pDrv->info.status.rx_busy = 1;
;;;1360   
;;;1361       kdp_set_serial_int((DRVUART_PORT)pDrv->uart_port, SERIAL_IER_DR);
;;;1362   
;;;1363       NVIC_SetVector((IRQn_Type)pDrv->res.irq_num, (uint32_t)pDrv->res.isr);
;;;1364       NVIC_EnableIRQ((IRQn_Type)pDrv->res.irq_num);
;;;1365   
;;;1366       if (pDrv->info.mode & UART_MODE_ASYN_RX)
;;;1367       {
;;;1368           return UART_API_RX_BUSY;
;;;1369       }
;;;1370       else if (pDrv->info.mode & UART_MODE_SYNC_RX)
;;;1371       {
;;;1372           int32_t timeout = pDrv->nTimeOutRx;
;;;1373           if (timeout <= 0)
;;;1374           {
;;;1375               //dbg_msg("Error: Rx timeout value is not set correctly\n");
;;;1376               timeout = DEFAULT_SYNC_TIMEOUT_CHARS_TIME;
;;;1377           }
;;;1378   
;;;1379           while ((pDrv->info.status.rx_busy == 1) && (timeout > 0))
;;;1380           {
;;;1381               osDelay(1);
;;;1382               timeout--;
;;;1383           }
;;;1384           if (timeout == 0)
;;;1385               return UART_API_TIMEOUT;
;;;1386           return UART_API_RETURN_SUCCESS;
;;;1387       }
;;;1388       else
;;;1389       {
;;;1390           //dbg_msg("Error: Sync/Async mode was not set\n");
;;;1391           return UART_API_ERROR;
;;;1392       }
;;;1393   }
00002c  bdf8              POP      {r3-r7,pc}
                  |L41.46|
00002e  2008              MOVS     r0,#8                 ;1319
000030  bdf8              POP      {r3-r7,pc}
                  |L41.50|
000032  7f60              LDRB     r0,[r4,#0x1d]         ;1329
000034  2801              CMP      r0,#1                 ;1329
000036  d035              BEQ      |L41.164|
000038  2000              MOVS     r0,#0                 ;1335
00003a  f8840020          STRB     r0,[r4,#0x20]         ;1335
00003e  f8840021          STRB     r0,[r4,#0x21]         ;1336
000042  77e0              STRB     r0,[r4,#0x1f]         ;1337
000044  f8840022          STRB     r0,[r4,#0x22]         ;1338
000048  62e2              STR      r2,[r4,#0x2c]         ;1342
00004a  6360              STR      r0,[r4,#0x34]         ;1342
00004c  63e0              STR      r0,[r4,#0x3c]         ;1343
00004e  6420              STR      r0,[r4,#0x40]         ;1344
000050  6263              STR      r3,[r4,#0x24]         ;1346
000052  7d21              LDRB     r1,[r4,#0x14]         ;1350
000054  2601              MOVS     r6,#1                 ;1325
000056  2901              CMP      r1,#1                 ;1350
000058  d10d              BNE      |L41.118|
00005a  f88d6000          STRB     r6,[sp,#0]            ;1353
00005e  f88d0001          STRB     r0,[sp,#1]            ;1354
000062  466a              MOV      r2,sp                 ;1355
000064  4619              MOV      r1,r3                 ;1355
000066  4620              MOV      r0,r4                 ;1355
000068  f7fffffe          BL       kdp_calculate_fifo_cfg
00006c  466a              MOV      r2,sp                 ;1356
00006e  2101              MOVS     r1,#1                 ;1356
000070  4628              MOV      r0,r5                 ;1356
000072  f7fffffe          BL       kdp_uart_control
                  |L41.118|
000076  7766              STRB     r6,[r4,#0x1d]         ;1359
000078  7820              LDRB     r0,[r4,#0]            ;1361
00007a  4918              LDR      r1,|L41.220|
00007c  f8510020          LDR      r0,[r1,r0,LSL #2]     ;1361
000080  6046              STR      r6,[r0,#4]            ;1361
000082  4917              LDR      r1,|L41.224|
000084  f894004c          LDRB     r0,[r4,#0x4c]         ;1363
000088  6d22              LDR      r2,[r4,#0x50]         ;1363
00008a  6809              LDR      r1,[r1,#0]            ;1363
00008c  b240              SXTB     r0,r0                 ;1363
00008e  eb010080          ADD      r0,r1,r0,LSL #2       ;1363
000092  6402              STR      r2,[r0,#0x40]         ;1364
000094  f894004c          LDRB     r0,[r4,#0x4c]         ;1364
000098  b240              SXTB     r0,r0                 ;1364
00009a  f7fffffe          BL       __NVIC_EnableIRQ
00009e  6ca0              LDR      r0,[r4,#0x48]         ;1366
0000a0  07c1              LSLS     r1,r0,#31             ;1366
0000a2  d001              BEQ      |L41.168|
                  |L41.164|
0000a4  2004              MOVS     r0,#4                 ;1368
0000a6  bdf8              POP      {r3-r7,pc}
                  |L41.168|
0000a8  0740              LSLS     r0,r0,#29             ;1370
0000aa  d513              BPL      |L41.212|
0000ac  6f25              LDR      r5,[r4,#0x70]         ;1373
0000ae  2d00              CMP      r5,#0                 ;1373
0000b0  dc06              BGT      |L41.192|
0000b2  f44f7500          MOV      r5,#0x200             ;1376
0000b6  e003              B        |L41.192|
                  |L41.184|
0000b8  2001              MOVS     r0,#1                 ;1381
0000ba  f7fffffe          BL       osDelay
0000be  1e6d              SUBS     r5,r5,#1              ;1381
                  |L41.192|
0000c0  7f60              LDRB     r0,[r4,#0x1d]         ;1379
0000c2  2801              CMP      r0,#1                 ;1379
0000c4  d101              BNE      |L41.202|
0000c6  2d00              CMP      r5,#0                 ;1379
0000c8  dcf6              BGT      |L41.184|
                  |L41.202|
0000ca  b10d              CBZ      r5,|L41.208|
0000cc  2000              MOVS     r0,#0                 ;1386
0000ce  bdf8              POP      {r3-r7,pc}
                  |L41.208|
0000d0  2020              MOVS     r0,#0x20              ;1385
0000d2  bdf8              POP      {r3-r7,pc}
                  |L41.212|
0000d4  2010              MOVS     r0,#0x10              ;1391
0000d6  bdf8              POP      {r3-r7,pc}
;;;1394   
                          ENDP

                  |L41.216|
                          DCD      ||.bss||
                  |L41.220|
                          DCD      ||.data||+0x38
                  |L41.224|
                          DCD      0xe000ed08

                          AREA ||i.kdp_uart_rx_busy_clear||, CODE, READONLY, ALIGN=2

                  kdp_uart_rx_busy_clear PROC
;;;1811   }
;;;1812   void kdp_uart_rx_busy_clear(kdp_uart_hdl_t handle)
000000  4903              LDR      r1,|L42.16|
;;;1813   {
;;;1814       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[handle];
000002  eb010080          ADD      r0,r1,r0,LSL #2
;;;1815   //    kdp_printf("Rx busy 0x%x\n", pDrv->info.status.rx_busy );
;;;1816       pDrv->info.status.rx_busy = 0;
000006  2100              MOVS     r1,#0
000008  6880              LDR      r0,[r0,#8]            ;1814
00000a  7741              STRB     r1,[r0,#0x1d]
;;;1817   
;;;1818   }
00000c  4770              BX       lr
                          ENDP

00000e  0000              DCW      0x0000
                  |L42.16|
                          DCD      ||.bss||

                          AREA ||i.kdp_uart_write||, CODE, READONLY, ALIGN=2

                  kdp_uart_write PROC
;;;1196   */
;;;1197   kdp_uart_api_sts_t kdp_uart_write(kdp_uart_hdl_t handle, uint8_t *data, uint32_t len)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1198   {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
;;;1199       uint32_t com_port = handle;
000008  4605              MOV      r5,r0
;;;1200   
;;;1201       if (com_port >= TOTAL_UART_DEV) {
00000a  2805              CMP      r0,#5
00000c  d20f              BCS      |L43.46|
;;;1202           //dbg_msg("Invalid parameter\n");
;;;1203           return UART_API_INVALID_PARAM;
;;;1204       }
;;;1205   
;;;1206       if (gDrvCtx.active_dev[com_port] == FALSE)
00000e  4832              LDR      r0,|L43.216|
000010  1941              ADDS     r1,r0,r5
000012  7849              LDRB     r1,[r1,#1]
000014  b159              CBZ      r1,|L43.46|
;;;1207       {
;;;1208           //dbg_msg("This UART device has been closed\n");
;;;1209           return UART_API_INVALID_PARAM;
;;;1210       }
;;;1211   
;;;1212       kdp_driver_hdl_t *pDrv = gDrvCtx.uart_dev[com_port];
000016  eb000085          ADD      r0,r0,r5,LSL #2
;;;1213   
;;;1214       if ((data == NULL) || (len == 0))
00001a  6884              LDR      r4,[r0,#8]
00001c  b13f              CBZ      r7,|L43.46|
00001e  b136              CBZ      r6,|L43.46|
;;;1215       {
;;;1216           // Invalid parameters
;;;1217           return UART_API_INVALID_PARAM;
;;;1218       }
;;;1219   
;;;1220       if ((pDrv->info.flags & UART_POWERED) == 0)
000020  f8940044          LDRB     r0,[r4,#0x44]
000024  0780              LSLS     r0,r0,#30
000026  d404              BMI      |L43.50|
;;;1221       {
;;;1222           // UART is not powered 
;;;1223           return UART_API_NOT_POWRERED;
000028  2001              MOVS     r0,#1
                  |L43.42|
;;;1224       }
;;;1225   
;;;1226       if (pDrv->info.status.tx_busy == 1)
;;;1227       {
;;;1228           // Send is not completed yet
;;;1229           return UART_API_TX_BUSY;
;;;1230       }
;;;1231   
;;;1232       if (pDrv->info.mode & UART_MODE_ASYN_TX)
;;;1233       {
;;;1234           /* setup TX FIFO
;;;1235              re-calculate FIFO trigger value based on buffer length
;;;1236           */
;;;1237           if (pDrv->config.fifo_en == TRUE)
;;;1238           {
;;;1239               kdp_uart_fifo_cfg_t cfg;
;;;1240               cfg.bEnFifo = TRUE;
;;;1241               cfg.fifo_trig_level = 0;      // init with 0
;;;1242               kdp_calculate_fifo_cfg(pDrv, len, &cfg);
;;;1243               kdp_uart_control(com_port, UART_CTRL_FIFO_TX, (uint8_t *)&cfg);
;;;1244           }
;;;1245   
;;;1246           pDrv->info.status.tx_busy = 1;
;;;1247   
;;;1248           // Save transmit buffer info
;;;1249           pDrv->info.xfer.tx_buf = (uint8_t *)data;
;;;1250           pDrv->info.xfer.tx_num = len;
;;;1251           pDrv->info.xfer.tx_cnt = 0;
;;;1252   
;;;1253           kdp_set_serial_int((DRVUART_PORT)pDrv->uart_port, SERIAL_IER_TE);
;;;1254   
;;;1255           NVIC_SetVector((IRQn_Type)pDrv->res.irq_num, (uint32_t)pDrv->res.isr);
;;;1256           NVIC_EnableIRQ((IRQn_Type)pDrv->res.irq_num);
;;;1257   
;;;1258           UART_TX_ISR(pDrv);
;;;1259   
;;;1260   
;;;1261           return UART_API_TX_BUSY;
;;;1262       }
;;;1263       else if (pDrv->info.mode & UART_MODE_SYNC_TX)
;;;1264       {
;;;1265   
;;;1266           pDrv->info.status.tx_busy = 1;
;;;1267   
;;;1268           while (len > 0)
;;;1269           {
;;;1270   
;;;1271               _check_tx_status((DRVUART_PORT)com_port);
;;;1272               outw(UART_PORT[com_port] + SERIAL_THR, *data++);
;;;1273   
;;;1274               len--;
;;;1275           }
;;;1276   
;;;1277           pDrv->info.status.tx_busy = 0;
;;;1278   
;;;1279           return UART_API_RETURN_SUCCESS;
;;;1280       }
;;;1281       else
;;;1282       {
;;;1283           //dbg_msg("Error: Sync/Async mode was not set\n");
;;;1284           return UART_API_ERROR;
;;;1285       }
;;;1286   }
00002a  e8bd8ff8          POP      {r3-r11,pc}
                  |L43.46|
00002e  2008              MOVS     r0,#8                 ;1217
000030  e7fb              B        |L43.42|
                  |L43.50|
000032  7f20              LDRB     r0,[r4,#0x1c]         ;1226
000034  2801              CMP      r0,#1                 ;1226
000036  d00c              BEQ      |L43.82|
000038  6ca0              LDR      r0,[r4,#0x48]         ;1232
00003a  f8dfa0a0          LDR      r10,|L43.220|
00003e  0781              LSLS     r1,r0,#30             ;1232
000040  f04f0900          MOV      r9,#0                 ;1232
000044  f04f0801          MOV      r8,#1                 ;1223
000048  d530              BPL      |L43.172|
00004a  7d20              LDRB     r0,[r4,#0x14]         ;1237
00004c  2801              CMP      r0,#1                 ;1237
00004e  d002              BEQ      |L43.86|
000050  e00f              B        |L43.114|
                  |L43.82|
000052  2002              MOVS     r0,#2                 ;1229
000054  e7e9              B        |L43.42|
                  |L43.86|
000056  f88d8000          STRB     r8,[sp,#0]            ;1240
00005a  f88d9001          STRB     r9,[sp,#1]            ;1241
00005e  466a              MOV      r2,sp                 ;1242
000060  4631              MOV      r1,r6                 ;1242
000062  4620              MOV      r0,r4                 ;1242
000064  f7fffffe          BL       kdp_calculate_fifo_cfg
000068  466a              MOV      r2,sp                 ;1243
00006a  2102              MOVS     r1,#2                 ;1243
00006c  4628              MOV      r0,r5                 ;1243
00006e  f7fffffe          BL       kdp_uart_control
                  |L43.114|
000072  f884801c          STRB     r8,[r4,#0x1c]         ;1246
000076  6327              STR      r7,[r4,#0x30]         ;1250
000078  62a6              STR      r6,[r4,#0x28]         ;1250
00007a  f8c49038          STR      r9,[r4,#0x38]         ;1251
00007e  7820              LDRB     r0,[r4,#0]            ;1253
000080  2102              MOVS     r1,#2                 ;1253
000082  f85a0020          LDR      r0,[r10,r0,LSL #2]    ;1253
000086  6041              STR      r1,[r0,#4]            ;1253
000088  f894004c          LDRB     r0,[r4,#0x4c]         ;1255
00008c  4914              LDR      r1,|L43.224|
00008e  b242              SXTB     r2,r0                 ;1255
000090  6d20              LDR      r0,[r4,#0x50]         ;1255
000092  6809              LDR      r1,[r1,#0]            ;1255
000094  eb010182          ADD      r1,r1,r2,LSL #2       ;1255
000098  6408              STR      r0,[r1,#0x40]         ;1256
00009a  f894004c          LDRB     r0,[r4,#0x4c]         ;1256
00009e  b240              SXTB     r0,r0                 ;1256
0000a0  f7fffffe          BL       __NVIC_EnableIRQ
0000a4  4620              MOV      r0,r4                 ;1258
0000a6  f7fffffe          BL       UART_TX_ISR
0000aa  e7d2              B        |L43.82|
                  |L43.172|
0000ac  0700              LSLS     r0,r0,#28             ;1263
0000ae  d510              BPL      |L43.210|
0000b0  f884801c          STRB     r8,[r4,#0x1c]         ;1266
0000b4  4653              MOV      r3,r10                ;1266
                  |L43.182|
0000b6  b2e8              UXTB     r0,r5                 ;1271
0000b8  f7fffffe          BL       _check_tx_status
0000bc  f8531025          LDR      r1,[r3,r5,LSL #2]     ;1272
0000c0  f8170b01          LDRB     r0,[r7],#1            ;1272
0000c4  6008              STR      r0,[r1,#0]            ;1272
0000c6  1e76              SUBS     r6,r6,#1              ;1272
0000c8  d1f5              BNE      |L43.182|
0000ca  f884901c          STRB     r9,[r4,#0x1c]         ;1277
0000ce  2000              MOVS     r0,#0                 ;1279
0000d0  e7ab              B        |L43.42|
                  |L43.210|
0000d2  2010              MOVS     r0,#0x10              ;1284
0000d4  e7a9              B        |L43.42|
;;;1287   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L43.216|
                          DCD      ||.bss||
                  |L43.220|
                          DCD      ||.data||+0x38
                  |L43.224|
                          DCD      0xe000ed08

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gDrvCtx
                          %        28

                          AREA ||.data||, DATA, ALIGN=2

                  gDriverInitialized
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  DriverCapabilities
000004  87010000          DCB      0x87,0x01,0x00,0x00
                  gUartIRQTbl
000008  1e1f3031          DCB      0x1e,0x1f,0x30,0x31
00000c  32000000          DCB      0x32,0x00,0x00,0x00
                  gUartISRs
                          DCD      UART0_ISR
                          DCD      UART1_ISR
                          DCD      UART2_ISR
                          DCD      UART3_ISR
                          DCD      UART4_ISR
                  gUartClk
                          DCD      0x01c9c380
                          DCD      0x01c9c380
                          DCD      0x01c9c380
                          DCD      0x01c9c380
                          DCD      0x01c9c380
                  UART_PORT
                          DCD      0xc1400000
                          DCD      0xc1500000
                          DCD      0xc1600000
                          DCD      0xc1700000
                          DCD      0xc1800000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\scpu\\drivers\\src\\kdp_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_kdp_uart_c_9150859b____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___10_kdp_uart_c_9150859b____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_kdp_uart_c_9150859b____REVSH|
#line 223
|__asm___10_kdp_uart_c_9150859b____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_kdp_uart_c_9150859b____RRX|
#line 410
|__asm___10_kdp_uart_c_9150859b____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
