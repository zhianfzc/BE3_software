L 1 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_lib.c"
N/*
N * Copyright (c) 2013-2022 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * -----------------------------------------------------------------------------
N *
N * Project:     CMSIS-RTOS RTX
N * Title:       RTX Library Configuration
N *
N * -----------------------------------------------------------------------------
N */
N
N#include "rtx_os.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include\rtx_os.h" 1
N/*
N * Copyright (c) 2013-2021 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * -----------------------------------------------------------------------------
N *
N * Project:     CMSIS-RTOS RTX
N * Title:       RTX OS definitions
N *
N * -----------------------------------------------------------------------------
N */
N 
N#ifndef RTX_OS_H_
N#define RTX_OS_H_
N 
N#include <stdint.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 30 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include\rtx_os.h" 2
N#include <stddef.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
X  #elif !0L
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 31 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include\rtx_os.h" 2
N#include "cmsis_os2.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include\cmsis_os2.h" 1
N/*
N * Copyright (c) 2013-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * ----------------------------------------------------------------------
N *
N * $Date:        12. June 2020
N * $Revision:    V2.1.3
N *
N * Project:      CMSIS-RTOS2 API
N * Title:        cmsis_os2.h header file
N *
N * Version 2.1.3
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osThreadGetId
N * Version 2.1.2
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osKernelGetInfo, osKernelGetState
N * Version 2.1.1
N *    Additional functions allowed to be called from Interrupt Service Routines:
N *    - osKernelGetTickCount, osKernelGetTickFreq
N *    Changed Kernel Tick type to uint32_t:
N *    - updated: osKernelGetTickCount, osDelayUntil
N * Version 2.1.0
N *    Support for critical and uncritical sections (nesting safe):
N *    - updated: osKernelLock, osKernelUnlock
N *    - added: osKernelRestoreLock
N *    Updated Thread and Event Flags:
N *    - changed flags parameter and return type from int32_t to uint32_t
N * Version 2.0.0
N *    Initial Release
N *---------------------------------------------------------------------------*/
N 
N#ifndef CMSIS_OS2_H_
N#define CMSIS_OS2_H_
N 
N#ifndef __NO_RETURN
N#if   defined(__CC_ARM)
X#if   1L
N#define __NO_RETURN __declspec(noreturn)
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S#define __NO_RETURN __attribute__((__noreturn__))
S#elif defined(__GNUC__)
S#define __NO_RETURN __attribute__((__noreturn__))
S#elif defined(__ICCARM__)
S#define __NO_RETURN __noreturn
S#else
S#define __NO_RETURN
N#endif
N#endif
N 
N#include <stdint.h>
N#include <stddef.h>
N 
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N 
N 
N//  ==== Enumerations, structures, defines ====
N 
N/// Version information.
Ntypedef struct {
N  uint32_t                       api;   ///< API version (major.minor.rev: mmnnnrrrr dec).
N  uint32_t                    kernel;   ///< Kernel version (major.minor.rev: mmnnnrrrr dec).
N} osVersion_t;
N 
N/// Kernel state.
Ntypedef enum {
N  osKernelInactive        =  0,         ///< Inactive.
N  osKernelReady           =  1,         ///< Ready.
N  osKernelRunning         =  2,         ///< Running.
N  osKernelLocked          =  3,         ///< Locked.
N  osKernelSuspended       =  4,         ///< Suspended.
N  osKernelError           = -1,         ///< Error.
N  osKernelReserved        = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osKernelState_t;
N 
N/// Thread state.
Ntypedef enum {
N  osThreadInactive        =  0,         ///< Inactive.
N  osThreadReady           =  1,         ///< Ready.
N  osThreadRunning         =  2,         ///< Running.
N  osThreadBlocked         =  3,         ///< Blocked.
N  osThreadTerminated      =  4,         ///< Terminated.
N  osThreadError           = -1,         ///< Error.
N  osThreadReserved        = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osThreadState_t;
N 
N/// Priority values.
Ntypedef enum {
N  osPriorityNone          =  0,         ///< No priority (not initialized).
N  osPriorityIdle          =  1,         ///< Reserved for Idle thread.
N  osPriorityLow           =  8,         ///< Priority: low
N  osPriorityLow1          =  8+1,       ///< Priority: low + 1
N  osPriorityLow2          =  8+2,       ///< Priority: low + 2
N  osPriorityLow3          =  8+3,       ///< Priority: low + 3
N  osPriorityLow4          =  8+4,       ///< Priority: low + 4
N  osPriorityLow5          =  8+5,       ///< Priority: low + 5
N  osPriorityLow6          =  8+6,       ///< Priority: low + 6
N  osPriorityLow7          =  8+7,       ///< Priority: low + 7
N  osPriorityBelowNormal   = 16,         ///< Priority: below normal
N  osPriorityBelowNormal1  = 16+1,       ///< Priority: below normal + 1
N  osPriorityBelowNormal2  = 16+2,       ///< Priority: below normal + 2
N  osPriorityBelowNormal3  = 16+3,       ///< Priority: below normal + 3
N  osPriorityBelowNormal4  = 16+4,       ///< Priority: below normal + 4
N  osPriorityBelowNormal5  = 16+5,       ///< Priority: below normal + 5
N  osPriorityBelowNormal6  = 16+6,       ///< Priority: below normal + 6
N  osPriorityBelowNormal7  = 16+7,       ///< Priority: below normal + 7
N  osPriorityNormal        = 24,         ///< Priority: normal
N  osPriorityNormal1       = 24+1,       ///< Priority: normal + 1
N  osPriorityNormal2       = 24+2,       ///< Priority: normal + 2
N  osPriorityNormal3       = 24+3,       ///< Priority: normal + 3
N  osPriorityNormal4       = 24+4,       ///< Priority: normal + 4
N  osPriorityNormal5       = 24+5,       ///< Priority: normal + 5
N  osPriorityNormal6       = 24+6,       ///< Priority: normal + 6
N  osPriorityNormal7       = 24+7,       ///< Priority: normal + 7
N  osPriorityAboveNormal   = 32,         ///< Priority: above normal
N  osPriorityAboveNormal1  = 32+1,       ///< Priority: above normal + 1
N  osPriorityAboveNormal2  = 32+2,       ///< Priority: above normal + 2
N  osPriorityAboveNormal3  = 32+3,       ///< Priority: above normal + 3
N  osPriorityAboveNormal4  = 32+4,       ///< Priority: above normal + 4
N  osPriorityAboveNormal5  = 32+5,       ///< Priority: above normal + 5
N  osPriorityAboveNormal6  = 32+6,       ///< Priority: above normal + 6
N  osPriorityAboveNormal7  = 32+7,       ///< Priority: above normal + 7
N  osPriorityHigh          = 40,         ///< Priority: high
N  osPriorityHigh1         = 40+1,       ///< Priority: high + 1
N  osPriorityHigh2         = 40+2,       ///< Priority: high + 2
N  osPriorityHigh3         = 40+3,       ///< Priority: high + 3
N  osPriorityHigh4         = 40+4,       ///< Priority: high + 4
N  osPriorityHigh5         = 40+5,       ///< Priority: high + 5
N  osPriorityHigh6         = 40+6,       ///< Priority: high + 6
N  osPriorityHigh7         = 40+7,       ///< Priority: high + 7
N  osPriorityRealtime      = 48,         ///< Priority: realtime
N  osPriorityRealtime1     = 48+1,       ///< Priority: realtime + 1
N  osPriorityRealtime2     = 48+2,       ///< Priority: realtime + 2
N  osPriorityRealtime3     = 48+3,       ///< Priority: realtime + 3
N  osPriorityRealtime4     = 48+4,       ///< Priority: realtime + 4
N  osPriorityRealtime5     = 48+5,       ///< Priority: realtime + 5
N  osPriorityRealtime6     = 48+6,       ///< Priority: realtime + 6
N  osPriorityRealtime7     = 48+7,       ///< Priority: realtime + 7
N  osPriorityISR           = 56,         ///< Reserved for ISR deferred thread.
N  osPriorityError         = -1,         ///< System cannot determine priority or illegal priority.
N  osPriorityReserved      = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osPriority_t;
N 
N/// Entry point of a thread.
Ntypedef void (*osThreadFunc_t) (void *argument);
N 
N/// Timer callback function.
Ntypedef void (*osTimerFunc_t) (void *argument);
N 
N/// Timer type.
Ntypedef enum {
N  osTimerOnce               = 0,          ///< One-shot timer.
N  osTimerPeriodic           = 1           ///< Repeating timer.
N} osTimerType_t;
N 
N// Timeout value.
N#define osWaitForever         0xFFFFFFFFU ///< Wait forever timeout value.
N 
N// Flags options (\ref osThreadFlagsWait and \ref osEventFlagsWait).
N#define osFlagsWaitAny        0x00000000U ///< Wait for any flag (default).
N#define osFlagsWaitAll        0x00000001U ///< Wait for all flags.
N#define osFlagsNoClear        0x00000002U ///< Do not clear flags which have been specified to wait for.
N 
N// Flags errors (returned by osThreadFlagsXxxx and osEventFlagsXxxx).
N#define osFlagsError          0x80000000U ///< Error indicator.
N#define osFlagsErrorUnknown   0xFFFFFFFFU ///< osError (-1).
N#define osFlagsErrorTimeout   0xFFFFFFFEU ///< osErrorTimeout (-2).
N#define osFlagsErrorResource  0xFFFFFFFDU ///< osErrorResource (-3).
N#define osFlagsErrorParameter 0xFFFFFFFCU ///< osErrorParameter (-4).
N#define osFlagsErrorISR       0xFFFFFFFAU ///< osErrorISR (-6).
N 
N// Thread attributes (attr_bits in \ref osThreadAttr_t).
N#define osThreadDetached      0x00000000U ///< Thread created in detached mode (default)
N#define osThreadJoinable      0x00000001U ///< Thread created in joinable mode
N 
N// Mutex attributes (attr_bits in \ref osMutexAttr_t).
N#define osMutexRecursive      0x00000001U ///< Recursive mutex.
N#define osMutexPrioInherit    0x00000002U ///< Priority inherit protocol.
N#define osMutexRobust         0x00000008U ///< Robust mutex.
N 
N/// Status code values returned by CMSIS-RTOS functions.
Ntypedef enum {
N  osOK                      =  0,         ///< Operation completed successfully.
N  osError                   = -1,         ///< Unspecified RTOS error: run-time error but no other error message fits.
N  osErrorTimeout            = -2,         ///< Operation not completed within the timeout period.
N  osErrorResource           = -3,         ///< Resource not available.
N  osErrorParameter          = -4,         ///< Parameter error.
N  osErrorNoMemory           = -5,         ///< System is out of memory: it was impossible to allocate or reserve memory for the operation.
N  osErrorISR                = -6,         ///< Not allowed in ISR context: the function cannot be called from interrupt service routines.
N  osStatusReserved          = 0x7FFFFFFF  ///< Prevents enum down-size compiler optimization.
N} osStatus_t;
N 
N 
N/// \details Thread ID identifies the thread.
Ntypedef void *osThreadId_t;
N 
N/// \details Timer ID identifies the timer.
Ntypedef void *osTimerId_t;
N 
N/// \details Event Flags ID identifies the event flags.
Ntypedef void *osEventFlagsId_t;
N 
N/// \details Mutex ID identifies the mutex.
Ntypedef void *osMutexId_t;
N 
N/// \details Semaphore ID identifies the semaphore.
Ntypedef void *osSemaphoreId_t;
N 
N/// \details Memory Pool ID identifies the memory pool.
Ntypedef void *osMemoryPoolId_t;
N 
N/// \details Message Queue ID identifies the message queue.
Ntypedef void *osMessageQueueId_t;
N 
N 
N#ifndef TZ_MODULEID_T
N#define TZ_MODULEID_T
N/// \details Data type that identifies secure software modules called by a process.
Ntypedef uint32_t TZ_ModuleId_t;
N#endif
N 
N 
N/// Attributes structure for thread.
Ntypedef struct {
N  const char                   *name;   ///< name of the thread
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                   *stack_mem;    ///< memory for stack
N  uint32_t                stack_size;   ///< size of stack
N  osPriority_t              priority;   ///< initial thread priority (default: osPriorityNormal)
N  TZ_ModuleId_t            tz_module;   ///< TrustZone module identifier
N  uint32_t                  reserved;   ///< reserved (must be 0)
N} osThreadAttr_t;
N 
N/// Attributes structure for timer.
Ntypedef struct {
N  const char                   *name;   ///< name of the timer
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osTimerAttr_t;
N 
N/// Attributes structure for event flags.
Ntypedef struct {
N  const char                   *name;   ///< name of the event flags
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osEventFlagsAttr_t;
N 
N/// Attributes structure for mutex.
Ntypedef struct {
N  const char                   *name;   ///< name of the mutex
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osMutexAttr_t;
N 
N/// Attributes structure for semaphore.
Ntypedef struct {
N  const char                   *name;   ///< name of the semaphore
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N} osSemaphoreAttr_t;
N 
N/// Attributes structure for memory pool.
Ntypedef struct {
N  const char                   *name;   ///< name of the memory pool
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                      *mp_mem;    ///< memory for data storage
N  uint32_t                   mp_size;   ///< size of provided memory for data storage 
N} osMemoryPoolAttr_t;
N 
N/// Attributes structure for message queue.
Ntypedef struct {
N  const char                   *name;   ///< name of the message queue
N  uint32_t                 attr_bits;   ///< attribute bits
N  void                      *cb_mem;    ///< memory for control block
N  uint32_t                   cb_size;   ///< size of provided memory for control block
N  void                      *mq_mem;    ///< memory for data storage
N  uint32_t                   mq_size;   ///< size of provided memory for data storage 
N} osMessageQueueAttr_t;
N 
N 
N//  ==== Kernel Management Functions ====
N 
N/// Initialize the RTOS Kernel.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelInitialize (void);
N 
N///  Get RTOS Kernel Information.
N/// \param[out]    version       pointer to buffer for retrieving version information.
N/// \param[out]    id_buf        pointer to buffer for retrieving kernel identification string.
N/// \param[in]     id_size       size of buffer for kernel identification string.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size);
N 
N/// Get the current RTOS Kernel state.
N/// \return current RTOS Kernel state.
NosKernelState_t osKernelGetState (void);
N 
N/// Start the RTOS Kernel scheduler.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osKernelStart (void);
N 
N/// Lock the RTOS Kernel scheduler.
N/// \return previous lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelLock (void);
N 
N/// Unlock the RTOS Kernel scheduler.
N/// \return previous lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelUnlock (void);
N 
N/// Restore the RTOS Kernel scheduler lock state.
N/// \param[in]     lock          lock state obtained by \ref osKernelLock or \ref osKernelUnlock.
N/// \return new lock state (1 - locked, 0 - not locked, error code if negative).
Nint32_t osKernelRestoreLock (int32_t lock);
N 
N/// Suspend the RTOS Kernel scheduler.
N/// \return time in ticks, for how long the system can sleep or power-down.
Nuint32_t osKernelSuspend (void);
N 
N/// Resume the RTOS Kernel scheduler.
N/// \param[in]     sleep_ticks   time in ticks for how long the system was in sleep or power-down mode.
Nvoid osKernelResume (uint32_t sleep_ticks);
N 
N/// Get the RTOS kernel tick count.
N/// \return RTOS kernel current tick count.
Nuint32_t osKernelGetTickCount (void);
N 
N/// Get the RTOS kernel tick frequency.
N/// \return frequency of the kernel tick in hertz, i.e. kernel ticks per second.
Nuint32_t osKernelGetTickFreq (void);
N 
N/// Get the RTOS kernel system timer count.
N/// \return RTOS kernel current system timer count as 32-bit value.
Nuint32_t osKernelGetSysTimerCount (void);
N 
N/// Get the RTOS kernel system timer frequency.
N/// \return frequency of the system timer in hertz, i.e. timer ticks per second.
Nuint32_t osKernelGetSysTimerFreq (void);
N 
N 
N//  ==== Thread Management Functions ====
N 
N/// Create a thread and add it to Active Threads.
N/// \param[in]     func          thread function.
N/// \param[in]     argument      pointer that is passed to the thread function as start argument.
N/// \param[in]     attr          thread attributes; NULL: default values.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr);
N 
N/// Get name of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return name as null-terminated string.
Nconst char *osThreadGetName (osThreadId_t thread_id);
N 
N/// Return the thread ID of the current running thread.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId_t osThreadGetId (void);
N 
N/// Get current thread state of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return current thread state of the specified thread.
NosThreadState_t osThreadGetState (osThreadId_t thread_id);
N 
N/// Get stack size of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return stack size in bytes.
Nuint32_t osThreadGetStackSize (osThreadId_t thread_id);
N 
N/// Get available stack space of a thread based on stack watermark recording during execution.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return remaining stack space in bytes.
Nuint32_t osThreadGetStackSpace (osThreadId_t thread_id);
N 
N/// Change priority of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \param[in]     priority      new priority value for the thread function.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority);
N 
N/// Get current priority of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return current priority value of the specified thread.
NosPriority_t osThreadGetPriority (osThreadId_t thread_id);
N 
N/// Pass control to next thread that is in state \b READY.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadYield (void);
N 
N/// Suspend execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadSuspend (osThreadId_t thread_id);
N 
N/// Resume execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadResume (osThreadId_t thread_id);
N 
N/// Detach a thread (thread storage can be reclaimed when thread terminates).
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadDetach (osThreadId_t thread_id);
N 
N/// Wait for specified thread to terminate.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadJoin (osThreadId_t thread_id);
N 
N/// Terminate execution of current running thread.
N__NO_RETURN void osThreadExit (void);
X__declspec(noreturn) void osThreadExit (void);
N 
N/// Terminate execution of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osThreadTerminate (osThreadId_t thread_id);
N 
N/// Get number of active threads.
N/// \return number of active threads.
Nuint32_t osThreadGetCount (void);
N 
N/// Enumerate active threads.
N/// \param[out]    thread_array  pointer to array for retrieving thread IDs.
N/// \param[in]     array_items   maximum number of items in array for retrieving thread IDs.
N/// \return number of enumerated threads.
Nuint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items);
N 
N 
N//  ==== Thread Flags Functions ====
N 
N/// Set the specified Thread Flags of a thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N/// \param[in]     flags         specifies the flags of the thread that shall be set.
N/// \return thread flags after setting or error code if highest bit set.
Nuint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags);
N 
N/// Clear the specified Thread Flags of current running thread.
N/// \param[in]     flags         specifies the flags of the thread that shall be cleared.
N/// \return thread flags before clearing or error code if highest bit set.
Nuint32_t osThreadFlagsClear (uint32_t flags);
N 
N/// Get the current Thread Flags of current running thread.
N/// \return current thread flags.
Nuint32_t osThreadFlagsGet (void);
N 
N/// Wait for one or more Thread Flags of the current running thread to become signaled.
N/// \param[in]     flags         specifies the flags to wait for.
N/// \param[in]     options       specifies flags options (osFlagsXxxx).
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return thread flags before clearing or error code if highest bit set.
Nuint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout);
N 
N 
N//  ==== Generic Wait Functions ====
N 
N/// Wait for Timeout (Time Delay).
N/// \param[in]     ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value
N/// \return status code that indicates the execution status of the function.
NosStatus_t osDelay (uint32_t ticks);
N 
N/// Wait until specified time.
N/// \param[in]     ticks         absolute time in ticks
N/// \return status code that indicates the execution status of the function.
NosStatus_t osDelayUntil (uint32_t ticks);
N 
N 
N//  ==== Timer Management Functions ====
N 
N/// Create and Initialize a timer.
N/// \param[in]     func          function pointer to callback function.
N/// \param[in]     type          \ref osTimerOnce for one-shot or \ref osTimerPeriodic for periodic behavior.
N/// \param[in]     argument      argument to the timer callback function.
N/// \param[in]     attr          timer attributes; NULL: default values.
N/// \return timer ID for reference by other functions or NULL in case of error.
NosTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr);
N 
N/// Get name of a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return name as null-terminated string.
Nconst char *osTimerGetName (osTimerId_t timer_id);
N 
N/// Start or restart a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \param[in]     ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value of the timer.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks);
N 
N/// Stop a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerStop (osTimerId_t timer_id);
N 
N/// Check if a timer is running.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return 0 not running, 1 running.
Nuint32_t osTimerIsRunning (osTimerId_t timer_id);
N 
N/// Delete a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osTimerDelete (osTimerId_t timer_id);
N 
N 
N//  ==== Event Flags Management Functions ====
N 
N/// Create and Initialize an Event Flags object.
N/// \param[in]     attr          event flags attributes; NULL: default values.
N/// \return event flags ID for reference by other functions or NULL in case of error.
NosEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr);
N 
N/// Get name of an Event Flags object.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return name as null-terminated string.
Nconst char *osEventFlagsGetName (osEventFlagsId_t ef_id);
N 
N/// Set the specified Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags that shall be set.
N/// \return event flags after setting or error code if highest bit set.
Nuint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags);
N 
N/// Clear the specified Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags that shall be cleared.
N/// \return event flags before clearing or error code if highest bit set.
Nuint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags);
N 
N/// Get the current Event Flags.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return current event flags.
Nuint32_t osEventFlagsGet (osEventFlagsId_t ef_id);
N 
N/// Wait for one or more Event Flags to become signaled.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \param[in]     flags         specifies the flags to wait for.
N/// \param[in]     options       specifies flags options (osFlagsXxxx).
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return event flags before clearing or error code if highest bit set.
Nuint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout);
N 
N/// Delete an Event Flags object.
N/// \param[in]     ef_id         event flags ID obtained by \ref osEventFlagsNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id);
N 
N 
N//  ==== Mutex Management Functions ====
N 
N/// Create and Initialize a Mutex object.
N/// \param[in]     attr          mutex attributes; NULL: default values.
N/// \return mutex ID for reference by other functions or NULL in case of error.
NosMutexId_t osMutexNew (const osMutexAttr_t *attr);
N 
N/// Get name of a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return name as null-terminated string.
Nconst char *osMutexGetName (osMutexId_t mutex_id);
N 
N/// Acquire a Mutex or timeout if it is locked.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout);
N 
N/// Release a Mutex that was acquired by \ref osMutexAcquire.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexRelease (osMutexId_t mutex_id);
N 
N/// Get Thread which owns a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return thread ID of owner thread or NULL when mutex was not acquired.
NosThreadId_t osMutexGetOwner (osMutexId_t mutex_id);
N 
N/// Delete a Mutex object.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMutexDelete (osMutexId_t mutex_id);
N 
N 
N//  ==== Semaphore Management Functions ====
N 
N/// Create and Initialize a Semaphore object.
N/// \param[in]     max_count     maximum number of available tokens.
N/// \param[in]     initial_count initial number of available tokens.
N/// \param[in]     attr          semaphore attributes; NULL: default values.
N/// \return semaphore ID for reference by other functions or NULL in case of error.
NosSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr);
N 
N/// Get name of a Semaphore object.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return name as null-terminated string.
Nconst char *osSemaphoreGetName (osSemaphoreId_t semaphore_id);
N 
N/// Acquire a Semaphore token or timeout if no tokens are available.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout);
N 
N/// Release a Semaphore token up to the initial maximum count.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id);
N 
N/// Get current Semaphore token count.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return number of tokens available.
Nuint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id);
N 
N/// Delete a Semaphore object.
N/// \param[in]     semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id);
N 
N 
N//  ==== Memory Pool Management Functions ====
N 
N/// Create and Initialize a Memory Pool object.
N/// \param[in]     block_count   maximum number of memory blocks in memory pool.
N/// \param[in]     block_size    memory block size in bytes.
N/// \param[in]     attr          memory pool attributes; NULL: default values.
N/// \return memory pool ID for reference by other functions or NULL in case of error.
NosMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr);
N 
N/// Get name of a Memory Pool object.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return name as null-terminated string.
Nconst char *osMemoryPoolGetName (osMemoryPoolId_t mp_id);
N 
N/// Allocate a memory block from a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return address of the allocated memory block or NULL in case of no memory is available.
Nvoid *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout);
N 
N/// Return an allocated memory block back to a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \param[in]     block         address of the allocated memory block to be returned to the memory pool.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block);
N 
N/// Get maximum number of memory blocks in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return maximum number of memory blocks.
Nuint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id);
N 
N/// Get memory block size in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return memory block size in bytes.
Nuint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id);
N 
N/// Get number of memory blocks used in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return number of memory blocks used.
Nuint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id);
N 
N/// Get number of memory blocks available in a Memory Pool.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return number of memory blocks available.
Nuint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id);
N 
N/// Delete a Memory Pool object.
N/// \param[in]     mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id);
N 
N 
N//  ==== Message Queue Management Functions ====
N 
N/// Create and Initialize a Message Queue object.
N/// \param[in]     msg_count     maximum number of messages in queue.
N/// \param[in]     msg_size      maximum message size in bytes.
N/// \param[in]     attr          message queue attributes; NULL: default values.
N/// \return message queue ID for reference by other functions or NULL in case of error.
NosMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr);
N 
N/// Get name of a Message Queue object.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return name as null-terminated string.
Nconst char *osMessageQueueGetName (osMessageQueueId_t mq_id);
N 
N/// Put a Message into a Queue or timeout if Queue is full.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \param[in]     msg_ptr       pointer to buffer with message to put into a queue.
N/// \param[in]     msg_prio      message priority.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout);
N 
N/// Get a Message from a Queue or timeout if Queue is empty.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \param[out]    msg_ptr       pointer to buffer for message to get from a queue.
N/// \param[out]    msg_prio      pointer to buffer for message priority or NULL.
N/// \param[in]     timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout);
N 
N/// Get maximum number of messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return maximum number of messages.
Nuint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id);
N 
N/// Get maximum message size in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return maximum message size in bytes.
Nuint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id);
N 
N/// Get number of queued messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return number of queued messages.
Nuint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id);
N 
N/// Get number of available slots for messages in a Message Queue.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return number of available slots for messages.
Nuint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id);
N 
N/// Reset a Message Queue to initial empty state.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueReset (osMessageQueueId_t mq_id);
N 
N/// Delete a Message Queue object.
N/// \param[in]     mq_id         message queue ID obtained by \ref osMessageQueueNew.
N/// \return status code that indicates the execution status of the function.
NosStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id);
N 
N 
N#ifdef  __cplusplus
S}
N#endif
N 
N#endif  // CMSIS_OS2_H_
L 32 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include\rtx_os.h" 2
N#include "rtx_def.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include\rtx_def.h" 1
N/*
N * Copyright (c) 2021 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * -----------------------------------------------------------------------------
N *
N * Project:     CMSIS-RTOS RTX
N * Title:       RTX derived definitions
N *
N * -----------------------------------------------------------------------------
N */
N
N#ifndef RTX_DEF_H_
N#define RTX_DEF_H_
N
N#ifdef   _RTE_
N#include "RTE_Components.h"
L 1 ".\RTE\_Target-scpu\RTE_Components.h" 1
N
N/*
N * Auto generated Run-Time-Environment Configuration File
N *      *** Do not modify ! ***
N *
N * Project: 'scpu' 
N * Target:  'Target-scpu' 
N */
N
N#ifndef RTE_COMPONENTS_H
N#define RTE_COMPONENTS_H
N
N
N/*
N * Define the Device Header File: 
N */
N#define CMSIS_device_header "ARMCM4_FP.h"
N
N/* ARM::CMSIS:RTOS2:Keil RTX5:Source:5.5.4 */
N#define RTE_CMSIS_RTOS2                 /* CMSIS-RTOS2 */
N        #define RTE_CMSIS_RTOS2_RTX5            /* CMSIS-RTOS2 Keil RTX5 */
N        #define RTE_CMSIS_RTOS2_RTX5_SOURCE     /* CMSIS-RTOS2 Keil RTX5 Source */
N
N
N#endif /* RTE_COMPONENTS_H */
L 31 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include\rtx_def.h" 2
N#endif
N#include "RTX_Config.h"
L 1 ".\RTE\CMSIS\RTX_Config.h" 1
N/*
N * Copyright (c) 2013-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * -----------------------------------------------------------------------------
N *
N * $Revision:   V5.4.0
N *
N * Project:     CMSIS-RTOS RTX
N * Title:       RTX Configuration definitions
N *
N * -----------------------------------------------------------------------------
N */
N 
N#ifndef RTX_CONFIG_H_
N#define RTX_CONFIG_H_
N 
N#ifdef   _RTE_
N#include "RTE_Components.h"
N#ifdef    RTE_RTX_CONFIG_H
S#include  RTE_RTX_CONFIG_H
N#endif
N#endif
N 
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N 
N// <h>System Configuration
N// =======================
N 
N//   <o>Global Dynamic Memory size [bytes] <0-1073741824:8>
N//   <i> Defines the combined global dynamic memory size.
N//   <i> Default: 4096
N#ifndef OS_DYNAMIC_MEM_SIZE
N#define OS_DYNAMIC_MEM_SIZE         4096
N#endif
N 
N//   <o>Kernel Tick Frequency [Hz] <1-1000000>
N//   <i> Defines base time unit for delays and timeouts.
N//   <i> Default: 1000 (1ms tick)
N#ifndef OS_TICK_FREQ
N#define OS_TICK_FREQ                1000
N#endif
N 
N//   <e>Round-Robin Thread switching
N//   <i> Enables Round-Robin Thread switching.
N#ifndef OS_ROBIN_ENABLE
N#define OS_ROBIN_ENABLE             1
N#endif
N 
N//     <o>Round-Robin Timeout <1-1000>
N//     <i> Defines how many ticks a thread will execute before a thread switch.
N//     <i> Default: 5
N#ifndef OS_ROBIN_TIMEOUT
N#define OS_ROBIN_TIMEOUT            5
N#endif
N 
N//   </e>
N 
N//   <o>ISR FIFO Queue 
N//      <4=>  4 entries    <8=>   8 entries   <12=>  12 entries   <16=>  16 entries
N//     <24=> 24 entries   <32=>  32 entries   <48=>  48 entries   <64=>  64 entries
N//     <96=> 96 entries  <128=> 128 entries  <196=> 196 entries  <256=> 256 entries
N//   <i> RTOS Functions called from ISR store requests to this buffer.
N//   <i> Default: 16 entries
N#ifndef OS_ISR_FIFO_QUEUE
N#define OS_ISR_FIFO_QUEUE           16
N#endif
N 
N//   <q>Object Memory usage counters
N//   <i> Enables object memory usage counters (requires RTX source variant).
N#ifndef OS_OBJ_MEM_USAGE
N#define OS_OBJ_MEM_USAGE            1
N#endif
N 
N// </h>
N 
N// <h>Thread Configuration
N// =======================
N 
N//   <e>Object specific Memory allocation
N//   <i> Enables object specific memory allocation.
N#ifndef OS_THREAD_OBJ_MEM
N#define OS_THREAD_OBJ_MEM           1
N#endif
N 
N//     <o>Number of user Threads <1-1000>
N//     <i> Defines maximum number of user threads that can be active at the same time.
N//     <i> Applies to user threads with system provided memory for control blocks.
N#ifndef OS_THREAD_NUM
N#define OS_THREAD_NUM               16
N#endif
N 
N//     <o>Number of user Threads with default Stack size <0-1000>
N//     <i> Defines maximum number of user threads with default stack size.
N//     <i> Applies to user threads with zero stack size specified.
N#ifndef OS_THREAD_DEF_STACK_NUM
N#define OS_THREAD_DEF_STACK_NUM     0
N#endif
N 
N//     <o>Total Stack size [bytes] for user Threads with user-provided Stack size <0-1073741824:8>
N//     <i> Defines the combined stack size for user threads with user-provided stack size.
N//     <i> Applies to user threads with user-provided stack size and system provided memory for stack.
N//     <i> Default: 0
N#ifndef OS_THREAD_USER_STACK_SIZE
N#define OS_THREAD_USER_STACK_SIZE   15360
N#endif
N 
N//   </e>
N 
N//   <o>Default Thread Stack size [bytes] <96-1073741824:8>
N//   <i> Defines stack size for threads with zero stack size specified.
N//   <i> Default: 256
N#ifndef OS_STACK_SIZE
N#define OS_STACK_SIZE               256
N#endif
N 
N//   <o>Idle Thread Stack size [bytes] <72-1073741824:8>
N//   <i> Defines stack size for Idle thread.
N//   <i> Default: 256
N#ifndef OS_IDLE_THREAD_STACK_SIZE
N#define OS_IDLE_THREAD_STACK_SIZE   256
N#endif
N 
N//   <o>Idle Thread TrustZone Module Identifier
N//   <i> Defines TrustZone Thread Context Management Identifier.
N//   <i> Applies only to cores with TrustZone technology.
N//   <i> Default: 0 (not used)
N#ifndef OS_IDLE_THREAD_TZ_MOD_ID
N#define OS_IDLE_THREAD_TZ_MOD_ID    0
N#endif
N 
N//   <q>Stack overrun checking
N//   <i> Enables stack overrun check at thread switch.
N//   <i> Enabling this option increases slightly the execution time of a thread switch.
N#ifndef OS_STACK_CHECK
N#define OS_STACK_CHECK              1
N#endif
N 
N//   <q>Stack usage watermark
N//   <i> Initializes thread stack with watermark pattern for analyzing stack usage.
N//   <i> Enabling this option increases significantly the execution time of thread creation.
N#ifndef OS_STACK_WATERMARK
N#define OS_STACK_WATERMARK          0
N#endif
N 
N//   <o>Processor mode for Thread execution 
N//     <0=> Unprivileged mode 
N//     <1=> Privileged mode
N//   <i> Default: Privileged mode
N#ifndef OS_PRIVILEGE_MODE
N#define OS_PRIVILEGE_MODE           1
N#endif
N 
N// </h>
N 
N// <h>Timer Configuration
N// ======================
N 
N//   <e>Object specific Memory allocation
N//   <i> Enables object specific memory allocation.
N#ifndef OS_TIMER_OBJ_MEM
N#define OS_TIMER_OBJ_MEM            0
N#endif
N 
N//     <o>Number of Timer objects <1-1000>
N//     <i> Defines maximum number of objects that can be active at the same time.
N//     <i> Applies to objects with system provided memory for control blocks.
N#ifndef OS_TIMER_NUM
N#define OS_TIMER_NUM                1
N#endif
N 
N//   </e>
N 
N//   <o>Timer Thread Priority
N//      <8=> Low
N//     <16=> Below Normal  <24=> Normal  <32=> Above Normal
N//     <40=> High
N//     <48=> Realtime
N//   <i> Defines priority for timer thread
N//   <i> Default: High
N#ifndef OS_TIMER_THREAD_PRIO
N#define OS_TIMER_THREAD_PRIO        24
N#endif
N 
N//   <o>Timer Thread Stack size [bytes] <0-1073741824:8>
N//   <i> Defines stack size for Timer thread.
N//   <i> May be set to 0 when timers are not used.
N//   <i> Default: 256
N#ifndef OS_TIMER_THREAD_STACK_SIZE
N#define OS_TIMER_THREAD_STACK_SIZE  1024
N#endif
N 
N//   <o>Timer Thread TrustZone Module Identifier
N//   <i> Defines TrustZone Thread Context Management Identifier.
N//   <i> Applies only to cores with TrustZone technology.
N//   <i> Default: 0 (not used)
N#ifndef OS_TIMER_THREAD_TZ_MOD_ID
N#define OS_TIMER_THREAD_TZ_MOD_ID   0
N#endif
N 
N//   <o>Timer Callback Queue entries <0-256>
N//   <i> Number of concurrent active timer callback functions.
N//   <i> May be set to 0 when timers are not used.
N//   <i> Default: 4
N#ifndef OS_TIMER_CB_QUEUE
N#define OS_TIMER_CB_QUEUE           4
N#endif
N 
N// </h>
N 
N// <h>Event Flags Configuration
N// ============================
N 
N//   <e>Object specific Memory allocation
N//   <i> Enables object specific memory allocation.
N#ifndef OS_EVFLAGS_OBJ_MEM
N#define OS_EVFLAGS_OBJ_MEM          0
N#endif
N 
N//     <o>Number of Event Flags objects <1-1000>
N//     <i> Defines maximum number of objects that can be active at the same time.
N//     <i> Applies to objects with system provided memory for control blocks.
N#ifndef OS_EVFLAGS_NUM
N#define OS_EVFLAGS_NUM              1
N#endif
N 
N//   </e>
N 
N// </h>
N 
N// <h>Mutex Configuration
N// ======================
N 
N//   <e>Object specific Memory allocation
N//   <i> Enables object specific memory allocation.
N#ifndef OS_MUTEX_OBJ_MEM
N#define OS_MUTEX_OBJ_MEM            0
N#endif
N 
N//     <o>Number of Mutex objects <1-1000>
N//     <i> Defines maximum number of objects that can be active at the same time.
N//     <i> Applies to objects with system provided memory for control blocks.
N#ifndef OS_MUTEX_NUM
N#define OS_MUTEX_NUM                1
N#endif
N 
N//   </e>
N 
N// </h>
N 
N// <h>Semaphore Configuration
N// ==========================
N 
N//   <e>Object specific Memory allocation
N//   <i> Enables object specific memory allocation.
N#ifndef OS_SEMAPHORE_OBJ_MEM
N#define OS_SEMAPHORE_OBJ_MEM        0
N#endif
N 
N//     <o>Number of Semaphore objects <1-1000>
N//     <i> Defines maximum number of objects that can be active at the same time.
N//     <i> Applies to objects with system provided memory for control blocks.
N#ifndef OS_SEMAPHORE_NUM
N#define OS_SEMAPHORE_NUM            1
N#endif
N 
N//   </e>
N 
N// </h>
N 
N// <h>Memory Pool Configuration
N// ============================
N 
N//   <e>Object specific Memory allocation
N//   <i> Enables object specific memory allocation.
N#ifndef OS_MEMPOOL_OBJ_MEM
N#define OS_MEMPOOL_OBJ_MEM          0
N#endif
N 
N//     <o>Number of Memory Pool objects <1-1000>
N//     <i> Defines maximum number of objects that can be active at the same time.
N//     <i> Applies to objects with system provided memory for control blocks.
N#ifndef OS_MEMPOOL_NUM
N#define OS_MEMPOOL_NUM              1
N#endif
N 
N//     <o>Data Storage Memory size [bytes] <0-1073741824:8>
N//     <i> Defines the combined data storage memory size.
N//     <i> Applies to objects with system provided memory for data storage.
N//     <i> Default: 0
N#ifndef OS_MEMPOOL_DATA_SIZE
N#define OS_MEMPOOL_DATA_SIZE        0
N#endif
N 
N//   </e>
N 
N// </h>
N 
N// <h>Message Queue Configuration
N// ==============================
N 
N//   <e>Object specific Memory allocation
N//   <i> Enables object specific memory allocation.
N#ifndef OS_MSGQUEUE_OBJ_MEM
N#define OS_MSGQUEUE_OBJ_MEM         0
N#endif
N 
N//     <o>Number of Message Queue objects <1-1000>
N//     <i> Defines maximum number of objects that can be active at the same time.
N//     <i> Applies to objects with system provided memory for control blocks.
N#ifndef OS_MSGQUEUE_NUM
N#define OS_MSGQUEUE_NUM             1
N#endif
N 
N//     <o>Data Storage Memory size [bytes] <0-1073741824:8>
N//     <i> Defines the combined data storage memory size.
N//     <i> Applies to objects with system provided memory for data storage.
N//     <i> Default: 0
N#ifndef OS_MSGQUEUE_DATA_SIZE
N#define OS_MSGQUEUE_DATA_SIZE       0
N#endif
N 
N//   </e>
N 
N// </h>
N 
N// <h>Event Recorder Configuration
N// ===============================
N 
N//   <e>Global Initialization
N//   <i> Initialize Event Recorder during 'osKernelInitialize'.
N#ifndef OS_EVR_INIT
N#define OS_EVR_INIT                 0
N#endif
N 
N//     <q>Start recording
N//     <i> Start event recording after initialization.
N#ifndef OS_EVR_START
N#define OS_EVR_START                1
N#endif
N 
N//     <h>Global Event Filter Setup
N//     <i> Initial event filter settings applied to all components.
N//       <o.0>Error events
N//       <o.1>API function call events
N//       <o.2>Operation events
N//       <o.3>Detailed operation events
N//     </h>
N#ifndef OS_EVR_LEVEL
N#define OS_EVR_LEVEL                0x00U
N#endif
N 
N//     <h>RTOS Event Filter Setup
N//     <i> Event filter settings for RTX components.
N//     <i> Only applicable if events for the respective component are generated.
N 
N//       <e.7>Memory Management
N//       <i> Filter enable settings for Memory Management events.
N//         <o.0>Error events
N//         <o.1>API function call events
N//         <o.2>Operation events
N//         <o.3>Detailed operation events
N//       </e>
N#ifndef OS_EVR_MEMORY_FILTER
N#define OS_EVR_MEMORY_FILTER        0x81U
N#endif
N 
N//       <e.7>Kernel
N//       <i> Filter enable settings for Kernel events.
N//         <o.0>Error events
N//         <o.1>API function call events
N//         <o.2>Operation events
N//         <o.3>Detailed operation events
N//       </e>
N#ifndef OS_EVR_KERNEL_FILTER
N#define OS_EVR_KERNEL_FILTER        0x81U
N#endif
N 
N//       <e.7>Thread
N//       <i> Filter enable settings for Thread events.
N//         <o.0>Error events
N//         <o.1>API function call events
N//         <o.2>Operation events
N//         <o.3>Detailed operation events
N//       </e>
N#ifndef OS_EVR_THREAD_FILTER
N#define OS_EVR_THREAD_FILTER        0x85U
N#endif
N 
N//       <e.7>Timer
N//       <i> Filter enable settings for Timer events.
N//         <o.0>Error events
N//         <o.1>API function call events
N//         <o.2>Operation events
N//         <o.3>Detailed operation events
N//       </e>
N#ifndef OS_EVR_TIMER_FILTER
N#define OS_EVR_TIMER_FILTER         0x81U
N#endif
N 
N//       <e.7>Event Flags
N//       <i> Filter enable settings for Event Flags events.
N//         <o.0>Error events
N//         <o.1>API function call events
N//         <o.2>Operation events
N//         <o.3>Detailed operation events
N//       </e>
N#ifndef OS_EVR_EVFLAGS_FILTER
N#define OS_EVR_EVFLAGS_FILTER       0x81U
N#endif
N 
N//       <e.7>Mutex
N//       <i> Filter enable settings for Mutex events.
N//         <o.0>Error events
N//         <o.1>API function call events
N//         <o.2>Operation events
N//         <o.3>Detailed operation events
N//       </e>
N#ifndef OS_EVR_MUTEX_FILTER
N#define OS_EVR_MUTEX_FILTER         0x81U
N#endif
N 
N//       <e.7>Semaphore
N//       <i> Filter enable settings for Semaphore events.
N//         <o.0>Error events
N//         <o.1>API function call events
N//         <o.2>Operation events
N//         <o.3>Detailed operation events
N//       </e>
N#ifndef OS_EVR_SEMAPHORE_FILTER
N#define OS_EVR_SEMAPHORE_FILTER     0x81U
N#endif
N 
N//       <e.7>Memory Pool
N//       <i> Filter enable settings for Memory Pool events.
N//         <o.0>Error events
N//         <o.1>API function call events
N//         <o.2>Operation events
N//         <o.3>Detailed operation events
N//       </e>
N#ifndef OS_EVR_MEMPOOL_FILTER
N#define OS_EVR_MEMPOOL_FILTER       0x81U
N#endif
N 
N//       <e.7>Message Queue
N//       <i> Filter enable settings for Message Queue events.
N//         <o.0>Error events
N//         <o.1>API function call events
N//         <o.2>Operation events
N//         <o.3>Detailed operation events
N//       </e>
N#ifndef OS_EVR_MSGQUEUE_FILTER
N#define OS_EVR_MSGQUEUE_FILTER      0x81U
N#endif
N 
N//     </h>
N 
N//   </e>
N 
N//   <h>RTOS Event Generation
N//   <i> Enables event generation for RTX components (requires RTX source variant).
N 
N//     <q>Memory Management
N//     <i> Enables Memory Management event generation.
N#ifndef OS_EVR_MEMORY
N#define OS_EVR_MEMORY               1
N#endif
N 
N//     <q>Kernel
N//     <i> Enables Kernel event generation.
N#ifndef OS_EVR_KERNEL
N#define OS_EVR_KERNEL               1
N#endif
N 
N//     <q>Thread
N//     <i> Enables Thread event generation.
N#ifndef OS_EVR_THREAD
N#define OS_EVR_THREAD               1
N#endif
N 
N//     <q>Timer
N//     <i> Enables Timer event generation.
N#ifndef OS_EVR_TIMER
N#define OS_EVR_TIMER                1
N#endif
N 
N//     <q>Event Flags
N//     <i> Enables Event Flags event generation.
N#ifndef OS_EVR_EVFLAGS
N#define OS_EVR_EVFLAGS              1
N#endif
N  
N//     <q>Mutex
N//     <i> Enables Mutex event generation.
N#ifndef OS_EVR_MUTEX
N#define OS_EVR_MUTEX                1
N#endif
N 
N//     <q>Semaphore
N//     <i> Enables Semaphore event generation.
N#ifndef OS_EVR_SEMAPHORE
N#define OS_EVR_SEMAPHORE            1
N#endif
N 
N//     <q>Memory Pool
N//     <i> Enables Memory Pool event generation.
N#ifndef OS_EVR_MEMPOOL
N#define OS_EVR_MEMPOOL              1
N#endif
N 
N//     <q>Message Queue
N//     <i> Enables Message Queue event generation.
N#ifndef OS_EVR_MSGQUEUE
N#define OS_EVR_MSGQUEUE             1
N#endif
N 
N//   </h>
N 
N// </h>
N 
N// Number of Threads which use standard C/C++ library libspace
N// (when thread specific memory allocation is not used).
N#if (OS_THREAD_OBJ_MEM == 0)
X#if (1 == 0)
S#define OS_THREAD_LIBSPACE_NUM      4
N#else
N#define OS_THREAD_LIBSPACE_NUM      OS_THREAD_NUM
N#endif
N 
N//------------- <<< end of configuration section >>> ---------------------------
N 
N#endif  // RTX_CONFIG_H_
L 33 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include\rtx_def.h" 2
N
N#if (defined(OS_OBJ_MEM_USAGE) && (OS_OBJ_MEM_USAGE != 0))
X#if (1L && (1 != 0))
N  #define RTX_OBJ_MEM_USAGE
N#endif
N
N#if (defined(OS_STACK_CHECK) && (OS_STACK_CHECK != 0))
X#if (1L && (1 != 0))
N  #define RTX_STACK_CHECK
N#endif
N
N#ifdef  RTE_CMSIS_RTOS2_RTX5_ARMV8M_NS
S  #define DOMAIN_NS             1
N#endif
N
N#endif  // RTX_DEF_H_
L 33 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include\rtx_os.h" 2
N 
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N 
N 
N/// Kernel Information
N#define osRtxVersionAPI      20010003   ///< API version (2.1.3)
N#define osRtxVersionKernel   50050004   ///< Kernel version (5.5.4)
N#define osRtxKernelId     "RTX V5.5.4"  ///< Kernel identification string
N 
N 
N//  ==== Common definitions ====
N 
N/// Object Identifier definitions
N#define osRtxIdInvalid          0x00U
N#define osRtxIdThread           0xF1U
N#define osRtxIdTimer            0xF2U
N#define osRtxIdEventFlags       0xF3U
N#define osRtxIdMutex            0xF5U
N#define osRtxIdSemaphore        0xF6U
N#define osRtxIdMemoryPool       0xF7U
N#define osRtxIdMessage          0xF9U
N#define osRtxIdMessageQueue     0xFAU
N 
N/// Object Flags definitions
N#define osRtxFlagSystemObject   0x01U
N#define osRtxFlagSystemMemory   0x02U
N 
N 
N//  ==== Kernel definitions ====
N 
N/// Kernel State definitions
N#define osRtxKernelInactive             ((uint8_t)osKernelInactive)
N#define osRtxKernelReady                ((uint8_t)osKernelReady)
N#define osRtxKernelRunning              ((uint8_t)osKernelRunning)
N#define osRtxKernelLocked               ((uint8_t)osKernelLocked)
N#define osRtxKernelSuspended            ((uint8_t)osKernelSuspended)
N 
N 
N//  ==== Thread definitions ====
N 
N/// Thread State definitions (extending osThreadState)
N#define osRtxThreadStateMask            0x0FU
N 
N#define osRtxThreadInactive             ((uint8_t)osThreadInactive)
N#define osRtxThreadReady                ((uint8_t)osThreadReady)
N#define osRtxThreadRunning              ((uint8_t)osThreadRunning)
N#define osRtxThreadBlocked              ((uint8_t)osThreadBlocked)
N#define osRtxThreadTerminated           ((uint8_t)osThreadTerminated)
N 
N#define osRtxThreadWaitingDelay         ((uint8_t)(osRtxThreadBlocked | 0x10U))
N#define osRtxThreadWaitingJoin          ((uint8_t)(osRtxThreadBlocked | 0x20U))
N#define osRtxThreadWaitingThreadFlags   ((uint8_t)(osRtxThreadBlocked | 0x30U))
N#define osRtxThreadWaitingEventFlags    ((uint8_t)(osRtxThreadBlocked | 0x40U))
N#define osRtxThreadWaitingMutex         ((uint8_t)(osRtxThreadBlocked | 0x50U))
N#define osRtxThreadWaitingSemaphore     ((uint8_t)(osRtxThreadBlocked | 0x60U))
N#define osRtxThreadWaitingMemoryPool    ((uint8_t)(osRtxThreadBlocked | 0x70U))
N#define osRtxThreadWaitingMessageGet    ((uint8_t)(osRtxThreadBlocked | 0x80U))
N#define osRtxThreadWaitingMessagePut    ((uint8_t)(osRtxThreadBlocked | 0x90U))
N 
N/// Thread Flags definitions
N#define osRtxThreadFlagDefStack 0x10U   ///< Default Stack flag
N 
N/// Stack Marker definitions
N#define osRtxStackMagicWord     0xE25A2EA5U ///< Stack Magic Word (Stack Base)
N#define osRtxStackFillPattern   0xCCCCCCCCU ///< Stack Fill Pattern 
N 
N/// Thread Control Block
Ntypedef struct osRtxThread_s {
N  uint8_t                          id;  ///< Object Identifier
N  uint8_t                       state;  ///< Object State
N  uint8_t                       flags;  ///< Object Flags
N  uint8_t                        attr;  ///< Object Attributes
N  const char                    *name;  ///< Object Name
N  struct osRtxThread_s   *thread_next;  ///< Link pointer to next Thread in Object list
N  struct osRtxThread_s   *thread_prev;  ///< Link pointer to previous Thread in Object list
N  struct osRtxThread_s    *delay_next;  ///< Link pointer to next Thread in Delay list
N  struct osRtxThread_s    *delay_prev;  ///< Link pointer to previous Thread in Delay list
N  struct osRtxThread_s   *thread_join;  ///< Thread waiting to Join
N  uint32_t                      delay;  ///< Delay Time/Round Robin Time Tick
N  int8_t                     priority;  ///< Thread Priority
N  int8_t                priority_base;  ///< Base Priority
N  uint8_t                 stack_frame;  ///< Stack Frame (EXC_RETURN[7..0])
N  uint8_t               flags_options;  ///< Thread/Event Flags Options
N  uint32_t                 wait_flags;  ///< Waiting Thread/Event Flags
N  uint32_t               thread_flags;  ///< Thread Flags
N  struct osRtxMutex_s     *mutex_list;  ///< Link pointer to list of owned Mutexes
N  void                     *stack_mem;  ///< Stack Memory
N  uint32_t                 stack_size;  ///< Stack Size
N  uint32_t                         sp;  ///< Current Stack Pointer
N  uint32_t                thread_addr;  ///< Thread entry address
N  uint32_t                  tz_memory;  ///< TrustZone Memory Identifier
N#ifdef RTX_TF_M_EXTENSION
S  uint32_t                  tz_module;  ///< TrustZone Module Identifier
N#endif
N} osRtxThread_t;
N 
N 
N//  ==== Timer definitions ====
N 
N/// Timer State definitions
N#define osRtxTimerInactive      0x00U   ///< Timer Inactive
N#define osRtxTimerStopped       0x01U   ///< Timer Stopped
N#define osRtxTimerRunning       0x02U   ///< Timer Running
N 
N/// Timer Type definitions
N#define osRtxTimerPeriodic      ((uint8_t)osTimerPeriodic)
N 
N/// Timer Function Information
Ntypedef struct {
N  osTimerFunc_t                  func;  ///< Function Pointer
N  void                           *arg;  ///< Function Argument
N} osRtxTimerFinfo_t;
N 
N/// Timer Control Block
Ntypedef struct osRtxTimer_s {
N  uint8_t                          id;  ///< Object Identifier
N  uint8_t                       state;  ///< Object State
N  uint8_t                       flags;  ///< Object Flags
N  uint8_t                        type;  ///< Timer Type (Periodic/One-shot)
N  const char                    *name;  ///< Object Name
N  struct osRtxTimer_s           *prev;  ///< Pointer to previous active Timer
N  struct osRtxTimer_s           *next;  ///< Pointer to next active Timer
N  uint32_t                       tick;  ///< Timer current Tick
N  uint32_t                       load;  ///< Timer Load value
N  osRtxTimerFinfo_t             finfo;  ///< Timer Function Info
N} osRtxTimer_t;
N 
N 
N//  ==== Event Flags definitions ====
N 
N/// Event Flags Control Block
Ntypedef struct {
N  uint8_t                          id;  ///< Object Identifier
N  uint8_t              reserved_state;  ///< Object State (not used)
N  uint8_t                       flags;  ///< Object Flags
N  uint8_t                    reserved;
N  const char                    *name;  ///< Object Name
N  osRtxThread_t          *thread_list;  ///< Waiting Threads List
N  uint32_t                event_flags;  ///< Event Flags
N} osRtxEventFlags_t;
N 
N 
N//  ==== Mutex definitions ====
N 
N/// Mutex Control Block
Ntypedef struct osRtxMutex_s {
N  uint8_t                          id;  ///< Object Identifier
N  uint8_t              reserved_state;  ///< Object State (not used)
N  uint8_t                       flags;  ///< Object Flags
N  uint8_t                        attr;  ///< Object Attributes
N  const char                    *name;  ///< Object Name
N  osRtxThread_t          *thread_list;  ///< Waiting Threads List
N  osRtxThread_t         *owner_thread;  ///< Owner Thread
N  struct osRtxMutex_s     *owner_prev;  ///< Pointer to previous owned Mutex
N  struct osRtxMutex_s     *owner_next;  ///< Pointer to next owned Mutex
N  uint8_t                        lock;  ///< Lock counter
N  uint8_t                  padding[3];
N} osRtxMutex_t;
N 
N 
N//  ==== Semaphore definitions ====
N 
N/// Semaphore Control Block
Ntypedef struct {
N  uint8_t                          id;  ///< Object Identifier
N  uint8_t              reserved_state;  ///< Object State (not used)
N  uint8_t                       flags;  ///< Object Flags
N  uint8_t                    reserved;
N  const char                    *name;  ///< Object Name
N  osRtxThread_t          *thread_list;  ///< Waiting Threads List
N  uint16_t                     tokens;  ///< Current number of tokens
N  uint16_t                 max_tokens;  ///< Maximum number of tokens
N} osRtxSemaphore_t;
N 
N 
N//  ==== Memory Pool definitions ====
N 
N/// Memory Pool Information
Ntypedef struct {
N  uint32_t                 max_blocks;  ///< Maximum number of Blocks
N  uint32_t                used_blocks;  ///< Number of used Blocks
N  uint32_t                 block_size;  ///< Block Size
N  void                    *block_base;  ///< Block Memory Base Address
N  void                     *block_lim;  ///< Block Memory Limit Address
N  void                    *block_free;  ///< First free Block Address
N} osRtxMpInfo_t;
N 
N/// Memory Pool Control Block
Ntypedef struct {
N  uint8_t                          id;  ///< Object Identifier
N  uint8_t              reserved_state;  ///< Object State (not used)
N  uint8_t                       flags;  ///< Object Flags
N  uint8_t                    reserved;
N  const char                    *name;  ///< Object Name
N  osRtxThread_t          *thread_list;  ///< Waiting Threads List
N  osRtxMpInfo_t               mp_info;  ///< Memory Pool Info
N} osRtxMemoryPool_t;
N 
N 
N//  ==== Message Queue definitions ====
N 
N/// Message Control Block
Ntypedef struct osRtxMessage_s {
N  uint8_t                          id;  ///< Object Identifier
N  uint8_t              reserved_state;  ///< Object State (not used)
N  uint8_t                       flags;  ///< Object Flags
N  uint8_t                    priority;  ///< Message Priority
N  struct osRtxMessage_s         *prev;  ///< Pointer to previous Message
N  struct osRtxMessage_s         *next;  ///< Pointer to next Message
N} osRtxMessage_t;
N 
N/// Message Queue Control Block
Ntypedef struct {
N  uint8_t                          id;  ///< Object Identifier
N  uint8_t              reserved_state;  ///< Object State (not used)
N  uint8_t                       flags;  ///< Object Flags
N  uint8_t                    reserved;
N  const char                    *name;  ///< Object Name
N  osRtxThread_t          *thread_list;  ///< Waiting Threads List
N  osRtxMpInfo_t               mp_info;  ///< Memory Pool Info
N  uint32_t                   msg_size;  ///< Message Size
N  uint32_t                  msg_count;  ///< Number of queued Messages
N  osRtxMessage_t           *msg_first;  ///< Pointer to first Message
N  osRtxMessage_t            *msg_last;  ///< Pointer to last Message
N} osRtxMessageQueue_t;
N 
N 
N//  ==== Generic Object definitions ====
N 
N/// Generic Object Control Block
Ntypedef struct {
N  uint8_t                          id;  ///< Object Identifier
N  uint8_t                       state;  ///< Object State
N  uint8_t                       flags;  ///< Object Flags
N  uint8_t                    reserved;
N  const char                    *name;  ///< Object Name
N  osRtxThread_t          *thread_list;  ///< Threads List
N} osRtxObject_t;
N 
N 
N//  ==== OS Runtime Information definitions ====
N 
N/// OS Runtime Information structure
Ntypedef struct {
N  const char                   *os_id;  ///< OS Identification
N  uint32_t                    version;  ///< OS Version
N  struct {                              ///< Kernel Info
N    uint8_t                     state;  ///< State
N    volatile uint8_t          blocked;  ///< Blocked
N    uint8_t                    pendSV;  ///< Pending SV
N    uint8_t                  reserved;
N    uint32_t                     tick;  ///< Tick counter
N  } kernel;
N  int32_t                   tick_irqn;  ///< Tick Timer IRQ Number
N  struct {                              ///< Thread Info
N    struct {                            ///< Thread Run Info
N      osRtxThread_t             *curr;  ///< Current running Thread
N      osRtxThread_t             *next;  ///< Next Thread to Run
N    } run;
N    osRtxObject_t               ready;  ///< Ready List Object
N    osRtxThread_t               *idle;  ///< Idle Thread
N    osRtxThread_t         *delay_list;  ///< Delay List
N    osRtxThread_t          *wait_list;  ///< Wait List (no Timeout)
N    osRtxThread_t     *terminate_list;  ///< Terminate Thread List
N    uint32_t                 reserved;
N    struct {                            ///< Thread Round Robin Info
N      osRtxThread_t           *thread;  ///< Round Robin Thread
N      uint32_t                timeout;  ///< Round Robin Timeout
N    } robin;
N  } thread;
N  struct {                              ///< Timer Info
N    osRtxTimer_t                *list;  ///< Active Timer List
N    osRtxThread_t             *thread;  ///< Timer Thread
N    osRtxMessageQueue_t           *mq;  ///< Timer Message Queue
N    void                (*tick)(void);  ///< Timer Tick Function
N  } timer;
N  struct {                              ///< ISR Post Processing Queue
N    uint16_t                      max;  ///< Maximum Items
N    uint16_t                      cnt;  ///< Item Count
N    uint16_t                       in;  ///< Incoming Item Index
N    uint16_t                      out;  ///< Outgoing Item Index
N    void                       **data;  ///< Queue Data
N  } isr_queue;
N  struct {                                      ///< ISR Post Processing functions
N    void          (*thread)(osRtxThread_t*);    ///< Thread Post Processing function
N    void (*event_flags)(osRtxEventFlags_t*);    ///< Event Flags Post Processing function
N    void    (*semaphore)(osRtxSemaphore_t*);    ///< Semaphore Post Processing function
N    void (*memory_pool)(osRtxMemoryPool_t*);    ///< Memory Pool Post Processing function
N    void        (*message)(osRtxMessage_t*);    ///< Message Post Processing function
N  } post_process;
N  struct {                              ///< Memory Pools (Variable Block Size)
N    void                       *stack;  ///< Stack Memory
N    void                     *mp_data;  ///< Memory Pool Data Memory
N    void                     *mq_data;  ///< Message Queue Data Memory
N    void                      *common;  ///< Common Memory
N  } mem;
N  struct {                              ///< Memory Pools (Fixed Block Size)
N    osRtxMpInfo_t              *stack;  ///< Stack for Threads
N    osRtxMpInfo_t             *thread;  ///< Thread Control Blocks
N    osRtxMpInfo_t              *timer;  ///< Timer Control Blocks
N    osRtxMpInfo_t        *event_flags;  ///< Event Flags Control Blocks
N    osRtxMpInfo_t              *mutex;  ///< Mutex Control Blocks
N    osRtxMpInfo_t          *semaphore;  ///< Semaphore Control Blocks
N    osRtxMpInfo_t        *memory_pool;  ///< Memory Pool Control Blocks
N    osRtxMpInfo_t      *message_queue;  ///< Message Queue Control Blocks
N  } mpi;
N} osRtxInfo_t;
N 
Nextern osRtxInfo_t osRtxInfo;           ///< OS Runtime Information
N 
N/// OS Runtime Object Memory Usage structure
Ntypedef struct {
N  uint32_t cnt_alloc;                   ///< Counter for alloc
N  uint32_t cnt_free;                    ///< Counter for free
N  uint32_t max_used;                    ///< Maximum used
N} osRtxObjectMemUsage_t;
N 
N/// OS Runtime Object Memory Usage variables
Nextern osRtxObjectMemUsage_t osRtxThreadMemUsage;
Nextern osRtxObjectMemUsage_t osRtxTimerMemUsage;
Nextern osRtxObjectMemUsage_t osRtxEventFlagsMemUsage;
Nextern osRtxObjectMemUsage_t osRtxMutexMemUsage;
Nextern osRtxObjectMemUsage_t osRtxSemaphoreMemUsage;
Nextern osRtxObjectMemUsage_t osRtxMemoryPoolMemUsage;
Nextern osRtxObjectMemUsage_t osRtxMessageQueueMemUsage;
N 
N 
N//  ==== OS API definitions ====
N 
N// Object Limits definitions
N#define osRtxThreadFlagsLimit    31U    ///< number of Thread Flags available per thread
N#define osRtxEventFlagsLimit     31U    ///< number of Event Flags available per object
N#define osRtxMutexLockLimit      255U   ///< maximum number of recursive mutex locks
N#define osRtxSemaphoreTokenLimit 65535U ///< maximum number of tokens per semaphore
N 
N// Control Block sizes
N#define osRtxThreadCbSize        sizeof(osRtxThread_t)
N#define osRtxTimerCbSize         sizeof(osRtxTimer_t)
N#define osRtxEventFlagsCbSize    sizeof(osRtxEventFlags_t)
N#define osRtxMutexCbSize         sizeof(osRtxMutex_t)
N#define osRtxSemaphoreCbSize     sizeof(osRtxSemaphore_t)
N#define osRtxMemoryPoolCbSize    sizeof(osRtxMemoryPool_t)
N#define osRtxMessageQueueCbSize  sizeof(osRtxMessageQueue_t)
N 
N/// Memory size in bytes for Memory Pool storage.
N/// \param         block_count   maximum number of memory blocks in memory pool.
N/// \param         block_size    memory block size in bytes.
N#define osRtxMemoryPoolMemSize(block_count, block_size) \
N  (4*(block_count)*(((block_size)+3)/4))
X#define osRtxMemoryPoolMemSize(block_count, block_size)   (4*(block_count)*(((block_size)+3)/4))
N 
N/// Memory size in bytes for Message Queue storage.
N/// \param         msg_count     maximum number of messages in queue.
N/// \param         msg_size      maximum message size in bytes.
N#define osRtxMessageQueueMemSize(msg_count, msg_size) \
N  (4*(msg_count)*(3+(((msg_size)+3)/4)))
X#define osRtxMessageQueueMemSize(msg_count, msg_size)   (4*(msg_count)*(3+(((msg_size)+3)/4)))
N 
N 
N//  ==== OS External Functions ====
N 
N// OS Error Codes
N#define osRtxErrorStackUnderflow        1U  ///< \deprecated Superseded by \ref osRtxErrorStackOverflow.
N#define osRtxErrorStackOverflow         1U  ///< Stack overflow, i.e. stack pointer below its lower memory limit for descending stacks.
N#define osRtxErrorISRQueueOverflow      2U  ///< ISR Queue overflow detected when inserting object.
N#define osRtxErrorTimerQueueOverflow    3U  ///< User Timer Callback Queue overflow detected for timer.
N#define osRtxErrorClibSpace             4U  ///< Standard C/C++ library libspace not available: increase \c OS_THREAD_LIBSPACE_NUM.
N#define osRtxErrorClibMutex             5U  ///< Standard C/C++ library mutex initialization failed.
N 
N/// OS Error Callback function
Nextern uint32_t osRtxErrorNotify (uint32_t code, void *object_id);
Nextern uint32_t osRtxKernelErrorNotify (uint32_t code, void *object_id);
N 
N/// OS Idle Thread
Nextern void osRtxIdleThread (void *argument);
N 
N/// OS Exception handlers
Nextern void SVC_Handler     (void);
Nextern void PendSV_Handler  (void);
Nextern void SysTick_Handler (void);
N 
N/// OS Trusted Firmware M Extension
N#ifdef RTX_TF_M_EXTENSION
Sextern uint32_t osRtxTzGetModuleId (void);
N#endif
N 
N 
N//  ==== OS External Configuration ====
N 
N/// OS Configuration flags
N#define osRtxConfigPrivilegedMode   (1UL<<0)    ///< Threads in Privileged mode
N#define osRtxConfigStackCheck       (1UL<<1)    ///< Stack overrun checking
N#define osRtxConfigStackWatermark   (1UL<<2)    ///< Stack usage Watermark
N 
N/// OS Configuration structure
Ntypedef struct {
N  uint32_t                             flags;   ///< OS Configuration Flags
N  uint32_t                         tick_freq;   ///< Kernel Tick Frequency
N  uint32_t                     robin_timeout;   ///< Round Robin Timeout Tick
N  struct {                                      ///< ISR Post Processing Queue
N    void                              **data;   ///< Queue Data
N    uint16_t                             max;   ///< Maximum Items
N    uint16_t                         padding;
N  } isr_queue;
N  struct {                                      ///< Memory Pools (Variable Block Size)
N    void                         *stack_addr;   ///< Stack Memory Address
N    uint32_t                      stack_size;   ///< Stack Memory Size
N    void                       *mp_data_addr;   ///< Memory Pool Memory Address
N    uint32_t                    mp_data_size;   ///< Memory Pool Memory Size
N    void                       *mq_data_addr;   ///< Message Queue Data Memory Address
N    uint32_t                    mq_data_size;   ///< Message Queue Data Memory Size
N    void                        *common_addr;   ///< Common Memory Address
N    uint32_t                     common_size;   ///< Common Memory Size
N  } mem;
N  struct {                                      ///< Memory Pools (Fixed Block Size)
N    osRtxMpInfo_t                     *stack;   ///< Stack for Threads
N    osRtxMpInfo_t                    *thread;   ///< Thread Control Blocks
N    osRtxMpInfo_t                     *timer;   ///< Timer Control Blocks
N    osRtxMpInfo_t               *event_flags;   ///< Event Flags Control Blocks
N    osRtxMpInfo_t                     *mutex;   ///< Mutex Control Blocks
N    osRtxMpInfo_t                 *semaphore;   ///< Semaphore Control Blocks
N    osRtxMpInfo_t               *memory_pool;   ///< Memory Pool Control Blocks
N    osRtxMpInfo_t             *message_queue;   ///< Message Queue Control Blocks
N  } mpi;
N  uint32_t                 thread_stack_size;   ///< Default Thread Stack Size
N  const
N  osThreadAttr_t           *idle_thread_attr;   ///< Idle Thread Attributes
N  const
N  osThreadAttr_t          *timer_thread_attr;   ///< Timer Thread Attributes
N  void               (*timer_thread)(void *);   ///< Timer Thread Function
N  int32_t               (*timer_setup)(void);   ///< Timer Setup Function
N  const
N  osMessageQueueAttr_t        *timer_mq_attr;   ///< Timer Message Queue Attributes
N  uint32_t                     timer_mq_mcnt;   ///< Timer Message Queue maximum Messages
N} osRtxConfig_t;
N 
Nextern const osRtxConfig_t osRtxConfig;         ///< OS Configuration
N 
N 
N#ifdef  __cplusplus
S}
N#endif
N 
N#endif  // RTX_OS_H_
L 27 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_lib.c" 2
N
N#ifdef    CMSIS_device_header
N#include  CMSIS_device_header
X#include  "ARMCM4_FP.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include\ARMCM4_FP.h" 1
N/**************************************************************************//**
N * @file     ARMCM4_FP.h
N * @brief    CMSIS Core Peripheral Access Layer Header File for
N *           ARMCM4 Device (configured for CM4 with FPU)
N * @version  V5.3.1
N * @date     09. July 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef ARMCM4_FP_H
N#define ARMCM4_FP_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N
Ntypedef enum IRQn
N{
N/* -------------------  Processor Exceptions Numbers  ----------------------------- */
N  NonMaskableInt_IRQn           = -14,     /*  2 Non Maskable Interrupt */
N  HardFault_IRQn                = -13,     /*  3 HardFault Interrupt */
N  MemoryManagement_IRQn         = -12,     /*  4 Memory Management Interrupt */
N  BusFault_IRQn                 = -11,     /*  5 Bus Fault Interrupt */
N  UsageFault_IRQn               = -10,     /*  6 Usage Fault Interrupt */
N  SVCall_IRQn                   =  -5,     /* 11 SV Call Interrupt */
N  DebugMonitor_IRQn             =  -4,     /* 12 Debug Monitor Interrupt */
N  PendSV_IRQn                   =  -2,     /* 14 Pend SV Interrupt */
N  SysTick_IRQn                  =  -1,     /* 15 System Tick Interrupt */
N
N/* -------------------  Processor Interrupt Numbers  ------------------------------ */
N  Interrupt0_IRQn               =   0,
N  Interrupt1_IRQn               =   1,
N  Interrupt2_IRQn               =   2,
N  Interrupt3_IRQn               =   3,
N  Interrupt4_IRQn               =   4,
N  Interrupt5_IRQn               =   5,
N  Interrupt6_IRQn               =   6,
N  Interrupt7_IRQn               =   7,
N  Interrupt8_IRQn               =   8,
N  Interrupt9_IRQn               =   9
N  /* Interrupts 10 .. 224 are left out */
N} IRQn_Type;
N
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* -------  Start of section using anonymous unions and disabling warnings  ------- */
N#if   defined (__CC_ARM)
X#if   1L
N  #pragma push
N  #pragma anon_unions
N#elif defined (__ICCARM__)
X#elif 0L
S  #pragma language=extended
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #pragma clang diagnostic push
S  #pragma clang diagnostic ignored "-Wc11-extensions"
S  #pragma clang diagnostic ignored "-Wreserved-id-macro"
S#elif defined (__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined (__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined (__TASKING__)
S  #pragma warning 586
S#elif defined (__CSMC__)
S  /* anonymous unions are enabled by default */
S#else
S  #warning Not supported compiler type
N#endif
N
N
N/* --------  Configuration of Core Peripherals  ----------------------------------- */
N#define __CM4_REV                 0x0001U   /* Core revision r0p1 */
N#define __MPU_PRESENT             1U        /* MPU present */
N#define __VTOR_PRESENT            1U        /* VTOR present */
N#define __NVIC_PRIO_BITS          3U        /* Number of Bits used for Priority Levels */
N#define __Vendor_SysTickConfig    0U        /* Set to 1 if different SysTick Config is used */
N#define __FPU_PRESENT             1U        /* FPU present */
N
N#include "core_cm4.h"                       /* Processor and core peripherals */
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V5.1.2
N * @date     04. June 2021
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M4
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.5
N * @date     02. February 2022
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2022 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 6U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 2
N
N/* CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM4_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM4_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) |                                     __CM4_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (4U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
X    #if 1L && (1U == 1U)
N      #define __FPU_USED       1U
N    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
N    #endif
N  #else
S    #define __FPU_USED         0U
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #if defined __ARM_FP
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.1.0
N * @date     09. October 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.3.2
N * @date     27. May 2021
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2021 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060750 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (0L && (__TARGET_ARCH_6S_M  == 1))   )
S  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (1L && (1 == 1))
N  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N  /* __ARM_ARCH_8_1M_MAIN__  not applicable */
N
N/* CMSIS compiler control DSP macros */
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1 == 1))     )
N  #define __ARM_FEATURE_DSP         1
N#endif
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif
N#ifndef   __NO_RETURN
S  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N#ifndef   __COMPILER_BARRIER
N  #define __COMPILER_BARRIER()                   __memory_changed()
N#endif
N
N/* #########################  Startup and Lowlevel Init  ######################## */
N
N#ifndef __PROGRAM_START
N#define __PROGRAM_START           __main
N#endif
N
N#ifndef __INITIAL_SP
N#define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit
N#endif
N
N#ifndef __STACK_LIMIT
N#define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base
N#endif
N
N#ifndef __VECTOR_TABLE
N#define __VECTOR_TABLE            __Vectors
N#endif
N
N#ifndef __VECTOR_TABLE_ATTRIBUTE
N#define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section("RESET")))
N#endif
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (1L && (1 == 1))     )
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value != 0U; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return result;
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (1L && (1 == 1))     )
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
S{
S  if ((sat >= 1U) && (sat <= 32U))
S  {
S    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
S    const int32_t min = -1 - max ;
S    if (val > max)
S    {
S      return max;
S    }
S    else if (val < min)
S    {
S      return min;
S    }
S  }
S  return val;
S}
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
S{
S  if (sat <= 31U)
S  {
S    const uint32_t max = ((1U << sat) - 1U);
S    if (val > (int32_t)max)
S    {
S      return max;
S    }
S    else if (val < 0)
S    {
S      return 0U;
S    }
S  }
S  return (uint32_t)val;
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing special-purpose register PRIMASK.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N  __ISB();
X  __isb(0xF);
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (1L && (1 == 1))     )
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing special-purpose register FAULTMASK.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting special-purpose register FAULTMASK.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1U);
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((1L && (1U == 1U)) &&      (1L && (1U    == 1U))     )
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((1L && (1U == 1U)) &&      (1L && (1U    == 1U))     )
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#else
S  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1 == 1))     )
N
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
N
N#define __SXTB16_RORn(ARG1, ARG2)        __SXTB16(__ROR(ARG1, ARG2))
N
N#define __SXTAB16_RORn(ARG1, ARG2, ARG3) __SXTAB16(ARG1, __ROR(ARG2, ARG3))
N
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6.6 LTM (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)
X#elif 1L && (5060750 >= 6010050) && (5060750 < 6100100)
S  #include "cmsis_armclang_ltm.h"
S
S  /*
S * Arm Compiler above 6.10.1 (armclang)
S */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #define __RESTRICT                             __restrict
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 163 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000U
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT             1U
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
N    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
N    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
N#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
N#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RESERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_MMARVALID_Pos             (SCB_CFSR_MEMFAULTSR_Pos + 7U)                 /*!< SCB CFSR (MMFSR): MMARVALID Position */
N#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
N
N#define SCB_CFSR_MLSPERR_Pos               (SCB_CFSR_MEMFAULTSR_Pos + 5U)                 /*!< SCB CFSR (MMFSR): MLSPERR Position */
N#define SCB_CFSR_MLSPERR_Msk               (1UL << SCB_CFSR_MLSPERR_Pos)                  /*!< SCB CFSR (MMFSR): MLSPERR Mask */
N
N#define SCB_CFSR_MSTKERR_Pos               (SCB_CFSR_MEMFAULTSR_Pos + 4U)                 /*!< SCB CFSR (MMFSR): MSTKERR Position */
N#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
N
N#define SCB_CFSR_MUNSTKERR_Pos             (SCB_CFSR_MEMFAULTSR_Pos + 3U)                 /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
N#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
N
N#define SCB_CFSR_DACCVIOL_Pos              (SCB_CFSR_MEMFAULTSR_Pos + 1U)                 /*!< SCB CFSR (MMFSR): DACCVIOL Position */
N#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
N
N#define SCB_CFSR_IACCVIOL_Pos              (SCB_CFSR_MEMFAULTSR_Pos + 0U)                 /*!< SCB CFSR (MMFSR): IACCVIOL Position */
N#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
N
N/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
N#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
N
N#define SCB_CFSR_LSPERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 5U)                  /*!< SCB CFSR (BFSR): LSPERR Position */
N#define SCB_CFSR_LSPERR_Msk               (1UL << SCB_CFSR_LSPERR_Pos)                    /*!< SCB CFSR (BFSR): LSPERR Mask */
N
N#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
N#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
N
N#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
N#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
N
N#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
N#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
N
N#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
N#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
N
N#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
N#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
N
N/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
N#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
N
N#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
N#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
N
N#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
N#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
N
N#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
N#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
N
N#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
N#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
N
N#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
N#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[32U];
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFFFFFFFFUL /*<< ITM_TPR_PRIVMASK_Pos*/)     /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IM  uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile const  uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER Register */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x1UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x1UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY2_Pos          0U                                         /*!< TPI ITATBCTR2: ATREADY2 Position */
N#define TPI_ITATBCTR2_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY2_Pos*/)   /*!< TPI ITATBCTR2: ATREADY2 Mask */
N
N#define TPI_ITATBCTR2_ATREADY1_Pos          0U                                         /*!< TPI ITATBCTR2: ATREADY1 Position */
N#define TPI_ITATBCTR2_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY1_Pos*/)   /*!< TPI ITATBCTR2: ATREADY1 Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x1UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x1UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY2_Pos          0U                                         /*!< TPI ITATBCTR0: ATREADY2 Position */
N#define TPI_ITATBCTR0_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY2_Pos*/)   /*!< TPI ITATBCTR0: ATREADY2 Mask */
N
N#define TPI_ITATBCTR0_ATREADY1_Pos          0U                                         /*!< TPI ITATBCTR0: ATREADY1 Position */
N#define TPI_ITATBCTR0_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY1_Pos*/)   /*!< TPI ITATBCTR0: ATREADY1 Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x3UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_SubType_Pos             4U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N#define TPI_DEVTYPE_MajorType_Pos           0U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N#define MPU_TYPE_RALIASES                  4U
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif /* defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U) */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N  \brief    Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
X  volatile uint32_t FPCCR;                   
N  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
X  volatile uint32_t FPCAR;                   
N  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
X  volatile uint32_t FPDSCR;                  
N  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
X  volatile const  uint32_t MVFR0;                   
N  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
X  volatile const  uint32_t MVFR1;                   
N  __IM  uint32_t MVFR2;                  /*!< Offset: 0x018 (R/ )  Media and FP Feature Register 2 */
X  volatile const  uint32_t MVFR2;                   
N} FPU_Type;
N
N/* Floating-Point Context Control Register Definitions */
N#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register Definitions */
N#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register Definitions */
N#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 Definitions */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 Definitions */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/* Media and FP Feature Register 2 Definitions */
N
N#define FPU_MVFR2_VFP_Misc_Pos              4U                                            /*!< MVFR2: VFP Misc bits Position */
N#define FPU_MVFR2_VFP_Misc_Msk             (0xFUL << FPU_MVFR2_VFP_Misc_Pos)              /*!< MVFR2: VFP Misc bits Mask */
N
N/*@} end of group CMSIS_FPU */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N#define FPU_BASE            (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
N#define FPU                 ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N  #define NVIC_GetActive              __NVIC_GetActive
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* The following EXC_RETURN values are saved the LR on exception entry */
N#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
N#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
N#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
N#define EXC_RETURN_HANDLER_FPU     (0xFFFFFFE1UL)     /* return to Handler mode, uses MSP after return, restore floating-point state */
N#define EXC_RETURN_THREAD_MSP_FPU  (0xFFFFFFE9UL)     /* return to Thread mode, uses MSP after return, restore floating-point state  */
N#define EXC_RETURN_THREAD_PSP_FPU  (0xFFFFFFEDUL)     /* return to Thread mode, uses PSP after return, restore floating-point state  */
N
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
X                (PriorityGroupTmp << 8U)  );               
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t __NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    __COMPILER_BARRIER();
X    __memory_changed();
N    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __COMPILER_BARRIER();
X    __memory_changed();
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __DSB();
X    __dsb(0xF);
N    __ISB();
X    __isb(0xF);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetActive(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - 3U)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3U)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)IRQn)]               >> (8U - 3U)));
N  }
N  else
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3U)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3U)) ? (uint32_t)(3U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3U));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3U)) ? (uint32_t)(3U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3U));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N  /* ARM Application Note 321 states that the M4 does not require the architectural barrier */
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
X__declspec(noreturn) static __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  __dsb(0xF);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  MPU functions  #################################### */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N
N#include "mpu_armv7.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\mpu_armv7.h" 1
N/******************************************************************************
N * @file     mpu_armv7.h
N * @brief    CMSIS MPU API for Armv7-M MPU
N * @version  V5.1.2
N * @date     25. May 2020
N ******************************************************************************/
N/*
N * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N 
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header    /* treat file as system include file */
N#endif
N 
N#ifndef ARM_MPU_ARMV7_H
N#define ARM_MPU_ARMV7_H
N
N#define ARM_MPU_REGION_SIZE_32B      ((uint8_t)0x04U) ///!< MPU Region Size 32 Bytes
N#define ARM_MPU_REGION_SIZE_64B      ((uint8_t)0x05U) ///!< MPU Region Size 64 Bytes
N#define ARM_MPU_REGION_SIZE_128B     ((uint8_t)0x06U) ///!< MPU Region Size 128 Bytes
N#define ARM_MPU_REGION_SIZE_256B     ((uint8_t)0x07U) ///!< MPU Region Size 256 Bytes
N#define ARM_MPU_REGION_SIZE_512B     ((uint8_t)0x08U) ///!< MPU Region Size 512 Bytes
N#define ARM_MPU_REGION_SIZE_1KB      ((uint8_t)0x09U) ///!< MPU Region Size 1 KByte
N#define ARM_MPU_REGION_SIZE_2KB      ((uint8_t)0x0AU) ///!< MPU Region Size 2 KBytes
N#define ARM_MPU_REGION_SIZE_4KB      ((uint8_t)0x0BU) ///!< MPU Region Size 4 KBytes
N#define ARM_MPU_REGION_SIZE_8KB      ((uint8_t)0x0CU) ///!< MPU Region Size 8 KBytes
N#define ARM_MPU_REGION_SIZE_16KB     ((uint8_t)0x0DU) ///!< MPU Region Size 16 KBytes
N#define ARM_MPU_REGION_SIZE_32KB     ((uint8_t)0x0EU) ///!< MPU Region Size 32 KBytes
N#define ARM_MPU_REGION_SIZE_64KB     ((uint8_t)0x0FU) ///!< MPU Region Size 64 KBytes
N#define ARM_MPU_REGION_SIZE_128KB    ((uint8_t)0x10U) ///!< MPU Region Size 128 KBytes
N#define ARM_MPU_REGION_SIZE_256KB    ((uint8_t)0x11U) ///!< MPU Region Size 256 KBytes
N#define ARM_MPU_REGION_SIZE_512KB    ((uint8_t)0x12U) ///!< MPU Region Size 512 KBytes
N#define ARM_MPU_REGION_SIZE_1MB      ((uint8_t)0x13U) ///!< MPU Region Size 1 MByte
N#define ARM_MPU_REGION_SIZE_2MB      ((uint8_t)0x14U) ///!< MPU Region Size 2 MBytes
N#define ARM_MPU_REGION_SIZE_4MB      ((uint8_t)0x15U) ///!< MPU Region Size 4 MBytes
N#define ARM_MPU_REGION_SIZE_8MB      ((uint8_t)0x16U) ///!< MPU Region Size 8 MBytes
N#define ARM_MPU_REGION_SIZE_16MB     ((uint8_t)0x17U) ///!< MPU Region Size 16 MBytes
N#define ARM_MPU_REGION_SIZE_32MB     ((uint8_t)0x18U) ///!< MPU Region Size 32 MBytes
N#define ARM_MPU_REGION_SIZE_64MB     ((uint8_t)0x19U) ///!< MPU Region Size 64 MBytes
N#define ARM_MPU_REGION_SIZE_128MB    ((uint8_t)0x1AU) ///!< MPU Region Size 128 MBytes
N#define ARM_MPU_REGION_SIZE_256MB    ((uint8_t)0x1BU) ///!< MPU Region Size 256 MBytes
N#define ARM_MPU_REGION_SIZE_512MB    ((uint8_t)0x1CU) ///!< MPU Region Size 512 MBytes
N#define ARM_MPU_REGION_SIZE_1GB      ((uint8_t)0x1DU) ///!< MPU Region Size 1 GByte
N#define ARM_MPU_REGION_SIZE_2GB      ((uint8_t)0x1EU) ///!< MPU Region Size 2 GBytes
N#define ARM_MPU_REGION_SIZE_4GB      ((uint8_t)0x1FU) ///!< MPU Region Size 4 GBytes
N
N#define ARM_MPU_AP_NONE 0U ///!< MPU Access Permission no access
N#define ARM_MPU_AP_PRIV 1U ///!< MPU Access Permission privileged access only
N#define ARM_MPU_AP_URO  2U ///!< MPU Access Permission unprivileged access read-only
N#define ARM_MPU_AP_FULL 3U ///!< MPU Access Permission full access
N#define ARM_MPU_AP_PRO  5U ///!< MPU Access Permission privileged access read-only
N#define ARM_MPU_AP_RO   6U ///!< MPU Access Permission read-only access
N
N/** MPU Region Base Address Register Value
N*
N* \param Region The region to be configured, number 0 to 15.
N* \param BaseAddress The base address for the region.
N*/
N#define ARM_MPU_RBAR(Region, BaseAddress) \
N  (((BaseAddress) & MPU_RBAR_ADDR_Msk) |  \
N   ((Region) & MPU_RBAR_REGION_Msk)    |  \
N   (MPU_RBAR_VALID_Msk))
X#define ARM_MPU_RBAR(Region, BaseAddress)   (((BaseAddress) & MPU_RBAR_ADDR_Msk) |     ((Region) & MPU_RBAR_REGION_Msk)    |     (MPU_RBAR_VALID_Msk))
N
N/**
N* MPU Memory Access Attributes
N* 
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N*/  
N#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)   \
N  ((((TypeExtField) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                  | \
N   (((IsShareable)  << MPU_RASR_S_Pos)   & MPU_RASR_S_Msk)                    | \
N   (((IsCacheable)  << MPU_RASR_C_Pos)   & MPU_RASR_C_Msk)                    | \
N   (((IsBufferable) << MPU_RASR_B_Pos)   & MPU_RASR_B_Msk))
X#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)     ((((TypeExtField) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                  |    (((IsShareable)  << MPU_RASR_S_Pos)   & MPU_RASR_S_Msk)                    |    (((IsCacheable)  << MPU_RASR_C_Pos)   & MPU_RASR_C_Msk)                    |    (((IsBufferable) << MPU_RASR_B_Pos)   & MPU_RASR_B_Msk))
N
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param AccessAttributes  Memory access attribution, see \ref ARM_MPU_ACCESS_.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/
N#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)    \
N  ((((DisableExec)      << MPU_RASR_XN_Pos)   & MPU_RASR_XN_Msk)                                  | \
N   (((AccessPermission) << MPU_RASR_AP_Pos)   & MPU_RASR_AP_Msk)                                  | \
N   (((AccessAttributes) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk))) | \
N   (((SubRegionDisable) << MPU_RASR_SRD_Pos)  & MPU_RASR_SRD_Msk)                                 | \
N   (((Size)             << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk)                                | \
N   (((MPU_RASR_ENABLE_Msk))))
X#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)      ((((DisableExec)      << MPU_RASR_XN_Pos)   & MPU_RASR_XN_Msk)                                  |    (((AccessPermission) << MPU_RASR_AP_Pos)   & MPU_RASR_AP_Msk)                                  |    (((AccessAttributes) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk))) |    (((SubRegionDisable) << MPU_RASR_SRD_Pos)  & MPU_RASR_SRD_Msk)                                 |    (((Size)             << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk)                                |    (((MPU_RASR_ENABLE_Msk))))
N
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/                         
N#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size) \
N  ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
X#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size)   ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
N
N/**
N* MPU Memory Access Attribute for strongly ordered memory.
N*  - TEX: 000b
N*  - Shareable
N*  - Non-cacheable
N*  - Non-bufferable
N*/ 
N#define ARM_MPU_ACCESS_ORDERED ARM_MPU_ACCESS_(0U, 1U, 0U, 0U)
N
N/**
N* MPU Memory Access Attribute for device memory.
N*  - TEX: 000b (if shareable) or 010b (if non-shareable)
N*  - Shareable or non-shareable
N*  - Non-cacheable
N*  - Bufferable (if shareable) or non-bufferable (if non-shareable)
N*
N* \param IsShareable Configures the device memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_DEVICE(IsShareable) ((IsShareable) ? ARM_MPU_ACCESS_(0U, 1U, 0U, 1U) : ARM_MPU_ACCESS_(2U, 0U, 0U, 0U))
N
N/**
N* MPU Memory Access Attribute for normal memory.
N*  - TEX: 1BBb (reflecting outer cacheability rules)
N*  - Shareable or non-shareable
N*  - Cacheable or non-cacheable (reflecting inner cacheability rules)
N*  - Bufferable or non-bufferable (reflecting inner cacheability rules)
N*
N* \param OuterCp Configures the outer cache policy.
N* \param InnerCp Configures the inner cache policy.
N* \param IsShareable Configures the memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_NORMAL(OuterCp, InnerCp, IsShareable) ARM_MPU_ACCESS_((4U | (OuterCp)), IsShareable, ((InnerCp) >> 1U), ((InnerCp) & 1U))
N
N/**
N* MPU Memory Access Attribute non-cacheable policy.
N*/
N#define ARM_MPU_CACHEP_NOCACHE 0U
N
N/**
N* MPU Memory Access Attribute write-back, write and read allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_WRA 1U
N
N/**
N* MPU Memory Access Attribute write-through, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WT_NWA 2U
N
N/**
N* MPU Memory Access Attribute write-back, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_NWA 3U
N
N
N/**
N* Struct for a single MPU Region
N*/
Ntypedef struct {
N  uint32_t RBAR; //!< The region base address register value (RBAR)
N  uint32_t RASR; //!< The region attribute and size register value (RASR) \ref MPU_RASR
N} ARM_MPU_Region_t;
N    
N/** Enable the MPU.
N* \param MPU_Control Default access permissions for unconfigured regions.
N*/
N__STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control)
Xstatic __inline void ARM_MPU_Enable(uint32_t MPU_Control)
N{
N  __DMB();
X  __dmb(0xF);
N  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL = MPU_Control | (1UL );
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
N  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR |= (1UL << 16U);
N#endif
N  __DSB();
X  __dsb(0xF);
N  __ISB();
X  __isb(0xF);
N}
N
N/** Disable the MPU.
N*/
N__STATIC_INLINE void ARM_MPU_Disable(void)
Xstatic __inline void ARM_MPU_Disable(void)
N{
N  __DMB();
X  __dmb(0xF);
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
N  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR &= ~(1UL << 16U);
N#endif
N  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL  &= ~(1UL );
N  __DSB();
X  __dsb(0xF);
N  __ISB();
X  __isb(0xF);
N}
N
N/** Clear and disable the given MPU region.
N* \param rnr Region number to be cleared.
N*/
N__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
Xstatic __inline void ARM_MPU_ClrRegion(uint32_t rnr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RASR = 0U;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = 0U;
N}
N
N/** Configure an MPU region.
N* \param rbar Value for RBAR register.
N* \param rasr Value for RASR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
N{
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Configure the given MPU region.
N* \param rnr Region number to be configured.
N* \param rbar Value for RBAR register.
N* \param rasr Value for RASR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Memcpy with strictly ordered memory access, e.g. used by code in ARM_MPU_Load().
N* \param dst Destination data is copied to.
N* \param src Source data is copied from.
N* \param len Amount of data words to be copied.
N*/
N__STATIC_INLINE void ARM_MPU_OrderedMemcpy(volatile uint32_t* dst, const uint32_t* __RESTRICT src, uint32_t len)
Xstatic __inline void ARM_MPU_OrderedMemcpy(volatile uint32_t* dst, const uint32_t* __restrict src, uint32_t len)
N{
N  uint32_t i;
N  for (i = 0U; i < len; ++i) 
N  {
N    dst[i] = src[i];
N  }
N}
N
N/** Load the given number of MPU regions from a table.
N* \param table Pointer to the MPU configuration table.
N* \param cnt Amount of regions to be configured.
N*/
N__STATIC_INLINE void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
Xstatic __inline void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
N{
N  const uint32_t rowWordSize = sizeof(ARM_MPU_Region_t)/4U;
N  while (cnt > MPU_TYPE_RALIASES) {
X  while (cnt > 4U) {
N    ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), MPU_TYPE_RALIASES*rowWordSize);
X    ARM_MPU_OrderedMemcpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), 4U*rowWordSize);
N    table += MPU_TYPE_RALIASES;
X    table += 4U;
N    cnt -= MPU_TYPE_RALIASES;
X    cnt -= 4U;
N  }
N  ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), cnt*rowWordSize);
X  ARM_MPU_OrderedMemcpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), cnt*rowWordSize);
N}
N
N#endif
L 1961 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include\core_cm4.h" 2
N
N#endif
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N  uint32_t mvfr0;
N
N  mvfr0 = FPU->MVFR0;
X  mvfr0 = ((FPU_Type *) ((0xE000E000UL) + 0x0F30UL) )->MVFR0;
N  if      ((mvfr0 & (FPU_MVFR0_Single_precision_Msk | FPU_MVFR0_Double_precision_Msk)) == 0x020U)
X  if      ((mvfr0 & ((0xFUL << 4U) | (0xFUL << 8U))) == 0x020U)
N  {
N    return 1U;           /* Single precision FPU */
N  }
N  else
N  {
N    return 0U;           /* No FPU */
N  }
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0U == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 3U) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != ((int32_t)0x5AA55AA5U))
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = ((int32_t)0x5AA55AA5U);        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == ((int32_t)0x5AA55AA5U))
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 100 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include\ARMCM4_FP.h" 2
N#include "system_ARMCM4.h"                  /* System Header */
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include\system_ARMCM4.h" 1
N/**************************************************************************//**
N * @file     system_ARMCM4.h
N * @brief    CMSIS Device System Header File for
N *           ARMCM4 Device
N * @version  V5.3.2
N * @date     15. November 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef SYSTEM_ARMCM4_H
N#define SYSTEM_ARMCM4_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N  \brief Exception / Interrupt Handler Function Prototype
N*/
Ntypedef void(*VECTOR_TABLE_Type)(void);
N
N/**
N  \brief System Clock Frequency (Core Clock)
N*/
Nextern uint32_t SystemCoreClock;
N
N/**
N  \brief Setup the microcontroller system.
N
N   Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N
N/**
N  \brief  Update SystemCoreClock variable.
N
N   Updates the SystemCoreClock with current core Clock retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_ARMCM4_H */
L 101 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include\ARMCM4_FP.h" 2
N
N
N/* --------  End of section using anonymous unions and disabling warnings  -------- */
N#if   defined (__CC_ARM)
X#if   1L
N  #pragma pop
N#elif defined (__ICCARM__)
X#elif 0L
S  /* leave anonymous unions enabled */
S#elif (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
S  #pragma clang diagnostic pop
S#elif defined (__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined (__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined (__TASKING__)
S  #pragma warning restore
S#elif defined (__CSMC__)
S  /* anonymous unions are enabled by default */
S#else
S  #warning Not supported compiler type
N#endif
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  /* ARMCM4_FP_H */
L 30 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_lib.c" 2
N#else
S#include "cmsis_compiler.h"
N#endif
N
N#ifdef    RTE_Compiler_EventRecorder
S#include "EventRecorder.h"
S#include "EventRecorderConf.h"
N#endif
N#include "rtx_evr.h"
L 1 "F:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include\rtx_evr.h" 1
N/*
N * Copyright (c) 2013-2021 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * -----------------------------------------------------------------------------
N *
N * Project:     CMSIS-RTOS RTX
N * Title:       RTX Event Recorder definitions
N *
N * -----------------------------------------------------------------------------
N */
N
N#ifndef RTX_EVR_H_
N#define RTX_EVR_H_
N
N#include "rtx_os.h"                     // RTX OS definitions
N
N// Initial Thread configuration covered also Thread Flags and Generic Wait
N#ifndef   OS_EVR_THFLAGS
N#define   OS_EVR_THFLAGS        OS_EVR_THREAD
N#endif
N#ifndef   OS_EVR_WAIT
N#define   OS_EVR_WAIT           OS_EVR_THREAD
N#endif
N
N#ifdef   _RTE_
N#include "RTE_Components.h"
N#endif
N
N#ifdef    RTE_Compiler_EventRecorder
S
S//lint -emacro((835,845),EventID) [MISRA Note 13]
S
S#include "EventRecorder.h"
S#include "EventRecorderConf.h"
S
S#if ((defined(OS_EVR_INIT) && (OS_EVR_INIT != 0)) || (EVENT_TIMESTAMP_SOURCE == 2))
S#ifndef EVR_RTX_KERNEL_GET_STATE_DISABLE
S#define EVR_RTX_KERNEL_GET_STATE_DISABLE
S#endif
S#endif
S
S#if (EVENT_TIMESTAMP_SOURCE == 2)
S#ifndef EVR_RTX_KERNEL_GET_SYS_TIMER_COUNT_DISABLE
S#define EVR_RTX_KERNEL_GET_SYS_TIMER_COUNT_DISABLE
S#endif
S#ifndef EVR_RTX_KERNEL_GET_SYS_TIMER_FREQ_DISABLE
S#define EVR_RTX_KERNEL_GET_SYS_TIMER_FREQ_DISABLE
S#endif
S#endif
S
S/// RTOS component number
S#define EvtRtxMemoryNo                  (0xF0U)
S#define EvtRtxKernelNo                  (0xF1U)
S#define EvtRtxThreadNo                  (0xF2U)
S#define EvtRtxThreadFlagsNo             (0xF4U)
S#define EvtRtxWaitNo                    (0xF3U)
S#define EvtRtxTimerNo                   (0xF6U)
S#define EvtRtxEventFlagsNo              (0xF5U)
S#define EvtRtxMutexNo                   (0xF7U)
S#define EvtRtxSemaphoreNo               (0xF8U)
S#define EvtRtxMemoryPoolNo              (0xF9U)
S#define EvtRtxMessageQueueNo            (0xFAU)
S
N#endif  // RTE_Compiler_EventRecorder
N
N
N/// Extended Status codes
N#define osRtxErrorKernelNotReady        (-7)
N#define osRtxErrorKernelNotRunning      (-8)
N#define osRtxErrorInvalidControlBlock   (-9)
N#define osRtxErrorInvalidDataMemory     (-10)
N#define osRtxErrorInvalidThreadStack    (-11)
N#define osRtxErrorInvalidPriority       (-12)
N#define osRtxErrorThreadNotJoinable     (-13)
N#define osRtxErrorMutexNotOwned         (-14)
N#define osRtxErrorMutexNotLocked        (-15)
N#define osRtxErrorMutexLockLimit        (-16)
N#define osRtxErrorSemaphoreCountLimit   (-17)
N#define osRtxErrorTZ_InitContext_S      (-18)
N#define osRtxErrorTZ_AllocContext_S     (-19)
N#define osRtxErrorTZ_FreeContext_S      (-20)
N#define osRtxErrorTZ_LoadContext_S      (-21)
N#define osRtxErrorTZ_SaveContext_S      (-22)
N
N
N//  ==== Memory Events ====
N
N/**
N  \brief  Event on memory initialization (Op)
N  \param[in]  mem           pointer to memory pool.
N  \param[in]  size          size of a memory pool in bytes.
N  \param[in]  result        execution status: 1 - success, 0 - failure.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_INIT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryInit (void *mem, uint32_t size, uint32_t result);
N#else
S#define EvrRtxMemoryInit(mem, size, result)
N#endif
N
N/**
N  \brief  Event on memory allocate (Op)
N  \param[in]  mem           pointer to memory pool.
N  \param[in]  size          size of a memory block in bytes.
N  \param[in]  type          memory block type: 0 - generic, 1 - control block.
N  \param[in]  block         pointer to allocated memory block or NULL in case of no memory is available.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_ALLOC_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryAlloc (void *mem, uint32_t size, uint32_t type, void *block);
N#else
S#define EvrRtxMemoryAlloc(mem, size, type, block)
N#endif
N
N/**
N  \brief  Event on memory free (Op)
N  \param[in]  mem           pointer to memory pool.
N  \param[in]  block         memory block to be returned to the memory pool.
N  \param[in]  result        execution status: 1 - success, 0 - failure.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_FREE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryFree (void *mem, void *block, uint32_t result);
N#else
S#define EvrRtxMemoryFree(mem, block, result)
N#endif
N
N/**
N  \brief  Event on memory block initialization (Op)
N  \param[in]  mp_info       memory pool info.
N  \param[in]  block_count   maximum number of memory blocks in memory pool.
N  \param[in]  block_size    size of a memory block in bytes.
N  \param[in]  block_mem     pointer to memory for block storage.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_BLOCK_INIT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryBlockInit (osRtxMpInfo_t *mp_info, uint32_t block_count, uint32_t block_size, void *block_mem);
N#else
S#define EvrRtxMemoryBlockInit(mp_info, block_count, block_size, block_mem)
N#endif
N
N/**
N  \brief  Event on memory block alloc (Op)
N  \param[in]  mp_info       memory pool info.
N  \param[in]  block         address of the allocated memory block or NULL in case of no memory is available.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_BLOCK_ALLOC_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryBlockAlloc (osRtxMpInfo_t *mp_info, void *block);
N#else
S#define EvrRtxMemoryBlockAlloc(mp_info, block)
N#endif
N
N/**
N  \brief  Event on memory block free (Op)
N  \param[in]  mp_info       memory pool info.
N  \param[in]  block         address of the allocated memory block to be returned to the memory pool.
N  \param[in]  status        extended execution status.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_BLOCK_FREE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryBlockFree (osRtxMpInfo_t *mp_info, void *block, int32_t status);
N#else
S#define EvrRtxMemoryBlockFree(mp_info, block, status)
N#endif
N
N
N//  ==== Kernel Events ====
N
N/**
N  \brief  Event on RTOS kernel error (Error)
N  \param[in]  status        extended execution status.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_ERROR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelError (int32_t status);
N#else
S#define EvrRtxKernelError(status)
N#endif
N
N/**
N  \brief  Event on RTOS kernel initialize (API)
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_INITIALIZE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelInitialize (void);
N#else
S#define EvrRtxKernelInitialize()
N#endif
N
N/**
N  \brief  Event on successful RTOS kernel initialize (Op)
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_INITIALIZED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelInitialized (void);
N#else
S#define EvrRtxKernelInitialized()
N#endif
N
N/**
N  \brief  Event on RTOS kernel information retrieve (API)
N  \param[in]  version       pointer to buffer for retrieving version information.
N  \param[in]  id_buf        pointer to buffer for retrieving kernel identification string.
N  \param[in]  id_size       size of buffer for kernel identification string.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_GET_INFO_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size);
N#else
S#define EvrRtxKernelGetInfo(version, id_buf, id_size)
N#endif
N
N/**
N  \brief  Event on successful RTOS kernel information retrieve (Op)
N  \param[in]  version       pointer to buffer for retrieving version information.
N  \param[in]  id_buf        pointer to buffer for retrieving kernel identification string.
N  \param[in]  id_size       size of buffer for kernel identification string.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_INFO_RETRIEVED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelInfoRetrieved (const osVersion_t *version, const char *id_buf, uint32_t id_size);
N#else
S#define EvrRtxKernelInfoRetrieved(version, id_buf, id_size)
N#endif
N
N/**
N  \brief  Event on current RTOS Kernel state retrieve (API)
N  \param[in]  state         current RTOS Kernel state.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_GET_STATE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelGetState (osKernelState_t state);
N#else
S#define EvrRtxKernelGetState(state)
N#endif
N
N/**
N  \brief  Event on RTOS Kernel scheduler start (API)
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_START_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelStart (void);
N#else
S#define EvrRtxKernelStart()
N#endif
N
N/**
N  \brief  Event on successful RTOS Kernel scheduler start (Op)
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_STARTED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelStarted (void);
N#else
S#define EvrRtxKernelStarted()
N#endif
N
N/**
N  \brief  Event on RTOS Kernel scheduler lock (API)
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_LOCK_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelLock (void);
N#else
S#define EvrRtxKernelLock()
N#endif
N
N/**
N  \brief  Event on successful RTOS Kernel scheduler lock (Op)
N  \param[in]  lock          previous lock state (1 - locked, 0 - not locked).
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_LOCKED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelLocked (int32_t lock);
N#else
S#define EvrRtxKernelLocked(lock)
N#endif
N
N/**
N  \brief  Event on RTOS Kernel scheduler unlock (API)
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_UNLOCK_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelUnlock (void);
N#else
S#define EvrRtxKernelUnlock()
N#endif
N
N/**
N  \brief  Event on successful RTOS Kernel scheduler unlock (Op)
N  \param[in]  lock          previous lock state (1 - locked, 0 - not locked).
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_UNLOCKED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelUnlocked (int32_t lock);
N#else
S#define EvrRtxKernelUnlocked(lock)
N#endif
N
N/**
N  \brief  Event on RTOS Kernel scheduler lock state restore (API)
N  \param[in]  lock          lock state obtained by \ref osKernelLock or \ref osKernelUnlock.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_RESTORE_LOCK_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelRestoreLock (int32_t lock);
N#else
S#define EvrRtxKernelRestoreLock(lock)
N#endif
N
N/**
N  \brief  Event on successful RTOS Kernel scheduler lock state restore (Op)
N  \param[in]  lock          new lock state (1 - locked, 0 - not locked).
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_LOCK_RESTORED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelLockRestored (int32_t lock);
N#else
S#define EvrRtxKernelLockRestored(lock)
N#endif
N
N/**
N  \brief  Event on RTOS Kernel scheduler suspend (API)
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_SUSPEND_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelSuspend (void);
N#else
S#define EvrRtxKernelSuspend()
N#endif
N
N/**
N  \brief  Event on successful RTOS Kernel scheduler suspend (Op)
N  \param[in]  sleep_ticks   time in ticks, for how long the system can sleep or power-down.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_SUSPENDED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelSuspended (uint32_t sleep_ticks);
N#else
S#define EvrRtxKernelSuspended(sleep_ticks)
N#endif
N
N/**
N  \brief  Event on RTOS Kernel scheduler resume (API)
N  \param[in]  sleep_ticks   time in ticks, for how long the system was in sleep or power-down mode.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_RESUME_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelResume (uint32_t sleep_ticks);
N#else
S#define EvrRtxKernelResume(sleep_ticks)
N#endif
N
N/**
N  \brief  Event on successful RTOS Kernel scheduler resume (Op)
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_RESUMED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelResumed (void);
N#else
S#define EvrRtxKernelResumed()
N#endif
N
N/**
N  \brief  Event on RTOS kernel tick count retrieve (API)
N  \param[in]  count         RTOS kernel current tick count.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_GET_TICK_COUNT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelGetTickCount (uint32_t count);
N#else
S#define EvrRtxKernelGetTickCount(count)
N#endif
N
N/**
N  \brief  Event on RTOS kernel tick frequency retrieve (API)
N  \param[in]  freq          frequency of the kernel tick.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_GET_TICK_FREQ_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelGetTickFreq (uint32_t freq);
N#else
S#define EvrRtxKernelGetTickFreq(freq)
N#endif
N
N/**
N  \brief  Event on RTOS kernel system timer count retrieve (API)
N  \param[in]  count         RTOS kernel current system timer count as 32-bit value.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_GET_SYS_TIMER_COUNT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelGetSysTimerCount (uint32_t count);
N#else
S#define EvrRtxKernelGetSysTimerCount(count)
N#endif
N
N/**
N  \brief  Event on RTOS kernel system timer frequency retrieve (API)
N  \param[in]  freq          frequency of the system timer.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_GET_SYS_TIMER_FREQ_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelGetSysTimerFreq (uint32_t freq);
N#else
S#define EvrRtxKernelGetSysTimerFreq(freq)
N#endif
N
N/**
N  \brief  Event on RTOS kernel system error (Error)
N  \param[in]  code          error code.
N  \param[in]  object_id     object that caused the error.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_ERROR_NOTIFY_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxKernelErrorNotify (uint32_t code, void *object_id);
N#else
S#define EvrRtxKernelErrorNotify(code, object_id)
N#endif
N
N
N//  ==== Thread Events ====
N
N/**
N  \brief  Event on thread error (Error)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId or NULL when ID is unknown.
N  \param[in]  status        extended execution status.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_ERROR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadError (osThreadId_t thread_id, int32_t status);
N#else
S#define EvrRtxThreadError(thread_id, status)
N#endif
N
N/**
N  \brief  Event on thread create and intialize (API)
N  \param[in]  func          thread function.
N  \param[in]  argument      pointer that is passed to the thread function as start argument.
N  \param[in]  attr          thread attributes.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_NEW_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr);
N#else
S#define EvrRtxThreadNew(func, argument, attr)
N#endif
N
N/**
N  \brief  Event on successful thread create (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]  thread_addr   thread entry address.
N  \param[in]  name          pointer to thread object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_CREATED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadCreated (osThreadId_t thread_id, uint32_t thread_addr, const char *name);
N#else
S#define EvrRtxThreadCreated(thread_id, thread_addr, name)
N#endif
N
N/**
N  \brief  Event on thread name retrieve (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]  name          pointer to thread object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_NAME_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadGetName (osThreadId_t thread_id, const char *name);
N#else
S#define EvrRtxThreadGetName(thread_id, name)
N#endif
N
N/**
N  \brief  Event on current running thread ID retrieve (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_ID_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadGetId (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadGetId(thread_id)
N#endif
N
N/**
N  \brief  Event on thread state retrieve (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]  state         current thread state of the specified thread.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_STATE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadGetState (osThreadId_t thread_id, osThreadState_t state);
N#else
S#define EvrRtxThreadGetState(thread_id, state)
N#endif
N
N/**
N  \brief  Event on thread stack size retrieve (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]  stack_size    stack size in bytes.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_STACK_SIZE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadGetStackSize (osThreadId_t thread_id, uint32_t stack_size);
N#else
S#define EvrRtxThreadGetStackSize(thread_id, stack_size)
N#endif
N
N/**
N  \brief  Event on available stack space retrieve (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]  stack_space   remaining stack space in bytes.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_STACK_SPACE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadGetStackSpace (osThreadId_t thread_id, uint32_t stack_space);
N#else
S#define EvrRtxThreadGetStackSpace(thread_id, stack_space)
N#endif
N
N/**
N  \brief  Event on thread priority set (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]  priority      new priority value for the thread function.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_SET_PRIORITY_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadSetPriority (osThreadId_t thread_id, osPriority_t priority);
N#else
S#define EvrRtxThreadSetPriority(thread_id, priority)
N#endif
N
N/**
N  \brief  Event on thread priority updated (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]  priority      new priority value for the thread function.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_PRIORITY_UPDATED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadPriorityUpdated (osThreadId_t thread_id, osPriority_t priority);
N#else
S#define EvrRtxThreadPriorityUpdated(thread_id, priority)
N#endif
N
N/**
N  \brief  Event on thread priority retrieve (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]  priority      current priority value of the specified thread.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_PRIORITY_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadGetPriority (osThreadId_t thread_id, osPriority_t priority);
N#else
S#define EvrRtxThreadGetPriority(thread_id, priority)
N#endif
N
N/**
N  \brief  Event on thread yield (API)
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_YIELD_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadYield (void);
N#else
S#define EvrRtxThreadYield()
N#endif
N
N/**
N  \brief  Event on thread suspend (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_SUSPEND_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadSuspend (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadSuspend(thread_id)
N#endif
N
N/**
N  \brief  Event on successful thread suspend (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_SUSPENDED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadSuspended (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadSuspended(thread_id)
N#endif
N
N/**
N  \brief  Event on thread resume (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_RESUME_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadResume (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadResume(thread_id)
N#endif
N
N/**
N  \brief  Event on successful thread resume (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_RESUMED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadResumed (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadResumed(thread_id)
N#endif
N
N/**
N  \brief  Event on thread detach (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_DETACH_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadDetach (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadDetach(thread_id)
N#endif
N
N/**
N  \brief  Event on successful thread detach (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_DETACHED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadDetached (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadDetached(thread_id)
N#endif
N
N/**
N  \brief  Event on thread join (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_JOIN_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadJoin (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadJoin(thread_id)
N#endif
N
N/**
N  \brief  Event on pending thread join (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_JOIN_PENDING_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadJoinPending (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadJoinPending(thread_id)
N#endif
N
N/**
N  \brief  Event on successful thread join (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_JOINED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadJoined (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadJoined(thread_id)
N#endif
N
N/**
N  \brief  Event on thread execution block (Detail)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_BLOCKED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadBlocked (osThreadId_t thread_id, uint32_t timeout);
N#else
S#define EvrRtxThreadBlocked(thread_id, timeout)
N#endif
N
N/**
N  \brief  Event on thread execution unblock (Detail)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]  ret_val       extended execution status of the thread.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_UNBLOCKED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadUnblocked (osThreadId_t thread_id, uint32_t ret_val);
N#else
S#define EvrRtxThreadUnblocked(thread_id, ret_val)
N#endif
N
N/**
N  \brief  Event on running thread pre-emption (Detail)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_PREEMPTED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadPreempted (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadPreempted(thread_id)
N#endif
N
N/**
N  \brief  Event on running thread switch (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_SWITCHED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadSwitched (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadSwitched(thread_id)
N#endif
N
N/**
N  \brief  Event on thread exit (API)
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_EXIT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadExit (void);
N#else
S#define EvrRtxThreadExit()
N#endif
N
N/**
N  \brief  Event on thread terminate (API)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_TERMINATE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadTerminate (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadTerminate(thread_id)
N#endif
N
N/**
N  \brief  Event on successful thread terminate (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_DESTROYED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadDestroyed (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadDestroyed(thread_id)
N#endif
N
N/**
N  \brief  Event on active thread count retrieve (API)
N  \param[in]  count         number of active threads.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_COUNT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadGetCount (uint32_t count);
N#else
S#define EvrRtxThreadGetCount(count)
N#endif
N
N/**
N  \brief  Event on active threads enumerate (API)
N  \param[in]  thread_array  pointer to array for retrieving thread IDs.
N  \param[in]  array_items   maximum number of items in array for retrieving thread IDs.
N  \param[in]  count         number of enumerated threads.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_ENUMERATE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items, uint32_t count);
N#else
S#define EvrRtxThreadEnumerate(thread_array, array_items, count)
N#endif
N
N
N//  ==== Thread Flags Events ====
N
N/**
N  \brief  Event on thread flags error (Error)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId or NULL when ID is unknown.
N  \param[in]  status        extended execution status.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THFLAGS != 0) && !defined(EVR_RTX_THREAD_FLAGS_ERROR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadFlagsError (osThreadId_t thread_id, int32_t status);
N#else
S#define EvrRtxThreadFlagsError(thread_id, status)
N#endif
N
N/**
N  \brief  Event on thread flags set (API)
N  \param[in]   thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]   flags         flags of the thread that shall be set.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THFLAGS != 0) && !defined(EVR_RTX_THREAD_FLAGS_SET_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadFlagsSet (osThreadId_t thread_id, uint32_t flags);
N#else
S#define EvrRtxThreadFlagsSet(thread_id, flags)
N#endif
N
N/**
N  \brief  Event on successful thread flags set (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N  \param[in]  thread_flags  thread flags after setting.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THFLAGS != 0) && !defined(EVR_RTX_THREAD_FLAGS_SET_DONE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadFlagsSetDone (osThreadId_t thread_id, uint32_t thread_flags);
N#else
S#define EvrRtxThreadFlagsSetDone(thread_id, thread_flags)
N#endif
N
N/**
N  \brief  Event on thread flags clear (API)
N  \param[in]  flags         flags of the thread that shall be cleared.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THFLAGS != 0) && !defined(EVR_RTX_THREAD_FLAGS_CLEAR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadFlagsClear (uint32_t flags);
N#else
S#define EvrRtxThreadFlagsClear(flags)
N#endif
N
N/**
N  \brief  Event on successful thread flags clear (Op)
N  \param[in]  thread_flags  thread flags before clearing.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THFLAGS != 0) && !defined(EVR_RTX_THREAD_FLAGS_CLEAR_DONE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadFlagsClearDone (uint32_t thread_flags);
N#else
S#define EvrRtxThreadFlagsClearDone(thread_flags)
N#endif
N
N/**
N  \brief  Event on thread flags retrieve (API)
N  \param[in]  thread_flags  current thread flags.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THFLAGS != 0) && !defined(EVR_RTX_THREAD_FLAGS_GET_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadFlagsGet (uint32_t thread_flags);
N#else
S#define EvrRtxThreadFlagsGet(thread_flags)
N#endif
N
N/**
N  \brief  Event on wait for thread flags (API)
N  \param[in]  flags         flags to wait for.
N  \param[in]  options       flags options (osFlagsXxxx).
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THFLAGS != 0) && !defined(EVR_RTX_THREAD_FLAGS_WAIT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout);
N#else
S#define EvrRtxThreadFlagsWait(flags, options, timeout)
N#endif
N
N/**
N  \brief  Event on pending wait for thread flags (Op)
N  \param[in]  flags         flags to wait for.
N  \param[in]  options       flags options (osFlagsXxxx).
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THFLAGS != 0) && !defined(EVR_RTX_THREAD_FLAGS_WAIT_PENDING_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadFlagsWaitPending (uint32_t flags, uint32_t options, uint32_t timeout);
N#else
S#define EvrRtxThreadFlagsWaitPending(flags, options, timeout)
N#endif
N
N/**
N  \brief  Event on wait timeout for thread flags (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THFLAGS != 0) && !defined(EVR_RTX_THREAD_FLAGS_WAIT_TIMEOUT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadFlagsWaitTimeout (osThreadId_t thread_id);
N#else
S#define EvrRtxThreadFlagsWaitTimeout(thread_id)
N#endif
N
N/**
N  \brief  Event on successful wait for thread flags (Op)
N  \param[in]  flags         flags to wait for.
N  \param[in]  options       flags options (osFlagsXxxx).
N  \param[in]  thread_flags  thread flags before clearing.
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THFLAGS != 0) && !defined(EVR_RTX_THREAD_FLAGS_WAIT_COMPLETED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadFlagsWaitCompleted (uint32_t flags, uint32_t options, uint32_t thread_flags, osThreadId_t thread_id);
N#else
S#define EvrRtxThreadFlagsWaitCompleted(flags, options, thread_flags, thread_id)
N#endif
N
N/**
N  \brief  Event on unsuccessful wait for thread flags (Op)
N  \param[in]  flags         flags to wait for.
N  \param[in]  options       flags options (osFlagsXxxx).
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THFLAGS != 0) && !defined(EVR_RTX_THREAD_FLAGS_WAIT_NOT_COMPLETED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxThreadFlagsWaitNotCompleted (uint32_t flags, uint32_t options);
N#else
S#define EvrRtxThreadFlagsWaitNotCompleted(flags, options)
N#endif
N
N
N//  ==== Generic Wait Events ====
N
N/**
N  \brief  Event on delay error (Error)
N  \param[in]  status        extended execution status.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_WAIT != 0) && !defined(EVR_RTX_DELAY_ERROR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxDelayError (int32_t status);
N#else
S#define EvrRtxDelayError(status)
N#endif
N
N/**
N  \brief  Event on delay for specified time (API)
N  \param[in]  ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_WAIT != 0) && !defined(EVR_RTX_DELAY_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxDelay (uint32_t ticks);
N#else
S#define EvrRtxDelay(ticks)
N#endif
N
N/**
N  \brief  Event on delay until specified time (API)
N  \param[in]  ticks         absolute time in ticks.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_WAIT != 0) && !defined(EVR_RTX_DELAY_UNTIL_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxDelayUntil (uint32_t ticks);
N#else
S#define EvrRtxDelayUntil(ticks)
N#endif
N
N/**
N  \brief  Event on delay started (Op)
N  \param[in]  ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_WAIT != 0) && !defined(EVR_RTX_DELAY_STARTED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxDelayStarted (uint32_t ticks);
N#else
S#define EvrRtxDelayStarted(ticks)
N#endif
N
N/**
N  \brief  Event on delay until specified time started (Op)
N  \param[in]  ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_WAIT != 0) && !defined(EVR_RTX_DELAY_UNTIL_STARTED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxDelayUntilStarted (uint32_t ticks);
N#else
S#define EvrRtxDelayUntilStarted(ticks)
N#endif
N
N/**
N  \brief  Event on delay completed (Op)
N  \param[in]  thread_id     thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_WAIT != 0) && !defined(EVR_RTX_DELAY_COMPLETED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxDelayCompleted (osThreadId_t thread_id);
N#else
S#define EvrRtxDelayCompleted(thread_id)
N#endif
N
N
N//  ==== Timer Events ====
N
N/**
N  \brief  Event on timer error (Error)
N  \param[in]  timer_id      timer ID obtained by \ref osTimerNew or NULL when ID is unknown.
N  \param[in]  status        extended execution status.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_ERROR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerError (osTimerId_t timer_id, int32_t status);
N#else
S#define EvrRtxTimerError(timer_id, status)
N#endif
N
N/**
N  \brief  Event on timer callback call (Op)
N  \param[in]  func          start address of a timer call back function.
N  \param[in]  argument      argument to the timer call back function.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_CALLBACK_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerCallback (osTimerFunc_t func, void *argument);
N#else
S#define EvrRtxTimerCallback(func, argument)
N#endif
N
N/**
N  \brief  Event on timer create and initialize (API)
N  \param[in]  func          start address of a timer call back function.
N  \param[in]  type          osTimerOnce for one-shot or osTimerPeriodic for periodic behavior.
N  \param[in]  argument      argument to the timer call back function.
N  \param[in]  attr          timer attributes.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_NEW_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr);
N#else
S#define EvrRtxTimerNew(func, type, argument, attr)
N#endif
N
N/**
N  \brief  Event on successful timer create (Op)
N  \param[in]  timer_id      timer ID obtained by \ref osTimerNew.
N  \param[in]  name          pointer to timer object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_CREATED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerCreated (osTimerId_t timer_id, const char *name);
N#else
S#define EvrRtxTimerCreated(timer_id, name)
N#endif
N
N/**
N  \brief  Event on timer name retrieve (API)
N  \param[in]  timer_id      timer ID obtained by \ref osTimerNew.
N  \param[in]  name          pointer to timer object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_GET_NAME_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerGetName (osTimerId_t timer_id, const char *name);
N#else
S#define EvrRtxTimerGetName(timer_id, name)
N#endif
N
N/**
N  \brief  Event on timer start (API)
N  \param[in]  timer_id      timer ID obtained by \ref osTimerNew.
N  \param[in]  ticks         \ref CMSIS_RTOS_TimeOutValue "time ticks" value of the timer.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_START_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerStart (osTimerId_t timer_id, uint32_t ticks);
N#else
S#define EvrRtxTimerStart(timer_id, ticks)
N#endif
N
N/**
N  \brief  Event on successful timer start (Op)
N  \param[in]  timer_id      timer ID obtained by \ref osTimerNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_STARTED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerStarted (osTimerId_t timer_id);
N#else
S#define EvrRtxTimerStarted(timer_id)
N#endif
N
N/**
N  \brief  Event on timer stop (API)
N  \param[in]  timer_id      timer ID obtained by \ref osTimerNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_STOP_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerStop (osTimerId_t timer_id);
N#else
S#define EvrRtxTimerStop(timer_id)
N#endif
N
N/**
N  \brief  Event on successful timer stop (Op)
N  \param[in]  timer_id      timer ID obtained by \ref osTimerNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_STOPPED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerStopped (osTimerId_t timer_id);
N#else
S#define EvrRtxTimerStopped(timer_id)
N#endif
N
N/**
N  \brief  Event on timer running state check (API)
N  \param[in]  timer_id      timer ID obtained by \ref osTimerNew.
N  \param[in]  running       running state: 0 not running, 1 running.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_IS_RUNNING_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerIsRunning (osTimerId_t timer_id, uint32_t running);
N#else
S#define EvrRtxTimerIsRunning(timer_id, running)
N#endif
N
N/**
N  \brief  Event on timer delete (API)
N  \param[in]  timer_id      timer ID obtained by \ref osTimerNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_DELETE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerDelete (osTimerId_t timer_id);
N#else
S#define EvrRtxTimerDelete(timer_id)
N#endif
N
N/**
N  \brief  Event on successful timer delete (Op)
N  \param[in]  timer_id      timer ID obtained by \ref osTimerNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_DESTROYED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxTimerDestroyed (osTimerId_t timer_id);
N#else
S#define EvrRtxTimerDestroyed(timer_id)
N#endif
N
N
N//  ==== Event Flags Events ====
N
N/**
N  \brief  Event on event flags error (Error)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew or NULL when ID is unknown.
N  \param[in]  status        extended execution status.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_ERROR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsError (osEventFlagsId_t ef_id, int32_t status);
N#else
S#define EvrRtxEventFlagsError(ef_id, status)
N#endif
N
N/**
N  \brief  Event on event flags create and initialize (API)
N  \param[in]  attr          event flags attributes.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_NEW_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsNew (const osEventFlagsAttr_t *attr);
N#else
S#define EvrRtxEventFlagsNew(attr)
N#endif
N
N/**
N  \brief  Event on successful event flags create (Op)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N  \param[in]  name          pointer to event flags object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_CREATED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsCreated (osEventFlagsId_t ef_id, const char *name);
N#else
S#define EvrRtxEventFlagsCreated(ef_id, name)
N#endif
N
N/**
N  \brief  Event on event flags name retrieve (API)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N  \param[in]  name          pointer to event flags object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_GET_NAME_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsGetName (osEventFlagsId_t ef_id, const char *name);
N#else
S#define EvrRtxEventFlagsGetName(ef_id, name)
N#endif
N
N/**
N  \brief  Event on event flags set (API)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N  \param[in]  flags         flags that shall be set.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_SET_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags);
N#else
S#define EvrRtxEventFlagsSet(ef_id, flags)
N#endif
N
N/**
N  \brief  Event on successful event flags set (Op)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N  \param[in]  event_flags   event flags after setting.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_SET_DONE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsSetDone (osEventFlagsId_t ef_id, uint32_t event_flags);
N#else
S#define EvrRtxEventFlagsSetDone(ef_id, event_flags)
N#endif
N
N/**
N  \brief  Event on event flags clear (API)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N  \param[in]  flags         flags that shall be cleared.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_CLEAR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags);
N#else
S#define EvrRtxEventFlagsClear(ef_id, flags)
N#endif
N
N/**
N  \brief  Event on successful event flags clear (Op)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N  \param[in]  event_flags   event flags before clearing.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_CLEAR_DONE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsClearDone (osEventFlagsId_t ef_id, uint32_t event_flags);
N#else
S#define EvrRtxEventFlagsClearDone(ef_id, event_flags)
N#endif
N
N/**
N  \brief  Event on event flags retrieve (API)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N  \param[in]  event_flags   current event flags.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_GET_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsGet (osEventFlagsId_t ef_id, uint32_t event_flags);
N#else
S#define EvrRtxEventFlagsGet(ef_id, event_flags)
N#endif
N
N/**
N  \brief  Event on wait for event flags (API)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N  \param[in]  flags         flags to wait for.
N  \param[in]  options       flags options (osFlagsXxxx).
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_WAIT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout);
N#else
S#define EvrRtxEventFlagsWait(ef_id, flags, options, timeout)
N#endif
N
N/**
N  \brief  Event on pending wait for event flags (Op)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N  \param[in]  flags         flags to wait for.
N  \param[in]  options       flags options (osFlagsXxxx).
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_WAIT_PENDING_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsWaitPending (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout);
N#else
S#define EvrRtxEventFlagsWaitPending(ef_id, flags, options, timeout)
N#endif
N
N/**
N  \brief  Event on wait timeout for event flags (Op)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_WAIT_TIMEOUT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsWaitTimeout (osEventFlagsId_t ef_id);
N#else
S#define EvrRtxEventFlagsWaitTimeout(ef_id)
N#endif
N
N/**
N  \brief  Event on successful wait for event flags (Op)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N  \param[in]  flags         flags to wait for.
N  \param[in]  options       flags options (osFlagsXxxx).
N  \param[in]  event_flags   event flags before clearing or 0 if specified flags have not been set.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_WAIT_COMPLETED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsWaitCompleted (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t event_flags);
N#else
S#define EvrRtxEventFlagsWaitCompleted(ef_id, flags, options, event_flags)
N#endif
N
N/**
N  \brief  Event on unsuccessful wait for event flags (Op)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N  \param[in]  flags         flags to wait for.
N  \param[in]  options       flags options (osFlagsXxxx).
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_WAIT_NOT_COMPLETED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsWaitNotCompleted (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options);
N#else
S#define EvrRtxEventFlagsWaitNotCompleted(ef_id, flags, options)
N#endif
N
N/**
N  \brief  Event on event flags delete (API)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_DELETE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsDelete (osEventFlagsId_t ef_id);
N#else
S#define EvrRtxEventFlagsDelete(ef_id)
N#endif
N
N/**
N  \brief  Event on successful event flags delete (Op)
N  \param[in]  ef_id         event flags ID obtained by \ref osEventFlagsNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_DESTROYED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxEventFlagsDestroyed (osEventFlagsId_t ef_id);
N#else
S#define EvrRtxEventFlagsDestroyed(ef_id)
N#endif
N
N
N//  ==== Mutex Events ====
N
N/**
N  \brief  Event on mutex error (Error)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew or NULL when ID is unknown.
N  \param[in]  status    extended execution status.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ERROR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexError (osMutexId_t mutex_id, int32_t status);
N#else
S#define EvrRtxMutexError(mutex_id, status)
N#endif
N
N/**
N  \brief  Event on mutex create and initialize (API)
N  \param[in]  attr      mutex attributes.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_NEW_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexNew (const osMutexAttr_t *attr);
N#else
S#define EvrRtxMutexNew(attr)
N#endif
N
N/**
N  \brief  Event on successful mutex create (Op)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N  \param[in]  name      pointer to mutex object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_CREATED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexCreated (osMutexId_t mutex_id, const char *name);
N#else
S#define EvrRtxMutexCreated(mutex_id, name)
N#endif
N
N/**
N  \brief  Event on mutex name retrieve (API)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N  \param[in]  name      pointer to mutex object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_GET_NAME_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexGetName (osMutexId_t mutex_id, const char *name);
N#else
S#define EvrRtxMutexGetName(mutex_id, name)
N#endif
N
N/**
N  \brief  Event on mutex acquire (API)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N  \param[in]  timeout   \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexAcquire (osMutexId_t mutex_id, uint32_t timeout);
N#else
S#define EvrRtxMutexAcquire(mutex_id, timeout)
N#endif
N
N/**
N  \brief  Event on pending mutex acquire (Op)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N  \param[in]  timeout   \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRE_PENDING_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexAcquirePending (osMutexId_t mutex_id, uint32_t timeout);
N#else
S#define EvrRtxMutexAcquirePending(mutex_id, timeout)
N#endif
N
N/**
N  \brief  Event on mutex acquire timeout (Op)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRE_TIMEOUT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexAcquireTimeout (osMutexId_t mutex_id);
N#else
S#define EvrRtxMutexAcquireTimeout(mutex_id)
N#endif
N
N/**
N  \brief  Event on successful mutex acquire (Op)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N  \param[in]  lock      current number of times mutex object is locked.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexAcquired (osMutexId_t mutex_id, uint32_t lock);
N#else
S#define EvrRtxMutexAcquired(mutex_id, lock)
N#endif
N
N/**
N  \brief  Event on unsuccessful mutex acquire (Op)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_NOT_ACQUIRED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexNotAcquired (osMutexId_t mutex_id);
N#else
S#define EvrRtxMutexNotAcquired(mutex_id)
N#endif
N
N/**
N  \brief  Event on mutex release (API)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_RELEASE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexRelease (osMutexId_t mutex_id);
N#else
S#define EvrRtxMutexRelease(mutex_id)
N#endif
N
N/**
N  \brief  Event on successful mutex release (Op)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N  \param[in]  lock      current number of times mutex object is locked.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_RELEASED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexReleased (osMutexId_t mutex_id, uint32_t lock);
N#else
S#define EvrRtxMutexReleased(mutex_id, lock)
N#endif
N
N/**
N  \brief  Event on mutex owner retrieve (API)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N  \param[in]  thread_id thread ID obtained by \ref osThreadNew or \ref osThreadGetId.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_GET_OWNER_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexGetOwner (osMutexId_t mutex_id, osThreadId_t thread_id);
N#else
S#define EvrRtxMutexGetOwner(mutex_id, thread_id)
N#endif
N
N/**
N  \brief  Event on mutex delete (API)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_DELETE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexDelete (osMutexId_t mutex_id);
N#else
S#define EvrRtxMutexDelete(mutex_id)
N#endif
N
N/**
N  \brief  Event on successful mutex delete (Op)
N  \param[in]  mutex_id  mutex ID obtained by \ref osMutexNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_DESTROYED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMutexDestroyed (osMutexId_t mutex_id);
N#else
S#define EvrRtxMutexDestroyed(mutex_id)
N#endif
N
N
N//  ==== Semaphore Events ====
N
N/**
N  \brief  Event on semaphore error (Error)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew or NULL when ID is unknown.
N  \param[in]  status        extended execution status.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_ERROR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreError (osSemaphoreId_t semaphore_id, int32_t status);
N#else
S#define EvrRtxSemaphoreError(semaphore_id, status)
N#endif
N
N/**
N  \brief  Event on semaphore create and initialize (API)
N  \param[in]  max_count     maximum number of available tokens.
N  \param[in]  initial_count initial number of available tokens.
N  \param[in]  attr          semaphore attributes.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_NEW_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr);
N#else
S#define EvrRtxSemaphoreNew(max_count, initial_count, attr)
N#endif
N
N/**
N  \brief  Event on successful semaphore create (Op)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N  \param[in]  name          pointer to semaphore object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_CREATED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreCreated (osSemaphoreId_t semaphore_id, const char *name);
N#else
S#define EvrRtxSemaphoreCreated(semaphore_id, name)
N#endif
N
N/**
N  \brief  Event on semaphore name retrieve (API)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N  \param[in]  name          pointer to semaphore object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_GET_NAME_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreGetName (osSemaphoreId_t semaphore_id, const char *name);
N#else
S#define EvrRtxSemaphoreGetName(semaphore_id, name)
N#endif
N
N/**
N  \brief  Event on semaphore acquire (API)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_ACQUIRE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout);
N#else
S#define EvrRtxSemaphoreAcquire(semaphore_id, timeout)
N#endif
N
N/**
N  \brief  Event on pending semaphore acquire (Op)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_ACQUIRE_PENDING_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreAcquirePending (osSemaphoreId_t semaphore_id, uint32_t timeout);
N#else
S#define EvrRtxSemaphoreAcquirePending(semaphore_id, timeout)
N#endif
N
N/**
N  \brief  Event on semaphore acquire timeout (Op)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_ACQUIRE_TIMEOUT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreAcquireTimeout (osSemaphoreId_t semaphore_id);
N#else
S#define EvrRtxSemaphoreAcquireTimeout(semaphore_id)
N#endif
N
N/**
N  \brief  Event on successful semaphore acquire (Op)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N  \param[in]  tokens        number of available tokens.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_ACQUIRED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreAcquired (osSemaphoreId_t semaphore_id, uint32_t tokens);
N#else
S#define EvrRtxSemaphoreAcquired(semaphore_id, tokens)
N#endif
N
N/**
N  \brief  Event on unsuccessful semaphore acquire (Op)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_NOT_ACQUIRED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreNotAcquired (osSemaphoreId_t semaphore_id);
N#else
S#define EvrRtxSemaphoreNotAcquired(semaphore_id)
N#endif
N
N/**
N  \brief  Event on semaphore release (API)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_RELEASE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreRelease (osSemaphoreId_t semaphore_id);
N#else
S#define EvrRtxSemaphoreRelease(semaphore_id)
N#endif
N
N/**
N  \brief  Event on successful semaphore release (Op)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N  \param[in]  tokens        number of available tokens.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_RELEASED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreReleased (osSemaphoreId_t semaphore_id, uint32_t tokens);
N#else
S#define EvrRtxSemaphoreReleased(semaphore_id, tokens)
N#endif
N
N/**
N  \brief  Event on semaphore token count retrieval (API)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N  \param[in]  count         current number of available tokens.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_GET_COUNT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreGetCount (osSemaphoreId_t semaphore_id, uint32_t count);
N#else
S#define EvrRtxSemaphoreGetCount(semaphore_id, count)
N#endif
N
N/**
N  \brief  Event on semaphore delete (API)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_DELETE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreDelete (osSemaphoreId_t semaphore_id);
N#else
S#define EvrRtxSemaphoreDelete(semaphore_id)
N#endif
N
N/**
N  \brief  Event on successful semaphore delete (Op)
N  \param[in]  semaphore_id  semaphore ID obtained by \ref osSemaphoreNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_DESTROYED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxSemaphoreDestroyed (osSemaphoreId_t semaphore_id);
N#else
S#define EvrRtxSemaphoreDestroyed(semaphore_id)
N#endif
N
N
N//  ==== Memory Pool Events ====
N
N/**
N  \brief  Event on memory pool error (Error)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew or NULL when ID is unknown.
N  \param[in]  status        extended execution status.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_ERROR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolError (osMemoryPoolId_t mp_id, int32_t status);
N#else
S#define EvrRtxMemoryPoolError(mp_id, status)
N#endif
N
N/**
N  \brief  Event on memory pool create and initialize (API)
N  \param[in]  block_count   maximum number of memory blocks in memory pool.
N  \param[in]  block_size    memory block size in bytes.
N  \param[in]  attr          memory pool attributes; NULL: default values.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_NEW_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr);
N#else
S#define EvrRtxMemoryPoolNew(block_count, block_size, attr)
N#endif
N
N/**
N  \brief  Event on successful memory pool create (Op)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  name          pointer to memory pool object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_CREATED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolCreated (osMemoryPoolId_t mp_id, const char *name);
N#else
S#define EvrRtxMemoryPoolCreated(mp_id, name)
N#endif
N
N/**
N  \brief  Event on memory pool name retrieve (API)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  name          pointer to memory pool object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_GET_NAME_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolGetName (osMemoryPoolId_t mp_id, const char *name);
N#else
S#define EvrRtxMemoryPoolGetName(mp_id, name)
N#endif
N
N/**
N  \brief  Event on memory pool allocation (API)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_ALLOC_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout);
N#else
S#define EvrRtxMemoryPoolAlloc(mp_id, timeout)
N#endif
N
N/**
N  \brief  Event on pending memory pool allocation (Op)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_ALLOC_PENDING_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolAllocPending (osMemoryPoolId_t mp_id, uint32_t timeout);
N#else
S#define EvrRtxMemoryPoolAllocPending(mp_id, timeout)
N#endif
N
N/**
N  \brief  Event on memory pool allocation timeout (Op)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_ALLOC_TIMEOUT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolAllocTimeout (osMemoryPoolId_t mp_id);
N#else
S#define EvrRtxMemoryPoolAllocTimeout(mp_id)
N#endif
N
N/**
N  \brief  Event on successful memory pool allocation (Op)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  block         address of the allocated memory block.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_ALLOCATED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolAllocated (osMemoryPoolId_t mp_id, void *block);
N#else
S#define EvrRtxMemoryPoolAllocated(mp_id, block)
N#endif
N
N/**
N  \brief  Event on unsuccessful memory pool allocation (Op)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_ALLOC_FAILED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolAllocFailed (osMemoryPoolId_t mp_id);
N#else
S#define EvrRtxMemoryPoolAllocFailed(mp_id)
N#endif
N
N/**
N  \brief  Event on memory pool free (API)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  block         address of the allocated memory block to be returned to the memory pool.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_FREE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolFree (osMemoryPoolId_t mp_id, void *block);
N#else
S#define EvrRtxMemoryPoolFree(mp_id, block)
N#endif
N
N/**
N  \brief  Event on successful memory pool free (Op)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  block         address of the allocated memory block to be returned to the memory pool.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_DEALLOCATED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolDeallocated (osMemoryPoolId_t mp_id, void *block);
N#else
S#define EvrRtxMemoryPoolDeallocated(mp_id, block)
N#endif
N
N/**
N  \brief  Event on unsuccessful memory pool free (Op)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  block         address of the allocated memory block to be returned to the memory pool.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_FREE_FAILED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolFreeFailed (osMemoryPoolId_t mp_id, void *block);
N#else
S#define EvrRtxMemoryPoolFreeFailed(mp_id, block)
N#endif
N
N/**
N  \brief  Event on memory pool capacity retrieve (API)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  capacity      maximum number of memory blocks.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_GET_CAPACITY_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolGetCapacity (osMemoryPoolId_t mp_id, uint32_t capacity);
N#else
S#define EvrRtxMemoryPoolGetCapacity(mp_id, capacity)
N#endif
N
N/**
N  \brief  Event on memory pool block size retrieve (API)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  block_size    memory block size in bytes.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_GET_BLOCK_SZIE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id, uint32_t block_size);
N#else
S#define EvrRtxMemoryPoolGetBlockSize(mp_id, block_size)
N#endif
N
N/**
N  \brief  Event on used memory pool blocks retrieve (API)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  count         number of memory blocks used.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_GET_COUNT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolGetCount (osMemoryPoolId_t mp_id, uint32_t count);
N#else
S#define EvrRtxMemoryPoolGetCount(mp_id, count)
N#endif
N
N/**
N  \brief  Event on available memory pool blocks retrieve (API)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N  \param[in]  space         number of memory blocks available.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_GET_SPACE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolGetSpace (osMemoryPoolId_t mp_id, uint32_t space);
N#else
S#define EvrRtxMemoryPoolGetSpace(mp_id, space)
N#endif
N
N/**
N  \brief  Event on memory pool delete (API)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_DELETE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolDelete (osMemoryPoolId_t mp_id);
N#else
S#define EvrRtxMemoryPoolDelete(mp_id)
N#endif
N
N/**
N  \brief  Event on successful memory pool delete (Op)
N  \param[in]  mp_id         memory pool ID obtained by \ref osMemoryPoolNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_DESTROYED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMemoryPoolDestroyed (osMemoryPoolId_t mp_id);
N#else
S#define EvrRtxMemoryPoolDestroyed(mp_id)
N#endif
N
N
N//  ==== Message Queue Events ====
N
N/**
N  \brief  Event on message queue error (Error)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew or NULL when ID is unknown.
N  \param[in]  status        extended execution status.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_ERROR_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueError (osMessageQueueId_t mq_id, int32_t status);
N#else
S#define EvrRtxMessageQueueError(mq_id, status)
N#endif
N
N/**
N  \brief  Event on message queue create and initialization (API)
N  \param[in]  msg_count     maximum number of messages in queue.
N  \param[in]  msg_size      maximum message size in bytes.
N  \param[in]  attr          message queue attributes; NULL: default values.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_NEW_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr);
N#else
S#define EvrRtxMessageQueueNew(msg_count, msg_size, attr)
N#endif
N
N/**
N  \brief  Event on successful message queue create (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  name          pointer to message queue object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_CREATED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueCreated (osMessageQueueId_t mq_id, const char *name);
N#else
S#define EvrRtxMessageQueueCreated(mq_id, name)
N#endif
N
N/**
N  \brief  Event on message queue name retrieve(API)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  name          pointer to message queue object name.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_NAME_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueGetName (osMessageQueueId_t mq_id, const char *name);
N#else
S#define EvrRtxMessageQueueGetName(mq_id, name)
N#endif
N
N/**
N  \brief  Event on message put (API)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  msg_ptr       pointer to buffer with message to put into a queue.
N  \param[in]  msg_prio      message priority.
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_PUT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout);
N#else
S#define EvrRtxMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout)
N#endif
N
N/**
N  \brief  Event on pending message put (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  msg_ptr       pointer to buffer with message to put into a queue.
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_PUT_PENDING_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueuePutPending (osMessageQueueId_t mq_id, const void *msg_ptr, uint32_t timeout);
N#else
S#define EvrRtxMessageQueuePutPending(mq_id, msg_ptr, timeout)
N#endif
N
N/**
N  \brief  Event on message put timeout (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_PUT_TIMEOUT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueuePutTimeout (osMessageQueueId_t mq_id);
N#else
S#define EvrRtxMessageQueuePutTimeout(mq_id)
N#endif
N
N/**
N  \brief  Event on pending message insert (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  msg_ptr       pointer to buffer with message to put into a queue.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_INSERT_PENDING_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueInsertPending (osMessageQueueId_t mq_id, const void *msg_ptr);
N#else
S#define EvrRtxMessageQueueInsertPending(mq_id, msg_ptr)
N#endif
N
N/**
N  \brief  Event on successful message insert (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  msg_ptr       pointer to buffer with message to put into a queue.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_INSERTED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueInserted (osMessageQueueId_t mq_id, const void *msg_ptr);
N#else
S#define EvrRtxMessageQueueInserted(mq_id, msg_ptr)
N#endif
N
N/**
N  \brief  Event on unsuccessful message insert (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  msg_ptr       pointer to buffer with message to put into a queue.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_NOT_INSERTED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueNotInserted (osMessageQueueId_t mq_id, const void *msg_ptr);
N#else
S#define EvrRtxMessageQueueNotInserted(mq_id, msg_ptr)
N#endif
N
N/**
N  \brief  Event on message get (API)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  msg_ptr       pointer to buffer for message to get from a queue.
N  \param[in]  msg_prio      message priority.
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout);
N#else
S#define EvrRtxMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout)
N#endif
N
N/**
N  \brief  Event on pending message get (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  msg_ptr       pointer to buffer for message to get from a queue.
N  \param[in]  timeout       \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_PENDING_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueGetPending (osMessageQueueId_t mq_id, void *msg_ptr, uint32_t timeout);
N#else
S#define EvrRtxMessageQueueGetPending(mq_id, msg_ptr, timeout)
N#endif
N
N/**
N  \brief  Event on message get timeout (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_TIMEOUT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueGetTimeout (osMessageQueueId_t mq_id);
N#else
S#define EvrRtxMessageQueueGetTimeout(mq_id)
N#endif
N
N/**
N  \brief  Event on successful message get (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  msg_ptr       pointer to buffer for message to get from a queue.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_RETRIEVED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueRetrieved (osMessageQueueId_t mq_id, void *msg_ptr);
N#else
S#define EvrRtxMessageQueueRetrieved(mq_id, msg_ptr)
N#endif
N
N/**
N  \brief  Event on unsuccessful message get (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  msg_ptr       pointer to buffer for message to get from a queue.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_NOT_RETRIEVED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueNotRetrieved (osMessageQueueId_t mq_id, void *msg_ptr);
N#else
S#define EvrRtxMessageQueueNotRetrieved(mq_id, msg_ptr)
N#endif
N
N/**
N  \brief  Event on message queue capacity retrieve (API)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  capacity      maximum number of messages.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_CAPACITY_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueGetCapacity (osMessageQueueId_t mq_id, uint32_t capacity);
N#else
S#define EvrRtxMessageQueueGetCapacity(mq_id, capacity)
N#endif
N
N/**
N  \brief  Event on message queue message size retrieve (API)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  msg_size      maximum message size in bytes.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_MSG_SIZE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueGetMsgSize (osMessageQueueId_t mq_id, uint32_t msg_size);
N#else
S#define EvrRtxMessageQueueGetMsgSize(mq_id, msg_size)
N#endif
N
N/**
N  \brief  Event on message queue message count retrieve (API)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  count         number of queued messages.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_COUNT_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueGetCount (osMessageQueueId_t mq_id, uint32_t count);
N#else
S#define EvrRtxMessageQueueGetCount(mq_id, count)
N#endif
N
N/**
N  \brief  Event on message queue message slots retrieve (API)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N  \param[in]  space         number of available slots for messages.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_SPACE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueGetSpace (osMessageQueueId_t mq_id, uint32_t space);
N#else
S#define EvrRtxMessageQueueGetSpace(mq_id, space)
N#endif
N
N/**
N  \brief  Event on message queue reset (API)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_RESET_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueReset (osMessageQueueId_t mq_id);
N#else
S#define EvrRtxMessageQueueReset(mq_id)
N#endif
N
N/**
N  \brief  Event on successful message queue reset (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_RESET_DONE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueResetDone (osMessageQueueId_t mq_id);
N#else
S#define EvrRtxMessageQueueResetDone(mq_id)
N#endif
N
N/**
N  \brief  Event on message queue delete (API)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_DELETE_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueDelete (osMessageQueueId_t mq_id);
N#else
S#define EvrRtxMessageQueueDelete(mq_id)
N#endif
N
N/**
N  \brief  Event on successful message queue delete (Op)
N  \param[in]  mq_id         message queue ID obtained by \ref osMessageQueueNew.
N*/
N#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_DESTROYED_DISABLE))
X#if (!0L && (1 != 0) && !0L)
Nextern void EvrRtxMessageQueueDestroyed (osMessageQueueId_t mq_id);
N#else
S#define EvrRtxMessageQueueDestroyed(mq_id)
N#endif
N
N
N#endif  // RTX_EVR_H_
L 39 "F:/Users/fu/AppData/Local/Arm/Packs/ARM/CMSIS/5.9.0/CMSIS/RTOS2/RTX/Source/rtx_lib.c" 2
N
N
N// System Configuration
N// ====================
N
N// Dynamic Memory
N#if (OS_DYNAMIC_MEM_SIZE != 0)
X#if (4096 != 0)
N#if ((OS_DYNAMIC_MEM_SIZE % 8) != 0)
X#if ((4096 % 8) != 0)
S#error "Invalid Dynamic Memory size!"
N#endif
Nstatic uint64_t os_mem[OS_DYNAMIC_MEM_SIZE/8] \
N__attribute__((section(".bss.os")));
Xstatic uint64_t os_mem[4096/8] __attribute__((section(".bss.os")));
N#endif
N
N// Kernel Tick Frequency
N#if (OS_TICK_FREQ < 1)
X#if (1000 < 1)
S#error "Invalid Kernel Tick Frequency!"
N#endif
N
N// ISR FIFO Queue
N#if (OS_ISR_FIFO_QUEUE < 4)
X#if (16 < 4)
S#error "Invalid ISR FIFO Queue size!"
N#endif
Nstatic void *os_isr_queue[OS_ISR_FIFO_QUEUE] \
N__attribute__((section(".bss.os")));
Xstatic void *os_isr_queue[16] __attribute__((section(".bss.os")));
N
N
N// Thread Configuration
N// ====================
N
N#if (((OS_STACK_SIZE % 8) != 0) || (OS_STACK_SIZE < 72))
X#if (((256 % 8) != 0) || (256 < 72))
S#error "Invalid default Thread Stack size!"
N#endif
N
N#if (((OS_IDLE_THREAD_STACK_SIZE % 8) != 0) || (OS_IDLE_THREAD_STACK_SIZE < 72))
X#if (((256 % 8) != 0) || (256 < 72))
S#error "Invalid Idle Thread Stack size!"
N#endif
N
N
N#if (OS_THREAD_OBJ_MEM != 0)
X#if (1 != 0)
N
N#if (OS_THREAD_NUM == 0)
X#if (16 == 0)
S#error "Invalid number of user Threads!"
N#endif
N
N#if ((OS_THREAD_USER_STACK_SIZE != 0) && ((OS_THREAD_USER_STACK_SIZE % 8) != 0))
X#if ((15360 != 0) && ((15360 % 8) != 0))
S#error "Invalid total Stack size!"
N#endif
N
N// Thread Control Blocks
Nstatic osRtxThread_t os_thread_cb[OS_THREAD_NUM] \
N__attribute__((section(".bss.os.thread.cb")));
Xstatic osRtxThread_t os_thread_cb[16] __attribute__((section(".bss.os.thread.cb")));
N
N// Thread Default Stack
N#if (OS_THREAD_DEF_STACK_NUM != 0)
X#if (0 != 0)
Sstatic uint64_t os_thread_def_stack[(OS_THREAD_DEF_STACK_NUM*OS_STACK_SIZE)/8] \
S__attribute__((section(".bss.os.thread.stack")));
Xstatic uint64_t os_thread_def_stack[(OS_THREAD_DEF_STACK_NUM*OS_STACK_SIZE)/8] __attribute__((section(".bss.os.thread.stack")));
N#endif
N
N// Memory Pool for Thread Control Blocks
Nstatic osRtxMpInfo_t os_mpi_thread \
N__attribute__((section(".data.os.thread.mpi"))) =
Xstatic osRtxMpInfo_t os_mpi_thread __attribute__((section(".data.os.thread.mpi"))) =
N{ (uint32_t)OS_THREAD_NUM, 0U, (uint32_t)osRtxThreadCbSize, &os_thread_cb[0], NULL, NULL };
X{ (uint32_t)16, 0U, (uint32_t)sizeof(osRtxThread_t), &os_thread_cb[0], 0, 0 };
N
N// Memory Pool for Thread Default Stack
N#if (OS_THREAD_DEF_STACK_NUM != 0)
X#if (0 != 0)
Sstatic osRtxMpInfo_t os_mpi_def_stack \
S__attribute__((section(".data.os.thread.mpi"))) =
Xstatic osRtxMpInfo_t os_mpi_def_stack __attribute__((section(".data.os.thread.mpi"))) =
S{ (uint32_t)OS_THREAD_DEF_STACK_NUM, 0U, (uint32_t)OS_STACK_SIZE, &os_thread_def_stack[0], NULL, NULL };
N#endif
N
N// Memory Pool for Thread Stack
N#if (OS_THREAD_USER_STACK_SIZE != 0)
X#if (15360 != 0)
Nstatic uint64_t os_thread_stack[(16 + (8*OS_THREAD_NUM) + OS_THREAD_USER_STACK_SIZE)/8] \
N__attribute__((section(".bss.os.thread.stack")));
Xstatic uint64_t os_thread_stack[(16 + (8*16) + 15360)/8] __attribute__((section(".bss.os.thread.stack")));
N#endif
N
N#endif  // (OS_THREAD_OBJ_MEM != 0)
N
N
N// Idle Thread Control Block
Nstatic osRtxThread_t os_idle_thread_cb \
N__attribute__((section(".bss.os.thread.cb")));
Xstatic osRtxThread_t os_idle_thread_cb __attribute__((section(".bss.os.thread.cb")));
N
N// Idle Thread Stack
Nstatic uint64_t os_idle_thread_stack[OS_IDLE_THREAD_STACK_SIZE/8] \
N__attribute__((section(".bss.os.thread.idle.stack")));
Xstatic uint64_t os_idle_thread_stack[256/8] __attribute__((section(".bss.os.thread.idle.stack")));
N
N// Idle Thread Attributes
Nstatic const osThreadAttr_t os_idle_thread_attr = {
N#if defined(OS_IDLE_THREAD_NAME)
X#if 0L
S  OS_IDLE_THREAD_NAME,
N#else
N  NULL,
X  0,
N#endif
N  osThreadDetached,
X  0x00000000U,
N  &os_idle_thread_cb,
N  (uint32_t)sizeof(os_idle_thread_cb),
N  &os_idle_thread_stack[0],
N  (uint32_t)sizeof(os_idle_thread_stack),
N  osPriorityIdle,
N#if defined(OS_IDLE_THREAD_TZ_MOD_ID)
X#if 1L
N  (uint32_t)OS_IDLE_THREAD_TZ_MOD_ID,
X  (uint32_t)0,
N#else
S  0U,
N#endif
N  0U
N};
N
N
N// Timer Configuration
N// ===================
N
N#if (OS_TIMER_OBJ_MEM != 0)
X#if (0 != 0)
S
S#if (OS_TIMER_NUM == 0)
S#error "Invalid number of Timer objects!"
S#endif
S
S// Timer Control Blocks
Sstatic osRtxTimer_t os_timer_cb[OS_TIMER_NUM] \
S__attribute__((section(".bss.os.timer.cb")));
Xstatic osRtxTimer_t os_timer_cb[OS_TIMER_NUM] __attribute__((section(".bss.os.timer.cb")));
S
S// Memory Pool for Timer Control Blocks
Sstatic osRtxMpInfo_t os_mpi_timer \
S__attribute__((section(".data.os.timer.mpi"))) =
Xstatic osRtxMpInfo_t os_mpi_timer __attribute__((section(".data.os.timer.mpi"))) =
S{ (uint32_t)OS_TIMER_NUM, 0U, (uint32_t)osRtxTimerCbSize, &os_timer_cb[0], NULL, NULL };
S
N#endif  // (OS_TIMER_OBJ_MEM != 0)
N
N
N#if ((OS_TIMER_THREAD_STACK_SIZE != 0) && (OS_TIMER_CB_QUEUE != 0))
X#if ((1024 != 0) && (4 != 0))
N
N#if (((OS_TIMER_THREAD_STACK_SIZE % 8) != 0) || (OS_TIMER_THREAD_STACK_SIZE < 96))
X#if (((1024 % 8) != 0) || (1024 < 96))
S#error "Invalid Timer Thread Stack size!"
N#endif
N
N// Timer Thread Control Block
Nstatic osRtxThread_t os_timer_thread_cb \
N__attribute__((section(".bss.os.thread.cb")));
Xstatic osRtxThread_t os_timer_thread_cb __attribute__((section(".bss.os.thread.cb")));
N
N// Timer Thread Stack
Nstatic uint64_t os_timer_thread_stack[OS_TIMER_THREAD_STACK_SIZE/8] \
N__attribute__((section(".bss.os.thread.timer.stack")));
Xstatic uint64_t os_timer_thread_stack[1024/8] __attribute__((section(".bss.os.thread.timer.stack")));
N
N// Timer Thread Attributes
Nstatic const osThreadAttr_t os_timer_thread_attr = {
N#if defined(OS_TIMER_THREAD_NAME)
X#if 0L
S  OS_TIMER_THREAD_NAME,
N#else
N  NULL,
X  0,
N#endif
N  osThreadDetached,
X  0x00000000U,
N  &os_timer_thread_cb,
N  (uint32_t)sizeof(os_timer_thread_cb),
N  &os_timer_thread_stack[0],
N  (uint32_t)sizeof(os_timer_thread_stack),
N  //lint -e{9030} -e{9034} "cast from signed to enum"
N  (osPriority_t)OS_TIMER_THREAD_PRIO,
X  (osPriority_t)24,
N#if defined(OS_TIMER_THREAD_TZ_MOD_ID)
X#if 1L
N  (uint32_t)OS_TIMER_THREAD_TZ_MOD_ID,
X  (uint32_t)0,
N#else
S  0U,
N#endif
N  0U
N};
N
N// Timer Message Queue Control Block
Nstatic osRtxMessageQueue_t os_timer_mq_cb \
N__attribute__((section(".bss.os.msgqueue.cb")));
Xstatic osRtxMessageQueue_t os_timer_mq_cb __attribute__((section(".bss.os.msgqueue.cb")));
N
N// Timer Message Queue Data
Nstatic uint32_t os_timer_mq_data[osRtxMessageQueueMemSize(OS_TIMER_CB_QUEUE,8)/4] \
N__attribute__((section(".bss.os.msgqueue.mem")));
Xstatic uint32_t os_timer_mq_data[(4*(4)*(3+(((8)+3)/4)))/4] __attribute__((section(".bss.os.msgqueue.mem")));
N
N// Timer Message Queue Attributes
Nstatic const osMessageQueueAttr_t os_timer_mq_attr = {
N  NULL,
X  0,
N  0U,
N  &os_timer_mq_cb,
N  (uint32_t)sizeof(os_timer_mq_cb),
N  &os_timer_mq_data[0],
N  (uint32_t)sizeof(os_timer_mq_data)
N};
N
Nextern int32_t osRtxTimerSetup  (void);
Nextern void    osRtxTimerThread (void *argument);
N
N#endif  // ((OS_TIMER_THREAD_STACK_SIZE != 0) && (OS_TIMER_CB_QUEUE != 0))
N
N
N// Event Flags Configuration
N// =========================
N
N#if (OS_EVFLAGS_OBJ_MEM != 0)
X#if (0 != 0)
S
S#if (OS_EVFLAGS_NUM == 0)
S#error "Invalid number of Event Flags objects!"
S#endif
S
S// Event Flags Control Blocks
Sstatic osRtxEventFlags_t os_ef_cb[OS_EVFLAGS_NUM] \
S__attribute__((section(".bss.os.evflags.cb")));
Xstatic osRtxEventFlags_t os_ef_cb[OS_EVFLAGS_NUM] __attribute__((section(".bss.os.evflags.cb")));
S
S// Memory Pool for Event Flags Control Blocks
Sstatic osRtxMpInfo_t os_mpi_ef \
S__attribute__((section(".data.os.evflags.mpi"))) =
Xstatic osRtxMpInfo_t os_mpi_ef __attribute__((section(".data.os.evflags.mpi"))) =
S{ (uint32_t)OS_EVFLAGS_NUM, 0U, (uint32_t)osRtxEventFlagsCbSize, &os_ef_cb[0], NULL, NULL };
S
N#endif  // (OS_EVFLAGS_OBJ_MEM != 0)
N
N
N// Mutex Configuration
N// ===================
N
N#if (OS_MUTEX_OBJ_MEM != 0)
X#if (0 != 0)
S
S#if (OS_MUTEX_NUM == 0)
S#error "Invalid number of Mutex objects!"
S#endif
S
S// Mutex Control Blocks
Sstatic osRtxMutex_t os_mutex_cb[OS_MUTEX_NUM] \
S__attribute__((section(".bss.os.mutex.cb")));
Xstatic osRtxMutex_t os_mutex_cb[OS_MUTEX_NUM] __attribute__((section(".bss.os.mutex.cb")));
S
S// Memory Pool for Mutex Control Blocks
Sstatic osRtxMpInfo_t os_mpi_mutex \
S__attribute__((section(".data.os.mutex.mpi"))) =
Xstatic osRtxMpInfo_t os_mpi_mutex __attribute__((section(".data.os.mutex.mpi"))) =
S{ (uint32_t)OS_MUTEX_NUM, 0U, (uint32_t)osRtxMutexCbSize, &os_mutex_cb[0], NULL, NULL };
S
N#endif  // (OS_MUTEX_OBJ_MEM != 0)
N
N
N// Semaphore Configuration
N// =======================
N
N#if (OS_SEMAPHORE_OBJ_MEM != 0)
X#if (0 != 0)
S
S#if (OS_SEMAPHORE_NUM == 0)
S#error "Invalid number of Semaphore objects!"
S#endif
S
S// Semaphore Control Blocks
Sstatic osRtxSemaphore_t os_semaphore_cb[OS_SEMAPHORE_NUM] \
S__attribute__((section(".bss.os.semaphore.cb")));
Xstatic osRtxSemaphore_t os_semaphore_cb[OS_SEMAPHORE_NUM] __attribute__((section(".bss.os.semaphore.cb")));
S
S// Memory Pool for Semaphore Control Blocks
Sstatic osRtxMpInfo_t os_mpi_semaphore \
S__attribute__((section(".data.os.semaphore.mpi"))) =
Xstatic osRtxMpInfo_t os_mpi_semaphore __attribute__((section(".data.os.semaphore.mpi"))) =
S{ (uint32_t)OS_SEMAPHORE_NUM, 0U, (uint32_t)osRtxSemaphoreCbSize, &os_semaphore_cb[0], NULL, NULL };
S
N#endif  // (OS_SEMAPHORE_OBJ_MEM != 0)
N
N
N// Memory Pool Configuration
N// =========================
N
N#if (OS_MEMPOOL_OBJ_MEM != 0)
X#if (0 != 0)
S
S#if (OS_MEMPOOL_NUM == 0)
S#error "Invalid number of Memory Pool objects!"
S#endif
S
S// Memory Pool Control Blocks
Sstatic osRtxMemoryPool_t os_mp_cb[OS_MEMPOOL_NUM] \
S__attribute__((section(".bss.os.mempool.cb")));
Xstatic osRtxMemoryPool_t os_mp_cb[OS_MEMPOOL_NUM] __attribute__((section(".bss.os.mempool.cb")));
S
S// Memory Pool for Memory Pool Control Blocks
Sstatic osRtxMpInfo_t os_mpi_mp \
S__attribute__((section(".data.os.mempool.mpi"))) =
Xstatic osRtxMpInfo_t os_mpi_mp __attribute__((section(".data.os.mempool.mpi"))) =
S{ (uint32_t)OS_MEMPOOL_NUM, 0U, (uint32_t)osRtxMemoryPoolCbSize, &os_mp_cb[0], NULL, NULL };
S
S// Memory Pool for Memory Pool Data Storage
S#if (OS_MEMPOOL_DATA_SIZE != 0)
S#if ((OS_MEMPOOL_DATA_SIZE % 8) != 0)
S#error "Invalid Data Memory size for Memory Pools!"
S#endif
Sstatic uint64_t os_mp_data[(16 + (8*OS_MEMPOOL_NUM) + OS_MEMPOOL_DATA_SIZE)/8] \
S__attribute__((section(".bss.os.mempool.mem")));
Xstatic uint64_t os_mp_data[(16 + (8*OS_MEMPOOL_NUM) + OS_MEMPOOL_DATA_SIZE)/8] __attribute__((section(".bss.os.mempool.mem")));
S#endif
S
N#endif  // (OS_MEMPOOL_OBJ_MEM != 0)
N
N
N// Message Queue Configuration
N// ===========================
N
N#if (OS_MSGQUEUE_OBJ_MEM != 0)
X#if (0 != 0)
S
S#if (OS_MSGQUEUE_NUM == 0)
S#error "Invalid number of Message Queue objects!"
S#endif
S
S// Message Queue Control Blocks
Sstatic osRtxMessageQueue_t os_mq_cb[OS_MSGQUEUE_NUM] \
S__attribute__((section(".bss.os.msgqueue.cb")));
Xstatic osRtxMessageQueue_t os_mq_cb[OS_MSGQUEUE_NUM] __attribute__((section(".bss.os.msgqueue.cb")));
S
S// Memory Pool for Message Queue Control Blocks
Sstatic osRtxMpInfo_t os_mpi_mq \
S__attribute__((section(".data.os.msgqueue.mpi"))) =
Xstatic osRtxMpInfo_t os_mpi_mq __attribute__((section(".data.os.msgqueue.mpi"))) =
S{ (uint32_t)OS_MSGQUEUE_NUM, 0U, (uint32_t)osRtxMessageQueueCbSize, &os_mq_cb[0], NULL, NULL };
S
S// Memory Pool for Message Queue Data Storage
S#if (OS_MSGQUEUE_DATA_SIZE != 0)
S#if ((OS_MSGQUEUE_DATA_SIZE % 8) != 0)
S#error "Invalid Data Memory size for Message Queues!"
S#endif
Sstatic uint64_t os_mq_data[(16 + ((8+12)*OS_MSGQUEUE_NUM) + OS_MSGQUEUE_DATA_SIZE + 7)/8] \
S__attribute__((section(".bss.os.msgqueue.mem")));
Xstatic uint64_t os_mq_data[(16 + ((8+12)*OS_MSGQUEUE_NUM) + OS_MSGQUEUE_DATA_SIZE + 7)/8] __attribute__((section(".bss.os.msgqueue.mem")));
S#endif
S
N#endif  // (OS_MSGQUEUE_OBJ_MEM != 0)
N
N
N// Event Recorder Configuration
N// ============================
N
N#if (defined(OS_EVR_INIT) && (OS_EVR_INIT != 0))
X#if (1L && (0 != 0))
S
S#ifdef RTE_Compiler_EventRecorder
S
S// Event Recorder Initialize
S__STATIC_INLINE void evr_initialize (void) {
S
S  (void)EventRecorderInitialize(OS_EVR_LEVEL, (uint32_t)OS_EVR_START);
S
S#if ((OS_EVR_MEMORY_LEVEL & 0x80U) != 0U)
S  (void)EventRecorderEnable(  OS_EVR_MEMORY_LEVEL & 0x0FU,    EvtRtxMemoryNo,       EvtRtxMemoryNo);
S  (void)EventRecorderDisable(~OS_EVR_MEMORY_LEVEL & 0x0FU,    EvtRtxMemoryNo,       EvtRtxMemoryNo);
S#endif
S#if ((OS_EVR_KERNEL_LEVEL & 0x80U) != 0U)
S  (void)EventRecorderEnable(  OS_EVR_KERNEL_LEVEL & 0x0FU,    EvtRtxKernelNo,       EvtRtxKernelNo);
S  (void)EventRecorderDisable(~OS_EVR_KERNEL_LEVEL & 0x0FU,    EvtRtxKernelNo,       EvtRtxMemoryNo);
S#endif
S#if ((OS_EVR_THREAD_LEVEL & 0x80U) != 0U)
S  (void)EventRecorderEnable(  OS_EVR_THREAD_LEVEL & 0x0FU,    EvtRtxThreadNo,       EvtRtxThreadNo);
S  (void)EventRecorderDisable(~OS_EVR_THREAD_LEVEL & 0x0FU,    EvtRtxThreadNo,       EvtRtxThreadNo);
S#endif
S#if ((OS_EVR_WAIT_LEVEL & 0x80U) != 0U)
S  (void)EventRecorderEnable(  OS_EVR_WAIT_LEVEL & 0x0FU,      EvtRtxWaitNo,         EvtRtxWaitNo);
S  (void)EventRecorderDisable(~OS_EVR_WAIT_LEVEL & 0x0FU,      EvtRtxWaitNo,         EvtRtxWaitNo);
S#endif
S#if ((OS_EVR_THFLAGS_LEVEL & 0x80U) != 0U)
S  (void)EventRecorderEnable(  OS_EVR_THFLAGS_LEVEL & 0x0FU,   EvtRtxThreadFlagsNo,  EvtRtxThreadFlagsNo);
S  (void)EventRecorderDisable(~OS_EVR_THFLAGS_LEVEL & 0x0FU,   EvtRtxThreadFlagsNo,  EvtRtxThreadFlagsNo);
S#endif
S#if ((OS_EVR_EVFLAGS_LEVEL & 0x80U) != 0U)
S  (void)EventRecorderEnable(  OS_EVR_EVFLAGS_LEVEL & 0x0FU,   EvtRtxEventFlagsNo,   EvtRtxEventFlagsNo);
S  (void)EventRecorderDisable(~OS_EVR_EVFLAGS_LEVEL & 0x0FU,   EvtRtxEventFlagsNo,   EvtRtxEventFlagsNo);
S#endif
S#if ((OS_EVR_TIMER_LEVEL & 0x80U) != 0U)
S  (void)EventRecorderEnable(  OS_EVR_TIMER_LEVEL & 0x0FU,     EvtRtxTimerNo,        EvtRtxTimerNo);
S  (void)EventRecorderDisable(~OS_EVR_TIMER_LEVEL & 0x0FU,     EvtRtxTimerNo,        EvtRtxTimerNo);
S#endif
S#if ((OS_EVR_MUTEX_LEVEL & 0x80U) != 0U)
S  (void)EventRecorderEnable(  OS_EVR_MUTEX_LEVEL & 0x0FU,     EvtRtxMutexNo,        EvtRtxMutexNo);
S  (void)EventRecorderDisable(~OS_EVR_MUTEX_LEVEL & 0x0FU,     EvtRtxMutexNo,        EvtRtxMutexNo);
S#endif
S#if ((OS_EVR_SEMAPHORE_LEVEL & 0x80U) != 0U)
S  (void)EventRecorderEnable(  OS_EVR_SEMAPHORE_LEVEL & 0x0FU, EvtRtxSemaphoreNo,    EvtRtxSemaphoreNo);
S  (void)EventRecorderDisable(~OS_EVR_SEMAPHORE_LEVEL & 0x0FU, EvtRtxSemaphoreNo,    EvtRtxSemaphoreNo);
S#endif
S#if ((OS_EVR_MEMPOOL_LEVEL & 0x80U) != 0U)
S  (void)EventRecorderEnable(  OS_EVR_MEMPOOL_LEVEL & 0x0FU,   EvtRtxMemoryPoolNo,   EvtRtxMemoryPoolNo);
S  (void)EventRecorderDisable(~OS_EVR_MEMPOOL_LEVEL & 0x0FU,   EvtRtxMemoryPoolNo,   EvtRtxMemoryPoolNo);
S#endif
S#if ((OS_EVR_MSGQUEUE_LEVEL & 0x80U) != 0U)
S  (void)EventRecorderEnable(  OS_EVR_MSGQUEUE_LEVEL & 0x0FU,  EvtRtxMessageQueueNo, EvtRtxMessageQueueNo);
S  (void)EventRecorderDisable(~OS_EVR_MSGQUEUE_LEVEL & 0x0FU,  EvtRtxMessageQueueNo, EvtRtxMessageQueueNo);
S#endif
S}
S
S#else
S#warning "Event Recorder cannot be initialized (Event Recorder component is not selected)!"
S#define evr_initialize()
S#endif
S
N#endif  // (OS_EVR_INIT != 0)
N
N
N// OS Configuration
N// ================
N
N
Nconst osRtxConfig_t osRtxConfig \
N__USED \
N__attribute__((section(".rodata"))) =
Xconst osRtxConfig_t osRtxConfig __attribute__((used)) __attribute__((section(".rodata"))) =
N{
N  //lint -e{835} "Zero argument to operator"
N  0U   // Flags
N#if (OS_PRIVILEGE_MODE != 0)
X#if (1 != 0)
N  | osRtxConfigPrivilegedMode
X  | (1UL<<0)
N#endif
N#if (OS_STACK_CHECK != 0)
X#if (1 != 0)
N  | osRtxConfigStackCheck
X  | (1UL<<1)
N#endif
N#if (OS_STACK_WATERMARK != 0)
X#if (0 != 0)
S  | osRtxConfigStackWatermark
N#endif
N  ,
N  (uint32_t)OS_TICK_FREQ,
X  (uint32_t)1000,
N#if (OS_ROBIN_ENABLE != 0)
X#if (1 != 0)
N  (uint32_t)OS_ROBIN_TIMEOUT,
X  (uint32_t)5,
N#else
S  0U,
N#endif
N  { &os_isr_queue[0], (uint16_t)(sizeof(os_isr_queue)/sizeof(void *)), 0U },
N  { 
N    // Memory Pools (Variable Block Size)
N#if ((OS_THREAD_OBJ_MEM != 0) && (OS_THREAD_USER_STACK_SIZE != 0))
X#if ((1 != 0) && (15360 != 0))
N    &os_thread_stack[0], sizeof(os_thread_stack),
N#else
S    NULL, 0U,
N#endif
N#if ((OS_MEMPOOL_OBJ_MEM != 0) && (OS_MEMPOOL_DATA_SIZE != 0))
X#if ((0 != 0) && (0 != 0))
S    &os_mp_data[0], sizeof(os_mp_data),
N#else
N    NULL, 0U,
X    0, 0U,
N#endif
N#if ((OS_MSGQUEUE_OBJ_MEM != 0) && (OS_MSGQUEUE_DATA_SIZE != 0))
X#if ((0 != 0) && (0 != 0))
S    &os_mq_data[0], sizeof(os_mq_data),
N#else
N    NULL, 0U,
X    0, 0U,
N#endif
N#if (OS_DYNAMIC_MEM_SIZE != 0)
X#if (4096 != 0)
N    &os_mem[0], (uint32_t)OS_DYNAMIC_MEM_SIZE,
X    &os_mem[0], (uint32_t)4096,
N#else
S    NULL, 0U
N#endif
N  },
N  {
N    // Memory Pools (Fixed Block Size)
N#if (OS_THREAD_OBJ_MEM != 0)
X#if (1 != 0)
N#if (OS_THREAD_DEF_STACK_NUM != 0)
X#if (0 != 0)
S    &os_mpi_def_stack,
N#else
N    NULL,
X    0,
N#endif
N    &os_mpi_thread,
N#else
S    NULL, 
S    NULL,
N#endif
N#if (OS_TIMER_OBJ_MEM != 0)
X#if (0 != 0)
S    &os_mpi_timer,
N#else
N    NULL,
X    0,
N#endif
N#if (OS_EVFLAGS_OBJ_MEM != 0)
X#if (0 != 0)
S    &os_mpi_ef,
N#else
N    NULL,
X    0,
N#endif
N#if (OS_MUTEX_OBJ_MEM != 0)
X#if (0 != 0)
S    &os_mpi_mutex,
N#else
N    NULL,
X    0,
N#endif
N#if (OS_SEMAPHORE_OBJ_MEM != 0)
X#if (0 != 0)
S    &os_mpi_semaphore,
N#else
N    NULL,
X    0,
N#endif
N#if (OS_MEMPOOL_OBJ_MEM != 0)
X#if (0 != 0)
S    &os_mpi_mp,
N#else
N    NULL,
X    0,
N#endif
N#if (OS_MSGQUEUE_OBJ_MEM != 0)
X#if (0 != 0)
S    &os_mpi_mq,
N#else
N    NULL,
X    0,
N#endif
N  },
N  (uint32_t)OS_STACK_SIZE,
X  (uint32_t)256,
N  &os_idle_thread_attr,
N#if ((OS_TIMER_THREAD_STACK_SIZE != 0) && (OS_TIMER_CB_QUEUE != 0))
X#if ((1024 != 0) && (4 != 0))
N  &os_timer_thread_attr,
N  osRtxTimerThread,
N  osRtxTimerSetup,
N  &os_timer_mq_attr,
N  (uint32_t)OS_TIMER_CB_QUEUE
X  (uint32_t)4
N#else
S  NULL,
S  NULL,
S  NULL,
S  NULL,
S  0U
N#endif
N};
N
N
N// Non weak reference to library irq module
N//lint -esym(526,irqRtxLib)    "Defined by Exception handlers"
N//lint -esym(714,irqRtxLibRef) "Non weak reference"
N//lint -esym(765,irqRtxLibRef) "Global scope"
Nextern const uint8_t         irqRtxLib;
Nextern const uint8_t * const irqRtxLibRef;
N       const uint8_t * const irqRtxLibRef = &irqRtxLib;
N
N// Default User SVC Table
N//lint -esym(714,osRtxUserSVC) "Referenced by Exception handlers"
N//lint -esym(765,osRtxUserSVC) "Global scope"
N//lint -e{9067} "extern array declared without size"
Nextern void * const osRtxUserSVC[];
N__WEAK void * const osRtxUserSVC[1] = { (void *)0 };
X__attribute__((weak)) void * const osRtxUserSVC[1] = { (void *)0 };
N
N
N// OS Sections
N// ===========
N
N#if  defined(__CC_ARM) || \
N    (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
X#if  1L ||     (1L && (5060750 >= 6010050))
N// Initialized through linker
N//lint -esym(728,  __os_thread_cb_start__,    __os_thread_cb_end__)
N//lint -esym(728,  __os_timer_cb_start__,     __os_timer_cb_end__)
N//lint -esym(728,  __os_evflags_cb_start__,   __os_evflags_cb_end__)
N//lint -esym(728,  __os_mutex_cb_start__,     __os_mutex_cb_end__)
N//lint -esym(728,  __os_semaphore_cb_start__, __os_semaphore_cb_end__)
N//lint -esym(728,  __os_mempool_cb_start__,   __os_mempool_cb_end__)
N//lint -esym(728,  __os_msgqueue_cb_start__,  __os_msgqueue_cb_end__)
Nstatic const uint32_t __os_thread_cb_start__    __attribute__((weakref(".bss.os.thread.cb$$Base")));
Nstatic const uint32_t __os_thread_cb_end__      __attribute__((weakref(".bss.os.thread.cb$$Limit")));
Nstatic const uint32_t __os_timer_cb_start__     __attribute__((weakref(".bss.os.timer.cb$$Base")));
Nstatic const uint32_t __os_timer_cb_end__       __attribute__((weakref(".bss.os.timer.cb$$Limit")));
Nstatic const uint32_t __os_evflags_cb_start__   __attribute__((weakref(".bss.os.evflags.cb$$Base")));
Nstatic const uint32_t __os_evflags_cb_end__     __attribute__((weakref(".bss.os.evflags.cb$$Limit")));
Nstatic const uint32_t __os_mutex_cb_start__     __attribute__((weakref(".bss.os.mutex.cb$$Base")));
Nstatic const uint32_t __os_mutex_cb_end__       __attribute__((weakref(".bss.os.mutex.cb$$Limit")));
Nstatic const uint32_t __os_semaphore_cb_start__ __attribute__((weakref(".bss.os.semaphore.cb$$Base")));
Nstatic const uint32_t __os_semaphore_cb_end__   __attribute__((weakref(".bss.os.semaphore.cb$$Limit")));
Nstatic const uint32_t __os_mempool_cb_start__   __attribute__((weakref(".bss.os.mempool.cb$$Base")));
Nstatic const uint32_t __os_mempool_cb_end__     __attribute__((weakref(".bss.os.mempool.cb$$Limit")));
Nstatic const uint32_t __os_msgqueue_cb_start__  __attribute__((weakref(".bss.os.msgqueue.cb$$Base")));
Nstatic const uint32_t __os_msgqueue_cb_end__    __attribute__((weakref(".bss.os.msgqueue.cb$$Limit")));
N#else
Sextern const uint32_t __os_thread_cb_start__    __attribute__((weak));
Sextern const uint32_t __os_thread_cb_end__      __attribute__((weak));
Sextern const uint32_t __os_timer_cb_start__     __attribute__((weak));
Sextern const uint32_t __os_timer_cb_end__       __attribute__((weak));
Sextern const uint32_t __os_evflags_cb_start__   __attribute__((weak));
Sextern const uint32_t __os_evflags_cb_end__     __attribute__((weak));
Sextern const uint32_t __os_mutex_cb_start__     __attribute__((weak));
Sextern const uint32_t __os_mutex_cb_end__       __attribute__((weak));
Sextern const uint32_t __os_semaphore_cb_start__ __attribute__((weak));
Sextern const uint32_t __os_semaphore_cb_end__   __attribute__((weak));
Sextern const uint32_t __os_mempool_cb_start__   __attribute__((weak));
Sextern const uint32_t __os_mempool_cb_end__     __attribute__((weak));
Sextern const uint32_t __os_msgqueue_cb_start__  __attribute__((weak));
Sextern const uint32_t __os_msgqueue_cb_end__    __attribute__((weak));
N#endif
N
N//lint -e{9067} "extern array declared without size"
Nextern const uint32_t * const os_cb_sections[];
N
N//lint -esym(714,os_cb_sections) "Referenced by debugger"
N//lint -esym(765,os_cb_sections) "Global scope"
Nconst uint32_t * const os_cb_sections[] \
N__USED \
N__attribute__((section(".rodata"))) =
Xconst uint32_t * const os_cb_sections[] __attribute__((used)) __attribute__((section(".rodata"))) =
N{
N  &__os_thread_cb_start__,
N  &__os_thread_cb_end__,
N  &__os_timer_cb_start__,
N  &__os_timer_cb_end__,
N  &__os_evflags_cb_start__,
N  &__os_evflags_cb_end__,
N  &__os_mutex_cb_start__,
N  &__os_mutex_cb_end__,
N  &__os_semaphore_cb_start__,
N  &__os_semaphore_cb_end__,
N  &__os_mempool_cb_start__,
N  &__os_mempool_cb_end__,
N  &__os_msgqueue_cb_start__,
N  &__os_msgqueue_cb_end__
N};
N
N
N// OS Initialization
N// =================
N
N#if  defined(__CC_ARM) || \
N    (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
X#if  1L ||     (1L && (5060750 >= 6010050))
N
N#ifndef __MICROLIB
S//lint -esym(714,_platform_post_stackheap_init) "Referenced by C library"
S//lint -esym(765,_platform_post_stackheap_init) "Global scope"
Sextern void _platform_post_stackheap_init (void);
S__WEAK void _platform_post_stackheap_init (void) {
S  (void)osKernelInitialize();
S}
N#endif
N
N#elif defined(__GNUC__)
X#elif 1L
S
Sextern void software_init_hook (void);
S__WEAK void software_init_hook (void) {
S  (void)osKernelInitialize();
S}
S
S#elif defined(__ICCARM__)
S
Sextern void $Super$$__iar_data_init3 (void);
Svoid $Sub$$__iar_data_init3 (void) {
S  $Super$$__iar_data_init3();
S  (void)osKernelInitialize();
S}
S
N#endif
N
N
N// OS Hooks
N// ========
N
N// RTOS Kernel Pre-Initialization Hook
N#if (defined(OS_EVR_INIT) && (OS_EVR_INIT != 0))
X#if (1L && (0 != 0))
Svoid osRtxKernelPreInit (void);
Svoid osRtxKernelPreInit (void) {
S  if (osKernelGetState() == osKernelInactive) {
S    evr_initialize();
S  }
S}
N#endif
N
N
N// C/C++ Standard Library Floating-point Initialization
N// ====================================================
N
N#if ( !defined(RTX_NO_FP_INIT_CLIB) && \
N     ( defined(__CC_ARM) || \
N      (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))) && \
N      !defined(__MICROLIB))
X#if ( !0L &&      ( 1L ||       (1L && (5060750 >= 6010050))) &&       !1L)
S
S#if  ((defined(__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S      (defined(__FPU_USED   ) && (__FPU_USED    == 1U)))
X#if  ((defined(__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&       (defined(__FPU_USED   ) && (__FPU_USED    == 1U)))
S
Sextern void $Super$$_fp_init (void);
S
Svoid $Sub$$_fp_init (void);
Svoid $Sub$$_fp_init (void) {
S  $Super$$_fp_init();
S  FPU->FPDSCR = __get_FPSCR();
S}
S
S#endif
S
N#endif
N
N
N// C/C++ Standard Library Multithreading Interface
N// ===============================================
N
N#if ( !defined(RTX_NO_MULTITHREAD_CLIB) && \
N     ( defined(__CC_ARM) || \
N      (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))) && \
N      !defined(__MICROLIB))
X#if ( !0L &&      ( 1L ||       (1L && (5060750 >= 6010050))) &&       !1L)
S
S#define LIBSPACE_SIZE 96
S
S//lint -esym(714,__user_perthread_libspace,_mutex_*) "Referenced by C library"
S//lint -esym(765,__user_perthread_libspace,_mutex_*) "Global scope"
S//lint -esym(9003, os_libspace*) "variables 'os_libspace*' defined at module scope"
S
S// Memory for libspace
Sstatic uint32_t os_libspace[OS_THREAD_LIBSPACE_NUM+1][LIBSPACE_SIZE/4] \
S__attribute__((section(".bss.os.libspace")));
Xstatic uint32_t os_libspace[OS_THREAD_LIBSPACE_NUM+1][LIBSPACE_SIZE/4] __attribute__((section(".bss.os.libspace")));
S
S// Thread IDs for libspace
Sstatic osThreadId_t os_libspace_id[OS_THREAD_LIBSPACE_NUM] \
S__attribute__((section(".bss.os.libspace")));
Xstatic osThreadId_t os_libspace_id[OS_THREAD_LIBSPACE_NUM] __attribute__((section(".bss.os.libspace")));
S
S// Check if Kernel has been started
Sstatic uint32_t os_kernel_is_active (void) {
S  static uint8_t os_kernel_active = 0U;
S
S  if (os_kernel_active == 0U) {
S    if (osKernelGetState() > osKernelReady) {
S      os_kernel_active = 1U;
S    }
S  }
S  return (uint32_t)os_kernel_active;
S}
S
S// Provide libspace for current thread
Svoid *__user_perthread_libspace (void);
Svoid *__user_perthread_libspace (void) {
S  osThreadId_t id;
S  uint32_t     n;
S
S  if (os_kernel_is_active() != 0U) {
S    id = osThreadGetId();
S    for (n = 0U; n < (uint32_t)OS_THREAD_LIBSPACE_NUM; n++) {
S      if (os_libspace_id[n] == NULL) {
S        os_libspace_id[n] = id;
S      }
S      if (os_libspace_id[n] == id) {
S        break;
S      }
S    }
S    if (n == (uint32_t)OS_THREAD_LIBSPACE_NUM) {
S      (void)osRtxKernelErrorNotify(osRtxErrorClibSpace, id);
S    }
S  } else {
S    n = OS_THREAD_LIBSPACE_NUM;
S  }
S
S  //lint -e{9087} "cast between pointers to different object types"
S  return (void *)&os_libspace[n][0];
S}
S
S// Mutex identifier
Stypedef void *mutex;
S
S//lint -save "Function prototypes defined in C library"
S//lint -e970 "Use of 'int' outside of a typedef"
S//lint -e818 "Pointer 'm' could be declared as pointing to const"
S
S// Initialize mutex
S__USED
Sint _mutex_initialize(mutex *m);
Sint _mutex_initialize(mutex *m) {
S  int result;
S
S  *m = osMutexNew(NULL);
S  if (*m != NULL) {
S    result = 1;
S  } else {
S    result = 0;
S    (void)osRtxKernelErrorNotify(osRtxErrorClibMutex, m);
S  }
S  return result;
S}
S
S// Acquire mutex
S__USED
Svoid _mutex_acquire(mutex *m);
Svoid _mutex_acquire(mutex *m) {
S  if (os_kernel_is_active() != 0U) {
S    (void)osMutexAcquire(*m, osWaitForever);
S  }
S}
S
S// Release mutex
S__USED
Svoid _mutex_release(mutex *m);
Svoid _mutex_release(mutex *m) {
S  if (os_kernel_is_active() != 0U) {
S    (void)osMutexRelease(*m);
S  }
S}
S
S// Free mutex
S__USED
Svoid _mutex_free(mutex *m);
Svoid _mutex_free(mutex *m) {
S  (void)osMutexDelete(*m);
S}
S
S//lint -restore
S
N#endif
