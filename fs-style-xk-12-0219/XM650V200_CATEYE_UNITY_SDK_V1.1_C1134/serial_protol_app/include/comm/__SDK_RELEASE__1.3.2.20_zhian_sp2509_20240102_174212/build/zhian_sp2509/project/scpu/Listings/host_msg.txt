; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\host_msg.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\host_msg.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\host_msg.crf ..\..\..\..\scpu\middleware\comm\host_msg.c]
                          THUMB

                          AREA ||i.gen_crc16||, CODE, READONLY, ALIGN=1

                  gen_crc16 PROC
;;;44     
;;;45     u16 gen_crc16(u8 *data, u32 size)
000000  b5f0              PUSH     {r4-r7,lr}
;;;46     {
;;;47         u16 out = 0;
000002  2200              MOVS     r2,#0
;;;48         int bits_read = 0, bit_flag, i;
000004  4613              MOV      r3,r2
;;;49     
;;;50         /* Sanity check: */
;;;51         if (data == NULL)
;;;52             return 0;
;;;53     
;;;54         while (size > 0) {
;;;55             bit_flag = out >> 15;
;;;56     
;;;57             /* Get next bit: */
;;;58             out <<= 1;
000006  f64f74ff          MOV      r4,#0xffff
;;;59             out |= (*data >> bits_read) & 1; // item a) work from the least significant bits
;;;60     
;;;61                                              /* Increment bit counter: */
;;;62             bits_read++;
;;;63             if (bits_read > 7)
;;;64             {
;;;65                 bits_read = 0;
;;;66                 data++;
;;;67                 size--;
;;;68             }
;;;69     
;;;70             /* Cycle check: */
;;;71             if (bit_flag)
;;;72                 out ^= CRC16_CONSTANT;
00000a  f2480505          MOV      r5,#0x8005
00000e  2800              CMP      r0,#0                 ;46
000010  d027              BEQ      |L1.98|
000012  e00f              B        |L1.52|
                  |L1.20|
000014  0bd6              LSRS     r6,r2,#15             ;55
000016  ea040742          AND      r7,r4,r2,LSL #1       ;58
00001a  7802              LDRB     r2,[r0,#0]            ;59
00001c  40da              LSRS     r2,r2,r3              ;59
00001e  f0020201          AND      r2,r2,#1              ;59
000022  433a              ORRS     r2,r2,r7              ;59
000024  1c5b              ADDS     r3,r3,#1              ;59
000026  2b07              CMP      r3,#7                 ;63
000028  dd02              BLE      |L1.48|
00002a  2300              MOVS     r3,#0                 ;65
00002c  1c40              ADDS     r0,r0,#1              ;65
00002e  1e49              SUBS     r1,r1,#1              ;65
                  |L1.48|
000030  b106              CBZ      r6,|L1.52|
000032  406a              EORS     r2,r2,r5
                  |L1.52|
000034  2900              CMP      r1,#0                 ;54
000036  d1ed              BNE      |L1.20|
;;;73     
;;;74         }
;;;75     
;;;76         // push out the last 16 bits
;;;77         for (i = 0; i < 16; ++i) {
000038  2000              MOVS     r0,#0
                  |L1.58|
;;;78             bit_flag = out >> 15;
00003a  0bd1              LSRS     r1,r2,#15
;;;79             out <<= 1;
00003c  ea040242          AND      r2,r4,r2,LSL #1
;;;80             if (bit_flag)
000040  d000              BEQ      |L1.68|
;;;81                 out ^= CRC16_CONSTANT;
000042  406a              EORS     r2,r2,r5
                  |L1.68|
000044  1c40              ADDS     r0,r0,#1
000046  2810              CMP      r0,#0x10              ;77
000048  dbf7              BLT      |L1.58|
;;;82         }
;;;83     
;;;84         // reverse the bits
;;;85         u16 crc = 0;
00004a  2000              MOVS     r0,#0
;;;86         i = 0x8000;
00004c  f44f4100          MOV      r1,#0x8000
;;;87         int j = 0x0001;
000050  2301              MOVS     r3,#1
                  |L1.82|
;;;88         for (; i != 0; i >>= 1, j <<= 1) {
;;;89             if (i & out) crc |= j;
000052  4211              TST      r1,r2
000054  d001              BEQ      |L1.90|
000056  4318              ORRS     r0,r0,r3
000058  b280              UXTH     r0,r0
                  |L1.90|
00005a  1049              ASRS     r1,r1,#1              ;88
00005c  ea4f0343          LSL      r3,r3,#1              ;88
000060  d1f7              BNE      |L1.82|
                  |L1.98|
;;;90         }
;;;91     
;;;92         return crc;
;;;93     }
000062  bdf0              POP      {r4-r7,pc}
;;;94     
                          ENDP


                          AREA ||i.kcomm_msg_init||, CODE, READONLY, ALIGN=1

                  kcomm_msg_init PROC
;;;117    
;;;118    void kcomm_msg_init(osThreadId_t tid_comm)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120    #if ( USB_HOST == YES )
;;;121        usb_set_notify_flag(tid_comm, FLAG_COMM_RX_DONE);
000002  2110              MOVS     r1,#0x10
000004  f7fffffe          BL       usb_set_notify_flag
;;;122        usb_init();
000008  e8bd4010          POP      {r4,lr}
00000c  f7ffbffe          B.W      usb_init
;;;123    #else
;;;124        kdp_uart_com_init();
;;;125    #endif
;;;126    }
;;;127    
                          ENDP


                          AREA ||i.kcomm_read||, CODE, READONLY, ALIGN=2

                  kcomm_read PROC
;;;203    
;;;204    int32_t kcomm_read(u32 address, u32 size)
000000  b570              PUSH     {r4-r6,lr}
;;;205    {
000002  000c              MOVS     r4,r1
000004  4605              MOV      r5,r0
000006  d002              BEQ      |L3.14|
;;;206    #if ( USB_HOST == YES )
;;;207        if(size == 0 || size >= 1024*1024) return -1; //if wrong length
000008  f5b41f80          CMP      r4,#0x100000
00000c  d302              BCC      |L3.20|
                  |L3.14|
00000e  f04f30ff          MOV      r0,#0xffffffff
;;;208    
;;;209        usb_com_write (ack_packet, 16, FLAG_COMM_RX_DONE, WMODE_ACK);
;;;210        return usb_com_read((u8*)address, size, FLAG_COMM_RX_DONE, 1);
;;;211    #else
;;;212        // NOTE: For uart, we also use msg_rx buffer for data receiving, thus destroying the command data that might
;;;213        //       be needed later.  So we must preserve it (save it in the msg_tx buffer) for restoration at the end.
;;;214        u32 block = size >> 12;
;;;215        u32 residual = size & 0x0FFF;
;;;216        u32 offset = 0;
;;;217    
;;;218        save_command();
;;;219    
;;;220        while (block) {
;;;221            kdp_uart_com_write(ack_packet, 16);
;;;222            kdp_uart_com_read((u8*) address + offset, 0x1000); // FLAG_COMM_UART_DONE);
;;;223            offset += 0x1000;
;;;224            block--;
;;;225        }
;;;226    
;;;227        if (residual) {
;;;228            kdp_uart_com_write(ack_packet, 16);
;;;229            kdp_uart_com_read((u8*) address + offset, residual); //, FLAG_COMM_UART_DONE);
;;;230        }
;;;231    
;;;232        restore_command();
;;;233    
;;;234        return size;
;;;235    #endif
;;;236    }
000012  bd70              POP      {r4-r6,pc}
                  |L3.20|
000014  2210              MOVS     r2,#0x10              ;209
000016  2301              MOVS     r3,#1                 ;209
000018  4611              MOV      r1,r2                 ;209
00001a  4805              LDR      r0,|L3.48|
00001c  f7fffffe          BL       usb_com_write
000020  4621              MOV      r1,r4                 ;210
000022  4628              MOV      r0,r5                 ;210
000024  e8bd4070          POP      {r4-r6,lr}            ;210
000028  2301              MOVS     r3,#1                 ;210
00002a  2210              MOVS     r2,#0x10              ;210
00002c  f7ffbffe          B.W      usb_com_read
;;;237    #endif
                          ENDP

                  |L3.48|
                          DCD      ||.data||+0x8

                          AREA ||i.kcomm_send_no_rsp||, CODE, READONLY, ALIGN=1

                  kcomm_send_no_rsp PROC
;;;110    
;;;111    void kcomm_send_no_rsp(void)
000000  f7ffbffe          B.W      usb_idle
;;;112    {
;;;113    #if ( USB_HOST == YES )
;;;114        usb_idle();
;;;115    #endif
;;;116    }
;;;117    
                          ENDP


                          AREA ||i.kcomm_send_rsp||, CODE, READONLY, ALIGN=2

                  kcomm_send_rsp PROC
;;;159     */
;;;160    void kcomm_send_rsp(u16 cmd, u8 *buf, int len)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
;;;162        if (len > 0) { // copy stuff beyond len and address
;;;163            memcpy((msg_tbuf + (sizeof(MsgHdr)+sizeof(RspPram))), buf, len);
000002  4d13              LDR      r5,|L5.80|
000004  1e14              SUBS     r4,r2,#0              ;161
000006  4606              MOV      r6,r0                 ;161
000008  dd03              BLE      |L5.18|
00000a  6868              LDR      r0,[r5,#4]  ; msg_tbuf
00000c  3010              ADDS     r0,r0,#0x10
00000e  f7fffffe          BL       __aeabi_memcpy
                  |L5.18|
000012  e9d50100          LDRD     r0,r1,[r5,#0]
;;;164        }
;;;165    
;;;166        MsgHdr *hdr = (MsgHdr*) msg_tbuf;
;;;167        CmdPram *args = (CmdPram*) (msg_rbuf + sizeof(MsgHdr));
;;;168        RspPram *rsp = (RspPram*) (msg_tbuf + sizeof(MsgHdr));
000016  3008              ADDS     r0,r0,#8
000018  f1010208          ADD      r2,r1,#8
;;;169    
;;;170        if (len >= 0) {
00001c  2c00              CMP      r4,#0
00001e  db0c              BLT      |L5.58|
;;;171            hdr->cmd = cmd | 0x8000;
000020  f4464300          ORR      r3,r6,#0x8000
000024  808b              STRH     r3,[r1,#4]
;;;172            hdr->msg_len = len + sizeof(RspPram);  // minimum msg payload include RspPram
000026  f1040308          ADD      r3,r4,#8
00002a  80cb              STRH     r3,[r1,#6]
;;;173            rsp->param1 = args->param1;
00002c  6801              LDR      r1,[r0,#0]
00002e  6011              STR      r1,[r2,#0]
;;;174            rsp->param2 = args->param2;
000030  6840              LDR      r0,[r0,#4]
000032  6050              STR      r0,[r2,#4]
;;;175            len += sizeof(MsgHdr)+sizeof(RspPram);
000034  f1040110          ADD      r1,r4,#0x10
000038  e003              B        |L5.66|
                  |L5.58|
;;;176        } else {
;;;177            hdr->cmd = cmd;
00003a  808e              STRH     r6,[r1,#4]
;;;178            hdr->msg_len = 0; // no message payload
00003c  2000              MOVS     r0,#0
00003e  80c8              STRH     r0,[r1,#6]
;;;179            len = sizeof(MsgHdr); // just send msg header
000040  2108              MOVS     r1,#8
                  |L5.66|
;;;180        }
;;;181    
;;;182        /* params won't be sent if len < 0 */
;;;183        dlog("resp: param1 [%u], param2 [%u], data len [%d]", args->param1, args->param2, len);
;;;184    
;;;185    #if ( USB_HOST == YES )
;;;186        kcomm_write_msg(msg_tbuf, len, 0);  // no crc
000042  6868              LDR      r0,[r5,#4]  ; msg_tbuf
000044  e8bd4070          POP      {r4-r6,lr}
000048  2200              MOVS     r2,#0
00004a  f7ffbffe          B.W      kcomm_write_msg
;;;187    #else
;;;188        kcomm_write_msg(msg_tbuf, len, 1);  // use crc
;;;189    #endif
;;;190    }
;;;191    
                          ENDP

00004e  0000              DCW      0x0000
                  |L5.80|
                          DCD      ||.data||

                          AREA ||i.kcomm_wait||, CODE, READONLY, ALIGN=2

                  kcomm_wait PROC
;;;191    
;;;192    void kcomm_wait(void)
000000  e92d4010          PUSH.W   {r4,lr}
                  |L6.4|
;;;193    {
;;;194    #if ( USB_HOST == YES )
;;;195        while (usb_get_mode() != 1)
000004  f7fffffe          BL       usb_get_mode
000008  2801              CMP      r0,#1
00000a  d1fb              BNE      |L6.4|
;;;196            ;  // wait till message is done
;;;197    #endif
;;;198    }
00000c  bd10              POP      {r4,pc}
;;;199    
                          ENDP


                          AREA ||i.kcomm_write||, CODE, READONLY, ALIGN=1

                  kcomm_write PROC
;;;99      */
;;;100    int kcomm_write(u8 *buf, int len, int mode)
000000  b510              PUSH     {r4,lr}
;;;101    {
;;;102    #if ( USB_HOST == YES )
;;;103        usb_com_write(buf, len, FLAG_COMM_RX_DONE, mode);  // use msg mode
000002  4613              MOV      r3,r2
000004  2210              MOVS     r2,#0x10
000006  f7fffffe          BL       usb_com_write
;;;104    #else
;;;105        kdp_uart_com_write(buf, len);
;;;106    #endif
;;;107    
;;;108        return 0;
00000a  2000              MOVS     r0,#0
;;;109    }
00000c  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.kcomm_write_msg||, CODE, READONLY, ALIGN=1

                  kcomm_write_msg PROC
;;;133     */
;;;134    int kcomm_write_msg(u8 *buf, int len, int crc_flag)
000000  b570              PUSH     {r4-r6,lr}
;;;135    {
000002  4605              MOV      r5,r0
;;;136        MsgHdr *msghdr;
;;;137        msghdr = (MsgHdr*) buf;
;;;138        msghdr->preamble = MSG_HDR_RSP;
000004  f6482035          MOV      r0,#0x8a35
000008  460c              MOV      r4,r1                 ;135
00000a  8028              STRH     r0,[r5,#0]
00000c  b152              CBZ      r2,|L8.36|
;;;139    
;;;140        if (crc_flag) {
;;;141            u32 *crc = (u32*)&buf[len];
00000e  4628              MOV      r0,r5
000010  192e              ADDS     r6,r5,r4
;;;142            *crc = gen_crc16(buf, len);
000012  4621              MOV      r1,r4
000014  f7fffffe          BL       gen_crc16
;;;143            msghdr->ctrl = len | PKT_CRC_FLAG; // packet + crc(4B) - pkt header (2B)
000018  6030              STR      r0,[r6,#0]
00001a  f4444080          ORR      r0,r4,#0x4000
00001e  8068              STRH     r0,[r5,#2]
000020  1d24              ADDS     r4,r4,#4
;;;144            len += 4; // adjust len to include crc
;;;145        } else {
000022  e001              B        |L8.40|
                  |L8.36|
;;;146            msghdr->ctrl = len - 4;
000024  1f20              SUBS     r0,r4,#4
000026  8068              STRH     r0,[r5,#2]
                  |L8.40|
;;;147        }
;;;148    
;;;149        kcomm_write(buf, len, WMODE_DEF);
000028  2200              MOVS     r2,#0
00002a  4621              MOV      r1,r4
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       kcomm_write
;;;150    
;;;151        return 0;
000032  2000              MOVS     r0,#0
;;;152    }
000034  bd70              POP      {r4-r6,pc}
;;;153    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  msg_rbuf
                          DCD      0x00000000
                  msg_tbuf
                          DCD      0x00000000
                  ack_packet
000008  358a0c00          DCB      0x35,0x8a,0x0c,0x00
00000c  04800800          DCB      0x04,0x80,0x08,0x00
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  00000000          DCB      0x00,0x00,0x00,0x00
000018  00000000          DCB      0x00,0x00,0x00,0x00
