; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ct130.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ct130.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\config -I..\..\..\..\board -I..\..\..\..\common\include -I..\..\..\..\scpu\device\include\CMSIS -I..\..\..\..\scpu\device\include\Kneron -I..\..\..\..\scpu\framework\include -I..\..\..\..\scpu\framework\include\framework -I..\..\..\..\scpu\drivers\include -I..\..\..\..\scpu\drivers\include\media\touch -I..\..\..\..\scpu\drivers\include\media\flash -I..\..\..\..\scpu\lib\kdp_system\inc -I..\..\..\..\scpu\lib\kdp_application\include\ -I..\..\..\..\scpu\lib\kdp_application\base\ -I..\..\..\..\scpu\lib\kdp_application\misc -I..\..\..\..\scpu\lib\kdp_e2e_r1n1\include -I..\..\..\..\scpu\include -I..\..\..\..\scpu\middleware\ota -I..\..\..\..\scpu\middleware\comm -I..\..\..\..\scpu\middleware\kdp_comm -I..\..\..\..\scpu\share -I..\..\..\..\scpu\share\gui_lib -I..\..\user -I.\RTE\CMSIS -I.\RTE\_Target-scpu -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\RTOS2\RTX\Include -IF:\Users\fu\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\Device\ARM\ARMCM4\Include -D__RTX -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DARMCM4_FP -D_RTE_ -DARM_MATH_CM4 -DTARGET_SCPU -DLOG_ENABLE -DKL520 -DHEAD_POSE_CHECK_PERCENT --omf_browse=.\objects\ct130.crf ..\..\..\..\scpu\drivers\media\touch\ct130.c]
                          THUMB

                          AREA ||i._ct130_get_active||, CODE, READONLY, ALIGN=2

                  _ct130_get_active PROC
;;;268    }
;;;269    int _ct130_get_active(void) {
000000  4802              LDR      r0,|L1.12|
;;;270        if (MOUSE_NONE == __pre_tp_state)
000002  7880              LDRB     r0,[r0,#2]  ; __pre_tp_state
000004  2800              CMP      r0,#0                 ;269
000006  d000              BEQ      |L1.10|
;;;271            return 0;
;;;272        else
;;;273            return 1;
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;274    }
00000a  4770              BX       lr
;;;275    
                          ENDP

                  |L1.12|
                          DCD      ||.data||

                          AREA ||i._ct130_get_info||, CODE, READONLY, ALIGN=1

                  _ct130_get_info PROC
;;;163    
;;;164    static u16 _ct130_get_info(struct core_device * core)
000000  b530              PUSH     {r4,r5,lr}
;;;165    {
000002  b087              SUB      sp,sp,#0x1c
;;;166        u8 dev_addr = 0x1A;
000004  251a              MOVS     r5,#0x1a
;;;167        u16 regAddr = 0;
;;;168        u8 buf1[20] = {0};
000006  2114              MOVS     r1,#0x14
000008  a802              ADD      r0,sp,#8
00000a  f7fffffe          BL       __aeabi_memclr4
;;;169        unsigned int chip_type;
;;;170        //unsigned int firmware_version, project_version, chip_type, checksum;
;;;171    
;;;172        //firmware_version=0;
;;;173        //project_version=0;
;;;174        chip_type=0;
;;;175        //checksum=0;
;;;176    
;;;177        regAddr = 0xD101;
;;;178        kdp_drv_i2c_write(I2C_ADAP_0, dev_addr, regAddr, 2, buf1[2]);
00000e  f89d000a          LDRB     r0,[sp,#0xa]
000012  9000              STR      r0,[sp,#0]
000014  f24d1201          MOV      r2,#0xd101            ;177
000018  2302              MOVS     r3,#2
00001a  4629              MOV      r1,r5
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       kdp_drv_i2c_write
;;;179    
;;;180        osDelay(10);
000022  200a              MOVS     r0,#0xa
000024  f7fffffe          BL       osDelay
;;;181    
;;;182        regAddr = 0xD204;
;;;183        kdp_drv_i2c_read_bytes(I2C_ADAP_0, dev_addr, regAddr, 2, buf1, 4);
000028  2104              MOVS     r1,#4
00002a  a802              ADD      r0,sp,#8
00002c  e9cd0100          STRD     r0,r1,[sp,#0]
000030  f24d2204          MOV      r2,#0xd204            ;182
000034  2302              MOVS     r3,#2
000036  4629              MOV      r1,r5
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       kdp_drv_i2c_read_bytes
;;;184    
;;;185        chip_type = buf1[3];
00003e  f89d000b          LDRB     r0,[sp,#0xb]
;;;186        chip_type <<= 8;
;;;187        chip_type |= buf1[2];
000042  f89d400a          LDRB     r4,[sp,#0xa]
000046  ea442400          ORR      r4,r4,r0,LSL #8
;;;188        
;;;189        osDelay(1);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       osDelay
;;;190    #if 0
;;;191        project_version |= buf1[1];
;;;192        project_version <<= 8;
;;;193        project_version |= buf1[0];
;;;194    
;;;195        regAddr = 0xD208;
;;;196        kdp_drv_i2c_read_bytes(I2C_ADAP_0, dev_addr, regAddr, 2, buf1, 4);
;;;197    
;;;198        firmware_version = buf1[3];
;;;199        firmware_version <<= 8;
;;;200        firmware_version |= buf1[2];
;;;201        firmware_version <<= 8;
;;;202        firmware_version |= buf1[1];
;;;203        firmware_version <<= 8;
;;;204        firmware_version |= buf1[0];
;;;205    
;;;206        regAddr = 0xD20C;
;;;207        kdp_drv_i2c_read_bytes(I2C_ADAP_0, dev_addr, regAddr, 2, buf1, 4);
;;;208    
;;;209        checksum = buf1[3];
;;;210        checksum <<= 8;
;;;211        checksum |= buf1[2];
;;;212        checksum <<= 8;
;;;213        checksum |= buf1[1];
;;;214        checksum <<= 8;
;;;215        checksum |= buf1[0];
;;;216    #endif
;;;217        //need to write reg 0xD109 back to touch_ic for making touch-ic be in normal status.
;;;218        regAddr = 0xD109;
;;;219        kdp_drv_i2c_write(I2C_ADAP_0, dev_addr, regAddr, 2, buf1[2]);
000050  f89d000a          LDRB     r0,[sp,#0xa]
000054  9000              STR      r0,[sp,#0]
000056  f24d1209          MOV      r2,#0xd109            ;218
00005a  2302              MOVS     r3,#2
00005c  4629              MOV      r1,r5
00005e  2000              MOVS     r0,#0
000060  f7fffffe          BL       kdp_drv_i2c_write
;;;220    
;;;221        if(chip_type == TOUCH_ID)
000064  2c82              CMP      r4,#0x82
000066  d003              BEQ      |L2.112|
;;;222            return chip_type;
;;;223        else 
;;;224            return 0xFFFF;
000068  f64f70ff          MOV      r0,#0xffff
                  |L2.108|
;;;225        
;;;226    }
00006c  b007              ADD      sp,sp,#0x1c
00006e  bd30              POP      {r4,r5,pc}
                  |L2.112|
000070  2082              MOVS     r0,#0x82              ;222
000072  e7fb              B        |L2.108|
;;;227    
                          ENDP


                          AREA ||i._ct130_get_raw_data||, CODE, READONLY, ALIGN=2

                  _ct130_get_raw_data PROC
;;;62     
;;;63     void _ct130_get_raw_data(struct core_device *core_d, u8 init_i2c)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;64     {
000004  b097              SUB      sp,sp,#0x5c
;;;65         u8 buf[30] = {0};
000006  2120              MOVS     r1,#0x20
000008  a808              ADD      r0,sp,#0x20
00000a  f7fffffe          BL       __aeabi_memclr4
;;;66         u8 i2c_buf[8] = {0};
00000e  2000              MOVS     r0,#0
;;;67         u8 cnt, i2c_len, idx, len_1=0, len_2=0;
;;;68         u16 i;
;;;69     
;;;70         //u8 finger_id;
;;;71         u32 input_x=0, input_y=0;
;;;72         u16 regAddr;
;;;73         int dev_addr = 0x1A;
;;;74     
;;;75         struct touch_driver *touch_drv = &kdp520_touch_driver;
000010  4e51              LDR      r6,|L3.344|
000012  9006              STR      r0,[sp,#0x18]         ;66
;;;76         struct touch_driver_ops *ops = (struct touch_driver_ops*)touch_drv->ctrller_ops;
000014  9007              STR      r0,[sp,#0x1c]
000016  6c30              LDR      r0,[r6,#0x40]
;;;77     
;;;78         //NVIC_DisableIRQ(GPIO_FTGPIO010_IRQ);
;;;79         ops->tp_gpio_set_int_stop();
000018  9012              STR      r0,[sp,#0x48]
00001a  f04f091a          MOV      r9,#0x1a              ;73
00001e  6800              LDR      r0,[r0,#0]
000020  4780              BLX      r0
;;;80     
;;;81         regAddr = 0xD000;
;;;82     
;;;83         kdp_drv_i2c_read_bytes(I2C_ADAP_0, dev_addr, regAddr, 2, buf, 7); //api style
000022  2107              MOVS     r1,#7
000024  a808              ADD      r0,sp,#0x20
000026  e9cd0100          STRD     r0,r1,[sp,#0]
00002a  f44f4250          MOV      r2,#0xd000            ;81
00002e  211a              MOVS     r1,#0x1a
000030  2302              MOVS     r3,#2
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       kdp_drv_i2c_read_bytes
;;;84     
;;;85     
;;;86         if (0xAB!=buf[6] || 0x80==buf[5])
000038  f89d1026          LDRB     r1,[sp,#0x26]
00003c  f04f0bab          MOV      r11,#0xab
000040  29ab              CMP      r1,#0xab
000042  d145              BNE      |L3.208|
000044  f89d0025          LDRB     r0,[sp,#0x25]
000048  2880              CMP      r0,#0x80
00004a  d041              BEQ      |L3.208|
;;;87             goto OUT_PROCESS;
;;;88     
;;;89         cnt = buf[5] & 0x7F;
00004c  f000047f          AND      r4,r0,#0x7f
;;;90         if (MAX_TOUCH_NUM<cnt || 0==cnt)
000050  2c05              CMP      r4,#5
000052  d83d              BHI      |L3.208|
000054  b3e4              CBZ      r4,|L3.208|
;;;91             goto OUT_PROCESS;
;;;92         if (1 == cnt)
000056  2c01              CMP      r4,#1
000058  d04b              BEQ      |L3.242|
;;;93             goto FINGER_PROCESS;
;;;94         else
;;;95         {
;;;96           i2c_len = (cnt-1)*5 + 1;
00005a  eb040084          ADD      r0,r4,r4,LSL #2
00005e  1f00              SUBS     r0,r0,#4
000060  f00008ff          AND      r8,r0,#0xff
;;;97           len_1   = i2c_len;
000064  46c2              MOV      r10,r8
;;;98     
;;;99         for(idx=0; idx<i2c_len; idx+=6)
000066  2500              MOVS     r5,#0
000068  e027              B        |L3.186|
;;;100        {
;;;101              regAddr = 0xD007+idx;
00006a  bf00              NOP      
                  |L3.108|
00006c  f24d0007          MOV      r0,#0xd007
000070  4428              ADD      r0,r0,r5
000072  b282              UXTH     r2,r0
;;;102          if(len_1>=6) {
000074  4650              MOV      r0,r10
000076  f1ba0f06          CMP      r10,#6
00007a  d303              BCC      |L3.132|
;;;103              len_2  = 6;
00007c  2706              MOVS     r7,#6
;;;104            len_1 -= 6;
00007e  1f80              SUBS     r0,r0,#6
000080  b2c0              UXTB     r0,r0
000082  e001              B        |L3.136|
                  |L3.132|
;;;105          }
;;;106          else {
;;;107            len_2 = len_1;
000084  4607              MOV      r7,r0
;;;108            len_1 = 0;
000086  2000              MOVS     r0,#0
                  |L3.136|
000088  4682              MOV      r10,r0
;;;109          }
;;;110    
;;;111          kdp_drv_i2c_read_bytes(I2C_ADAP_0, dev_addr, regAddr, 2, i2c_buf, len_2); //api style
00008a  a806              ADD      r0,sp,#0x18
00008c  e9cd0700          STRD     r0,r7,[sp,#0]
000090  4649              MOV      r1,r9
000092  2302              MOVS     r3,#2
000094  2000              MOVS     r0,#0
000096  f7fffffe          BL       kdp_drv_i2c_read_bytes
;;;112    			
;;;113              for(i=0; i<len_2; i++)
00009a  2000              MOVS     r0,#0
00009c  aa06              ADD      r2,sp,#0x18           ;66
00009e  a908              ADD      r1,sp,#0x20           ;65
0000a0  e007              B        |L3.178|
                  |L3.162|
;;;114                  buf[5+idx+i] = i2c_buf[i];
0000a2  eb050c00          ADD      r12,r5,r0
0000a6  5c13              LDRB     r3,[r2,r0]
0000a8  448c              ADD      r12,r12,r1
0000aa  1c40              ADDS     r0,r0,#1
0000ac  f88c3005          STRB     r3,[r12,#5]
0000b0  b280              UXTH     r0,r0                 ;113
                  |L3.178|
0000b2  42b8              CMP      r0,r7                 ;113
0000b4  d3f5              BCC      |L3.162|
0000b6  1dad              ADDS     r5,r5,#6              ;113
0000b8  b2ed              UXTB     r5,r5                 ;99
                  |L3.186|
0000ba  4545              CMP      r5,r8                 ;99
0000bc  d3d6              BCC      |L3.108|
;;;115        }
;;;116        i2c_len += 5;
0000be  f1080005          ADD      r0,r8,#5
0000c2  b2c0              UXTB     r0,r0
;;;117    
;;;118          if (buf[i2c_len - 1] != 0xAB)
0000c4  a908              ADD      r1,sp,#0x20
0000c6  4408              ADD      r0,r0,r1
0000c8  f8100c01          LDRB     r0,[r0,#-1]
0000cc  28ab              CMP      r0,#0xab
0000ce  d010              BEQ      |L3.242|
                  |L3.208|
;;;119              goto OUT_PROCESS;
;;;120        }
;;;121    
;;;122    FINGER_PROCESS:
;;;123        regAddr = 0xD000;
;;;124        i2c_buf[2] = 0xAB;
;;;125    
;;;126    
;;;127        kdp_drv_i2c_write(I2C_ADAP_0, dev_addr, regAddr, 2, i2c_buf[2]); //api style
;;;128    
;;;129    
;;;130        idx = 0;
;;;131        __touch_data.count = cnt;
;;;132        //dbg_msg_touch("touch cnt : %d.\n", cnt);
;;;133        for (i = 0; i < cnt; i++) {
;;;134            input_x = (unsigned int)((buf[idx + 1] << 4) | ((buf[idx + 3] >> 4) & 0x0F));
;;;135            input_y = (unsigned int)((buf[idx + 2] << 4) | (buf[idx + 3] & 0x0F));
;;;136            //finger_id = (buf[idx] >> 4) & 0x0F;
;;;137            //dbg_msg_touch("x : %d, y : %d, id : %d.\n", input_x, input_y, finger_id);
;;;138            idx += 5;
;;;139    
;;;140            if (touch_drv->inverse_x_axis)
;;;141                __touch_data.input_x[i] = touch_drv->x_range_max - input_x;
;;;142            else
;;;143                __touch_data.input_x[i] = input_x;
;;;144    
;;;145            if (touch_drv->inverse_y_axis)
;;;146                __touch_data.input_y[i] = touch_drv->y_range_max - input_y;
;;;147            else
;;;148                __touch_data.input_y[i] = input_y;
;;;149        }
;;;150        goto END;
;;;151    
;;;152    OUT_PROCESS:
;;;153        regAddr = 0xD000;
0000d0  f44f4250          MOV      r2,#0xd000
;;;154        buf[2] = 0xAB;
0000d4  f88db022          STRB     r11,[sp,#0x22]
;;;155        
;;;156    
;;;157        kdp_drv_i2c_write(I2C_ADAP_0, dev_addr, regAddr, 2, buf[2]); //api style
0000d8  4649              MOV      r1,r9
0000da  2302              MOVS     r3,#2
0000dc  2000              MOVS     r0,#0
0000de  f8cdb000          STR      r11,[sp,#0]
0000e2  f7fffffe          BL       kdp_drv_i2c_write
                  |L3.230|
;;;158    
;;;159    END:
;;;160        //NVIC_EnableIRQ(GPIO_FTGPIO010_IRQ);
;;;161        ops->tp_gpio_set_int_start();
0000e6  9812              LDR      r0,[sp,#0x48]
0000e8  6840              LDR      r0,[r0,#4]
0000ea  4780              BLX      r0
;;;162    }
0000ec  b017              ADD      sp,sp,#0x5c
0000ee  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.242|
0000f2  f44f4250          MOV      r2,#0xd000            ;123
0000f6  f88db01a          STRB     r11,[sp,#0x1a]        ;124
0000fa  4649              MOV      r1,r9                 ;127
0000fc  2302              MOVS     r3,#2                 ;127
0000fe  2000              MOVS     r0,#0                 ;127
000100  f8cdb000          STR      r11,[sp,#0]           ;127
000104  f7fffffe          BL       kdp_drv_i2c_write
000108  4a14              LDR      r2,|L3.348|
00010a  2100              MOVS     r1,#0                 ;130
00010c  4608              MOV      r0,r1                 ;133
00010e  f8824028          STRB     r4,[r2,#0x28]         ;131
000112  e01e              B        |L3.338|
                  |L3.276|
000114  ab08              ADD      r3,sp,#0x20           ;134
000116  185f              ADDS     r7,r3,r1              ;134
000118  787b              LDRB     r3,[r7,#1]            ;134
00011a  011d              LSLS     r5,r3,#4              ;134
00011c  78fb              LDRB     r3,[r7,#3]            ;134
00011e  78bf              LDRB     r7,[r7,#2]            ;135
000120  ea451513          ORR      r5,r5,r3,LSR #4       ;134
000124  f367131f          BFI      r3,r7,#4,#28          ;135
000128  1d49              ADDS     r1,r1,#5              ;135
00012a  f8967092          LDRB     r7,[r6,#0x92]         ;140
00012e  b2c9              UXTB     r1,r1                 ;138
000130  b117              CBZ      r7,|L3.312|
000132  f8b6708e          LDRH     r7,[r6,#0x8e]         ;141
000136  1b7d              SUBS     r5,r7,r5              ;141
                  |L3.312|
000138  f8425020          STR      r5,[r2,r0,LSL #2]     ;143
00013c  f8965093          LDRB     r5,[r6,#0x93]         ;145
000140  b115              CBZ      r5,|L3.328|
000142  f8b65090          LDRH     r5,[r6,#0x90]         ;146
000146  1aeb              SUBS     r3,r5,r3              ;146
                  |L3.328|
000148  eb020580          ADD      r5,r2,r0,LSL #2       ;148
00014c  1c40              ADDS     r0,r0,#1              ;148
00014e  b280              UXTH     r0,r0                 ;133
000150  616b              STR      r3,[r5,#0x14]         ;133
                  |L3.338|
000152  42a0              CMP      r0,r4                 ;133
000154  d3de              BCC      |L3.276|
000156  e7c6              B        |L3.230|
;;;163    
                          ENDP

                  |L3.344|
                          DCD      kdp520_touch_driver
                  |L3.348|
                          DCD      ||.bss||

                          AREA ||i._ct130_init||, CODE, READONLY, ALIGN=2

                  _ct130_init PROC
;;;27     
;;;28     int _ct130_init(struct core_device *core_d)
000000  4803              LDR      r0,|L4.16|
;;;29     {
;;;30         int ret;
;;;31     
;;;32         struct touch_driver *touch_drv = &kdp520_touch_driver;
;;;33         struct touch_driver_ops *ops = (struct touch_driver_ops*)touch_drv->ctrller_ops;
000002  6c00              LDR      r0,[r0,#0x40]
000004  b108              CBZ      r0,|L4.10|
;;;34      
;;;35         if (!ops)
;;;36             return -1;
;;;37     
;;;38         ret = 0;
000006  2000              MOVS     r0,#0
;;;39     
;;;40         return ret;
;;;41     }
000008  4770              BX       lr
                  |L4.10|
00000a  f04f30ff          MOV      r0,#0xffffffff        ;36
00000e  4770              BX       lr
;;;42     
                          ENDP

                  |L4.16|
                          DCD      kdp520_touch_driver

                          AREA ||i._ct130_read_touch_id||, CODE, READONLY, ALIGN=1

                  _ct130_read_touch_id PROC
;;;42     
;;;43     u16 _ct130_read_touch_id(struct core_device *core_d)
000000  2000              MOVS     r0,#0
;;;44     {
;;;45         u16 id = 0;
;;;46         //TODO : read ID
;;;47         return id;
;;;48     }
000002  4770              BX       lr
;;;49     
                          ENDP


                          AREA ||i._ct130_set_inactive||, CODE, READONLY, ALIGN=2

                  _ct130_set_inactive PROC
;;;265    
;;;266    void _ct130_set_inactive(void) {
000000  4902              LDR      r1,|L6.12|
;;;267        __touch_data.count = 0;
000002  2000              MOVS     r0,#0
000004  f8810028          STRB     r0,[r1,#0x28]
;;;268    }
000008  4770              BX       lr
;;;269    int _ct130_get_active(void) {
                          ENDP

00000a  0000              DCW      0x0000
                  |L6.12|
                          DCD      ||.bss||

                          AREA ||i._ct130_start||, CODE, READONLY, ALIGN=2

                  _ct130_start PROC
;;;49     
;;;50     void _ct130_start(struct core_device *core_d)
000000  4801              LDR      r0,|L7.8|
;;;51     {
;;;52         struct touch_driver *touch_drv = &kdp520_touch_driver;
;;;53         struct touch_driver_ops *ops = (struct touch_driver_ops*)touch_drv->ctrller_ops;
000002  6c00              LDR      r0,[r0,#0x40]
;;;54         ops->tp_gpio_set_int_start();
000004  6840              LDR      r0,[r0,#4]
000006  4700              BX       r0
;;;55     }
;;;56     void _ct130_stop(struct core_device *core_d)
                          ENDP

                  |L7.8|
                          DCD      kdp520_touch_driver

                          AREA ||i._ct130_state_handler||, CODE, READONLY, ALIGN=2

                  _ct130_state_handler PROC
;;;230    static kl520_mouse_state __pre_tp_state = MOUSE_NONE;
;;;231    void _ct130_state_handler(struct core_device *core_d, void* pData)
000000  b530              PUSH     {r4,r5,lr}
;;;232    {
;;;233        kl520_mouse_info* data = (kl520_mouse_info*)pData;
;;;234    
;;;235        if (0 == __touch_data.count) {
000002  4c15              LDR      r4,|L8.88|
;;;236            __cnt_down = 0;
;;;237            if (MOUSE_DOWN==__pre_tp_state || MOUSE_MOVE==__pre_tp_state) {
000004  2201              MOVS     r2,#1
000006  4815              LDR      r0,|L8.92|
000008  f8945028          LDRB     r5,[r4,#0x28]         ;235  ; __touch_data
00000c  2300              MOVS     r3,#0
00000e  b15d              CBZ      r5,|L8.40|
;;;238                data->state = MOUSE_UP;
;;;239                __cnt_up++;
;;;240            }
;;;241            else if (MOUSE_UP==__pre_tp_state) {
;;;242                if (MOUSE_UP_MAX_CNT <= __cnt_up)
;;;243                    data->state = MOUSE_NONE;
;;;244                else
;;;245                    __cnt_up++;
;;;246            }
;;;247            else
;;;248                data->state = MOUSE_NONE;
;;;249        }
;;;250        else {
;;;251            __cnt_up = 0;
000010  7043              STRB     r3,[r0,#1]
;;;252            if (MOUSE_DOWN_MAX_CNT > __cnt_down) {
000012  7803              LDRB     r3,[r0,#0]  ; __cnt_down
000014  b1e3              CBZ      r3,|L8.80|
;;;253                data->state = MOUSE_DOWN;
;;;254                __cnt_down++;
;;;255            }
;;;256            else
;;;257                data->state = MOUSE_MOVE;
000016  2202              MOVS     r2,#2
000018  700a              STRB     r2,[r1,#0]
                  |L8.26|
;;;258        }
;;;259    
;;;260        __pre_tp_state = data->state;
00001a  780a              LDRB     r2,[r1,#0]
00001c  7082              STRB     r2,[r0,#2]
;;;261        //single touch
;;;262        data->x = __touch_data.input_x[0];
00001e  8820              LDRH     r0,[r4,#0]  ; __touch_data
000020  8048              STRH     r0,[r1,#2]
;;;263        data->y = __touch_data.input_y[0];
000022  8aa0              LDRH     r0,[r4,#0x14]  ; __touch_data
000024  8088              STRH     r0,[r1,#4]
;;;264    }
000026  bd30              POP      {r4,r5,pc}
                  |L8.40|
000028  7003              STRB     r3,[r0,#0]            ;236
00002a  7885              LDRB     r5,[r0,#2]            ;237  ; __pre_tp_state
00002c  2d01              CMP      r5,#1                 ;237
00002e  d004              BEQ      |L8.58|
000030  2d02              CMP      r5,#2                 ;237
000032  d002              BEQ      |L8.58|
000034  2d03              CMP      r5,#3                 ;241
000036  d005              BEQ      |L8.68|
000038  e006              B        |L8.72|
                  |L8.58|
00003a  2203              MOVS     r2,#3                 ;238
00003c  700a              STRB     r2,[r1,#0]            ;238
00003e  7842              LDRB     r2,[r0,#1]            ;239  ; __cnt_up
000040  1c52              ADDS     r2,r2,#1              ;239
000042  e003              B        |L8.76|
                  |L8.68|
000044  7845              LDRB     r5,[r0,#1]            ;242  ; __cnt_up
000046  b10d              CBZ      r5,|L8.76|
                  |L8.72|
000048  700b              STRB     r3,[r1,#0]            ;248
00004a  e7e6              B        |L8.26|
                  |L8.76|
00004c  7042              STRB     r2,[r0,#1]            ;245
00004e  e7e4              B        |L8.26|
                  |L8.80|
000050  700a              STRB     r2,[r1,#0]            ;253
000052  7002              STRB     r2,[r0,#0]            ;254
000054  e7e1              B        |L8.26|
;;;265    
                          ENDP

000056  0000              DCW      0x0000
                  |L8.88|
                          DCD      ||.bss||
                  |L8.92|
                          DCD      ||.data||

                          AREA ||i._ct130_stop||, CODE, READONLY, ALIGN=2

                  _ct130_stop PROC
;;;55     }
;;;56     void _ct130_stop(struct core_device *core_d)
000000  4801              LDR      r0,|L9.8|
;;;57     {
;;;58         struct touch_driver *touch_drv = &kdp520_touch_driver;
;;;59         struct touch_driver_ops *ops = (struct touch_driver_ops*)touch_drv->ctrller_ops;
000002  6c00              LDR      r0,[r0,#0x40]
;;;60         ops->tp_gpio_set_int_stop();
000004  6800              LDR      r0,[r0,#0]
000006  4700              BX       r0
;;;61     }
;;;62     
                          ENDP

                  |L9.8|
                          DCD      kdp520_touch_driver

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  __touch_data
                          %        44

                          AREA ||.data||, DATA, ALIGN=0

                  __cnt_down
000000  00                DCB      0x00
                  __cnt_up
000001  00                DCB      0x00
                  __pre_tp_state
000002  00                DCB      0x00

                          AREA ||area_number.14||, DATA, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.data||
                  ct130_driver
                          DCD      _ct130_init
                          DCD      _ct130_get_info
                          DCD      _ct130_start
                          DCD      _ct130_stop
                          DCD      _ct130_get_raw_data
                          DCD      _ct130_state_handler
                          DCD      _ct130_set_inactive
                          DCD      _ct130_get_active

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\scpu\\drivers\\media\\touch\\ct130.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_ct130_c_9ebb3d57____REV16|
#line 208 "F:\\Users\\fu\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.9.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___7_ct130_c_9ebb3d57____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_ct130_c_9ebb3d57____REVSH|
#line 223
|__asm___7_ct130_c_9ebb3d57____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_ct130_c_9ebb3d57____RRX|
#line 410
|__asm___7_ct130_c_9ebb3d57____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
